<!-- build time:Tue Jun 19 2018 15:23:32 GMT+0800 (CST) --><!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="TIRp90R4UV"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css"><meta name="keywords" content="js面向对象继承,"><link rel="shortcut icon" type="image/x-icon" href="/uploads/favicon.ico?v=5.1.2"><meta name="description" content="题记关于继承已经是老生常谈的事情了，不管是css的继承还是js的继承，都已经出了不少文章，本次将继续和大家一起探讨js中面向对象的继承。由于js不像java那样是完全面向对象的语言，js是基于对象的，它没有类的概念。所以，要想实现继承，一般都是基于原型链的方式；一、继承初探大多数JavaScript的实现用 __proto__ 属性来表示一个对象的原型链。我们可以简单的把prototype看做是一"><meta name="keywords" content="js面向对象继承"><meta property="og:type" content="article"><meta property="og:title" content="javascript 面向对象继承详解"><meta property="og:url" content="http://www.grycheng.com/2015/08/29/javascript-面向对象继承详解/index.html"><meta property="og:site_name" content="BaoSheng"><meta property="og:description" content="题记关于继承已经是老生常谈的事情了，不管是css的继承还是js的继承，都已经出了不少文章，本次将继续和大家一起探讨js中面向对象的继承。由于js不像java那样是完全面向对象的语言，js是基于对象的，它没有类的概念。所以，要想实现继承，一般都是基于原型链的方式；一、继承初探大多数JavaScript的实现用 __proto__ 属性来表示一个对象的原型链。我们可以简单的把prototype看做是一"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http://www.npm8.com/wp-content/uploads/2015/08/14.png"><meta property="og:image" content="http://www.npm8.com/wp-content/uploads/2015/08/23.png"><meta property="og:image" content="http://www.npm8.com/wp-content/uploads/2015/08/33.png"><meta property="og:image" content="http://www.npm8.com/wp-content/uploads/2015/08/42.png"><meta property="og:image" content="http://www.npm8.com/wp-content/uploads/2015/08/53.png"><meta property="og:image" content="http://www.npm8.com/wp-content/uploads/2015/08/63.png"><meta property="og:image" content="http://www.npm8.com/wp-content/uploads/2015/08/73.png"><meta property="og:image" content="http://www.npm8.com/wp-content/uploads/2015/08/83.png"><meta property="og:image" content="http://www.npm8.com/wp-content/uploads/2015/08/92.png"><meta property="og:image" content="http://www.npm8.com/wp-content/uploads/2015/08/102-650x480.png"><meta property="og:image" content="http://www.npm8.com/wp-content/uploads/2015/08/111-650x466.png"><meta property="og:updated_time" content="2018-06-14T07:47:52.074Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="javascript 面向对象继承详解"><meta name="twitter:description" content="题记关于继承已经是老生常谈的事情了，不管是css的继承还是js的继承，都已经出了不少文章，本次将继续和大家一起探讨js中面向对象的继承。由于js不像java那样是完全面向对象的语言，js是基于对象的，它没有类的概念。所以，要想实现继承，一般都是基于原型链的方式；一、继承初探大多数JavaScript的实现用 __proto__ 属性来表示一个对象的原型链。我们可以简单的把prototype看做是一"><meta name="twitter:image" content="http://www.npm8.com/wp-content/uploads/2015/08/14.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",sidebar:{position:"left",display:"post",offset:12,offset_float:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.grycheng.com/2015/08/29/javascript-面向对象继承详解/"><title>javascript 面向对象继承详解 | BaoSheng</title><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?‘6c005185d8aabb2ec10cf577df122aa7’";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">BaoSheng</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">Rome was not built in a day.</h1></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.grycheng.com/2015/08/29/javascript-面向对象继承详解/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="baosheng"><meta itemprop="description" content=""><meta itemprop="image" content="/uploads/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="BaoSheng"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">javascript 面向对象继承详解</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-29T16:34:19+08:00">2015-08-29 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JS-Jq/" itemprop="url" rel="index"><span itemprop="name">JS/Jq</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p><strong>题记</strong></p><p>关于继承已经是老生常谈的事情了，不管是css的继承还是js的继承，都已经出了不少文章，本次将继续和大家一起探讨js中面向对象的继承。由于<code>js</code>不像<code>java</code>那样是完全面向对象的语言，<code>js</code>是基于对象的，它没有类的概念。所以，要想实现继承，一般都是基于原型链的方式；</p><h2 id="一、继承初探"><a href="#一、继承初探" class="headerlink" title="一、继承初探"></a><strong>一、继承初探</strong></h2><p>大多数JavaScript的实现用 <code>__proto__</code> 属性来表示一个对象的原型链。</p><p>我们可以简单的把<code>prototype</code>看做是一个模版，新创建的自定义对象都是这个模版（<code>prototype</code>）的一个拷贝 （实际上不是拷贝而是链接，只不过这种链接是不可见，新实例化的对象内部有一个看不见的<code>__proto__</code>指针，指向原型对象)</p><p>当查找一个对象的属性时，JavaScript 会向上遍历原型链，直到找到给定名称的属性为止。查找方式可以这样表示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>(<span class="params">obj, prop</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> (obj.hasOwnProperty(prop)) &#123;</div><div class="line"><span class="keyword">return</span> obj[prop];</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (obj.__proto__ !== <span class="literal">null</span>) &#123;</div><div class="line"><span class="keyword">return</span> getProperty(obj.__proto__, prop);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">undefined</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们在js中使用面向对象很多时候是这样子的：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line"><span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.printInfo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">': '</span> + <span class="keyword">this</span>.age);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'Jack'</span>,<span class="number">17</span>);</div><div class="line"></div><div class="line">person.printInfo(); <span class="comment">// Jack: 17</span></div></pre></td></tr></table></figure><p></p><p>而变一下，可以发现，这种方式也是可以的<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = &#123;</div><div class="line"><span class="comment">/* 声明所需的项 */</span></div><div class="line">name : <span class="string">'name'</span>,</div><div class="line">age: <span class="string">'age'</span>,</div><div class="line"></div><div class="line">printInfo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">': '</span> + <span class="keyword">this</span>.age);</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">name: <span class="string">'Jack'</span>,</div><div class="line">age: <span class="number">17</span>,</div><div class="line">__proto__: Person</div><div class="line">&#125;;</div><div class="line"></div><div class="line">person.printInfo(); <span class="comment">// Jack: 17</span></div></pre></td></tr></table></figure><p></p><p>其实这里就是通过将 <strong>proto</strong> 指向了Person从而达到了原型继承的目的（这也许也是后续某种继承方式的来源）</p><p>以上两种方式是等价的，但我们看到的更多还是new方式来产生实例对象，其实new方式也是通过继承方式实现的，那一个new 究竟做了什么操作呢？</p><p><strong>有两个版本，哪个比较中肯就用哪个吧</strong></p><p><strong>1）</strong><br>1、创建一个空对象，并且 <span class="hljs-keyword">this 变量引用该对象，同时还继承了该函数的原型（即把<strong>proto</strong>属性设置为该对象的prototype。<br><span class="hljs-number">2、属性和方法被加入到 <span class="hljs-keyword">this 引用的对象中（使用apply传参调用）。<br><span class="hljs-number">3、新创建的对象由 <span class="hljs-keyword">this 所引用，并且最后隐式的返回实例。</span></span></span></span></span><br>用代码实现应该就是这样的<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* new Constructor() */</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">new</span> (<span class="params">f</span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> n = &#123; <span class="string">'__proto__'</span>: f.prototype &#125;; <span class="comment">/* step 1 */</span></div><div class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">f.apply(n, <span class="built_in">arguments</span>); <span class="comment">/* step 2 */</span></div><div class="line"><span class="keyword">return</span> n; <span class="comment">/* step 3 */</span></div><div class="line">&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p><strong>2）</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line">obj.__proto__ = Base.prototype;</div><div class="line">Base.call(obj);</div></pre></td></tr></table></figure><p></p><p><img src="http://www.npm8.com/wp-content/uploads/2015/08/14.png" alt="1"></p><p>不过我用代码实现的时候，两种情况都出现了无线调用堆栈溢出的情况，也许new的操作内部没那么简单</p><p><img src="http://www.npm8.com/wp-content/uploads/2015/08/23.png" alt="2"> <img src="http://www.npm8.com/wp-content/uploads/2015/08/33.png" alt="3"></p><p><img src="http://www.npm8.com/wp-content/uploads/2015/08/42.png" alt="4"> <img src="http://www.npm8.com/wp-content/uploads/2015/08/53.png" alt="5"></p><h2 id="二、继承方式概览"><a href="#二、继承方式概览" class="headerlink" title="二、继承方式概览"></a><strong>二、继承方式概览</strong></h2><p>说了那么多new 也乱了，不如直接切入正题，谈谈js流行的几种继承方式</p><h3 id="1）对象冒充"><a href="#1）对象冒充" class="headerlink" title="1）对象冒充"></a><strong>1）对象冒充</strong></h3><p>对象冒充也分为几类 – 添加临时属性、apply/call等方式</p><p><strong>添加临时属性</strong></p><p>缺点是只能继承显示指明的属性，原型上的属性没办法<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line"><span class="keyword">this</span>.words = <span class="string">'words'</span>;</div><div class="line"></div><div class="line"><span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">': '</span> + <span class="keyword">this</span>.words);</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line">Parent.prototype.say1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">': '</span> + <span class="keyword">this</span>.words);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.temp = Parent;</div><div class="line"><span class="keyword">this</span>.temp(name);</div><div class="line"><span class="comment">// 传参name后即可获取到相应name,words属性，即可销毁temp</span></div><div class="line"><span class="keyword">delete</span> <span class="keyword">this</span>.temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">'child'</span>);</div><div class="line">child.say();</div><div class="line">child.say1();</div></pre></td></tr></table></figure><p></p><p><img src="http://www.npm8.com/wp-content/uploads/2015/08/63.png" alt="6"></p><p><strong>call/apply</strong></p><p>实际上是改变了Parent中this的指向，原理跟上个方法一样，但也不能拿到原型的属性<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line"><span class="keyword">this</span>.words = <span class="string">'words'</span>;</div><div class="line"></div><div class="line"><span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">': '</span> + <span class="keyword">this</span>.words);</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line">Parent.prototype.say1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">': '</span> + <span class="keyword">this</span>.words);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>)</span>&#123;</div><div class="line"><span class="comment">//Parent.call(this,name);</span></div><div class="line">Parent.apply(<span class="keyword">this</span>,[name]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">'child'</span>);</div><div class="line">child.say();</div><div class="line">child.say1();</div></pre></td></tr></table></figure><p></p><p>对象冒充还有一个缺点就是易造成内存的浪费</p><p>因为每次冒充的过程都需要实例化一次父对象，而每次实例化的过程，this显示指明的属性将在每个实例中独立存在，不会共用。</p><p>比如say()这种方法，每次调用Child都会新产生并。而原型上的say1()方法就可以共用。</p><p>&nbsp;</p><h3 id="2）原型链继承"><a href="#2）原型链继承" class="headerlink" title="2）原型链继承"></a>2）原型链继承</h3><p>这种继承方式也许是最常见的了：将父类的新实例赋值给构造函数的原型<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line"><span class="keyword">this</span>.words = <span class="string">'words'</span>;</div><div class="line"></div><div class="line"><span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">': '</span> + <span class="keyword">this</span>.words);</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line">Parent.prototype.say1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">': '</span> + <span class="keyword">this</span>.words);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Child.prototype = <span class="keyword">new</span> Parent();</div><div class="line"><span class="comment">// 如果不加上这句，Child的constructor就会被Parent的覆盖，变成 Parent</span></div><div class="line">Child.prototype.constructor = Child;</div><div class="line"></div><div class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">'child'</span>);</div><div class="line">child.say();</div><div class="line">child.say1();</div></pre></td></tr></table></figure><p></p><p><img src="http://www.npm8.com/wp-content/uploads/2015/08/73.png" alt="7"></p><p>可以看到，child不仅可以继承到parent的say()也能拿到say1() ,关键点在于 new Parent()这个new操作</p><p>根据最开始我们谈到的new操作，可以知道它具体干了什么</p><p>下面来一个变体，这种方式也行，虽然不必在Child中再次定义this.name ,但再次new Child()时，就不能更新我们需要的值。</p><p>所以这应该也算是原型链继承的一个不足吧<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line"><span class="keyword">this</span>.words = <span class="string">'words'</span>;</div><div class="line">&#125;</div><div class="line">Parent.prototype.say1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">': '</span> + <span class="keyword">this</span>.words);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// 直接在参数中写child</span></div><div class="line">Child.prototype = <span class="keyword">new</span> Parent(<span class="string">'child'</span>);</div><div class="line">Child.prototype.constructor = Child;</div><div class="line"></div><div class="line"><span class="comment">// 这样 newChild就无效了</span></div><div class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">'newChild'</span>);</div><div class="line">child.say1();</div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Parent();</div><div class="line">p.say1(); <span class="comment">// child: words</span></div></pre></td></tr></table></figure><p></p><h3 id="3-原型链-对象冒充（借用构造函数）"><a href="#3-原型链-对象冒充（借用构造函数）" class="headerlink" title="3) 原型链+对象冒充（借用构造函数）"></a>3) 原型链+对象冒充（借用构造函数）</h3><p>原型链方式和对象冒充方式都各有缺陷，两者的缺陷正是对方的优势。两者一结合，自然又是一个好方法，就叫它组合继承吧。</p><p>它背后的思路是 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line"><span class="keyword">this</span>.words = <span class="string">'words'</span>;</div><div class="line">&#125;</div><div class="line">Parent.prototype.say1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">': '</span> + <span class="keyword">this</span>.words);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>)</span>&#123;</div><div class="line"><span class="comment">// 对象冒充</span></div><div class="line">Parent.call(<span class="keyword">this</span>,name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 原型链继承</span></div><div class="line">Child.prototype = <span class="keyword">new</span> Parent();</div><div class="line">Child.prototype.constructor = Child;</div><div class="line"></div><div class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">'child'</span>);</div><div class="line">child.say1(); <span class="comment">// child: words</span></div></pre></td></tr></table></figure><p></p><h3 id="4）直接继承父类的-prototype"><a href="#4）直接继承父类的-prototype" class="headerlink" title="4）直接继承父类的 prototype"></a>4）直接继承父类的 prototype</h3><p>我们知道了原型链的继承是<br>Child.prototype = new Parent();<br>那可不可以跳过实例化父类，直接拿Parent的原型呢？</p><p>Child.prototype = Parent.prototype;<br>其实这也是可以的，来看个例子。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line"><span class="keyword">this</span>.words = <span class="string">'words'</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line">Parent.prototype.age = <span class="number">30</span>;</div><div class="line">Parent.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</div><div class="line">&#125;;</div><div class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">': '</span> + <span class="keyword">this</span>.words);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>)</span>&#123;</div><div class="line"><span class="comment">// Parent.call(this,name);</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 直接继承父类prototype</span></div><div class="line">Child.prototype = Parent.prototype;</div><div class="line">Child.prototype.constructor = Child;</div><div class="line"></div><div class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">'child'</span>);</div><div class="line">child.say(); <span class="comment">// undefined: undefined</span></div><div class="line">child.sayAge(); <span class="comment">//30</span></div></pre></td></tr></table></figure><p></p><p>可以看到，这种方式仅仅只能拿到父类的原型属性，实例上的name和words属性就拿不到了。</p><p>如果想拿，那就使用Parent.call(this.name)就可以啦。</p><p>由此看来，直接用prototype应该会更快，因为不需要像上一个方法那样实例化一个对象耗时。但也是有缺点的。</p><p>缺点是 Child.prototype和Parent.prototype现在指向了同一个对象，那么任何对Child.prototype的修改，都会反映到Parent.prototype。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line"><span class="keyword">this</span>.words = <span class="string">'words'</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line">Parent.prototype.age = <span class="number">30</span>;</div><div class="line">Parent.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</div><div class="line">&#125;;</div><div class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">': '</span> + <span class="keyword">this</span>.words);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">Parent.call(<span class="keyword">this</span>,name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 直接继承父类prototype</span></div><div class="line">Child.prototype = Parent.prototype;</div><div class="line"></div><div class="line"><span class="comment">//Child.prototype = new Parent();</span></div><div class="line">Child.prototype.constructor = Child;</div><div class="line"></div><div class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">'child'</span>);</div><div class="line">child.say();</div><div class="line">child.sayAge();</div><div class="line"></div><div class="line">Child.prototype.age = <span class="number">40</span>;</div><div class="line"><span class="built_in">console</span>.log(Parent.prototype.age); <span class="comment">// 40</span></div></pre></td></tr></table></figure><p></p><p>可以看到父级的原型也被更改了，而原型链继承的方式则不会。</p><p>但聪明的人类想出了一个好办法：用一个空对象作为中介，再利用操作prototype，</p><p>既避免了实例化对象产生太多的耗时，又避免的父子prototype混用的情况。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line"><span class="keyword">this</span>.words = <span class="string">'words'</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line">Parent.prototype.age = <span class="number">30</span>;</div><div class="line">Parent.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</div><div class="line">&#125;;</div><div class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">': '</span> + <span class="keyword">this</span>.words);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">Parent.call(<span class="keyword">this</span>,name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 封装成函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">Child,Parent</span>)</span>&#123;</div><div class="line"><span class="comment">// 中介对象</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">F.prototype = Parent.prototype;</div><div class="line">Child.prototype = <span class="keyword">new</span> F();</div><div class="line">Child.prototype.constructor = Child;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 继承</span></div><div class="line">extend(Child,Parent);</div><div class="line"></div><div class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">'child'</span>);</div><div class="line">child.say();</div><div class="line">child.sayAge();</div><div class="line"></div><div class="line">Child.prototype.age = <span class="number">40</span>;</div><div class="line"><span class="built_in">console</span>.log(Parent.prototype.age); <span class="comment">// 30</span></div></pre></td></tr></table></figure><p></p><p><img src="http://www.npm8.com/wp-content/uploads/2015/08/83.png" alt="8"></p><h3 id="5）原型式继承"><a href="#5）原型式继承" class="headerlink" title="5）原型式继承"></a>5）原型式继承</h3><p>这种继承借助原型并基于已有的对象创建新对象，同时还不用创建自定义类型的方式称为<code>原型式继承。</code></p><p>可以封装成一个方法，这方法其实只做一件事，就是把子对象的prototype属性，指向父对象，从而使得子对象与父对象连在一起。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Parent = &#123;</div><div class="line">name : <span class="string">'parent'</span>,</div><div class="line">words: [<span class="string">'word1'</span>,<span class="string">'word2'</span>],</div><div class="line">say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">': '</span> + <span class="keyword">this</span>.words);</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 封装成方法</span></div><div class="line"><span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span>(<span class="params">Parent</span>)</span>&#123;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"><span class="comment">// 这里不用F.prototype = Parent.prototype的原因是</span></div><div class="line"><span class="comment">// 通过对象字面量定义的Parent对象没有这个直接的prototype属性（属于Object的）</span></div><div class="line"><span class="comment">// 如果通过 function Parent()方式定义则可以</span></div><div class="line"></div><div class="line">F.prototype = Parent;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> Child = <span class="built_in">Object</span>.create(Parent);</div><div class="line">Child.say();</div><div class="line"></div><div class="line">Child.name = <span class="string">'child'</span>;</div><div class="line">Child.words.push(<span class="string">'word3'</span>);</div><div class="line">Child.say();</div><div class="line">Parent.say();</div></pre></td></tr></table></figure><p></p><p><img src="http://www.npm8.com/wp-content/uploads/2015/08/92.png" alt="9"></p><p>Child继承了父类的属性方法后就可以自行更新属性值或再定义了，不过这里存在一个属性共享问题。</p><p>如果是引用类型的数据，比如Object ，就比如Child往words里添加了一项，父类也会被更新，造成某种程度上的问题。</p><p>而解决引用类型数据共享问题的方法，一般就是不继承该属性，或者</p><p>&nbsp;</p><h3 id="6）把父对象的属性，全部拷贝给子对象"><a href="#6）把父对象的属性，全部拷贝给子对象" class="headerlink" title="6）把父对象的属性，全部拷贝给子对象"></a>6）把父对象的属性，全部拷贝给子对象</h3><p>除了使用”prototype链”以外，还有另一种思路：把父对象的属性，全部拷贝给子对象，也能实现继承。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Parent = &#123;</div><div class="line">name : <span class="string">'parent'</span>,</div><div class="line">words: [<span class="string">'word1'</span>,<span class="string">'word2'</span>],</div><div class="line">say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">': '</span> + <span class="keyword">this</span>.words);</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 对象拷贝函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extendCopy</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> newObj = &#123;&#125;;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">in</span> obj)&#123;</div><div class="line">newObj[item] = obj[item];</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> newObj;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> Child = extendCopy(Parent);</div><div class="line">Child.say(); <span class="comment">// parent: word1,word2</span></div><div class="line"></div><div class="line">Child.name = <span class="string">'child'</span>;</div><div class="line">Child.words.push(<span class="string">'word3'</span>);</div><div class="line">Child.say(); <span class="comment">// child: word1,word2,word3</span></div><div class="line">Parent.say();<span class="comment">// parent: word1,word2,word3</span></div></pre></td></tr></table></figure><p></p><p>这样的拷贝有一个问题。</p><p>那就是，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，而不是真正拷贝，因此存在父对象被篡改的可能。</p><p>所以上方Child修改之后也会反应到Parent上去。</p><p>所以需要进行<strong>深度拷贝</strong>，一直到拿到真正的值为止<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Parent = &#123;</div><div class="line">name : <span class="string">'parent'</span>,</div><div class="line">words: [<span class="string">'word1'</span>,<span class="string">'word2'</span>],</div><div class="line">say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">': '</span> + <span class="keyword">this</span>.words);</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 引用类型 深拷贝函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj,newObj</span>)</span>&#123;</div><div class="line">newObj = newObj || &#123;&#125;;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">in</span> obj)&#123;</div><div class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> obj[item] === <span class="string">'object'</span>)&#123;</div><div class="line">newObj[item] = (<span class="built_in">Object</span>.prototype.toString.call(obj[item]) === <span class="string">'[object Array]'</span>) ? [] : &#123;&#125;;</div><div class="line">deepCopy(obj[item],newObj[item]);</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">newObj[item] = obj[item]</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> newObj;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> Child = deepCopy(Parent);</div><div class="line">Child.say(); <span class="comment">// parent: word1,word2</span></div><div class="line"></div><div class="line">Child.name = <span class="string">'child'</span>;</div><div class="line">Child.words.push(<span class="string">'word3'</span>);</div><div class="line">Child.say(); <span class="comment">// child: word1,word2,word3</span></div><div class="line">Parent.say();<span class="comment">// parent: word1,word2</span></div></pre></td></tr></table></figure><p></p><p>最后附图两张：</p><p><a href="http://www.npm8.com/wp-content/uploads/2015/08/102.png" target="_blank" rel="external"><img src="http://www.npm8.com/wp-content/uploads/2015/08/102-650x480.png" alt="10"></a></p><p><a href="http://www.npm8.com/wp-content/uploads/2015/08/111.png" target="_blank" rel="external"><img src="http://www.npm8.com/wp-content/uploads/2015/08/111-650x466.png" alt="11"></a><br>&nbsp;</p></div><div><div style="padding:10px 0;margin:20px auto;width:94%;text-align:center"><div></div><button id="rewardButton" disable="enable" onclick='var e=document.getElementById("QR");"none"===e.style.display?e.style.display="block":e.style.display="none"'><span>打赏一个泡泡糖</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" src="/uploads/wechatpay.jpg" alt="baosheng WeChat Pay"><p>微信</p></div><div id="alipay" style="display:inline-block"><img id="alipay_qr" src="/uploads/alipay.jpg" alt="baosheng Alipay"><p>支付宝</p></div></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/js面向对象继承/" rel="tag"># js面向对象继承</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2015/08/29/rgba与opacity区别详解/" rel="next" title="RGBA与Opacity区别详解"><i class="fa fa-chevron-left"></i> RGBA与Opacity区别详解</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2015/08/29/phaser新手教程：怪物要糖果demo/" rel="prev" title="Phaser新手教程：开发”怪物要糖果“游戏">Phaser新手教程：开发”怪物要糖果“游戏 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zMDA4OC82NjQz"></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/uploads/avatar.jpg" alt="baosheng"><p class="site-author-name" itemprop="name">baosheng</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">513</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">9</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">805</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-globe"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://www.npm8.com/" title="申请友情链接加QQ：347675731" target="_blank">申请友情链接加QQ：347675731</a></li></ul></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、继承初探"><span class="nav-number">1.</span> <span class="nav-text">一、继承初探</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、继承方式概览"><span class="nav-number">2.</span> <span class="nav-text">二、继承方式概览</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）对象冒充"><span class="nav-number">2.1.</span> <span class="nav-text">1）对象冒充</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）原型链继承"><span class="nav-number">2.2.</span> <span class="nav-text">2）原型链继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-原型链-对象冒充（借用构造函数）"><span class="nav-number">2.3.</span> <span class="nav-text">3) 原型链+对象冒充（借用构造函数）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4）直接继承父类的-prototype"><span class="nav-number">2.4.</span> <span class="nav-text">4）直接继承父类的 prototype</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5）原型式继承"><span class="nav-number">2.5.</span> <span class="nav-text">5）原型式继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6）把父对象的属性，全部拷贝给子对象"><span class="nav-number">2.6.</span> <span class="nav-text">6）把父对象的属性，全部拷贝给子对象</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2014 - <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">baosheng</span><script language="javascript" type="text/javascript" src="//js.users.51.la/19323703.js"></script><noscript><a href="//www.51.la/?19323703" target="_blank"><img alt="&#x6211;&#x8981;&#x5566;&#x514D;&#x8D39;&#x7EDF;&#x8BA1;" src="//img.users.51.la/19323703.asp" style="border:none"></a></noscript></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script><script type="text/javascript">!function(e,t){var n,c=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&(n=e.createElement(t),n.src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,c.parentNode.insertBefore(n,c))}(document,"script")</script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,r=document.getElementById(e),s=document.getElementById(o),a=function(){var t=r.value.trim().toLowerCase(),e=t.split(/[\s\-]+/);e.length>1&&e.push(t);var o=[];if(t.length>0&&n.forEach(function(n){function r(e,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===t&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(t,e){var o="",n=e.start;return e.hits.forEach(function(e){o+=t.substring(n,e.position);var r=e.position+e.length;o+='<b class="search-keyword">'+t.substring(e.position,r)+"</b>",n=r}),o+=t.substring(n,e.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url),d=[],g=[];if(""!=l&&(e.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());(s=e.indexOf(t,r))>-1;)a.push({position:s,word:t}),r=s+n;return a}d=d.concat(e(t,h,!1)),g=g.concat(e(t,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;w<0&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(t){b+="<a href='"+f+'\'><p class="search-result">'+s(p,t)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===e.length&&""===e[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{o.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var a='<ul class="search-result-list">';o.forEach(function(t){a+=t.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){var e=27===t.which&&$(".search-popup").is(":visible");e&&onPopupClose()})</script><script>!function(){var t=document.createElement("script"),s=window.location.protocol.split(":")[0];"https"===s?t.src="https://zz.bdstatic.com/linksubmit/push.js":t.src="http://push.zhanzhang.baidu.com/push.js";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script></body></html><!-- rebuild by neat -->